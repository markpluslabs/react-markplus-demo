{"mappings":"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","sources":["<anon>","node_modules/mermaid/dist/chunks/mermaid.esm/chunk-ZTYE4VVB.mjs","node_modules/mermaid/dist/chunks/mermaid.esm/chunk-46UCTVYF.mjs","node_modules/@parcel/runtime-js/lib/runtime-acf45b9438193a5f.js","node_modules/@parcel/runtime-js/lib/helpers/browser/esm-js-loader.js","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/runtime-56328d6041f450de.js","node_modules/@parcel/runtime-js/lib/runtime-9747340b63b7976d.js","node_modules/@parcel/runtime-js/lib/runtime-8d2a46c887e3d6b2.js","node_modules/@parcel/runtime-js/lib/runtime-97a5d9b9384c72c1.js","node_modules/mermaid/dist/chunks/mermaid.esm/chunk-5PULXXUT.mjs","node_modules/mermaid/dist/chunks/mermaid.esm/chunk-ACX3ZYE2.mjs","node_modules/mermaid/dist/chunks/mermaid.esm/chunk-VUYTGWVG.mjs","node_modules/mermaid/dist/chunks/mermaid.esm/chunk-FKTRZSYK.mjs","node_modules/mermaid/dist/chunks/mermaid.esm/chunk-55U4IUQG.mjs"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire94c2\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"9nJgw\", function(module, exports) {\n\n$parcel$export(module.exports, \"parse\", () => $7efda43c46063a35$export$98e6a39c04603d36);\n\nvar $bYG2S = parcelRequire(\"bYG2S\");\n\nvar $7xxrv = parcelRequire(\"7xxrv\");\n// ../parser/dist/mermaid-parser.core.mjs\nvar $7efda43c46063a35$var$parsers = {};\n\n\n\n\n\nvar $7efda43c46063a35$var$initializers = {\n    info: /* @__PURE__ */ (0, $bYG2S.__name)(async ()=>{\n        const { createInfoServices: createInfoServices2 } = await (parcelRequire(\"3nMuO\"));\n        const parser = createInfoServices2().Info.parser.LangiumParser;\n        $7efda43c46063a35$var$parsers.info = parser;\n    }, \"info\"),\n    packet: /* @__PURE__ */ (0, $bYG2S.__name)(async ()=>{\n        const { createPacketServices: createPacketServices2 } = await (parcelRequire(\"8j2w0\"));\n        const parser = createPacketServices2().Packet.parser.LangiumParser;\n        $7efda43c46063a35$var$parsers.packet = parser;\n    }, \"packet\"),\n    pie: /* @__PURE__ */ (0, $bYG2S.__name)(async ()=>{\n        const { createPieServices: createPieServices2 } = await (parcelRequire(\"6zM4s\"));\n        const parser = createPieServices2().Pie.parser.LangiumParser;\n        $7efda43c46063a35$var$parsers.pie = parser;\n    }, \"pie\"),\n    architecture: /* @__PURE__ */ (0, $bYG2S.__name)(async ()=>{\n        const { createArchitectureServices: createArchitectureServices2 } = await (parcelRequire(\"it5sz\"));\n        const parser = createArchitectureServices2().Architecture.parser.LangiumParser;\n        $7efda43c46063a35$var$parsers.architecture = parser;\n    }, \"architecture\"),\n    gitGraph: /* @__PURE__ */ (0, $bYG2S.__name)(async ()=>{\n        const { createGitGraphServices: createGitGraphServices2 } = await (parcelRequire(\"bNRfS\"));\n        const parser = createGitGraphServices2().GitGraph.parser.LangiumParser;\n        $7efda43c46063a35$var$parsers.gitGraph = parser;\n    }, \"gitGraph\")\n};\nasync function $7efda43c46063a35$export$98e6a39c04603d36(diagramType, text) {\n    const initializer = $7efda43c46063a35$var$initializers[diagramType];\n    if (!initializer) throw new Error(`Unknown diagram type: ${diagramType}`);\n    if (!$7efda43c46063a35$var$parsers[diagramType]) await initializer();\n    const parser = $7efda43c46063a35$var$parsers[diagramType];\n    const result = parser.parse(text);\n    if (result.lexerErrors.length > 0 || result.parserErrors.length > 0) throw new $7efda43c46063a35$var$MermaidParseError(result);\n    return result.value;\n}\n(0, $7xxrv.__name)($7efda43c46063a35$export$98e6a39c04603d36, \"parse\");\n(0, $bYG2S.__name)($7efda43c46063a35$export$98e6a39c04603d36, \"parse\");\nvar $7efda43c46063a35$var$MermaidParseError = class extends Error {\n    static{\n        (0, $7xxrv.__name)(this, \"MermaidParseError\");\n    }\n    constructor(result){\n        const lexerErrors = result.lexerErrors.map((err)=>err.message).join(\"\\n\");\n        const parserErrors = result.parserErrors.map((err)=>err.message).join(\"\\n\");\n        super(`Parsing failed: ${lexerErrors} ${parserErrors}`);\n        this.result = result;\n    }\n    static{\n        (0, $bYG2S.__name)(this, \"MermaidParseError\");\n    }\n};\n\n});\nparcelRegister(\"bYG2S\", function(module, exports) {\n\n$parcel$export(module.exports, \"EmptyFileSystem\", () => $1d44efb04eab6ceb$export$9849fb42e1532cce);\n$parcel$export(module.exports, \"createDefaultCoreModule\", () => $1d44efb04eab6ceb$export$eab5a4b5adef815d);\n$parcel$export(module.exports, \"createDefaultSharedCoreModule\", () => $1d44efb04eab6ceb$export$dbab074a2a0a86aa);\n$parcel$export(module.exports, \"inject\", () => $1d44efb04eab6ceb$export$a976684a0efeb93f);\n$parcel$export(module.exports, \"__name\", () => $1d44efb04eab6ceb$export$3777ff4d263eb622);\n$parcel$export(module.exports, \"MermaidGeneratedSharedModule\", () => $1d44efb04eab6ceb$export$7b9033c24b3bcb4e);\n$parcel$export(module.exports, \"InfoGeneratedModule\", () => $1d44efb04eab6ceb$export$e4b0bc98a20a633a);\n$parcel$export(module.exports, \"PacketGeneratedModule\", () => $1d44efb04eab6ceb$export$d28586600dc40d43);\n$parcel$export(module.exports, \"PieGeneratedModule\", () => $1d44efb04eab6ceb$export$9a9f13da65008281);\n$parcel$export(module.exports, \"ArchitectureGeneratedModule\", () => $1d44efb04eab6ceb$export$28acc4e42f5f4855);\n$parcel$export(module.exports, \"GitGraphGeneratedModule\", () => $1d44efb04eab6ceb$export$3805a3057b70f628);\n$parcel$export(module.exports, \"AbstractMermaidValueConverter\", () => $1d44efb04eab6ceb$export$6024982db2edb064);\n$parcel$export(module.exports, \"CommonValueConverter\", () => $1d44efb04eab6ceb$export$5814ff0710a44fb8);\n$parcel$export(module.exports, \"AbstractMermaidTokenBuilder\", () => $1d44efb04eab6ceb$export$a487a80f9ea1e74e);\n\nvar $76RTQ = parcelRequire(\"76RTQ\");\n\nvar $f34bP = parcelRequire(\"f34bP\");\n\nvar $2266r = parcelRequire(\"2266r\");\n\nvar $7xxrv = parcelRequire(\"7xxrv\");\n\nvar $hPtJY = parcelRequire(\"hPtJY\");\n// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/ral.js\nvar $1d44efb04eab6ceb$var$require_ral = (0, $7xxrv.__commonJS)({\n    \"../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/ral.js\" (exports) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n        var _ral;\n        function RAL() {\n            if (_ral === void 0) throw new Error(`No runtime abstraction layer installed`);\n            return _ral;\n        }\n        (0, $7xxrv.__name)(RAL, \"RAL\");\n        (function(RAL2) {\n            function install(ral) {\n                if (ral === void 0) throw new Error(`No runtime abstraction layer provided`);\n                _ral = ral;\n            }\n            (0, $7xxrv.__name)(install, \"install\");\n            RAL2.install = install;\n        })(RAL || (RAL = {}));\n        exports.default = RAL;\n    }\n});\n// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/is.js\nvar $1d44efb04eab6ceb$var$require_is = (0, $7xxrv.__commonJS)({\n    \"../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/is.js\" (exports) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n        exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;\n        function boolean(value) {\n            return value === true || value === false;\n        }\n        (0, $7xxrv.__name)(boolean, \"boolean\");\n        exports.boolean = boolean;\n        function string(value) {\n            return typeof value === \"string\" || value instanceof String;\n        }\n        (0, $7xxrv.__name)(string, \"string\");\n        exports.string = string;\n        function number(value) {\n            return typeof value === \"number\" || value instanceof Number;\n        }\n        (0, $7xxrv.__name)(number, \"number\");\n        exports.number = number;\n        function error(value) {\n            return value instanceof Error;\n        }\n        (0, $7xxrv.__name)(error, \"error\");\n        exports.error = error;\n        function func(value) {\n            return typeof value === \"function\";\n        }\n        (0, $7xxrv.__name)(func, \"func\");\n        exports.func = func;\n        function array(value) {\n            return Array.isArray(value);\n        }\n        (0, $7xxrv.__name)(array, \"array\");\n        exports.array = array;\n        function stringArray(value) {\n            return array(value) && value.every((elem)=>string(elem));\n        }\n        (0, $7xxrv.__name)(stringArray, \"stringArray\");\n        exports.stringArray = stringArray;\n    }\n});\n// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/events.js\nvar $1d44efb04eab6ceb$var$require_events = (0, $7xxrv.__commonJS)({\n    \"../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/events.js\" (exports) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n        exports.Emitter = exports.Event = void 0;\n        var ral_1 = $1d44efb04eab6ceb$var$require_ral();\n        var Event;\n        (function(Event2) {\n            const _disposable = {\n                dispose () {}\n            };\n            Event2.None = function() {\n                return _disposable;\n            };\n        })(Event || (exports.Event = Event = {}));\n        var CallbackList = class {\n            static{\n                (0, $7xxrv.__name)(this, \"CallbackList\");\n            }\n            add(callback, context = null, bucket) {\n                if (!this._callbacks) {\n                    this._callbacks = [];\n                    this._contexts = [];\n                }\n                this._callbacks.push(callback);\n                this._contexts.push(context);\n                if (Array.isArray(bucket)) bucket.push({\n                    dispose: /* @__PURE__ */ (0, $7xxrv.__name)(()=>this.remove(callback, context), \"dispose\")\n                });\n            }\n            remove(callback, context = null) {\n                if (!this._callbacks) return;\n                let foundCallbackWithDifferentContext = false;\n                for(let i = 0, len = this._callbacks.length; i < len; i++)if (this._callbacks[i] === callback) {\n                    if (this._contexts[i] === context) {\n                        this._callbacks.splice(i, 1);\n                        this._contexts.splice(i, 1);\n                        return;\n                    } else foundCallbackWithDifferentContext = true;\n                }\n                if (foundCallbackWithDifferentContext) throw new Error(\"When adding a listener with a context, you should remove it with the same context\");\n            }\n            invoke(...args) {\n                if (!this._callbacks) return [];\n                const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);\n                for(let i = 0, len = callbacks.length; i < len; i++)try {\n                    ret.push(callbacks[i].apply(contexts[i], args));\n                } catch (e) {\n                    (0, ral_1.default)().console.error(e);\n                }\n                return ret;\n            }\n            isEmpty() {\n                return !this._callbacks || this._callbacks.length === 0;\n            }\n            dispose() {\n                this._callbacks = void 0;\n                this._contexts = void 0;\n            }\n        };\n        var Emitter2 = class _Emitter {\n            static{\n                (0, $7xxrv.__name)(this, \"Emitter\");\n            }\n            constructor(_options){\n                this._options = _options;\n            }\n            /**\n       * For the public to allow to subscribe\n       * to events from this Emitter\n       */ get event() {\n                if (!this._event) this._event = (listener, thisArgs, disposables)=>{\n                    if (!this._callbacks) this._callbacks = new CallbackList();\n                    if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) this._options.onFirstListenerAdd(this);\n                    this._callbacks.add(listener, thisArgs);\n                    const result = {\n                        dispose: /* @__PURE__ */ (0, $7xxrv.__name)(()=>{\n                            if (!this._callbacks) return;\n                            this._callbacks.remove(listener, thisArgs);\n                            result.dispose = _Emitter._noop;\n                            if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) this._options.onLastListenerRemove(this);\n                        }, \"dispose\")\n                    };\n                    if (Array.isArray(disposables)) disposables.push(result);\n                    return result;\n                };\n                return this._event;\n            }\n            /**\n       * To be kept private to fire an event to\n       * subscribers\n       */ fire(event) {\n                if (this._callbacks) this._callbacks.invoke.call(this._callbacks, event);\n            }\n            dispose() {\n                if (this._callbacks) {\n                    this._callbacks.dispose();\n                    this._callbacks = void 0;\n                }\n            }\n        };\n        exports.Emitter = Emitter2;\n        Emitter2._noop = function() {};\n    }\n});\n// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/cancellation.js\nvar $1d44efb04eab6ceb$var$require_cancellation = (0, $7xxrv.__commonJS)({\n    \"../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/cancellation.js\" (exports) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n        exports.CancellationTokenSource = exports.CancellationToken = void 0;\n        var ral_1 = $1d44efb04eab6ceb$var$require_ral();\n        var Is2 = $1d44efb04eab6ceb$var$require_is();\n        var events_1 = $1d44efb04eab6ceb$var$require_events();\n        var CancellationToken11;\n        (function(CancellationToken12) {\n            CancellationToken12.None = Object.freeze({\n                isCancellationRequested: false,\n                onCancellationRequested: events_1.Event.None\n            });\n            CancellationToken12.Cancelled = Object.freeze({\n                isCancellationRequested: true,\n                onCancellationRequested: events_1.Event.None\n            });\n            function is(value) {\n                const candidate = value;\n                return candidate && (candidate === CancellationToken12.None || candidate === CancellationToken12.Cancelled || Is2.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);\n            }\n            (0, $7xxrv.__name)(is, \"is\");\n            CancellationToken12.is = is;\n        })(CancellationToken11 || (exports.CancellationToken = CancellationToken11 = {}));\n        var shortcutEvent = Object.freeze(function(callback, context) {\n            const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);\n            return {\n                dispose () {\n                    handle.dispose();\n                }\n            };\n        });\n        var MutableToken = class {\n            static{\n                (0, $7xxrv.__name)(this, \"MutableToken\");\n            }\n            constructor(){\n                this._isCancelled = false;\n            }\n            cancel() {\n                if (!this._isCancelled) {\n                    this._isCancelled = true;\n                    if (this._emitter) {\n                        this._emitter.fire(void 0);\n                        this.dispose();\n                    }\n                }\n            }\n            get isCancellationRequested() {\n                return this._isCancelled;\n            }\n            get onCancellationRequested() {\n                if (this._isCancelled) return shortcutEvent;\n                if (!this._emitter) this._emitter = new events_1.Emitter();\n                return this._emitter.event;\n            }\n            dispose() {\n                if (this._emitter) {\n                    this._emitter.dispose();\n                    this._emitter = void 0;\n                }\n            }\n        };\n        var CancellationTokenSource3 = class {\n            static{\n                (0, $7xxrv.__name)(this, \"CancellationTokenSource\");\n            }\n            get token() {\n                if (!this._token) this._token = new MutableToken();\n                return this._token;\n            }\n            cancel() {\n                if (!this._token) this._token = CancellationToken11.Cancelled;\n                else this._token.cancel();\n            }\n            dispose() {\n                if (!this._token) this._token = CancellationToken11.None;\n                else if (this._token instanceof MutableToken) this._token.dispose();\n            }\n        };\n        exports.CancellationTokenSource = CancellationTokenSource3;\n    }\n});\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/index.js\nvar $1d44efb04eab6ceb$export$d254ce2913df4585 = {};\n(0, $7xxrv.__export)($1d44efb04eab6ceb$export$d254ce2913df4585, {\n    AbstractAstReflection: ()=>$1d44efb04eab6ceb$var$AbstractAstReflection,\n    AbstractCstNode: ()=>$1d44efb04eab6ceb$var$AbstractCstNode,\n    AbstractLangiumParser: ()=>$1d44efb04eab6ceb$var$AbstractLangiumParser,\n    AbstractParserErrorMessageProvider: ()=>$1d44efb04eab6ceb$var$AbstractParserErrorMessageProvider,\n    AbstractThreadedAsyncParser: ()=>$1d44efb04eab6ceb$var$AbstractThreadedAsyncParser,\n    AstUtils: ()=>$1d44efb04eab6ceb$var$ast_utils_exports,\n    BiMap: ()=>$1d44efb04eab6ceb$var$BiMap,\n    Cancellation: ()=>$1d44efb04eab6ceb$var$cancellation_exports,\n    CompositeCstNodeImpl: ()=>$1d44efb04eab6ceb$var$CompositeCstNodeImpl,\n    ContextCache: ()=>$1d44efb04eab6ceb$var$ContextCache,\n    CstNodeBuilder: ()=>$1d44efb04eab6ceb$var$CstNodeBuilder,\n    CstUtils: ()=>$1d44efb04eab6ceb$var$cst_utils_exports,\n    DONE_RESULT: ()=>$1d44efb04eab6ceb$var$DONE_RESULT,\n    DatatypeSymbol: ()=>$1d44efb04eab6ceb$var$DatatypeSymbol,\n    DefaultAstNodeDescriptionProvider: ()=>$1d44efb04eab6ceb$var$DefaultAstNodeDescriptionProvider,\n    DefaultAstNodeLocator: ()=>$1d44efb04eab6ceb$var$DefaultAstNodeLocator,\n    DefaultAsyncParser: ()=>$1d44efb04eab6ceb$var$DefaultAsyncParser,\n    DefaultCommentProvider: ()=>$1d44efb04eab6ceb$var$DefaultCommentProvider,\n    DefaultConfigurationProvider: ()=>$1d44efb04eab6ceb$var$DefaultConfigurationProvider,\n    DefaultDocumentBuilder: ()=>$1d44efb04eab6ceb$var$DefaultDocumentBuilder,\n    DefaultDocumentValidator: ()=>$1d44efb04eab6ceb$var$DefaultDocumentValidator,\n    DefaultHydrator: ()=>$1d44efb04eab6ceb$var$DefaultHydrator,\n    DefaultIndexManager: ()=>$1d44efb04eab6ceb$var$DefaultIndexManager,\n    DefaultJsonSerializer: ()=>$1d44efb04eab6ceb$var$DefaultJsonSerializer,\n    DefaultLangiumDocumentFactory: ()=>$1d44efb04eab6ceb$var$DefaultLangiumDocumentFactory,\n    DefaultLangiumDocuments: ()=>$1d44efb04eab6ceb$var$DefaultLangiumDocuments,\n    DefaultLexer: ()=>$1d44efb04eab6ceb$var$DefaultLexer,\n    DefaultLinker: ()=>$1d44efb04eab6ceb$var$DefaultLinker,\n    DefaultNameProvider: ()=>$1d44efb04eab6ceb$var$DefaultNameProvider,\n    DefaultReferenceDescriptionProvider: ()=>$1d44efb04eab6ceb$var$DefaultReferenceDescriptionProvider,\n    DefaultReferences: ()=>$1d44efb04eab6ceb$var$DefaultReferences,\n    DefaultScopeComputation: ()=>$1d44efb04eab6ceb$var$DefaultScopeComputation,\n    DefaultScopeProvider: ()=>$1d44efb04eab6ceb$var$DefaultScopeProvider,\n    DefaultServiceRegistry: ()=>$1d44efb04eab6ceb$var$DefaultServiceRegistry,\n    DefaultTokenBuilder: ()=>$1d44efb04eab6ceb$var$DefaultTokenBuilder,\n    DefaultValueConverter: ()=>$1d44efb04eab6ceb$var$DefaultValueConverter,\n    DefaultWorkspaceLock: ()=>$1d44efb04eab6ceb$var$DefaultWorkspaceLock,\n    DefaultWorkspaceManager: ()=>$1d44efb04eab6ceb$var$DefaultWorkspaceManager,\n    Deferred: ()=>$1d44efb04eab6ceb$var$Deferred,\n    Disposable: ()=>$1d44efb04eab6ceb$var$Disposable,\n    DisposableCache: ()=>$1d44efb04eab6ceb$var$DisposableCache,\n    DocumentCache: ()=>$1d44efb04eab6ceb$var$DocumentCache,\n    DocumentState: ()=>$1d44efb04eab6ceb$var$DocumentState,\n    DocumentValidator: ()=>$1d44efb04eab6ceb$var$DocumentValidator,\n    EMPTY_SCOPE: ()=>$1d44efb04eab6ceb$var$EMPTY_SCOPE,\n    EMPTY_STREAM: ()=>$1d44efb04eab6ceb$var$EMPTY_STREAM,\n    EmptyFileSystem: ()=>$1d44efb04eab6ceb$export$9849fb42e1532cce,\n    EmptyFileSystemProvider: ()=>$1d44efb04eab6ceb$var$EmptyFileSystemProvider,\n    ErrorWithLocation: ()=>$1d44efb04eab6ceb$var$ErrorWithLocation,\n    GrammarAST: ()=>$1d44efb04eab6ceb$var$ast_exports,\n    GrammarUtils: ()=>$1d44efb04eab6ceb$var$grammar_utils_exports,\n    JSDocDocumentationProvider: ()=>$1d44efb04eab6ceb$var$JSDocDocumentationProvider,\n    LangiumCompletionParser: ()=>$1d44efb04eab6ceb$var$LangiumCompletionParser,\n    LangiumParser: ()=>$1d44efb04eab6ceb$var$LangiumParser,\n    LangiumParserErrorMessageProvider: ()=>$1d44efb04eab6ceb$var$LangiumParserErrorMessageProvider,\n    LeafCstNodeImpl: ()=>$1d44efb04eab6ceb$var$LeafCstNodeImpl,\n    MapScope: ()=>$1d44efb04eab6ceb$var$MapScope,\n    Module: ()=>$1d44efb04eab6ceb$var$Module,\n    MultiMap: ()=>$1d44efb04eab6ceb$var$MultiMap,\n    OperationCancelled: ()=>$1d44efb04eab6ceb$var$OperationCancelled,\n    ParserWorker: ()=>$1d44efb04eab6ceb$var$ParserWorker,\n    Reduction: ()=>$1d44efb04eab6ceb$var$Reduction,\n    RegExpUtils: ()=>$1d44efb04eab6ceb$var$regexp_utils_exports,\n    RootCstNodeImpl: ()=>$1d44efb04eab6ceb$var$RootCstNodeImpl,\n    SimpleCache: ()=>$1d44efb04eab6ceb$var$SimpleCache,\n    StreamImpl: ()=>$1d44efb04eab6ceb$var$StreamImpl,\n    StreamScope: ()=>$1d44efb04eab6ceb$var$StreamScope,\n    TextDocument: ()=>$1d44efb04eab6ceb$var$TextDocument2,\n    TreeStreamImpl: ()=>$1d44efb04eab6ceb$var$TreeStreamImpl,\n    URI: ()=>$1d44efb04eab6ceb$var$URI2,\n    UriUtils: ()=>$1d44efb04eab6ceb$var$UriUtils,\n    ValidationCategory: ()=>$1d44efb04eab6ceb$var$ValidationCategory,\n    ValidationRegistry: ()=>$1d44efb04eab6ceb$var$ValidationRegistry,\n    ValueConverter: ()=>$1d44efb04eab6ceb$var$ValueConverter,\n    WorkspaceCache: ()=>$1d44efb04eab6ceb$var$WorkspaceCache,\n    assertUnreachable: ()=>$1d44efb04eab6ceb$var$assertUnreachable,\n    createCompletionParser: ()=>$1d44efb04eab6ceb$var$createCompletionParser,\n    createDefaultCoreModule: ()=>$1d44efb04eab6ceb$export$eab5a4b5adef815d,\n    createDefaultSharedCoreModule: ()=>$1d44efb04eab6ceb$export$dbab074a2a0a86aa,\n    createGrammarConfig: ()=>$1d44efb04eab6ceb$var$createGrammarConfig,\n    createLangiumParser: ()=>$1d44efb04eab6ceb$var$createLangiumParser,\n    delayNextTick: ()=>$1d44efb04eab6ceb$var$delayNextTick,\n    diagnosticData: ()=>$1d44efb04eab6ceb$var$diagnosticData,\n    eagerLoad: ()=>$1d44efb04eab6ceb$var$eagerLoad,\n    getDiagnosticRange: ()=>$1d44efb04eab6ceb$var$getDiagnosticRange,\n    inject: ()=>$1d44efb04eab6ceb$export$a976684a0efeb93f,\n    interruptAndCheck: ()=>$1d44efb04eab6ceb$var$interruptAndCheck,\n    isAstNode: ()=>$1d44efb04eab6ceb$var$isAstNode,\n    isAstNodeDescription: ()=>$1d44efb04eab6ceb$var$isAstNodeDescription,\n    isAstNodeWithComment: ()=>$1d44efb04eab6ceb$var$isAstNodeWithComment,\n    isCompositeCstNode: ()=>$1d44efb04eab6ceb$var$isCompositeCstNode,\n    isIMultiModeLexerDefinition: ()=>$1d44efb04eab6ceb$var$isIMultiModeLexerDefinition,\n    isJSDoc: ()=>$1d44efb04eab6ceb$var$isJSDoc,\n    isLeafCstNode: ()=>$1d44efb04eab6ceb$var$isLeafCstNode,\n    isLinkingError: ()=>$1d44efb04eab6ceb$var$isLinkingError,\n    isNamed: ()=>$1d44efb04eab6ceb$var$isNamed,\n    isOperationCancelled: ()=>$1d44efb04eab6ceb$var$isOperationCancelled,\n    isReference: ()=>$1d44efb04eab6ceb$var$isReference,\n    isRootCstNode: ()=>$1d44efb04eab6ceb$var$isRootCstNode,\n    isTokenTypeArray: ()=>$1d44efb04eab6ceb$var$isTokenTypeArray,\n    isTokenTypeDictionary: ()=>$1d44efb04eab6ceb$var$isTokenTypeDictionary,\n    loadGrammarFromJson: ()=>$1d44efb04eab6ceb$var$loadGrammarFromJson,\n    parseJSDoc: ()=>$1d44efb04eab6ceb$var$parseJSDoc,\n    prepareLangiumParser: ()=>$1d44efb04eab6ceb$var$prepareLangiumParser,\n    setInterruptionPeriod: ()=>$1d44efb04eab6ceb$var$setInterruptionPeriod,\n    startCancelableOperation: ()=>$1d44efb04eab6ceb$var$startCancelableOperation,\n    stream: ()=>$1d44efb04eab6ceb$var$stream,\n    toDiagnosticSeverity: ()=>$1d44efb04eab6ceb$var$toDiagnosticSeverity\n});\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/cst-utils.js\nvar $1d44efb04eab6ceb$var$cst_utils_exports = {};\n(0, $7xxrv.__export)($1d44efb04eab6ceb$var$cst_utils_exports, {\n    DefaultNameRegexp: ()=>$1d44efb04eab6ceb$var$DefaultNameRegexp,\n    RangeComparison: ()=>$1d44efb04eab6ceb$var$RangeComparison,\n    compareRange: ()=>$1d44efb04eab6ceb$var$compareRange,\n    findCommentNode: ()=>$1d44efb04eab6ceb$var$findCommentNode,\n    findDeclarationNodeAtOffset: ()=>$1d44efb04eab6ceb$var$findDeclarationNodeAtOffset,\n    findLeafNodeAtOffset: ()=>$1d44efb04eab6ceb$var$findLeafNodeAtOffset,\n    findLeafNodeBeforeOffset: ()=>$1d44efb04eab6ceb$var$findLeafNodeBeforeOffset,\n    flattenCst: ()=>$1d44efb04eab6ceb$var$flattenCst,\n    getInteriorNodes: ()=>$1d44efb04eab6ceb$var$getInteriorNodes,\n    getNextNode: ()=>$1d44efb04eab6ceb$var$getNextNode,\n    getPreviousNode: ()=>$1d44efb04eab6ceb$var$getPreviousNode,\n    getStartlineNode: ()=>$1d44efb04eab6ceb$var$getStartlineNode,\n    inRange: ()=>$1d44efb04eab6ceb$var$inRange,\n    isChildNode: ()=>$1d44efb04eab6ceb$var$isChildNode,\n    isCommentNode: ()=>$1d44efb04eab6ceb$var$isCommentNode,\n    streamCst: ()=>$1d44efb04eab6ceb$var$streamCst,\n    toDocumentSegment: ()=>$1d44efb04eab6ceb$var$toDocumentSegment,\n    tokenToRange: ()=>$1d44efb04eab6ceb$var$tokenToRange\n});\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/syntax-tree.js\nfunction $1d44efb04eab6ceb$var$isAstNode(obj) {\n    return typeof obj === \"object\" && obj !== null && typeof obj.$type === \"string\";\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isAstNode, \"isAstNode\");\nfunction $1d44efb04eab6ceb$var$isReference(obj) {\n    return typeof obj === \"object\" && obj !== null && typeof obj.$refText === \"string\";\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isReference, \"isReference\");\nfunction $1d44efb04eab6ceb$var$isAstNodeDescription(obj) {\n    return typeof obj === \"object\" && obj !== null && typeof obj.name === \"string\" && typeof obj.type === \"string\" && typeof obj.path === \"string\";\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isAstNodeDescription, \"isAstNodeDescription\");\nfunction $1d44efb04eab6ceb$var$isLinkingError(obj) {\n    return typeof obj === \"object\" && obj !== null && $1d44efb04eab6ceb$var$isAstNode(obj.container) && $1d44efb04eab6ceb$var$isReference(obj.reference) && typeof obj.message === \"string\";\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isLinkingError, \"isLinkingError\");\nvar $1d44efb04eab6ceb$var$AbstractAstReflection = class {\n    static{\n        (0, $7xxrv.__name)(this, \"AbstractAstReflection\");\n    }\n    constructor(){\n        this.subtypes = {};\n        this.allSubtypes = {};\n    }\n    isInstance(node, type) {\n        return $1d44efb04eab6ceb$var$isAstNode(node) && this.isSubtype(node.$type, type);\n    }\n    isSubtype(subtype, supertype) {\n        if (subtype === supertype) return true;\n        let nested = this.subtypes[subtype];\n        if (!nested) nested = this.subtypes[subtype] = {};\n        const existing = nested[supertype];\n        if (existing !== void 0) return existing;\n        else {\n            const result = this.computeIsSubtype(subtype, supertype);\n            nested[supertype] = result;\n            return result;\n        }\n    }\n    getAllSubTypes(type) {\n        const existing = this.allSubtypes[type];\n        if (existing) return existing;\n        else {\n            const allTypes = this.getAllTypes();\n            const types = [];\n            for (const possibleSubType of allTypes)if (this.isSubtype(possibleSubType, type)) types.push(possibleSubType);\n            this.allSubtypes[type] = types;\n            return types;\n        }\n    }\n};\nfunction $1d44efb04eab6ceb$var$isCompositeCstNode(node) {\n    return typeof node === \"object\" && node !== null && Array.isArray(node.content);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isCompositeCstNode, \"isCompositeCstNode\");\nfunction $1d44efb04eab6ceb$var$isLeafCstNode(node) {\n    return typeof node === \"object\" && node !== null && typeof node.tokenType === \"object\";\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isLeafCstNode, \"isLeafCstNode\");\nfunction $1d44efb04eab6ceb$var$isRootCstNode(node) {\n    return $1d44efb04eab6ceb$var$isCompositeCstNode(node) && typeof node.fullText === \"string\";\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isRootCstNode, \"isRootCstNode\");\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/stream.js\nvar $1d44efb04eab6ceb$var$StreamImpl = class _StreamImpl {\n    static{\n        (0, $7xxrv.__name)(this, \"StreamImpl\");\n    }\n    constructor(startFn, nextFn){\n        this.startFn = startFn;\n        this.nextFn = nextFn;\n    }\n    iterator() {\n        const iterator = {\n            state: this.startFn(),\n            next: /* @__PURE__ */ (0, $7xxrv.__name)(()=>this.nextFn(iterator.state), \"next\"),\n            [Symbol.iterator]: ()=>iterator\n        };\n        return iterator;\n    }\n    [Symbol.iterator]() {\n        return this.iterator();\n    }\n    isEmpty() {\n        const iterator = this.iterator();\n        return Boolean(iterator.next().done);\n    }\n    count() {\n        const iterator = this.iterator();\n        let count = 0;\n        let next = iterator.next();\n        while(!next.done){\n            count++;\n            next = iterator.next();\n        }\n        return count;\n    }\n    toArray() {\n        const result = [];\n        const iterator = this.iterator();\n        let next;\n        do {\n            next = iterator.next();\n            if (next.value !== void 0) result.push(next.value);\n        }while (!next.done);\n        return result;\n    }\n    toSet() {\n        return new Set(this);\n    }\n    toMap(keyFn, valueFn) {\n        const entryStream = this.map((element)=>[\n                keyFn ? keyFn(element) : element,\n                valueFn ? valueFn(element) : element\n            ]);\n        return new Map(entryStream);\n    }\n    toString() {\n        return this.join();\n    }\n    concat(other) {\n        const iterator = other[Symbol.iterator]();\n        return new _StreamImpl(()=>({\n                first: this.startFn(),\n                firstDone: false\n            }), (state)=>{\n            let result;\n            if (!state.firstDone) {\n                do {\n                    result = this.nextFn(state.first);\n                    if (!result.done) return result;\n                }while (!result.done);\n                state.firstDone = true;\n            }\n            do {\n                result = iterator.next();\n                if (!result.done) return result;\n            }while (!result.done);\n            return $1d44efb04eab6ceb$var$DONE_RESULT;\n        });\n    }\n    join(separator = \",\") {\n        const iterator = this.iterator();\n        let value = \"\";\n        let result;\n        let addSeparator = false;\n        do {\n            result = iterator.next();\n            if (!result.done) {\n                if (addSeparator) value += separator;\n                value += $1d44efb04eab6ceb$var$toString(result.value);\n            }\n            addSeparator = true;\n        }while (!result.done);\n        return value;\n    }\n    indexOf(searchElement, fromIndex = 0) {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while(!next.done){\n            if (index >= fromIndex && next.value === searchElement) return index;\n            next = iterator.next();\n            index++;\n        }\n        return -1;\n    }\n    every(predicate) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while(!next.done){\n            if (!predicate(next.value)) return false;\n            next = iterator.next();\n        }\n        return true;\n    }\n    some(predicate) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while(!next.done){\n            if (predicate(next.value)) return true;\n            next = iterator.next();\n        }\n        return false;\n    }\n    forEach(callbackfn) {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while(!next.done){\n            callbackfn(next.value, index);\n            next = iterator.next();\n            index++;\n        }\n    }\n    map(callbackfn) {\n        return new _StreamImpl(this.startFn, (state)=>{\n            const { done: done, value: value } = this.nextFn(state);\n            if (done) return $1d44efb04eab6ceb$var$DONE_RESULT;\n            else return {\n                done: false,\n                value: callbackfn(value)\n            };\n        });\n    }\n    filter(predicate) {\n        return new _StreamImpl(this.startFn, (state)=>{\n            let result;\n            do {\n                result = this.nextFn(state);\n                if (!result.done && predicate(result.value)) return result;\n            }while (!result.done);\n            return $1d44efb04eab6ceb$var$DONE_RESULT;\n        });\n    }\n    nonNullable() {\n        return this.filter((e)=>e !== void 0 && e !== null);\n    }\n    reduce(callbackfn, initialValue) {\n        const iterator = this.iterator();\n        let previousValue = initialValue;\n        let next = iterator.next();\n        while(!next.done){\n            if (previousValue === void 0) previousValue = next.value;\n            else previousValue = callbackfn(previousValue, next.value);\n            next = iterator.next();\n        }\n        return previousValue;\n    }\n    reduceRight(callbackfn, initialValue) {\n        return this.recursiveReduce(this.iterator(), callbackfn, initialValue);\n    }\n    recursiveReduce(iterator, callbackfn, initialValue) {\n        const next = iterator.next();\n        if (next.done) return initialValue;\n        const previousValue = this.recursiveReduce(iterator, callbackfn, initialValue);\n        if (previousValue === void 0) return next.value;\n        return callbackfn(previousValue, next.value);\n    }\n    find(predicate) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while(!next.done){\n            if (predicate(next.value)) return next.value;\n            next = iterator.next();\n        }\n        return void 0;\n    }\n    findIndex(predicate) {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while(!next.done){\n            if (predicate(next.value)) return index;\n            next = iterator.next();\n            index++;\n        }\n        return -1;\n    }\n    includes(searchElement) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while(!next.done){\n            if (next.value === searchElement) return true;\n            next = iterator.next();\n        }\n        return false;\n    }\n    flatMap(callbackfn) {\n        return new _StreamImpl(()=>({\n                this: this.startFn()\n            }), (state)=>{\n            do {\n                if (state.iterator) {\n                    const next = state.iterator.next();\n                    if (next.done) state.iterator = void 0;\n                    else return next;\n                }\n                const { done: done, value: value } = this.nextFn(state.this);\n                if (!done) {\n                    const mapped = callbackfn(value);\n                    if ($1d44efb04eab6ceb$var$isIterable(mapped)) state.iterator = mapped[Symbol.iterator]();\n                    else return {\n                        done: false,\n                        value: mapped\n                    };\n                }\n            }while (state.iterator);\n            return $1d44efb04eab6ceb$var$DONE_RESULT;\n        });\n    }\n    flat(depth) {\n        if (depth === void 0) depth = 1;\n        if (depth <= 0) return this;\n        const stream2 = depth > 1 ? this.flat(depth - 1) : this;\n        return new _StreamImpl(()=>({\n                this: stream2.startFn()\n            }), (state)=>{\n            do {\n                if (state.iterator) {\n                    const next = state.iterator.next();\n                    if (next.done) state.iterator = void 0;\n                    else return next;\n                }\n                const { done: done, value: value } = stream2.nextFn(state.this);\n                if (!done) {\n                    if ($1d44efb04eab6ceb$var$isIterable(value)) state.iterator = value[Symbol.iterator]();\n                    else return {\n                        done: false,\n                        value: value\n                    };\n                }\n            }while (state.iterator);\n            return $1d44efb04eab6ceb$var$DONE_RESULT;\n        });\n    }\n    head() {\n        const iterator = this.iterator();\n        const result = iterator.next();\n        if (result.done) return void 0;\n        return result.value;\n    }\n    tail(skipCount = 1) {\n        return new _StreamImpl(()=>{\n            const state = this.startFn();\n            for(let i = 0; i < skipCount; i++){\n                const next = this.nextFn(state);\n                if (next.done) return state;\n            }\n            return state;\n        }, this.nextFn);\n    }\n    limit(maxSize) {\n        return new _StreamImpl(()=>({\n                size: 0,\n                state: this.startFn()\n            }), (state)=>{\n            state.size++;\n            if (state.size > maxSize) return $1d44efb04eab6ceb$var$DONE_RESULT;\n            return this.nextFn(state.state);\n        });\n    }\n    distinct(by) {\n        const set = /* @__PURE__ */ new Set();\n        return this.filter((e)=>{\n            const value = by ? by(e) : e;\n            if (set.has(value)) return false;\n            else {\n                set.add(value);\n                return true;\n            }\n        });\n    }\n    exclude(other, key) {\n        const otherKeySet = /* @__PURE__ */ new Set();\n        for (const item of other){\n            const value = key ? key(item) : item;\n            otherKeySet.add(value);\n        }\n        return this.filter((e)=>{\n            const ownKey = key ? key(e) : e;\n            return !otherKeySet.has(ownKey);\n        });\n    }\n};\nfunction $1d44efb04eab6ceb$var$toString(item) {\n    if (typeof item === \"string\") return item;\n    if (typeof item === \"undefined\") return \"undefined\";\n    if (typeof item.toString === \"function\") return item.toString();\n    return Object.prototype.toString.call(item);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$toString, \"toString\");\nfunction $1d44efb04eab6ceb$var$isIterable(obj) {\n    return !!obj && typeof obj[Symbol.iterator] === \"function\";\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isIterable, \"isIterable\");\nvar $1d44efb04eab6ceb$var$EMPTY_STREAM = new $1d44efb04eab6ceb$var$StreamImpl(()=>void 0, ()=>$1d44efb04eab6ceb$var$DONE_RESULT);\nvar $1d44efb04eab6ceb$var$DONE_RESULT = Object.freeze({\n    done: true,\n    value: void 0\n});\nfunction $1d44efb04eab6ceb$var$stream(...collections) {\n    if (collections.length === 1) {\n        const collection = collections[0];\n        if (collection instanceof $1d44efb04eab6ceb$var$StreamImpl) return collection;\n        if ($1d44efb04eab6ceb$var$isIterable(collection)) return new $1d44efb04eab6ceb$var$StreamImpl(()=>collection[Symbol.iterator](), (iterator)=>iterator.next());\n        if (typeof collection.length === \"number\") return new $1d44efb04eab6ceb$var$StreamImpl(()=>({\n                index: 0\n            }), (state)=>{\n            if (state.index < collection.length) return {\n                done: false,\n                value: collection[state.index++]\n            };\n            else return $1d44efb04eab6ceb$var$DONE_RESULT;\n        });\n    }\n    if (collections.length > 1) return new $1d44efb04eab6ceb$var$StreamImpl(()=>({\n            collIndex: 0,\n            arrIndex: 0\n        }), (state)=>{\n        do {\n            if (state.iterator) {\n                const next = state.iterator.next();\n                if (!next.done) return next;\n                state.iterator = void 0;\n            }\n            if (state.array) {\n                if (state.arrIndex < state.array.length) return {\n                    done: false,\n                    value: state.array[state.arrIndex++]\n                };\n                state.array = void 0;\n                state.arrIndex = 0;\n            }\n            if (state.collIndex < collections.length) {\n                const collection = collections[state.collIndex++];\n                if ($1d44efb04eab6ceb$var$isIterable(collection)) state.iterator = collection[Symbol.iterator]();\n                else if (collection && typeof collection.length === \"number\") state.array = collection;\n            }\n        }while (state.iterator || state.array || state.collIndex < collections.length);\n        return $1d44efb04eab6ceb$var$DONE_RESULT;\n    });\n    return $1d44efb04eab6ceb$var$EMPTY_STREAM;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$stream, \"stream\");\nvar $1d44efb04eab6ceb$var$TreeStreamImpl = class extends $1d44efb04eab6ceb$var$StreamImpl {\n    static{\n        (0, $7xxrv.__name)(this, \"TreeStreamImpl\");\n    }\n    constructor(root, children, options){\n        super(()=>({\n                iterators: (options === null || options === void 0 ? void 0 : options.includeRoot) ? [\n                    [\n                        root\n                    ][Symbol.iterator]()\n                ] : [\n                    children(root)[Symbol.iterator]()\n                ],\n                pruned: false\n            }), (state)=>{\n            if (state.pruned) {\n                state.iterators.pop();\n                state.pruned = false;\n            }\n            while(state.iterators.length > 0){\n                const iterator = state.iterators[state.iterators.length - 1];\n                const next = iterator.next();\n                if (next.done) state.iterators.pop();\n                else {\n                    state.iterators.push(children(next.value)[Symbol.iterator]());\n                    return next;\n                }\n            }\n            return $1d44efb04eab6ceb$var$DONE_RESULT;\n        });\n    }\n    iterator() {\n        const iterator = {\n            state: this.startFn(),\n            next: /* @__PURE__ */ (0, $7xxrv.__name)(()=>this.nextFn(iterator.state), \"next\"),\n            prune: /* @__PURE__ */ (0, $7xxrv.__name)(()=>{\n                iterator.state.pruned = true;\n            }, \"prune\"),\n            [Symbol.iterator]: ()=>iterator\n        };\n        return iterator;\n    }\n};\nvar $1d44efb04eab6ceb$var$Reduction;\n(function(Reduction2) {\n    function sum(stream2) {\n        return stream2.reduce((a, b)=>a + b, 0);\n    }\n    (0, $7xxrv.__name)(sum, \"sum\");\n    Reduction2.sum = sum;\n    function product(stream2) {\n        return stream2.reduce((a, b)=>a * b, 0);\n    }\n    (0, $7xxrv.__name)(product, \"product\");\n    Reduction2.product = product;\n    function min(stream2) {\n        return stream2.reduce((a, b)=>Math.min(a, b));\n    }\n    (0, $7xxrv.__name)(min, \"min\");\n    Reduction2.min = min;\n    function max(stream2) {\n        return stream2.reduce((a, b)=>Math.max(a, b));\n    }\n    (0, $7xxrv.__name)(max, \"max\");\n    Reduction2.max = max;\n})($1d44efb04eab6ceb$var$Reduction || ($1d44efb04eab6ceb$var$Reduction = {}));\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/cst-utils.js\nfunction $1d44efb04eab6ceb$var$streamCst(node) {\n    return new $1d44efb04eab6ceb$var$TreeStreamImpl(node, (element)=>{\n        if ($1d44efb04eab6ceb$var$isCompositeCstNode(element)) return element.content;\n        else return [];\n    }, {\n        includeRoot: true\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$streamCst, \"streamCst\");\nfunction $1d44efb04eab6ceb$var$flattenCst(node) {\n    return $1d44efb04eab6ceb$var$streamCst(node).filter($1d44efb04eab6ceb$var$isLeafCstNode);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$flattenCst, \"flattenCst\");\nfunction $1d44efb04eab6ceb$var$isChildNode(child, parent) {\n    while(child.container){\n        child = child.container;\n        if (child === parent) return true;\n    }\n    return false;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isChildNode, \"isChildNode\");\nfunction $1d44efb04eab6ceb$var$tokenToRange(token) {\n    return {\n        start: {\n            character: token.startColumn - 1,\n            line: token.startLine - 1\n        },\n        end: {\n            character: token.endColumn,\n            line: token.endLine - 1\n        }\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$tokenToRange, \"tokenToRange\");\nfunction $1d44efb04eab6ceb$var$toDocumentSegment(node) {\n    if (!node) return void 0;\n    const { offset: offset, end: end, range: range } = node;\n    return {\n        range: range,\n        offset: offset,\n        end: end,\n        length: end - offset\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$toDocumentSegment, \"toDocumentSegment\");\nvar $1d44efb04eab6ceb$var$RangeComparison;\n(function(RangeComparison2) {\n    RangeComparison2[RangeComparison2[\"Before\"] = 0] = \"Before\";\n    RangeComparison2[RangeComparison2[\"After\"] = 1] = \"After\";\n    RangeComparison2[RangeComparison2[\"OverlapFront\"] = 2] = \"OverlapFront\";\n    RangeComparison2[RangeComparison2[\"OverlapBack\"] = 3] = \"OverlapBack\";\n    RangeComparison2[RangeComparison2[\"Inside\"] = 4] = \"Inside\";\n})($1d44efb04eab6ceb$var$RangeComparison || ($1d44efb04eab6ceb$var$RangeComparison = {}));\nfunction $1d44efb04eab6ceb$var$compareRange(range, to) {\n    if (range.end.line < to.start.line || range.end.line === to.start.line && range.end.character < range.start.character) return $1d44efb04eab6ceb$var$RangeComparison.Before;\n    else if (range.start.line > to.end.line || range.start.line === to.end.line && range.start.character > to.end.character) return $1d44efb04eab6ceb$var$RangeComparison.After;\n    const startInside = range.start.line > to.start.line || range.start.line === to.start.line && range.start.character >= to.start.character;\n    const endInside = range.end.line < to.end.line || range.end.line === to.end.line && range.end.character <= to.end.character;\n    if (startInside && endInside) return $1d44efb04eab6ceb$var$RangeComparison.Inside;\n    else if (startInside) return $1d44efb04eab6ceb$var$RangeComparison.OverlapBack;\n    else return $1d44efb04eab6ceb$var$RangeComparison.OverlapFront;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$compareRange, \"compareRange\");\nfunction $1d44efb04eab6ceb$var$inRange(range, to) {\n    const comparison = $1d44efb04eab6ceb$var$compareRange(range, to);\n    return comparison > $1d44efb04eab6ceb$var$RangeComparison.After;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$inRange, \"inRange\");\nvar $1d44efb04eab6ceb$var$DefaultNameRegexp = /^[\\w\\p{L}]$/u;\nfunction $1d44efb04eab6ceb$var$findDeclarationNodeAtOffset(cstNode, offset, nameRegexp = $1d44efb04eab6ceb$var$DefaultNameRegexp) {\n    if (cstNode) {\n        if (offset > 0) {\n            const localOffset = offset - cstNode.offset;\n            const textAtOffset = cstNode.text.charAt(localOffset);\n            if (!nameRegexp.test(textAtOffset)) offset--;\n        }\n        return $1d44efb04eab6ceb$var$findLeafNodeAtOffset(cstNode, offset);\n    }\n    return void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findDeclarationNodeAtOffset, \"findDeclarationNodeAtOffset\");\nfunction $1d44efb04eab6ceb$var$findCommentNode(cstNode, commentNames) {\n    if (cstNode) {\n        const previous = $1d44efb04eab6ceb$var$getPreviousNode(cstNode, true);\n        if (previous && $1d44efb04eab6ceb$var$isCommentNode(previous, commentNames)) return previous;\n        if ($1d44efb04eab6ceb$var$isRootCstNode(cstNode)) {\n            const endIndex = cstNode.content.findIndex((e)=>!e.hidden);\n            for(let i = endIndex - 1; i >= 0; i--){\n                const child = cstNode.content[i];\n                if ($1d44efb04eab6ceb$var$isCommentNode(child, commentNames)) return child;\n            }\n        }\n    }\n    return void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findCommentNode, \"findCommentNode\");\nfunction $1d44efb04eab6ceb$var$isCommentNode(cstNode, commentNames) {\n    return $1d44efb04eab6ceb$var$isLeafCstNode(cstNode) && commentNames.includes(cstNode.tokenType.name);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isCommentNode, \"isCommentNode\");\nfunction $1d44efb04eab6ceb$var$findLeafNodeAtOffset(node, offset) {\n    if ($1d44efb04eab6ceb$var$isLeafCstNode(node)) return node;\n    else if ($1d44efb04eab6ceb$var$isCompositeCstNode(node)) {\n        const searchResult = $1d44efb04eab6ceb$var$binarySearch(node, offset, false);\n        if (searchResult) return $1d44efb04eab6ceb$var$findLeafNodeAtOffset(searchResult, offset);\n    }\n    return void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findLeafNodeAtOffset, \"findLeafNodeAtOffset\");\nfunction $1d44efb04eab6ceb$var$findLeafNodeBeforeOffset(node, offset) {\n    if ($1d44efb04eab6ceb$var$isLeafCstNode(node)) return node;\n    else if ($1d44efb04eab6ceb$var$isCompositeCstNode(node)) {\n        const searchResult = $1d44efb04eab6ceb$var$binarySearch(node, offset, true);\n        if (searchResult) return $1d44efb04eab6ceb$var$findLeafNodeBeforeOffset(searchResult, offset);\n    }\n    return void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findLeafNodeBeforeOffset, \"findLeafNodeBeforeOffset\");\nfunction $1d44efb04eab6ceb$var$binarySearch(node, offset, closest) {\n    let left = 0;\n    let right = node.content.length - 1;\n    let closestNode = void 0;\n    while(left <= right){\n        const middle = Math.floor((left + right) / 2);\n        const middleNode = node.content[middle];\n        if (middleNode.offset <= offset && middleNode.end > offset) return middleNode;\n        if (middleNode.end <= offset) {\n            closestNode = closest ? middleNode : void 0;\n            left = middle + 1;\n        } else right = middle - 1;\n    }\n    return closestNode;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$binarySearch, \"binarySearch\");\nfunction $1d44efb04eab6ceb$var$getPreviousNode(node, hidden = true) {\n    while(node.container){\n        const parent = node.container;\n        let index = parent.content.indexOf(node);\n        while(index > 0){\n            index--;\n            const previous = parent.content[index];\n            if (hidden || !previous.hidden) return previous;\n        }\n        node = parent;\n    }\n    return void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getPreviousNode, \"getPreviousNode\");\nfunction $1d44efb04eab6ceb$var$getNextNode(node, hidden = true) {\n    while(node.container){\n        const parent = node.container;\n        let index = parent.content.indexOf(node);\n        const last = parent.content.length - 1;\n        while(index < last){\n            index++;\n            const next = parent.content[index];\n            if (hidden || !next.hidden) return next;\n        }\n        node = parent;\n    }\n    return void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getNextNode, \"getNextNode\");\nfunction $1d44efb04eab6ceb$var$getStartlineNode(node) {\n    if (node.range.start.character === 0) return node;\n    const line = node.range.start.line;\n    let last = node;\n    let index;\n    while(node.container){\n        const parent = node.container;\n        const selfIndex = index !== null && index !== void 0 ? index : parent.content.indexOf(node);\n        if (selfIndex === 0) {\n            node = parent;\n            index = void 0;\n        } else {\n            index = selfIndex - 1;\n            node = parent.content[index];\n        }\n        if (node.range.start.line !== line) break;\n        last = node;\n    }\n    return last;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getStartlineNode, \"getStartlineNode\");\nfunction $1d44efb04eab6ceb$var$getInteriorNodes(start, end) {\n    const commonParent = $1d44efb04eab6ceb$var$getCommonParent(start, end);\n    if (!commonParent) return [];\n    return commonParent.parent.content.slice(commonParent.a + 1, commonParent.b);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getInteriorNodes, \"getInteriorNodes\");\nfunction $1d44efb04eab6ceb$var$getCommonParent(a, b) {\n    const aParents = $1d44efb04eab6ceb$var$getParentChain(a);\n    const bParents = $1d44efb04eab6ceb$var$getParentChain(b);\n    let current;\n    for(let i = 0; i < aParents.length && i < bParents.length; i++){\n        const aParent = aParents[i];\n        const bParent = bParents[i];\n        if (aParent.parent === bParent.parent) current = {\n            parent: aParent.parent,\n            a: aParent.index,\n            b: bParent.index\n        };\n        else break;\n    }\n    return current;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getCommonParent, \"getCommonParent\");\nfunction $1d44efb04eab6ceb$var$getParentChain(node) {\n    const chain = [];\n    while(node.container){\n        const parent = node.container;\n        const index = parent.content.indexOf(node);\n        chain.push({\n            parent: parent,\n            index: index\n        });\n        node = parent;\n    }\n    return chain.reverse();\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getParentChain, \"getParentChain\");\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/grammar-utils.js\nvar $1d44efb04eab6ceb$var$grammar_utils_exports = {};\n(0, $7xxrv.__export)($1d44efb04eab6ceb$var$grammar_utils_exports, {\n    findAssignment: ()=>$1d44efb04eab6ceb$var$findAssignment,\n    findNameAssignment: ()=>$1d44efb04eab6ceb$var$findNameAssignment,\n    findNodeForKeyword: ()=>$1d44efb04eab6ceb$var$findNodeForKeyword,\n    findNodeForProperty: ()=>$1d44efb04eab6ceb$var$findNodeForProperty,\n    findNodesForKeyword: ()=>$1d44efb04eab6ceb$var$findNodesForKeyword,\n    findNodesForKeywordInternal: ()=>$1d44efb04eab6ceb$var$findNodesForKeywordInternal,\n    findNodesForProperty: ()=>$1d44efb04eab6ceb$var$findNodesForProperty,\n    getActionAtElement: ()=>$1d44efb04eab6ceb$var$getActionAtElement,\n    getActionType: ()=>$1d44efb04eab6ceb$var$getActionType,\n    getAllReachableRules: ()=>$1d44efb04eab6ceb$var$getAllReachableRules,\n    getCrossReferenceTerminal: ()=>$1d44efb04eab6ceb$var$getCrossReferenceTerminal,\n    getEntryRule: ()=>$1d44efb04eab6ceb$var$getEntryRule,\n    getExplicitRuleType: ()=>$1d44efb04eab6ceb$var$getExplicitRuleType,\n    getHiddenRules: ()=>$1d44efb04eab6ceb$var$getHiddenRules,\n    getRuleType: ()=>$1d44efb04eab6ceb$var$getRuleType,\n    getTypeName: ()=>$1d44efb04eab6ceb$var$getTypeName,\n    isArrayCardinality: ()=>$1d44efb04eab6ceb$var$isArrayCardinality,\n    isArrayOperator: ()=>$1d44efb04eab6ceb$var$isArrayOperator,\n    isCommentTerminal: ()=>$1d44efb04eab6ceb$var$isCommentTerminal,\n    isDataType: ()=>$1d44efb04eab6ceb$var$isDataType,\n    isDataTypeRule: ()=>$1d44efb04eab6ceb$var$isDataTypeRule,\n    isOptionalCardinality: ()=>$1d44efb04eab6ceb$var$isOptionalCardinality,\n    terminalRegex: ()=>$1d44efb04eab6ceb$var$terminalRegex\n});\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/errors.js\nvar $1d44efb04eab6ceb$var$ErrorWithLocation = class extends Error {\n    static{\n        (0, $7xxrv.__name)(this, \"ErrorWithLocation\");\n    }\n    constructor(node, message){\n        super(node ? `${message} at ${node.range.start.line}:${node.range.start.character}` : message);\n    }\n};\nfunction $1d44efb04eab6ceb$var$assertUnreachable(_) {\n    throw new Error(\"Error! The input value was not handled.\");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$assertUnreachable, \"assertUnreachable\");\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/languages/generated/ast.js\nvar $1d44efb04eab6ceb$var$ast_exports = {};\n(0, $7xxrv.__export)($1d44efb04eab6ceb$var$ast_exports, {\n    AbstractElement: ()=>$1d44efb04eab6ceb$var$AbstractElement,\n    AbstractRule: ()=>$1d44efb04eab6ceb$var$AbstractRule,\n    AbstractType: ()=>$1d44efb04eab6ceb$var$AbstractType,\n    Action: ()=>$1d44efb04eab6ceb$var$Action,\n    Alternatives: ()=>$1d44efb04eab6ceb$var$Alternatives,\n    ArrayLiteral: ()=>$1d44efb04eab6ceb$var$ArrayLiteral,\n    ArrayType: ()=>$1d44efb04eab6ceb$var$ArrayType,\n    Assignment: ()=>$1d44efb04eab6ceb$var$Assignment,\n    BooleanLiteral: ()=>$1d44efb04eab6ceb$var$BooleanLiteral,\n    CharacterRange: ()=>$1d44efb04eab6ceb$var$CharacterRange,\n    Condition: ()=>$1d44efb04eab6ceb$var$Condition,\n    Conjunction: ()=>$1d44efb04eab6ceb$var$Conjunction,\n    CrossReference: ()=>$1d44efb04eab6ceb$var$CrossReference,\n    Disjunction: ()=>$1d44efb04eab6ceb$var$Disjunction,\n    EndOfFile: ()=>$1d44efb04eab6ceb$var$EndOfFile,\n    Grammar: ()=>$1d44efb04eab6ceb$var$Grammar,\n    GrammarImport: ()=>$1d44efb04eab6ceb$var$GrammarImport,\n    Group: ()=>$1d44efb04eab6ceb$var$Group,\n    InferredType: ()=>$1d44efb04eab6ceb$var$InferredType,\n    Interface: ()=>$1d44efb04eab6ceb$var$Interface,\n    Keyword: ()=>$1d44efb04eab6ceb$var$Keyword,\n    LangiumGrammarAstReflection: ()=>$1d44efb04eab6ceb$var$LangiumGrammarAstReflection,\n    LangiumGrammarTerminals: ()=>$1d44efb04eab6ceb$var$LangiumGrammarTerminals,\n    NamedArgument: ()=>$1d44efb04eab6ceb$var$NamedArgument,\n    NegatedToken: ()=>$1d44efb04eab6ceb$var$NegatedToken,\n    Negation: ()=>$1d44efb04eab6ceb$var$Negation,\n    NumberLiteral: ()=>$1d44efb04eab6ceb$var$NumberLiteral,\n    Parameter: ()=>$1d44efb04eab6ceb$var$Parameter,\n    ParameterReference: ()=>$1d44efb04eab6ceb$var$ParameterReference,\n    ParserRule: ()=>$1d44efb04eab6ceb$var$ParserRule,\n    ReferenceType: ()=>$1d44efb04eab6ceb$var$ReferenceType,\n    RegexToken: ()=>$1d44efb04eab6ceb$var$RegexToken,\n    ReturnType: ()=>$1d44efb04eab6ceb$var$ReturnType,\n    RuleCall: ()=>$1d44efb04eab6ceb$var$RuleCall,\n    SimpleType: ()=>$1d44efb04eab6ceb$var$SimpleType,\n    StringLiteral: ()=>$1d44efb04eab6ceb$var$StringLiteral,\n    TerminalAlternatives: ()=>$1d44efb04eab6ceb$var$TerminalAlternatives,\n    TerminalGroup: ()=>$1d44efb04eab6ceb$var$TerminalGroup,\n    TerminalRule: ()=>$1d44efb04eab6ceb$var$TerminalRule,\n    TerminalRuleCall: ()=>$1d44efb04eab6ceb$var$TerminalRuleCall,\n    Type: ()=>$1d44efb04eab6ceb$var$Type,\n    TypeAttribute: ()=>$1d44efb04eab6ceb$var$TypeAttribute,\n    TypeDefinition: ()=>$1d44efb04eab6ceb$var$TypeDefinition,\n    UnionType: ()=>$1d44efb04eab6ceb$var$UnionType,\n    UnorderedGroup: ()=>$1d44efb04eab6ceb$var$UnorderedGroup,\n    UntilToken: ()=>$1d44efb04eab6ceb$var$UntilToken,\n    ValueLiteral: ()=>$1d44efb04eab6ceb$var$ValueLiteral,\n    Wildcard: ()=>$1d44efb04eab6ceb$var$Wildcard,\n    isAbstractElement: ()=>$1d44efb04eab6ceb$var$isAbstractElement,\n    isAbstractRule: ()=>$1d44efb04eab6ceb$var$isAbstractRule,\n    isAbstractType: ()=>$1d44efb04eab6ceb$var$isAbstractType,\n    isAction: ()=>$1d44efb04eab6ceb$var$isAction,\n    isAlternatives: ()=>$1d44efb04eab6ceb$var$isAlternatives,\n    isArrayLiteral: ()=>$1d44efb04eab6ceb$var$isArrayLiteral,\n    isArrayType: ()=>$1d44efb04eab6ceb$var$isArrayType,\n    isAssignment: ()=>$1d44efb04eab6ceb$var$isAssignment,\n    isBooleanLiteral: ()=>$1d44efb04eab6ceb$var$isBooleanLiteral,\n    isCharacterRange: ()=>$1d44efb04eab6ceb$var$isCharacterRange,\n    isCondition: ()=>$1d44efb04eab6ceb$var$isCondition,\n    isConjunction: ()=>$1d44efb04eab6ceb$var$isConjunction,\n    isCrossReference: ()=>$1d44efb04eab6ceb$var$isCrossReference,\n    isDisjunction: ()=>$1d44efb04eab6ceb$var$isDisjunction,\n    isEndOfFile: ()=>$1d44efb04eab6ceb$var$isEndOfFile,\n    isFeatureName: ()=>$1d44efb04eab6ceb$var$isFeatureName,\n    isGrammar: ()=>$1d44efb04eab6ceb$var$isGrammar,\n    isGrammarImport: ()=>$1d44efb04eab6ceb$var$isGrammarImport,\n    isGroup: ()=>$1d44efb04eab6ceb$var$isGroup,\n    isInferredType: ()=>$1d44efb04eab6ceb$var$isInferredType,\n    isInterface: ()=>$1d44efb04eab6ceb$var$isInterface,\n    isKeyword: ()=>$1d44efb04eab6ceb$var$isKeyword,\n    isNamedArgument: ()=>$1d44efb04eab6ceb$var$isNamedArgument,\n    isNegatedToken: ()=>$1d44efb04eab6ceb$var$isNegatedToken,\n    isNegation: ()=>$1d44efb04eab6ceb$var$isNegation,\n    isNumberLiteral: ()=>$1d44efb04eab6ceb$var$isNumberLiteral,\n    isParameter: ()=>$1d44efb04eab6ceb$var$isParameter,\n    isParameterReference: ()=>$1d44efb04eab6ceb$var$isParameterReference,\n    isParserRule: ()=>$1d44efb04eab6ceb$var$isParserRule,\n    isPrimitiveType: ()=>$1d44efb04eab6ceb$var$isPrimitiveType,\n    isReferenceType: ()=>$1d44efb04eab6ceb$var$isReferenceType,\n    isRegexToken: ()=>$1d44efb04eab6ceb$var$isRegexToken,\n    isReturnType: ()=>$1d44efb04eab6ceb$var$isReturnType,\n    isRuleCall: ()=>$1d44efb04eab6ceb$var$isRuleCall,\n    isSimpleType: ()=>$1d44efb04eab6ceb$var$isSimpleType,\n    isStringLiteral: ()=>$1d44efb04eab6ceb$var$isStringLiteral,\n    isTerminalAlternatives: ()=>$1d44efb04eab6ceb$var$isTerminalAlternatives,\n    isTerminalGroup: ()=>$1d44efb04eab6ceb$var$isTerminalGroup,\n    isTerminalRule: ()=>$1d44efb04eab6ceb$var$isTerminalRule,\n    isTerminalRuleCall: ()=>$1d44efb04eab6ceb$var$isTerminalRuleCall,\n    isType: ()=>$1d44efb04eab6ceb$var$isType,\n    isTypeAttribute: ()=>$1d44efb04eab6ceb$var$isTypeAttribute,\n    isTypeDefinition: ()=>$1d44efb04eab6ceb$var$isTypeDefinition,\n    isUnionType: ()=>$1d44efb04eab6ceb$var$isUnionType,\n    isUnorderedGroup: ()=>$1d44efb04eab6ceb$var$isUnorderedGroup,\n    isUntilToken: ()=>$1d44efb04eab6ceb$var$isUntilToken,\n    isValueLiteral: ()=>$1d44efb04eab6ceb$var$isValueLiteral,\n    isWildcard: ()=>$1d44efb04eab6ceb$var$isWildcard,\n    reflection: ()=>$1d44efb04eab6ceb$var$reflection\n});\nvar $1d44efb04eab6ceb$var$LangiumGrammarTerminals = {\n    ID: /\\^?[_a-zA-Z][\\w_]*/,\n    STRING: /\"(\\\\.|[^\"\\\\])*\"|'(\\\\.|[^'\\\\])*'/,\n    NUMBER: /NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity)/,\n    RegexLiteral: /\\/(?![*+?])(?:[^\\r\\n\\[/\\\\]|\\\\.|\\[(?:[^\\r\\n\\]\\\\]|\\\\.)*\\])+\\/[a-z]*/,\n    WS: /\\s+/,\n    ML_COMMENT: /\\/\\*[\\s\\S]*?\\*\\//,\n    SL_COMMENT: /\\/\\/[^\\n\\r]*/\n};\nvar $1d44efb04eab6ceb$var$AbstractRule = \"AbstractRule\";\nfunction $1d44efb04eab6ceb$var$isAbstractRule(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$AbstractRule);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isAbstractRule, \"isAbstractRule\");\nvar $1d44efb04eab6ceb$var$AbstractType = \"AbstractType\";\nfunction $1d44efb04eab6ceb$var$isAbstractType(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$AbstractType);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isAbstractType, \"isAbstractType\");\nvar $1d44efb04eab6ceb$var$Condition = \"Condition\";\nfunction $1d44efb04eab6ceb$var$isCondition(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$Condition);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isCondition, \"isCondition\");\nfunction $1d44efb04eab6ceb$var$isFeatureName(item) {\n    return $1d44efb04eab6ceb$var$isPrimitiveType(item) || item === \"current\" || item === \"entry\" || item === \"extends\" || item === \"false\" || item === \"fragment\" || item === \"grammar\" || item === \"hidden\" || item === \"import\" || item === \"interface\" || item === \"returns\" || item === \"terminal\" || item === \"true\" || item === \"type\" || item === \"infer\" || item === \"infers\" || item === \"with\" || typeof item === \"string\" && /\\^?[_a-zA-Z][\\w_]*/.test(item);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isFeatureName, \"isFeatureName\");\nfunction $1d44efb04eab6ceb$var$isPrimitiveType(item) {\n    return item === \"string\" || item === \"number\" || item === \"boolean\" || item === \"Date\" || item === \"bigint\";\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isPrimitiveType, \"isPrimitiveType\");\nvar $1d44efb04eab6ceb$var$TypeDefinition = \"TypeDefinition\";\nfunction $1d44efb04eab6ceb$var$isTypeDefinition(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$TypeDefinition);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isTypeDefinition, \"isTypeDefinition\");\nvar $1d44efb04eab6ceb$var$ValueLiteral = \"ValueLiteral\";\nfunction $1d44efb04eab6ceb$var$isValueLiteral(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$ValueLiteral);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isValueLiteral, \"isValueLiteral\");\nvar $1d44efb04eab6ceb$var$AbstractElement = \"AbstractElement\";\nfunction $1d44efb04eab6ceb$var$isAbstractElement(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$AbstractElement);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isAbstractElement, \"isAbstractElement\");\nvar $1d44efb04eab6ceb$var$ArrayLiteral = \"ArrayLiteral\";\nfunction $1d44efb04eab6ceb$var$isArrayLiteral(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$ArrayLiteral);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isArrayLiteral, \"isArrayLiteral\");\nvar $1d44efb04eab6ceb$var$ArrayType = \"ArrayType\";\nfunction $1d44efb04eab6ceb$var$isArrayType(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$ArrayType);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isArrayType, \"isArrayType\");\nvar $1d44efb04eab6ceb$var$BooleanLiteral = \"BooleanLiteral\";\nfunction $1d44efb04eab6ceb$var$isBooleanLiteral(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$BooleanLiteral);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isBooleanLiteral, \"isBooleanLiteral\");\nvar $1d44efb04eab6ceb$var$Conjunction = \"Conjunction\";\nfunction $1d44efb04eab6ceb$var$isConjunction(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$Conjunction);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isConjunction, \"isConjunction\");\nvar $1d44efb04eab6ceb$var$Disjunction = \"Disjunction\";\nfunction $1d44efb04eab6ceb$var$isDisjunction(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$Disjunction);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isDisjunction, \"isDisjunction\");\nvar $1d44efb04eab6ceb$var$Grammar = \"Grammar\";\nfunction $1d44efb04eab6ceb$var$isGrammar(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$Grammar);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isGrammar, \"isGrammar\");\nvar $1d44efb04eab6ceb$var$GrammarImport = \"GrammarImport\";\nfunction $1d44efb04eab6ceb$var$isGrammarImport(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$GrammarImport);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isGrammarImport, \"isGrammarImport\");\nvar $1d44efb04eab6ceb$var$InferredType = \"InferredType\";\nfunction $1d44efb04eab6ceb$var$isInferredType(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$InferredType);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isInferredType, \"isInferredType\");\nvar $1d44efb04eab6ceb$var$Interface = \"Interface\";\nfunction $1d44efb04eab6ceb$var$isInterface(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$Interface);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isInterface, \"isInterface\");\nvar $1d44efb04eab6ceb$var$NamedArgument = \"NamedArgument\";\nfunction $1d44efb04eab6ceb$var$isNamedArgument(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$NamedArgument);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isNamedArgument, \"isNamedArgument\");\nvar $1d44efb04eab6ceb$var$Negation = \"Negation\";\nfunction $1d44efb04eab6ceb$var$isNegation(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$Negation);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isNegation, \"isNegation\");\nvar $1d44efb04eab6ceb$var$NumberLiteral = \"NumberLiteral\";\nfunction $1d44efb04eab6ceb$var$isNumberLiteral(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$NumberLiteral);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isNumberLiteral, \"isNumberLiteral\");\nvar $1d44efb04eab6ceb$var$Parameter = \"Parameter\";\nfunction $1d44efb04eab6ceb$var$isParameter(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$Parameter);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isParameter, \"isParameter\");\nvar $1d44efb04eab6ceb$var$ParameterReference = \"ParameterReference\";\nfunction $1d44efb04eab6ceb$var$isParameterReference(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$ParameterReference);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isParameterReference, \"isParameterReference\");\nvar $1d44efb04eab6ceb$var$ParserRule = \"ParserRule\";\nfunction $1d44efb04eab6ceb$var$isParserRule(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$ParserRule);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isParserRule, \"isParserRule\");\nvar $1d44efb04eab6ceb$var$ReferenceType = \"ReferenceType\";\nfunction $1d44efb04eab6ceb$var$isReferenceType(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$ReferenceType);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isReferenceType, \"isReferenceType\");\nvar $1d44efb04eab6ceb$var$ReturnType = \"ReturnType\";\nfunction $1d44efb04eab6ceb$var$isReturnType(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$ReturnType);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isReturnType, \"isReturnType\");\nvar $1d44efb04eab6ceb$var$SimpleType = \"SimpleType\";\nfunction $1d44efb04eab6ceb$var$isSimpleType(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$SimpleType);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isSimpleType, \"isSimpleType\");\nvar $1d44efb04eab6ceb$var$StringLiteral = \"StringLiteral\";\nfunction $1d44efb04eab6ceb$var$isStringLiteral(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$StringLiteral);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isStringLiteral, \"isStringLiteral\");\nvar $1d44efb04eab6ceb$var$TerminalRule = \"TerminalRule\";\nfunction $1d44efb04eab6ceb$var$isTerminalRule(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$TerminalRule);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isTerminalRule, \"isTerminalRule\");\nvar $1d44efb04eab6ceb$var$Type = \"Type\";\nfunction $1d44efb04eab6ceb$var$isType(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$Type);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isType, \"isType\");\nvar $1d44efb04eab6ceb$var$TypeAttribute = \"TypeAttribute\";\nfunction $1d44efb04eab6ceb$var$isTypeAttribute(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$TypeAttribute);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isTypeAttribute, \"isTypeAttribute\");\nvar $1d44efb04eab6ceb$var$UnionType = \"UnionType\";\nfunction $1d44efb04eab6ceb$var$isUnionType(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$UnionType);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isUnionType, \"isUnionType\");\nvar $1d44efb04eab6ceb$var$Action = \"Action\";\nfunction $1d44efb04eab6ceb$var$isAction(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$Action);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isAction, \"isAction\");\nvar $1d44efb04eab6ceb$var$Alternatives = \"Alternatives\";\nfunction $1d44efb04eab6ceb$var$isAlternatives(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$Alternatives);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isAlternatives, \"isAlternatives\");\nvar $1d44efb04eab6ceb$var$Assignment = \"Assignment\";\nfunction $1d44efb04eab6ceb$var$isAssignment(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$Assignment);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isAssignment, \"isAssignment\");\nvar $1d44efb04eab6ceb$var$CharacterRange = \"CharacterRange\";\nfunction $1d44efb04eab6ceb$var$isCharacterRange(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$CharacterRange);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isCharacterRange, \"isCharacterRange\");\nvar $1d44efb04eab6ceb$var$CrossReference = \"CrossReference\";\nfunction $1d44efb04eab6ceb$var$isCrossReference(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$CrossReference);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isCrossReference, \"isCrossReference\");\nvar $1d44efb04eab6ceb$var$EndOfFile = \"EndOfFile\";\nfunction $1d44efb04eab6ceb$var$isEndOfFile(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$EndOfFile);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isEndOfFile, \"isEndOfFile\");\nvar $1d44efb04eab6ceb$var$Group = \"Group\";\nfunction $1d44efb04eab6ceb$var$isGroup(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$Group);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isGroup, \"isGroup\");\nvar $1d44efb04eab6ceb$var$Keyword = \"Keyword\";\nfunction $1d44efb04eab6ceb$var$isKeyword(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$Keyword);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isKeyword, \"isKeyword\");\nvar $1d44efb04eab6ceb$var$NegatedToken = \"NegatedToken\";\nfunction $1d44efb04eab6ceb$var$isNegatedToken(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$NegatedToken);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isNegatedToken, \"isNegatedToken\");\nvar $1d44efb04eab6ceb$var$RegexToken = \"RegexToken\";\nfunction $1d44efb04eab6ceb$var$isRegexToken(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$RegexToken);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isRegexToken, \"isRegexToken\");\nvar $1d44efb04eab6ceb$var$RuleCall = \"RuleCall\";\nfunction $1d44efb04eab6ceb$var$isRuleCall(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$RuleCall);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isRuleCall, \"isRuleCall\");\nvar $1d44efb04eab6ceb$var$TerminalAlternatives = \"TerminalAlternatives\";\nfunction $1d44efb04eab6ceb$var$isTerminalAlternatives(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$TerminalAlternatives);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isTerminalAlternatives, \"isTerminalAlternatives\");\nvar $1d44efb04eab6ceb$var$TerminalGroup = \"TerminalGroup\";\nfunction $1d44efb04eab6ceb$var$isTerminalGroup(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$TerminalGroup);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isTerminalGroup, \"isTerminalGroup\");\nvar $1d44efb04eab6ceb$var$TerminalRuleCall = \"TerminalRuleCall\";\nfunction $1d44efb04eab6ceb$var$isTerminalRuleCall(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$TerminalRuleCall);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isTerminalRuleCall, \"isTerminalRuleCall\");\nvar $1d44efb04eab6ceb$var$UnorderedGroup = \"UnorderedGroup\";\nfunction $1d44efb04eab6ceb$var$isUnorderedGroup(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$UnorderedGroup);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isUnorderedGroup, \"isUnorderedGroup\");\nvar $1d44efb04eab6ceb$var$UntilToken = \"UntilToken\";\nfunction $1d44efb04eab6ceb$var$isUntilToken(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$UntilToken);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isUntilToken, \"isUntilToken\");\nvar $1d44efb04eab6ceb$var$Wildcard = \"Wildcard\";\nfunction $1d44efb04eab6ceb$var$isWildcard(item) {\n    return $1d44efb04eab6ceb$var$reflection.isInstance(item, $1d44efb04eab6ceb$var$Wildcard);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isWildcard, \"isWildcard\");\nvar $1d44efb04eab6ceb$var$LangiumGrammarAstReflection = class extends $1d44efb04eab6ceb$var$AbstractAstReflection {\n    static{\n        (0, $7xxrv.__name)(this, \"LangiumGrammarAstReflection\");\n    }\n    getAllTypes() {\n        return [\n            \"AbstractElement\",\n            \"AbstractRule\",\n            \"AbstractType\",\n            \"Action\",\n            \"Alternatives\",\n            \"ArrayLiteral\",\n            \"ArrayType\",\n            \"Assignment\",\n            \"BooleanLiteral\",\n            \"CharacterRange\",\n            \"Condition\",\n            \"Conjunction\",\n            \"CrossReference\",\n            \"Disjunction\",\n            \"EndOfFile\",\n            \"Grammar\",\n            \"GrammarImport\",\n            \"Group\",\n            \"InferredType\",\n            \"Interface\",\n            \"Keyword\",\n            \"NamedArgument\",\n            \"NegatedToken\",\n            \"Negation\",\n            \"NumberLiteral\",\n            \"Parameter\",\n            \"ParameterReference\",\n            \"ParserRule\",\n            \"ReferenceType\",\n            \"RegexToken\",\n            \"ReturnType\",\n            \"RuleCall\",\n            \"SimpleType\",\n            \"StringLiteral\",\n            \"TerminalAlternatives\",\n            \"TerminalGroup\",\n            \"TerminalRule\",\n            \"TerminalRuleCall\",\n            \"Type\",\n            \"TypeAttribute\",\n            \"TypeDefinition\",\n            \"UnionType\",\n            \"UnorderedGroup\",\n            \"UntilToken\",\n            \"ValueLiteral\",\n            \"Wildcard\"\n        ];\n    }\n    computeIsSubtype(subtype, supertype) {\n        switch(subtype){\n            case $1d44efb04eab6ceb$var$Action:\n            case $1d44efb04eab6ceb$var$Alternatives:\n            case $1d44efb04eab6ceb$var$Assignment:\n            case $1d44efb04eab6ceb$var$CharacterRange:\n            case $1d44efb04eab6ceb$var$CrossReference:\n            case $1d44efb04eab6ceb$var$EndOfFile:\n            case $1d44efb04eab6ceb$var$Group:\n            case $1d44efb04eab6ceb$var$Keyword:\n            case $1d44efb04eab6ceb$var$NegatedToken:\n            case $1d44efb04eab6ceb$var$RegexToken:\n            case $1d44efb04eab6ceb$var$RuleCall:\n            case $1d44efb04eab6ceb$var$TerminalAlternatives:\n            case $1d44efb04eab6ceb$var$TerminalGroup:\n            case $1d44efb04eab6ceb$var$TerminalRuleCall:\n            case $1d44efb04eab6ceb$var$UnorderedGroup:\n            case $1d44efb04eab6ceb$var$UntilToken:\n            case $1d44efb04eab6ceb$var$Wildcard:\n                return this.isSubtype($1d44efb04eab6ceb$var$AbstractElement, supertype);\n            case $1d44efb04eab6ceb$var$ArrayLiteral:\n            case $1d44efb04eab6ceb$var$NumberLiteral:\n            case $1d44efb04eab6ceb$var$StringLiteral:\n                return this.isSubtype($1d44efb04eab6ceb$var$ValueLiteral, supertype);\n            case $1d44efb04eab6ceb$var$ArrayType:\n            case $1d44efb04eab6ceb$var$ReferenceType:\n            case $1d44efb04eab6ceb$var$SimpleType:\n            case $1d44efb04eab6ceb$var$UnionType:\n                return this.isSubtype($1d44efb04eab6ceb$var$TypeDefinition, supertype);\n            case $1d44efb04eab6ceb$var$BooleanLiteral:\n                return this.isSubtype($1d44efb04eab6ceb$var$Condition, supertype) || this.isSubtype($1d44efb04eab6ceb$var$ValueLiteral, supertype);\n            case $1d44efb04eab6ceb$var$Conjunction:\n            case $1d44efb04eab6ceb$var$Disjunction:\n            case $1d44efb04eab6ceb$var$Negation:\n            case $1d44efb04eab6ceb$var$ParameterReference:\n                return this.isSubtype($1d44efb04eab6ceb$var$Condition, supertype);\n            case $1d44efb04eab6ceb$var$InferredType:\n            case $1d44efb04eab6ceb$var$Interface:\n            case $1d44efb04eab6ceb$var$Type:\n                return this.isSubtype($1d44efb04eab6ceb$var$AbstractType, supertype);\n            case $1d44efb04eab6ceb$var$ParserRule:\n                return this.isSubtype($1d44efb04eab6ceb$var$AbstractRule, supertype) || this.isSubtype($1d44efb04eab6ceb$var$AbstractType, supertype);\n            case $1d44efb04eab6ceb$var$TerminalRule:\n                return this.isSubtype($1d44efb04eab6ceb$var$AbstractRule, supertype);\n            default:\n                return false;\n        }\n    }\n    getReferenceType(refInfo) {\n        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n        switch(referenceId){\n            case \"Action:type\":\n            case \"CrossReference:type\":\n            case \"Interface:superTypes\":\n            case \"ParserRule:returnType\":\n            case \"SimpleType:typeRef\":\n                return $1d44efb04eab6ceb$var$AbstractType;\n            case \"Grammar:hiddenTokens\":\n            case \"ParserRule:hiddenTokens\":\n            case \"RuleCall:rule\":\n                return $1d44efb04eab6ceb$var$AbstractRule;\n            case \"Grammar:usedGrammars\":\n                return $1d44efb04eab6ceb$var$Grammar;\n            case \"NamedArgument:parameter\":\n            case \"ParameterReference:parameter\":\n                return $1d44efb04eab6ceb$var$Parameter;\n            case \"TerminalRuleCall:rule\":\n                return $1d44efb04eab6ceb$var$TerminalRule;\n            default:\n                throw new Error(`${referenceId} is not a valid reference id.`);\n        }\n    }\n    getTypeMetaData(type) {\n        switch(type){\n            case \"AbstractElement\":\n                return {\n                    name: \"AbstractElement\",\n                    properties: [\n                        {\n                            name: \"cardinality\"\n                        },\n                        {\n                            name: \"lookahead\"\n                        }\n                    ]\n                };\n            case \"ArrayLiteral\":\n                return {\n                    name: \"ArrayLiteral\",\n                    properties: [\n                        {\n                            name: \"elements\",\n                            defaultValue: []\n                        }\n                    ]\n                };\n            case \"ArrayType\":\n                return {\n                    name: \"ArrayType\",\n                    properties: [\n                        {\n                            name: \"elementType\"\n                        }\n                    ]\n                };\n            case \"BooleanLiteral\":\n                return {\n                    name: \"BooleanLiteral\",\n                    properties: [\n                        {\n                            name: \"true\",\n                            defaultValue: false\n                        }\n                    ]\n                };\n            case \"Conjunction\":\n                return {\n                    name: \"Conjunction\",\n                    properties: [\n                        {\n                            name: \"left\"\n                        },\n                        {\n                            name: \"right\"\n                        }\n                    ]\n                };\n            case \"Disjunction\":\n                return {\n                    name: \"Disjunction\",\n                    properties: [\n                        {\n                            name: \"left\"\n                        },\n                        {\n                            name: \"right\"\n                        }\n                    ]\n                };\n            case \"Grammar\":\n                return {\n                    name: \"Grammar\",\n                    properties: [\n                        {\n                            name: \"definesHiddenTokens\",\n                            defaultValue: false\n                        },\n                        {\n                            name: \"hiddenTokens\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"imports\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"interfaces\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"isDeclared\",\n                            defaultValue: false\n                        },\n                        {\n                            name: \"name\"\n                        },\n                        {\n                            name: \"rules\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"types\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"usedGrammars\",\n                            defaultValue: []\n                        }\n                    ]\n                };\n            case \"GrammarImport\":\n                return {\n                    name: \"GrammarImport\",\n                    properties: [\n                        {\n                            name: \"path\"\n                        }\n                    ]\n                };\n            case \"InferredType\":\n                return {\n                    name: \"InferredType\",\n                    properties: [\n                        {\n                            name: \"name\"\n                        }\n                    ]\n                };\n            case \"Interface\":\n                return {\n                    name: \"Interface\",\n                    properties: [\n                        {\n                            name: \"attributes\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"name\"\n                        },\n                        {\n                            name: \"superTypes\",\n                            defaultValue: []\n                        }\n                    ]\n                };\n            case \"NamedArgument\":\n                return {\n                    name: \"NamedArgument\",\n                    properties: [\n                        {\n                            name: \"calledByName\",\n                            defaultValue: false\n                        },\n                        {\n                            name: \"parameter\"\n                        },\n                        {\n                            name: \"value\"\n                        }\n                    ]\n                };\n            case \"Negation\":\n                return {\n                    name: \"Negation\",\n                    properties: [\n                        {\n                            name: \"value\"\n                        }\n                    ]\n                };\n            case \"NumberLiteral\":\n                return {\n                    name: \"NumberLiteral\",\n                    properties: [\n                        {\n                            name: \"value\"\n                        }\n                    ]\n                };\n            case \"Parameter\":\n                return {\n                    name: \"Parameter\",\n                    properties: [\n                        {\n                            name: \"name\"\n                        }\n                    ]\n                };\n            case \"ParameterReference\":\n                return {\n                    name: \"ParameterReference\",\n                    properties: [\n                        {\n                            name: \"parameter\"\n                        }\n                    ]\n                };\n            case \"ParserRule\":\n                return {\n                    name: \"ParserRule\",\n                    properties: [\n                        {\n                            name: \"dataType\"\n                        },\n                        {\n                            name: \"definesHiddenTokens\",\n                            defaultValue: false\n                        },\n                        {\n                            name: \"definition\"\n                        },\n                        {\n                            name: \"entry\",\n                            defaultValue: false\n                        },\n                        {\n                            name: \"fragment\",\n                            defaultValue: false\n                        },\n                        {\n                            name: \"hiddenTokens\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"inferredType\"\n                        },\n                        {\n                            name: \"name\"\n                        },\n                        {\n                            name: \"parameters\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"returnType\"\n                        },\n                        {\n                            name: \"wildcard\",\n                            defaultValue: false\n                        }\n                    ]\n                };\n            case \"ReferenceType\":\n                return {\n                    name: \"ReferenceType\",\n                    properties: [\n                        {\n                            name: \"referenceType\"\n                        }\n                    ]\n                };\n            case \"ReturnType\":\n                return {\n                    name: \"ReturnType\",\n                    properties: [\n                        {\n                            name: \"name\"\n                        }\n                    ]\n                };\n            case \"SimpleType\":\n                return {\n                    name: \"SimpleType\",\n                    properties: [\n                        {\n                            name: \"primitiveType\"\n                        },\n                        {\n                            name: \"stringType\"\n                        },\n                        {\n                            name: \"typeRef\"\n                        }\n                    ]\n                };\n            case \"StringLiteral\":\n                return {\n                    name: \"StringLiteral\",\n                    properties: [\n                        {\n                            name: \"value\"\n                        }\n                    ]\n                };\n            case \"TerminalRule\":\n                return {\n                    name: \"TerminalRule\",\n                    properties: [\n                        {\n                            name: \"definition\"\n                        },\n                        {\n                            name: \"fragment\",\n                            defaultValue: false\n                        },\n                        {\n                            name: \"hidden\",\n                            defaultValue: false\n                        },\n                        {\n                            name: \"name\"\n                        },\n                        {\n                            name: \"type\"\n                        }\n                    ]\n                };\n            case \"Type\":\n                return {\n                    name: \"Type\",\n                    properties: [\n                        {\n                            name: \"name\"\n                        },\n                        {\n                            name: \"type\"\n                        }\n                    ]\n                };\n            case \"TypeAttribute\":\n                return {\n                    name: \"TypeAttribute\",\n                    properties: [\n                        {\n                            name: \"defaultValue\"\n                        },\n                        {\n                            name: \"isOptional\",\n                            defaultValue: false\n                        },\n                        {\n                            name: \"name\"\n                        },\n                        {\n                            name: \"type\"\n                        }\n                    ]\n                };\n            case \"UnionType\":\n                return {\n                    name: \"UnionType\",\n                    properties: [\n                        {\n                            name: \"types\",\n                            defaultValue: []\n                        }\n                    ]\n                };\n            case \"Action\":\n                return {\n                    name: \"Action\",\n                    properties: [\n                        {\n                            name: \"cardinality\"\n                        },\n                        {\n                            name: \"feature\"\n                        },\n                        {\n                            name: \"inferredType\"\n                        },\n                        {\n                            name: \"lookahead\"\n                        },\n                        {\n                            name: \"operator\"\n                        },\n                        {\n                            name: \"type\"\n                        }\n                    ]\n                };\n            case \"Alternatives\":\n                return {\n                    name: \"Alternatives\",\n                    properties: [\n                        {\n                            name: \"cardinality\"\n                        },\n                        {\n                            name: \"elements\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"lookahead\"\n                        }\n                    ]\n                };\n            case \"Assignment\":\n                return {\n                    name: \"Assignment\",\n                    properties: [\n                        {\n                            name: \"cardinality\"\n                        },\n                        {\n                            name: \"feature\"\n                        },\n                        {\n                            name: \"lookahead\"\n                        },\n                        {\n                            name: \"operator\"\n                        },\n                        {\n                            name: \"terminal\"\n                        }\n                    ]\n                };\n            case \"CharacterRange\":\n                return {\n                    name: \"CharacterRange\",\n                    properties: [\n                        {\n                            name: \"cardinality\"\n                        },\n                        {\n                            name: \"left\"\n                        },\n                        {\n                            name: \"lookahead\"\n                        },\n                        {\n                            name: \"right\"\n                        }\n                    ]\n                };\n            case \"CrossReference\":\n                return {\n                    name: \"CrossReference\",\n                    properties: [\n                        {\n                            name: \"cardinality\"\n                        },\n                        {\n                            name: \"deprecatedSyntax\",\n                            defaultValue: false\n                        },\n                        {\n                            name: \"lookahead\"\n                        },\n                        {\n                            name: \"terminal\"\n                        },\n                        {\n                            name: \"type\"\n                        }\n                    ]\n                };\n            case \"EndOfFile\":\n                return {\n                    name: \"EndOfFile\",\n                    properties: [\n                        {\n                            name: \"cardinality\"\n                        },\n                        {\n                            name: \"lookahead\"\n                        }\n                    ]\n                };\n            case \"Group\":\n                return {\n                    name: \"Group\",\n                    properties: [\n                        {\n                            name: \"cardinality\"\n                        },\n                        {\n                            name: \"elements\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"guardCondition\"\n                        },\n                        {\n                            name: \"lookahead\"\n                        }\n                    ]\n                };\n            case \"Keyword\":\n                return {\n                    name: \"Keyword\",\n                    properties: [\n                        {\n                            name: \"cardinality\"\n                        },\n                        {\n                            name: \"lookahead\"\n                        },\n                        {\n                            name: \"value\"\n                        }\n                    ]\n                };\n            case \"NegatedToken\":\n                return {\n                    name: \"NegatedToken\",\n                    properties: [\n                        {\n                            name: \"cardinality\"\n                        },\n                        {\n                            name: \"lookahead\"\n                        },\n                        {\n                            name: \"terminal\"\n                        }\n                    ]\n                };\n            case \"RegexToken\":\n                return {\n                    name: \"RegexToken\",\n                    properties: [\n                        {\n                            name: \"cardinality\"\n                        },\n                        {\n                            name: \"lookahead\"\n                        },\n                        {\n                            name: \"regex\"\n                        }\n                    ]\n                };\n            case \"RuleCall\":\n                return {\n                    name: \"RuleCall\",\n                    properties: [\n                        {\n                            name: \"arguments\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"cardinality\"\n                        },\n                        {\n                            name: \"lookahead\"\n                        },\n                        {\n                            name: \"rule\"\n                        }\n                    ]\n                };\n            case \"TerminalAlternatives\":\n                return {\n                    name: \"TerminalAlternatives\",\n                    properties: [\n                        {\n                            name: \"cardinality\"\n                        },\n                        {\n                            name: \"elements\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"lookahead\"\n                        }\n                    ]\n                };\n            case \"TerminalGroup\":\n                return {\n                    name: \"TerminalGroup\",\n                    properties: [\n                        {\n                            name: \"cardinality\"\n                        },\n                        {\n                            name: \"elements\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"lookahead\"\n                        }\n                    ]\n                };\n            case \"TerminalRuleCall\":\n                return {\n                    name: \"TerminalRuleCall\",\n                    properties: [\n                        {\n                            name: \"cardinality\"\n                        },\n                        {\n                            name: \"lookahead\"\n                        },\n                        {\n                            name: \"rule\"\n                        }\n                    ]\n                };\n            case \"UnorderedGroup\":\n                return {\n                    name: \"UnorderedGroup\",\n                    properties: [\n                        {\n                            name: \"cardinality\"\n                        },\n                        {\n                            name: \"elements\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"lookahead\"\n                        }\n                    ]\n                };\n            case \"UntilToken\":\n                return {\n                    name: \"UntilToken\",\n                    properties: [\n                        {\n                            name: \"cardinality\"\n                        },\n                        {\n                            name: \"lookahead\"\n                        },\n                        {\n                            name: \"terminal\"\n                        }\n                    ]\n                };\n            case \"Wildcard\":\n                return {\n                    name: \"Wildcard\",\n                    properties: [\n                        {\n                            name: \"cardinality\"\n                        },\n                        {\n                            name: \"lookahead\"\n                        }\n                    ]\n                };\n            default:\n                return {\n                    name: type,\n                    properties: []\n                };\n        }\n    }\n};\nvar $1d44efb04eab6ceb$var$reflection = new $1d44efb04eab6ceb$var$LangiumGrammarAstReflection();\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/ast-utils.js\nvar $1d44efb04eab6ceb$var$ast_utils_exports = {};\n(0, $7xxrv.__export)($1d44efb04eab6ceb$var$ast_utils_exports, {\n    assignMandatoryProperties: ()=>$1d44efb04eab6ceb$var$assignMandatoryProperties,\n    copyAstNode: ()=>$1d44efb04eab6ceb$var$copyAstNode,\n    findLocalReferences: ()=>$1d44efb04eab6ceb$var$findLocalReferences,\n    findRootNode: ()=>$1d44efb04eab6ceb$var$findRootNode,\n    getContainerOfType: ()=>$1d44efb04eab6ceb$var$getContainerOfType,\n    getDocument: ()=>$1d44efb04eab6ceb$var$getDocument,\n    hasContainerOfType: ()=>$1d44efb04eab6ceb$var$hasContainerOfType,\n    linkContentToContainer: ()=>$1d44efb04eab6ceb$var$linkContentToContainer,\n    streamAllContents: ()=>$1d44efb04eab6ceb$var$streamAllContents,\n    streamAst: ()=>$1d44efb04eab6ceb$var$streamAst,\n    streamContents: ()=>$1d44efb04eab6ceb$var$streamContents,\n    streamReferences: ()=>$1d44efb04eab6ceb$var$streamReferences\n});\nfunction $1d44efb04eab6ceb$var$linkContentToContainer(node) {\n    for (const [name, value] of Object.entries(node))if (!name.startsWith(\"$\")) {\n        if (Array.isArray(value)) value.forEach((item, index)=>{\n            if ($1d44efb04eab6ceb$var$isAstNode(item)) {\n                item.$container = node;\n                item.$containerProperty = name;\n                item.$containerIndex = index;\n            }\n        });\n        else if ($1d44efb04eab6ceb$var$isAstNode(value)) {\n            value.$container = node;\n            value.$containerProperty = name;\n        }\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$linkContentToContainer, \"linkContentToContainer\");\nfunction $1d44efb04eab6ceb$var$getContainerOfType(node, typePredicate) {\n    let item = node;\n    while(item){\n        if (typePredicate(item)) return item;\n        item = item.$container;\n    }\n    return void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getContainerOfType, \"getContainerOfType\");\nfunction $1d44efb04eab6ceb$var$hasContainerOfType(node, predicate) {\n    let item = node;\n    while(item){\n        if (predicate(item)) return true;\n        item = item.$container;\n    }\n    return false;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$hasContainerOfType, \"hasContainerOfType\");\nfunction $1d44efb04eab6ceb$var$getDocument(node) {\n    const rootNode = $1d44efb04eab6ceb$var$findRootNode(node);\n    const result = rootNode.$document;\n    if (!result) throw new Error(\"AST node has no document.\");\n    return result;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getDocument, \"getDocument\");\nfunction $1d44efb04eab6ceb$var$findRootNode(node) {\n    while(node.$container)node = node.$container;\n    return node;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findRootNode, \"findRootNode\");\nfunction $1d44efb04eab6ceb$var$streamContents(node, options) {\n    if (!node) throw new Error(\"Node must be an AstNode.\");\n    const range = options === null || options === void 0 ? void 0 : options.range;\n    return new $1d44efb04eab6ceb$var$StreamImpl(()=>({\n            keys: Object.keys(node),\n            keyIndex: 0,\n            arrayIndex: 0\n        }), (state)=>{\n        while(state.keyIndex < state.keys.length){\n            const property = state.keys[state.keyIndex];\n            if (!property.startsWith(\"$\")) {\n                const value = node[property];\n                if ($1d44efb04eab6ceb$var$isAstNode(value)) {\n                    state.keyIndex++;\n                    if ($1d44efb04eab6ceb$var$isAstNodeInRange(value, range)) return {\n                        done: false,\n                        value: value\n                    };\n                } else if (Array.isArray(value)) {\n                    while(state.arrayIndex < value.length){\n                        const index = state.arrayIndex++;\n                        const element = value[index];\n                        if ($1d44efb04eab6ceb$var$isAstNode(element) && $1d44efb04eab6ceb$var$isAstNodeInRange(element, range)) return {\n                            done: false,\n                            value: element\n                        };\n                    }\n                    state.arrayIndex = 0;\n                }\n            }\n            state.keyIndex++;\n        }\n        return $1d44efb04eab6ceb$var$DONE_RESULT;\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$streamContents, \"streamContents\");\nfunction $1d44efb04eab6ceb$var$streamAllContents(root, options) {\n    if (!root) throw new Error(\"Root node must be an AstNode.\");\n    return new $1d44efb04eab6ceb$var$TreeStreamImpl(root, (node)=>$1d44efb04eab6ceb$var$streamContents(node, options));\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$streamAllContents, \"streamAllContents\");\nfunction $1d44efb04eab6ceb$var$streamAst(root, options) {\n    if (!root) throw new Error(\"Root node must be an AstNode.\");\n    else if ((options === null || options === void 0 ? void 0 : options.range) && !$1d44efb04eab6ceb$var$isAstNodeInRange(root, options.range)) return new $1d44efb04eab6ceb$var$TreeStreamImpl(root, ()=>[]);\n    return new $1d44efb04eab6ceb$var$TreeStreamImpl(root, (node)=>$1d44efb04eab6ceb$var$streamContents(node, options), {\n        includeRoot: true\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$streamAst, \"streamAst\");\nfunction $1d44efb04eab6ceb$var$isAstNodeInRange(astNode, range) {\n    var _a;\n    if (!range) return true;\n    const nodeRange = (_a = astNode.$cstNode) === null || _a === void 0 ? void 0 : _a.range;\n    if (!nodeRange) return false;\n    return $1d44efb04eab6ceb$var$inRange(nodeRange, range);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isAstNodeInRange, \"isAstNodeInRange\");\nfunction $1d44efb04eab6ceb$var$streamReferences(node) {\n    return new $1d44efb04eab6ceb$var$StreamImpl(()=>({\n            keys: Object.keys(node),\n            keyIndex: 0,\n            arrayIndex: 0\n        }), (state)=>{\n        while(state.keyIndex < state.keys.length){\n            const property = state.keys[state.keyIndex];\n            if (!property.startsWith(\"$\")) {\n                const value = node[property];\n                if ($1d44efb04eab6ceb$var$isReference(value)) {\n                    state.keyIndex++;\n                    return {\n                        done: false,\n                        value: {\n                            reference: value,\n                            container: node,\n                            property: property\n                        }\n                    };\n                } else if (Array.isArray(value)) {\n                    while(state.arrayIndex < value.length){\n                        const index = state.arrayIndex++;\n                        const element = value[index];\n                        if ($1d44efb04eab6ceb$var$isReference(element)) return {\n                            done: false,\n                            value: {\n                                reference: element,\n                                container: node,\n                                property: property,\n                                index: index\n                            }\n                        };\n                    }\n                    state.arrayIndex = 0;\n                }\n            }\n            state.keyIndex++;\n        }\n        return $1d44efb04eab6ceb$var$DONE_RESULT;\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$streamReferences, \"streamReferences\");\nfunction $1d44efb04eab6ceb$var$findLocalReferences(targetNode, lookup = $1d44efb04eab6ceb$var$getDocument(targetNode).parseResult.value) {\n    const refs = [];\n    $1d44efb04eab6ceb$var$streamAst(lookup).forEach((node)=>{\n        $1d44efb04eab6ceb$var$streamReferences(node).forEach((refInfo)=>{\n            if (refInfo.reference.ref === targetNode) refs.push(refInfo.reference);\n        });\n    });\n    return $1d44efb04eab6ceb$var$stream(refs);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findLocalReferences, \"findLocalReferences\");\nfunction $1d44efb04eab6ceb$var$assignMandatoryProperties(reflection3, node) {\n    const typeMetaData = reflection3.getTypeMetaData(node.$type);\n    const genericNode = node;\n    for (const property of typeMetaData.properties)if (property.defaultValue !== void 0 && genericNode[property.name] === void 0) genericNode[property.name] = $1d44efb04eab6ceb$var$copyDefaultValue(property.defaultValue);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$assignMandatoryProperties, \"assignMandatoryProperties\");\nfunction $1d44efb04eab6ceb$var$copyDefaultValue(propertyType) {\n    if (Array.isArray(propertyType)) return [\n        ...propertyType.map($1d44efb04eab6ceb$var$copyDefaultValue)\n    ];\n    else return propertyType;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$copyDefaultValue, \"copyDefaultValue\");\nfunction $1d44efb04eab6ceb$var$copyAstNode(node, buildReference) {\n    const copy = {\n        $type: node.$type\n    };\n    for (const [name, value] of Object.entries(node))if (!name.startsWith(\"$\")) {\n        if ($1d44efb04eab6ceb$var$isAstNode(value)) copy[name] = $1d44efb04eab6ceb$var$copyAstNode(value, buildReference);\n        else if ($1d44efb04eab6ceb$var$isReference(value)) copy[name] = buildReference(copy, name, value.$refNode, value.$refText);\n        else if (Array.isArray(value)) {\n            const copiedArray = [];\n            for (const element of value){\n                if ($1d44efb04eab6ceb$var$isAstNode(element)) copiedArray.push($1d44efb04eab6ceb$var$copyAstNode(element, buildReference));\n                else if ($1d44efb04eab6ceb$var$isReference(element)) copiedArray.push(buildReference(copy, name, element.$refNode, element.$refText));\n                else copiedArray.push(element);\n            }\n            copy[name] = copiedArray;\n        } else copy[name] = value;\n    }\n    $1d44efb04eab6ceb$var$linkContentToContainer(copy);\n    return copy;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$copyAstNode, \"copyAstNode\");\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/regexp-utils.js\nvar $1d44efb04eab6ceb$var$regexp_utils_exports = {};\n(0, $7xxrv.__export)($1d44efb04eab6ceb$var$regexp_utils_exports, {\n    NEWLINE_REGEXP: ()=>$1d44efb04eab6ceb$var$NEWLINE_REGEXP,\n    escapeRegExp: ()=>$1d44efb04eab6ceb$var$escapeRegExp,\n    getCaseInsensitivePattern: ()=>$1d44efb04eab6ceb$var$getCaseInsensitivePattern,\n    getTerminalParts: ()=>$1d44efb04eab6ceb$var$getTerminalParts,\n    isMultilineComment: ()=>$1d44efb04eab6ceb$var$isMultilineComment,\n    isWhitespace: ()=>$1d44efb04eab6ceb$var$isWhitespace,\n    partialMatches: ()=>$1d44efb04eab6ceb$var$partialMatches,\n    partialRegExp: ()=>$1d44efb04eab6ceb$var$partialRegExp\n});\n// ../../node_modules/.pnpm/@chevrotain+regexp-to-ast@11.0.3/node_modules/@chevrotain/regexp-to-ast/lib/src/utils.js\nfunction $1d44efb04eab6ceb$var$cc(char) {\n    return char.charCodeAt(0);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$cc, \"cc\");\nfunction $1d44efb04eab6ceb$var$insertToSet(item, set) {\n    if (Array.isArray(item)) item.forEach(function(subItem) {\n        set.push(subItem);\n    });\n    else set.push(item);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$insertToSet, \"insertToSet\");\nfunction $1d44efb04eab6ceb$var$addFlag(flagObj, flagKey) {\n    if (flagObj[flagKey] === true) throw \"duplicate flag \" + flagKey;\n    const x = flagObj[flagKey];\n    flagObj[flagKey] = true;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$addFlag, \"addFlag\");\nfunction $1d44efb04eab6ceb$var$ASSERT_EXISTS(obj) {\n    if (obj === void 0) throw Error(\"Internal Error - Should never get here!\");\n    return true;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$ASSERT_EXISTS, \"ASSERT_EXISTS\");\nfunction $1d44efb04eab6ceb$var$ASSERT_NEVER_REACH_HERE() {\n    throw Error(\"Internal Error - Should never get here!\");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$ASSERT_NEVER_REACH_HERE, \"ASSERT_NEVER_REACH_HERE\");\nfunction $1d44efb04eab6ceb$var$isCharacter(obj) {\n    return obj[\"type\"] === \"Character\";\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isCharacter, \"isCharacter\");\n// ../../node_modules/.pnpm/@chevrotain+regexp-to-ast@11.0.3/node_modules/@chevrotain/regexp-to-ast/lib/src/character-classes.js\nvar $1d44efb04eab6ceb$var$digitsCharCodes = [];\nfor(let i = $1d44efb04eab6ceb$var$cc(\"0\"); i <= $1d44efb04eab6ceb$var$cc(\"9\"); i++)$1d44efb04eab6ceb$var$digitsCharCodes.push(i);\nvar $1d44efb04eab6ceb$var$wordCharCodes = [\n    $1d44efb04eab6ceb$var$cc(\"_\")\n].concat($1d44efb04eab6ceb$var$digitsCharCodes);\nfor(let i = $1d44efb04eab6ceb$var$cc(\"a\"); i <= $1d44efb04eab6ceb$var$cc(\"z\"); i++)$1d44efb04eab6ceb$var$wordCharCodes.push(i);\nfor(let i = $1d44efb04eab6ceb$var$cc(\"A\"); i <= $1d44efb04eab6ceb$var$cc(\"Z\"); i++)$1d44efb04eab6ceb$var$wordCharCodes.push(i);\nvar $1d44efb04eab6ceb$var$whitespaceCodes = [\n    $1d44efb04eab6ceb$var$cc(\" \"),\n    $1d44efb04eab6ceb$var$cc(\"\\f\"),\n    $1d44efb04eab6ceb$var$cc(\"\\n\"),\n    $1d44efb04eab6ceb$var$cc(\"\\r\"),\n    $1d44efb04eab6ceb$var$cc(\"\t\"),\n    $1d44efb04eab6ceb$var$cc(\"\\v\"),\n    $1d44efb04eab6ceb$var$cc(\"\t\"),\n    $1d44efb04eab6ceb$var$cc(\"\\xA0\"),\n    $1d44efb04eab6ceb$var$cc(\"\\u1680\"),\n    $1d44efb04eab6ceb$var$cc(\"\\u2000\"),\n    $1d44efb04eab6ceb$var$cc(\"\\u2001\"),\n    $1d44efb04eab6ceb$var$cc(\"\\u2002\"),\n    $1d44efb04eab6ceb$var$cc(\"\\u2003\"),\n    $1d44efb04eab6ceb$var$cc(\"\\u2004\"),\n    $1d44efb04eab6ceb$var$cc(\"\\u2005\"),\n    $1d44efb04eab6ceb$var$cc(\"\\u2006\"),\n    $1d44efb04eab6ceb$var$cc(\"\\u2007\"),\n    $1d44efb04eab6ceb$var$cc(\"\\u2008\"),\n    $1d44efb04eab6ceb$var$cc(\"\\u2009\"),\n    $1d44efb04eab6ceb$var$cc(\"\\u200A\"),\n    $1d44efb04eab6ceb$var$cc(\"\\u2028\"),\n    $1d44efb04eab6ceb$var$cc(\"\\u2029\"),\n    $1d44efb04eab6ceb$var$cc(\"\\u202F\"),\n    $1d44efb04eab6ceb$var$cc(\"\\u205F\"),\n    $1d44efb04eab6ceb$var$cc(\"\\u3000\"),\n    $1d44efb04eab6ceb$var$cc(\"\\uFEFF\")\n];\n// ../../node_modules/.pnpm/@chevrotain+regexp-to-ast@11.0.3/node_modules/@chevrotain/regexp-to-ast/lib/src/regexp-parser.js\nvar $1d44efb04eab6ceb$var$hexDigitPattern = /[0-9a-fA-F]/;\nvar $1d44efb04eab6ceb$var$decimalPattern = /[0-9]/;\nvar $1d44efb04eab6ceb$var$decimalPatternNoZero = /[1-9]/;\nvar $1d44efb04eab6ceb$var$RegExpParser = class {\n    static{\n        (0, $7xxrv.__name)(this, \"RegExpParser\");\n    }\n    constructor(){\n        this.idx = 0;\n        this.input = \"\";\n        this.groupIdx = 0;\n    }\n    saveState() {\n        return {\n            idx: this.idx,\n            input: this.input,\n            groupIdx: this.groupIdx\n        };\n    }\n    restoreState(newState2) {\n        this.idx = newState2.idx;\n        this.input = newState2.input;\n        this.groupIdx = newState2.groupIdx;\n    }\n    pattern(input) {\n        this.idx = 0;\n        this.input = input;\n        this.groupIdx = 0;\n        this.consumeChar(\"/\");\n        const value = this.disjunction();\n        this.consumeChar(\"/\");\n        const flags = {\n            type: \"Flags\",\n            loc: {\n                begin: this.idx,\n                end: input.length\n            },\n            global: false,\n            ignoreCase: false,\n            multiLine: false,\n            unicode: false,\n            sticky: false\n        };\n        while(this.isRegExpFlag())switch(this.popChar()){\n            case \"g\":\n                $1d44efb04eab6ceb$var$addFlag(flags, \"global\");\n                break;\n            case \"i\":\n                $1d44efb04eab6ceb$var$addFlag(flags, \"ignoreCase\");\n                break;\n            case \"m\":\n                $1d44efb04eab6ceb$var$addFlag(flags, \"multiLine\");\n                break;\n            case \"u\":\n                $1d44efb04eab6ceb$var$addFlag(flags, \"unicode\");\n                break;\n            case \"y\":\n                $1d44efb04eab6ceb$var$addFlag(flags, \"sticky\");\n                break;\n        }\n        if (this.idx !== this.input.length) throw Error(\"Redundant input: \" + this.input.substring(this.idx));\n        return {\n            type: \"Pattern\",\n            flags: flags,\n            value: value,\n            loc: this.loc(0)\n        };\n    }\n    disjunction() {\n        const alts = [];\n        const begin = this.idx;\n        alts.push(this.alternative());\n        while(this.peekChar() === \"|\"){\n            this.consumeChar(\"|\");\n            alts.push(this.alternative());\n        }\n        return {\n            type: \"Disjunction\",\n            value: alts,\n            loc: this.loc(begin)\n        };\n    }\n    alternative() {\n        const terms = [];\n        const begin = this.idx;\n        while(this.isTerm())terms.push(this.term());\n        return {\n            type: \"Alternative\",\n            value: terms,\n            loc: this.loc(begin)\n        };\n    }\n    term() {\n        if (this.isAssertion()) return this.assertion();\n        else return this.atom();\n    }\n    assertion() {\n        const begin = this.idx;\n        switch(this.popChar()){\n            case \"^\":\n                return {\n                    type: \"StartAnchor\",\n                    loc: this.loc(begin)\n                };\n            case \"$\":\n                return {\n                    type: \"EndAnchor\",\n                    loc: this.loc(begin)\n                };\n            case \"\\\\\":\n                switch(this.popChar()){\n                    case \"b\":\n                        return {\n                            type: \"WordBoundary\",\n                            loc: this.loc(begin)\n                        };\n                    case \"B\":\n                        return {\n                            type: \"NonWordBoundary\",\n                            loc: this.loc(begin)\n                        };\n                }\n                throw Error(\"Invalid Assertion Escape\");\n            case \"(\":\n                this.consumeChar(\"?\");\n                let type;\n                switch(this.popChar()){\n                    case \"=\":\n                        type = \"Lookahead\";\n                        break;\n                    case \"!\":\n                        type = \"NegativeLookahead\";\n                        break;\n                }\n                $1d44efb04eab6ceb$var$ASSERT_EXISTS(type);\n                const disjunction = this.disjunction();\n                this.consumeChar(\")\");\n                return {\n                    type: type,\n                    value: disjunction,\n                    loc: this.loc(begin)\n                };\n        }\n        return $1d44efb04eab6ceb$var$ASSERT_NEVER_REACH_HERE();\n    }\n    quantifier(isBacktracking = false) {\n        let range = void 0;\n        const begin = this.idx;\n        switch(this.popChar()){\n            case \"*\":\n                range = {\n                    atLeast: 0,\n                    atMost: Infinity\n                };\n                break;\n            case \"+\":\n                range = {\n                    atLeast: 1,\n                    atMost: Infinity\n                };\n                break;\n            case \"?\":\n                range = {\n                    atLeast: 0,\n                    atMost: 1\n                };\n                break;\n            case \"{\":\n                const atLeast = this.integerIncludingZero();\n                switch(this.popChar()){\n                    case \"}\":\n                        range = {\n                            atLeast: atLeast,\n                            atMost: atLeast\n                        };\n                        break;\n                    case \",\":\n                        let atMost;\n                        if (this.isDigit()) {\n                            atMost = this.integerIncludingZero();\n                            range = {\n                                atLeast: atLeast,\n                                atMost: atMost\n                            };\n                        } else range = {\n                            atLeast: atLeast,\n                            atMost: Infinity\n                        };\n                        this.consumeChar(\"}\");\n                        break;\n                }\n                if (isBacktracking === true && range === void 0) return void 0;\n                $1d44efb04eab6ceb$var$ASSERT_EXISTS(range);\n                break;\n        }\n        if (isBacktracking === true && range === void 0) return void 0;\n        if ($1d44efb04eab6ceb$var$ASSERT_EXISTS(range)) {\n            if (this.peekChar(0) === \"?\") {\n                this.consumeChar(\"?\");\n                range.greedy = false;\n            } else range.greedy = true;\n            range.type = \"Quantifier\";\n            range.loc = this.loc(begin);\n            return range;\n        }\n    }\n    atom() {\n        let atom2;\n        const begin = this.idx;\n        switch(this.peekChar()){\n            case \".\":\n                atom2 = this.dotAll();\n                break;\n            case \"\\\\\":\n                atom2 = this.atomEscape();\n                break;\n            case \"[\":\n                atom2 = this.characterClass();\n                break;\n            case \"(\":\n                atom2 = this.group();\n                break;\n        }\n        if (atom2 === void 0 && this.isPatternCharacter()) atom2 = this.patternCharacter();\n        if ($1d44efb04eab6ceb$var$ASSERT_EXISTS(atom2)) {\n            atom2.loc = this.loc(begin);\n            if (this.isQuantifier()) atom2.quantifier = this.quantifier();\n            return atom2;\n        }\n        return $1d44efb04eab6ceb$var$ASSERT_NEVER_REACH_HERE();\n    }\n    dotAll() {\n        this.consumeChar(\".\");\n        return {\n            type: \"Set\",\n            complement: true,\n            value: [\n                $1d44efb04eab6ceb$var$cc(\"\\n\"),\n                $1d44efb04eab6ceb$var$cc(\"\\r\"),\n                $1d44efb04eab6ceb$var$cc(\"\\u2028\"),\n                $1d44efb04eab6ceb$var$cc(\"\\u2029\")\n            ]\n        };\n    }\n    atomEscape() {\n        this.consumeChar(\"\\\\\");\n        switch(this.peekChar()){\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n                return this.decimalEscapeAtom();\n            case \"d\":\n            case \"D\":\n            case \"s\":\n            case \"S\":\n            case \"w\":\n            case \"W\":\n                return this.characterClassEscape();\n            case \"f\":\n            case \"n\":\n            case \"r\":\n            case \"t\":\n            case \"v\":\n                return this.controlEscapeAtom();\n            case \"c\":\n                return this.controlLetterEscapeAtom();\n            case \"0\":\n                return this.nulCharacterAtom();\n            case \"x\":\n                return this.hexEscapeSequenceAtom();\n            case \"u\":\n                return this.regExpUnicodeEscapeSequenceAtom();\n            default:\n                return this.identityEscapeAtom();\n        }\n    }\n    decimalEscapeAtom() {\n        const value = this.positiveInteger();\n        return {\n            type: \"GroupBackReference\",\n            value: value\n        };\n    }\n    characterClassEscape() {\n        let set;\n        let complement = false;\n        switch(this.popChar()){\n            case \"d\":\n                set = $1d44efb04eab6ceb$var$digitsCharCodes;\n                break;\n            case \"D\":\n                set = $1d44efb04eab6ceb$var$digitsCharCodes;\n                complement = true;\n                break;\n            case \"s\":\n                set = $1d44efb04eab6ceb$var$whitespaceCodes;\n                break;\n            case \"S\":\n                set = $1d44efb04eab6ceb$var$whitespaceCodes;\n                complement = true;\n                break;\n            case \"w\":\n                set = $1d44efb04eab6ceb$var$wordCharCodes;\n                break;\n            case \"W\":\n                set = $1d44efb04eab6ceb$var$wordCharCodes;\n                complement = true;\n                break;\n        }\n        if ($1d44efb04eab6ceb$var$ASSERT_EXISTS(set)) return {\n            type: \"Set\",\n            value: set,\n            complement: complement\n        };\n        return $1d44efb04eab6ceb$var$ASSERT_NEVER_REACH_HERE();\n    }\n    controlEscapeAtom() {\n        let escapeCode;\n        switch(this.popChar()){\n            case \"f\":\n                escapeCode = $1d44efb04eab6ceb$var$cc(\"\\f\");\n                break;\n            case \"n\":\n                escapeCode = $1d44efb04eab6ceb$var$cc(\"\\n\");\n                break;\n            case \"r\":\n                escapeCode = $1d44efb04eab6ceb$var$cc(\"\\r\");\n                break;\n            case \"t\":\n                escapeCode = $1d44efb04eab6ceb$var$cc(\"\t\");\n                break;\n            case \"v\":\n                escapeCode = $1d44efb04eab6ceb$var$cc(\"\\v\");\n                break;\n        }\n        if ($1d44efb04eab6ceb$var$ASSERT_EXISTS(escapeCode)) return {\n            type: \"Character\",\n            value: escapeCode\n        };\n        return $1d44efb04eab6ceb$var$ASSERT_NEVER_REACH_HERE();\n    }\n    controlLetterEscapeAtom() {\n        this.consumeChar(\"c\");\n        const letter = this.popChar();\n        if (/[a-zA-Z]/.test(letter) === false) throw Error(\"Invalid \");\n        const letterCode = letter.toUpperCase().charCodeAt(0) - 64;\n        return {\n            type: \"Character\",\n            value: letterCode\n        };\n    }\n    nulCharacterAtom() {\n        this.consumeChar(\"0\");\n        return {\n            type: \"Character\",\n            value: $1d44efb04eab6ceb$var$cc(\"\\0\")\n        };\n    }\n    hexEscapeSequenceAtom() {\n        this.consumeChar(\"x\");\n        return this.parseHexDigits(2);\n    }\n    regExpUnicodeEscapeSequenceAtom() {\n        this.consumeChar(\"u\");\n        return this.parseHexDigits(4);\n    }\n    identityEscapeAtom() {\n        const escapedChar = this.popChar();\n        return {\n            type: \"Character\",\n            value: $1d44efb04eab6ceb$var$cc(escapedChar)\n        };\n    }\n    classPatternCharacterAtom() {\n        switch(this.peekChar()){\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n            case \"\\\\\":\n            case \"]\":\n                throw Error(\"TBD\");\n            default:\n                const nextChar = this.popChar();\n                return {\n                    type: \"Character\",\n                    value: $1d44efb04eab6ceb$var$cc(nextChar)\n                };\n        }\n    }\n    characterClass() {\n        const set = [];\n        let complement = false;\n        this.consumeChar(\"[\");\n        if (this.peekChar(0) === \"^\") {\n            this.consumeChar(\"^\");\n            complement = true;\n        }\n        while(this.isClassAtom()){\n            const from = this.classAtom();\n            const isFromSingleChar = from.type === \"Character\";\n            if ($1d44efb04eab6ceb$var$isCharacter(from) && this.isRangeDash()) {\n                this.consumeChar(\"-\");\n                const to = this.classAtom();\n                const isToSingleChar = to.type === \"Character\";\n                if ($1d44efb04eab6ceb$var$isCharacter(to)) {\n                    if (to.value < from.value) throw Error(\"Range out of order in character class\");\n                    set.push({\n                        from: from.value,\n                        to: to.value\n                    });\n                } else {\n                    $1d44efb04eab6ceb$var$insertToSet(from.value, set);\n                    set.push($1d44efb04eab6ceb$var$cc(\"-\"));\n                    $1d44efb04eab6ceb$var$insertToSet(to.value, set);\n                }\n            } else $1d44efb04eab6ceb$var$insertToSet(from.value, set);\n        }\n        this.consumeChar(\"]\");\n        return {\n            type: \"Set\",\n            complement: complement,\n            value: set\n        };\n    }\n    classAtom() {\n        switch(this.peekChar()){\n            case \"]\":\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n                throw Error(\"TBD\");\n            case \"\\\\\":\n                return this.classEscape();\n            default:\n                return this.classPatternCharacterAtom();\n        }\n    }\n    classEscape() {\n        this.consumeChar(\"\\\\\");\n        switch(this.peekChar()){\n            case \"b\":\n                this.consumeChar(\"b\");\n                return {\n                    type: \"Character\",\n                    value: $1d44efb04eab6ceb$var$cc(\"\\b\")\n                };\n            case \"d\":\n            case \"D\":\n            case \"s\":\n            case \"S\":\n            case \"w\":\n            case \"W\":\n                return this.characterClassEscape();\n            case \"f\":\n            case \"n\":\n            case \"r\":\n            case \"t\":\n            case \"v\":\n                return this.controlEscapeAtom();\n            case \"c\":\n                return this.controlLetterEscapeAtom();\n            case \"0\":\n                return this.nulCharacterAtom();\n            case \"x\":\n                return this.hexEscapeSequenceAtom();\n            case \"u\":\n                return this.regExpUnicodeEscapeSequenceAtom();\n            default:\n                return this.identityEscapeAtom();\n        }\n    }\n    group() {\n        let capturing = true;\n        this.consumeChar(\"(\");\n        switch(this.peekChar(0)){\n            case \"?\":\n                this.consumeChar(\"?\");\n                this.consumeChar(\":\");\n                capturing = false;\n                break;\n            default:\n                this.groupIdx++;\n                break;\n        }\n        const value = this.disjunction();\n        this.consumeChar(\")\");\n        const groupAst = {\n            type: \"Group\",\n            capturing: capturing,\n            value: value\n        };\n        if (capturing) groupAst[\"idx\"] = this.groupIdx;\n        return groupAst;\n    }\n    positiveInteger() {\n        let number = this.popChar();\n        if ($1d44efb04eab6ceb$var$decimalPatternNoZero.test(number) === false) throw Error(\"Expecting a positive integer\");\n        while($1d44efb04eab6ceb$var$decimalPattern.test(this.peekChar(0)))number += this.popChar();\n        return parseInt(number, 10);\n    }\n    integerIncludingZero() {\n        let number = this.popChar();\n        if ($1d44efb04eab6ceb$var$decimalPattern.test(number) === false) throw Error(\"Expecting an integer\");\n        while($1d44efb04eab6ceb$var$decimalPattern.test(this.peekChar(0)))number += this.popChar();\n        return parseInt(number, 10);\n    }\n    patternCharacter() {\n        const nextChar = this.popChar();\n        switch(nextChar){\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n            case \"^\":\n            case \"$\":\n            case \"\\\\\":\n            case \".\":\n            case \"*\":\n            case \"+\":\n            case \"?\":\n            case \"(\":\n            case \")\":\n            case \"[\":\n            case \"|\":\n                throw Error(\"TBD\");\n            default:\n                return {\n                    type: \"Character\",\n                    value: $1d44efb04eab6ceb$var$cc(nextChar)\n                };\n        }\n    }\n    isRegExpFlag() {\n        switch(this.peekChar(0)){\n            case \"g\":\n            case \"i\":\n            case \"m\":\n            case \"u\":\n            case \"y\":\n                return true;\n            default:\n                return false;\n        }\n    }\n    isRangeDash() {\n        return this.peekChar() === \"-\" && this.isClassAtom(1);\n    }\n    isDigit() {\n        return $1d44efb04eab6ceb$var$decimalPattern.test(this.peekChar(0));\n    }\n    isClassAtom(howMuch = 0) {\n        switch(this.peekChar(howMuch)){\n            case \"]\":\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n                return false;\n            default:\n                return true;\n        }\n    }\n    isTerm() {\n        return this.isAtom() || this.isAssertion();\n    }\n    isAtom() {\n        if (this.isPatternCharacter()) return true;\n        switch(this.peekChar(0)){\n            case \".\":\n            case \"\\\\\":\n            case \"[\":\n            case \"(\":\n                return true;\n            default:\n                return false;\n        }\n    }\n    isAssertion() {\n        switch(this.peekChar(0)){\n            case \"^\":\n            case \"$\":\n                return true;\n            case \"\\\\\":\n                switch(this.peekChar(1)){\n                    case \"b\":\n                    case \"B\":\n                        return true;\n                    default:\n                        return false;\n                }\n            case \"(\":\n                return this.peekChar(1) === \"?\" && (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\");\n            default:\n                return false;\n        }\n    }\n    isQuantifier() {\n        const prevState = this.saveState();\n        try {\n            return this.quantifier(true) !== void 0;\n        } catch (e) {\n            return false;\n        } finally{\n            this.restoreState(prevState);\n        }\n    }\n    isPatternCharacter() {\n        switch(this.peekChar()){\n            case \"^\":\n            case \"$\":\n            case \"\\\\\":\n            case \".\":\n            case \"*\":\n            case \"+\":\n            case \"?\":\n            case \"(\":\n            case \")\":\n            case \"[\":\n            case \"|\":\n            case \"/\":\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n                return false;\n            default:\n                return true;\n        }\n    }\n    parseHexDigits(howMany) {\n        let hexString = \"\";\n        for(let i = 0; i < howMany; i++){\n            const hexChar = this.popChar();\n            if ($1d44efb04eab6ceb$var$hexDigitPattern.test(hexChar) === false) throw Error(\"Expecting a HexDecimal digits\");\n            hexString += hexChar;\n        }\n        const charCode = parseInt(hexString, 16);\n        return {\n            type: \"Character\",\n            value: charCode\n        };\n    }\n    peekChar(howMuch = 0) {\n        return this.input[this.idx + howMuch];\n    }\n    popChar() {\n        const nextChar = this.peekChar(0);\n        this.consumeChar(void 0);\n        return nextChar;\n    }\n    consumeChar(char) {\n        if (char !== void 0 && this.input[this.idx] !== char) throw Error(\"Expected: '\" + char + \"' but found: '\" + this.input[this.idx] + \"' at offset: \" + this.idx);\n        if (this.idx >= this.input.length) throw Error(\"Unexpected end of input\");\n        this.idx++;\n    }\n    loc(begin) {\n        return {\n            begin: begin,\n            end: this.idx\n        };\n    }\n};\n// ../../node_modules/.pnpm/@chevrotain+regexp-to-ast@11.0.3/node_modules/@chevrotain/regexp-to-ast/lib/src/base-regexp-visitor.js\nvar $1d44efb04eab6ceb$var$BaseRegExpVisitor = class {\n    static{\n        (0, $7xxrv.__name)(this, \"BaseRegExpVisitor\");\n    }\n    visitChildren(node) {\n        for(const key in node){\n            const child = node[key];\n            if (node.hasOwnProperty(key)) {\n                if (child.type !== void 0) this.visit(child);\n                else if (Array.isArray(child)) child.forEach((subChild)=>{\n                    this.visit(subChild);\n                }, this);\n            }\n        }\n    }\n    visit(node) {\n        switch(node.type){\n            case \"Pattern\":\n                this.visitPattern(node);\n                break;\n            case \"Flags\":\n                this.visitFlags(node);\n                break;\n            case \"Disjunction\":\n                this.visitDisjunction(node);\n                break;\n            case \"Alternative\":\n                this.visitAlternative(node);\n                break;\n            case \"StartAnchor\":\n                this.visitStartAnchor(node);\n                break;\n            case \"EndAnchor\":\n                this.visitEndAnchor(node);\n                break;\n            case \"WordBoundary\":\n                this.visitWordBoundary(node);\n                break;\n            case \"NonWordBoundary\":\n                this.visitNonWordBoundary(node);\n                break;\n            case \"Lookahead\":\n                this.visitLookahead(node);\n                break;\n            case \"NegativeLookahead\":\n                this.visitNegativeLookahead(node);\n                break;\n            case \"Character\":\n                this.visitCharacter(node);\n                break;\n            case \"Set\":\n                this.visitSet(node);\n                break;\n            case \"Group\":\n                this.visitGroup(node);\n                break;\n            case \"GroupBackReference\":\n                this.visitGroupBackReference(node);\n                break;\n            case \"Quantifier\":\n                this.visitQuantifier(node);\n                break;\n        }\n        this.visitChildren(node);\n    }\n    visitPattern(node) {}\n    visitFlags(node) {}\n    visitDisjunction(node) {}\n    visitAlternative(node) {}\n    // Assertion\n    visitStartAnchor(node) {}\n    visitEndAnchor(node) {}\n    visitWordBoundary(node) {}\n    visitNonWordBoundary(node) {}\n    visitLookahead(node) {}\n    visitNegativeLookahead(node) {}\n    // atoms\n    visitCharacter(node) {}\n    visitSet(node) {}\n    visitGroup(node) {}\n    visitGroupBackReference(node) {}\n    visitQuantifier(node) {}\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/regexp-utils.js\nvar $1d44efb04eab6ceb$var$NEWLINE_REGEXP = /\\r?\\n/gm;\nvar $1d44efb04eab6ceb$var$regexpParser = new $1d44efb04eab6ceb$var$RegExpParser();\nvar $1d44efb04eab6ceb$var$TerminalRegExpVisitor = class extends $1d44efb04eab6ceb$var$BaseRegExpVisitor {\n    static{\n        (0, $7xxrv.__name)(this, \"TerminalRegExpVisitor\");\n    }\n    constructor(){\n        super(...arguments);\n        this.isStarting = true;\n        this.endRegexpStack = [];\n        this.multiline = false;\n    }\n    get endRegex() {\n        return this.endRegexpStack.join(\"\");\n    }\n    reset(regex) {\n        this.multiline = false;\n        this.regex = regex;\n        this.startRegexp = \"\";\n        this.isStarting = true;\n        this.endRegexpStack = [];\n    }\n    visitGroup(node) {\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        }\n    }\n    visitCharacter(node) {\n        const char = String.fromCharCode(node.value);\n        if (!this.multiline && char === \"\\n\") this.multiline = true;\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        } else {\n            const escapedChar = $1d44efb04eab6ceb$var$escapeRegExp(char);\n            this.endRegexpStack.push(escapedChar);\n            if (this.isStarting) this.startRegexp += escapedChar;\n        }\n    }\n    visitSet(node) {\n        if (!this.multiline) {\n            const set = this.regex.substring(node.loc.begin, node.loc.end);\n            const regex = new RegExp(set);\n            this.multiline = Boolean(\"\\n\".match(regex));\n        }\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        } else {\n            const set = this.regex.substring(node.loc.begin, node.loc.end);\n            this.endRegexpStack.push(set);\n            if (this.isStarting) this.startRegexp += set;\n        }\n    }\n    visitChildren(node) {\n        if (node.type === \"Group\") {\n            const group = node;\n            if (group.quantifier) return;\n        }\n        super.visitChildren(node);\n    }\n};\nvar $1d44efb04eab6ceb$var$visitor = new $1d44efb04eab6ceb$var$TerminalRegExpVisitor();\nfunction $1d44efb04eab6ceb$var$getTerminalParts(regexp) {\n    try {\n        if (typeof regexp !== \"string\") regexp = regexp.source;\n        regexp = `/${regexp}/`;\n        const pattern = $1d44efb04eab6ceb$var$regexpParser.pattern(regexp);\n        const parts = [];\n        for (const alternative of pattern.value.value){\n            $1d44efb04eab6ceb$var$visitor.reset(regexp);\n            $1d44efb04eab6ceb$var$visitor.visit(alternative);\n            parts.push({\n                start: $1d44efb04eab6ceb$var$visitor.startRegexp,\n                end: $1d44efb04eab6ceb$var$visitor.endRegex\n            });\n        }\n        return parts;\n    } catch (_a) {\n        return [];\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getTerminalParts, \"getTerminalParts\");\nfunction $1d44efb04eab6ceb$var$isMultilineComment(regexp) {\n    try {\n        if (typeof regexp === \"string\") regexp = new RegExp(regexp);\n        regexp = regexp.toString();\n        $1d44efb04eab6ceb$var$visitor.reset(regexp);\n        $1d44efb04eab6ceb$var$visitor.visit($1d44efb04eab6ceb$var$regexpParser.pattern(regexp));\n        return $1d44efb04eab6ceb$var$visitor.multiline;\n    } catch (_a) {\n        return false;\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isMultilineComment, \"isMultilineComment\");\nfunction $1d44efb04eab6ceb$var$isWhitespace(value) {\n    const regexp = typeof value === \"string\" ? new RegExp(value) : value;\n    return regexp.test(\" \");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isWhitespace, \"isWhitespace\");\nfunction $1d44efb04eab6ceb$var$escapeRegExp(value) {\n    return value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$escapeRegExp, \"escapeRegExp\");\nfunction $1d44efb04eab6ceb$var$getCaseInsensitivePattern(keyword) {\n    return Array.prototype.map.call(keyword, (letter)=>/\\w/.test(letter) ? `[${letter.toLowerCase()}${letter.toUpperCase()}]` : $1d44efb04eab6ceb$var$escapeRegExp(letter)).join(\"\");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getCaseInsensitivePattern, \"getCaseInsensitivePattern\");\nfunction $1d44efb04eab6ceb$var$partialMatches(regex, input) {\n    const partial = $1d44efb04eab6ceb$var$partialRegExp(regex);\n    const match = input.match(partial);\n    return !!match && match[0].length > 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$partialMatches, \"partialMatches\");\nfunction $1d44efb04eab6ceb$var$partialRegExp(regex) {\n    if (typeof regex === \"string\") regex = new RegExp(regex);\n    const re = regex, source = regex.source;\n    let i = 0;\n    function process2() {\n        let result = \"\", tmp;\n        function appendRaw(nbChars) {\n            result += source.substr(i, nbChars);\n            i += nbChars;\n        }\n        (0, $7xxrv.__name)(appendRaw, \"appendRaw\");\n        function appendOptional(nbChars) {\n            result += \"(?:\" + source.substr(i, nbChars) + \"|$)\";\n            i += nbChars;\n        }\n        (0, $7xxrv.__name)(appendOptional, \"appendOptional\");\n        while(i < source.length)switch(source[i]){\n            case \"\\\\\":\n                switch(source[i + 1]){\n                    case \"c\":\n                        appendOptional(3);\n                        break;\n                    case \"x\":\n                        appendOptional(4);\n                        break;\n                    case \"u\":\n                        if (re.unicode) {\n                            if (source[i + 2] === \"{\") appendOptional(source.indexOf(\"}\", i) - i + 1);\n                            else appendOptional(6);\n                        } else appendOptional(2);\n                        break;\n                    case \"p\":\n                    case \"P\":\n                        if (re.unicode) appendOptional(source.indexOf(\"}\", i) - i + 1);\n                        else appendOptional(2);\n                        break;\n                    case \"k\":\n                        appendOptional(source.indexOf(\">\", i) - i + 1);\n                        break;\n                    default:\n                        appendOptional(2);\n                        break;\n                }\n                break;\n            case \"[\":\n                tmp = /\\[(?:\\\\.|.)*?\\]/g;\n                tmp.lastIndex = i;\n                tmp = tmp.exec(source) || [];\n                appendOptional(tmp[0].length);\n                break;\n            case \"|\":\n            case \"^\":\n            case \"$\":\n            case \"*\":\n            case \"+\":\n            case \"?\":\n                appendRaw(1);\n                break;\n            case \"{\":\n                tmp = /\\{\\d+,?\\d*\\}/g;\n                tmp.lastIndex = i;\n                tmp = tmp.exec(source);\n                if (tmp) appendRaw(tmp[0].length);\n                else appendOptional(1);\n                break;\n            case \"(\":\n                if (source[i + 1] === \"?\") switch(source[i + 2]){\n                    case \":\":\n                        result += \"(?:\";\n                        i += 3;\n                        result += process2() + \"|$)\";\n                        break;\n                    case \"=\":\n                        result += \"(?=\";\n                        i += 3;\n                        result += process2() + \")\";\n                        break;\n                    case \"!\":\n                        tmp = i;\n                        i += 3;\n                        process2();\n                        result += source.substr(tmp, i - tmp);\n                        break;\n                    case \"<\":\n                        switch(source[i + 3]){\n                            case \"=\":\n                            case \"!\":\n                                tmp = i;\n                                i += 4;\n                                process2();\n                                result += source.substr(tmp, i - tmp);\n                                break;\n                            default:\n                                appendRaw(source.indexOf(\">\", i) - i + 1);\n                                result += process2() + \"|$)\";\n                                break;\n                        }\n                        break;\n                }\n                else {\n                    appendRaw(1);\n                    result += process2() + \"|$)\";\n                }\n                break;\n            case \")\":\n                ++i;\n                return result;\n            default:\n                appendOptional(1);\n                break;\n        }\n        return result;\n    }\n    (0, $7xxrv.__name)(process2, \"process\");\n    return new RegExp(process2(), regex.flags);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$partialRegExp, \"partialRegExp\");\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/grammar-utils.js\nfunction $1d44efb04eab6ceb$var$getEntryRule(grammar) {\n    return grammar.rules.find((e)=>$1d44efb04eab6ceb$var$isParserRule(e) && e.entry);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getEntryRule, \"getEntryRule\");\nfunction $1d44efb04eab6ceb$var$getHiddenRules(grammar) {\n    return grammar.rules.filter((e)=>$1d44efb04eab6ceb$var$isTerminalRule(e) && e.hidden);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getHiddenRules, \"getHiddenRules\");\nfunction $1d44efb04eab6ceb$var$getAllReachableRules(grammar, allTerminals) {\n    const ruleNames = /* @__PURE__ */ new Set();\n    const entryRule = $1d44efb04eab6ceb$var$getEntryRule(grammar);\n    if (!entryRule) return new Set(grammar.rules);\n    const topMostRules = [\n        entryRule\n    ].concat($1d44efb04eab6ceb$var$getHiddenRules(grammar));\n    for (const rule of topMostRules)$1d44efb04eab6ceb$var$ruleDfs(rule, ruleNames, allTerminals);\n    const rules = /* @__PURE__ */ new Set();\n    for (const rule of grammar.rules)if (ruleNames.has(rule.name) || $1d44efb04eab6ceb$var$isTerminalRule(rule) && rule.hidden) rules.add(rule);\n    return rules;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getAllReachableRules, \"getAllReachableRules\");\nfunction $1d44efb04eab6ceb$var$ruleDfs(rule, visitedSet, allTerminals) {\n    visitedSet.add(rule.name);\n    $1d44efb04eab6ceb$var$streamAllContents(rule).forEach((node)=>{\n        if ($1d44efb04eab6ceb$var$isRuleCall(node) || allTerminals && $1d44efb04eab6ceb$var$isTerminalRuleCall(node)) {\n            const refRule = node.rule.ref;\n            if (refRule && !visitedSet.has(refRule.name)) $1d44efb04eab6ceb$var$ruleDfs(refRule, visitedSet, allTerminals);\n        }\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$ruleDfs, \"ruleDfs\");\nfunction $1d44efb04eab6ceb$var$getCrossReferenceTerminal(crossRef) {\n    if (crossRef.terminal) return crossRef.terminal;\n    else if (crossRef.type.ref) {\n        const nameAssigment = $1d44efb04eab6ceb$var$findNameAssignment(crossRef.type.ref);\n        return nameAssigment === null || nameAssigment === void 0 ? void 0 : nameAssigment.terminal;\n    }\n    return void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getCrossReferenceTerminal, \"getCrossReferenceTerminal\");\nfunction $1d44efb04eab6ceb$var$isCommentTerminal(terminalRule) {\n    return terminalRule.hidden && !$1d44efb04eab6ceb$var$terminalRegex(terminalRule).test(\" \");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isCommentTerminal, \"isCommentTerminal\");\nfunction $1d44efb04eab6ceb$var$findNodesForProperty(node, property) {\n    if (!node || !property) return [];\n    return $1d44efb04eab6ceb$var$findNodesForPropertyInternal(node, property, node.astNode, true);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findNodesForProperty, \"findNodesForProperty\");\nfunction $1d44efb04eab6ceb$var$findNodeForProperty(node, property, index) {\n    if (!node || !property) return void 0;\n    const nodes = $1d44efb04eab6ceb$var$findNodesForPropertyInternal(node, property, node.astNode, true);\n    if (nodes.length === 0) return void 0;\n    if (index !== void 0) index = Math.max(0, Math.min(index, nodes.length - 1));\n    else index = 0;\n    return nodes[index];\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findNodeForProperty, \"findNodeForProperty\");\nfunction $1d44efb04eab6ceb$var$findNodesForPropertyInternal(node, property, element, first2) {\n    if (!first2) {\n        const nodeFeature = $1d44efb04eab6ceb$var$getContainerOfType(node.grammarSource, $1d44efb04eab6ceb$var$isAssignment);\n        if (nodeFeature && nodeFeature.feature === property) return [\n            node\n        ];\n    }\n    if ($1d44efb04eab6ceb$var$isCompositeCstNode(node) && node.astNode === element) return node.content.flatMap((e)=>$1d44efb04eab6ceb$var$findNodesForPropertyInternal(e, property, element, false));\n    return [];\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findNodesForPropertyInternal, \"findNodesForPropertyInternal\");\nfunction $1d44efb04eab6ceb$var$findNodesForKeyword(node, keyword) {\n    if (!node) return [];\n    return $1d44efb04eab6ceb$var$findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findNodesForKeyword, \"findNodesForKeyword\");\nfunction $1d44efb04eab6ceb$var$findNodeForKeyword(node, keyword, index) {\n    if (!node) return void 0;\n    const nodes = $1d44efb04eab6ceb$var$findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);\n    if (nodes.length === 0) return void 0;\n    if (index !== void 0) index = Math.max(0, Math.min(index, nodes.length - 1));\n    else index = 0;\n    return nodes[index];\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findNodeForKeyword, \"findNodeForKeyword\");\nfunction $1d44efb04eab6ceb$var$findNodesForKeywordInternal(node, keyword, element) {\n    if (node.astNode !== element) return [];\n    if ($1d44efb04eab6ceb$var$isKeyword(node.grammarSource) && node.grammarSource.value === keyword) return [\n        node\n    ];\n    const treeIterator = $1d44efb04eab6ceb$var$streamCst(node).iterator();\n    let result;\n    const keywordNodes = [];\n    do {\n        result = treeIterator.next();\n        if (!result.done) {\n            const childNode = result.value;\n            if (childNode.astNode === element) {\n                if ($1d44efb04eab6ceb$var$isKeyword(childNode.grammarSource) && childNode.grammarSource.value === keyword) keywordNodes.push(childNode);\n            } else treeIterator.prune();\n        }\n    }while (!result.done);\n    return keywordNodes;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findNodesForKeywordInternal, \"findNodesForKeywordInternal\");\nfunction $1d44efb04eab6ceb$var$findAssignment(cstNode) {\n    var _a;\n    const astNode = cstNode.astNode;\n    while(astNode === ((_a = cstNode.container) === null || _a === void 0 ? void 0 : _a.astNode)){\n        const assignment = $1d44efb04eab6ceb$var$getContainerOfType(cstNode.grammarSource, $1d44efb04eab6ceb$var$isAssignment);\n        if (assignment) return assignment;\n        cstNode = cstNode.container;\n    }\n    return void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findAssignment, \"findAssignment\");\nfunction $1d44efb04eab6ceb$var$findNameAssignment(type) {\n    let startNode = type;\n    if ($1d44efb04eab6ceb$var$isInferredType(startNode)) {\n        if ($1d44efb04eab6ceb$var$isAction(startNode.$container)) startNode = startNode.$container.$container;\n        else if ($1d44efb04eab6ceb$var$isParserRule(startNode.$container)) startNode = startNode.$container;\n        else $1d44efb04eab6ceb$var$assertUnreachable(startNode.$container);\n    }\n    return $1d44efb04eab6ceb$var$findNameAssignmentInternal(type, startNode, /* @__PURE__ */ new Map());\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findNameAssignment, \"findNameAssignment\");\nfunction $1d44efb04eab6ceb$var$findNameAssignmentInternal(type, startNode, cache) {\n    var _a;\n    function go(node, refType) {\n        let childAssignment = void 0;\n        const parentAssignment = $1d44efb04eab6ceb$var$getContainerOfType(node, $1d44efb04eab6ceb$var$isAssignment);\n        if (!parentAssignment) childAssignment = $1d44efb04eab6ceb$var$findNameAssignmentInternal(refType, refType, cache);\n        cache.set(type, childAssignment);\n        return childAssignment;\n    }\n    (0, $7xxrv.__name)(go, \"go\");\n    if (cache.has(type)) return cache.get(type);\n    cache.set(type, void 0);\n    for (const node of $1d44efb04eab6ceb$var$streamAllContents(startNode)){\n        if ($1d44efb04eab6ceb$var$isAssignment(node) && node.feature.toLowerCase() === \"name\") {\n            cache.set(type, node);\n            return node;\n        } else if ($1d44efb04eab6ceb$var$isRuleCall(node) && $1d44efb04eab6ceb$var$isParserRule(node.rule.ref)) return go(node, node.rule.ref);\n        else if ($1d44efb04eab6ceb$var$isSimpleType(node) && ((_a = node.typeRef) === null || _a === void 0 ? void 0 : _a.ref)) return go(node, node.typeRef.ref);\n    }\n    return void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findNameAssignmentInternal, \"findNameAssignmentInternal\");\nfunction $1d44efb04eab6ceb$var$getActionAtElement(element) {\n    const parent = element.$container;\n    if ($1d44efb04eab6ceb$var$isGroup(parent)) {\n        const elements = parent.elements;\n        const index = elements.indexOf(element);\n        for(let i = index - 1; i >= 0; i--){\n            const item = elements[i];\n            if ($1d44efb04eab6ceb$var$isAction(item)) return item;\n            else {\n                const action = $1d44efb04eab6ceb$var$streamAllContents(elements[i]).find($1d44efb04eab6ceb$var$isAction);\n                if (action) return action;\n            }\n        }\n    }\n    if ($1d44efb04eab6ceb$var$isAbstractElement(parent)) return $1d44efb04eab6ceb$var$getActionAtElement(parent);\n    else return void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getActionAtElement, \"getActionAtElement\");\nfunction $1d44efb04eab6ceb$var$isOptionalCardinality(cardinality, element) {\n    return cardinality === \"?\" || cardinality === \"*\" || $1d44efb04eab6ceb$var$isGroup(element) && Boolean(element.guardCondition);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isOptionalCardinality, \"isOptionalCardinality\");\nfunction $1d44efb04eab6ceb$var$isArrayCardinality(cardinality) {\n    return cardinality === \"*\" || cardinality === \"+\";\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isArrayCardinality, \"isArrayCardinality\");\nfunction $1d44efb04eab6ceb$var$isArrayOperator(operator) {\n    return operator === \"+=\";\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isArrayOperator, \"isArrayOperator\");\nfunction $1d44efb04eab6ceb$var$isDataTypeRule(rule) {\n    return $1d44efb04eab6ceb$var$isDataTypeRuleInternal(rule, /* @__PURE__ */ new Set());\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isDataTypeRule, \"isDataTypeRule\");\nfunction $1d44efb04eab6ceb$var$isDataTypeRuleInternal(rule, visited) {\n    if (visited.has(rule)) return true;\n    else visited.add(rule);\n    for (const node of $1d44efb04eab6ceb$var$streamAllContents(rule)){\n        if ($1d44efb04eab6ceb$var$isRuleCall(node)) {\n            if (!node.rule.ref) return false;\n            if ($1d44efb04eab6ceb$var$isParserRule(node.rule.ref) && !$1d44efb04eab6ceb$var$isDataTypeRuleInternal(node.rule.ref, visited)) return false;\n        } else if ($1d44efb04eab6ceb$var$isAssignment(node)) return false;\n        else if ($1d44efb04eab6ceb$var$isAction(node)) return false;\n    }\n    return Boolean(rule.definition);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isDataTypeRuleInternal, \"isDataTypeRuleInternal\");\nfunction $1d44efb04eab6ceb$var$isDataType(type) {\n    return $1d44efb04eab6ceb$var$isDataTypeInternal(type.type, /* @__PURE__ */ new Set());\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isDataType, \"isDataType\");\nfunction $1d44efb04eab6ceb$var$isDataTypeInternal(type, visited) {\n    if (visited.has(type)) return true;\n    else visited.add(type);\n    if ($1d44efb04eab6ceb$var$isArrayType(type)) return false;\n    else if ($1d44efb04eab6ceb$var$isReferenceType(type)) return false;\n    else if ($1d44efb04eab6ceb$var$isUnionType(type)) return type.types.every((e)=>$1d44efb04eab6ceb$var$isDataTypeInternal(e, visited));\n    else if ($1d44efb04eab6ceb$var$isSimpleType(type)) {\n        if (type.primitiveType !== void 0) return true;\n        else if (type.stringType !== void 0) return true;\n        else if (type.typeRef !== void 0) {\n            const ref = type.typeRef.ref;\n            if ($1d44efb04eab6ceb$var$isType(ref)) return $1d44efb04eab6ceb$var$isDataTypeInternal(ref.type, visited);\n            else return false;\n        } else return false;\n    } else return false;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isDataTypeInternal, \"isDataTypeInternal\");\nfunction $1d44efb04eab6ceb$var$getExplicitRuleType(rule) {\n    if (rule.inferredType) return rule.inferredType.name;\n    else if (rule.dataType) return rule.dataType;\n    else if (rule.returnType) {\n        const refType = rule.returnType.ref;\n        if (refType) {\n            if ($1d44efb04eab6ceb$var$isParserRule(refType)) return refType.name;\n            else if ($1d44efb04eab6ceb$var$isInterface(refType) || $1d44efb04eab6ceb$var$isType(refType)) return refType.name;\n        }\n    }\n    return void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getExplicitRuleType, \"getExplicitRuleType\");\nfunction $1d44efb04eab6ceb$var$getTypeName(type) {\n    var _a;\n    if ($1d44efb04eab6ceb$var$isParserRule(type)) return $1d44efb04eab6ceb$var$isDataTypeRule(type) ? type.name : (_a = $1d44efb04eab6ceb$var$getExplicitRuleType(type)) !== null && _a !== void 0 ? _a : type.name;\n    else if ($1d44efb04eab6ceb$var$isInterface(type) || $1d44efb04eab6ceb$var$isType(type) || $1d44efb04eab6ceb$var$isReturnType(type)) return type.name;\n    else if ($1d44efb04eab6ceb$var$isAction(type)) {\n        const actionType = $1d44efb04eab6ceb$var$getActionType(type);\n        if (actionType) return actionType;\n    } else if ($1d44efb04eab6ceb$var$isInferredType(type)) return type.name;\n    throw new Error(\"Cannot get name of Unknown Type\");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getTypeName, \"getTypeName\");\nfunction $1d44efb04eab6ceb$var$getActionType(action) {\n    var _a;\n    if (action.inferredType) return action.inferredType.name;\n    else if ((_a = action.type) === null || _a === void 0 ? void 0 : _a.ref) return $1d44efb04eab6ceb$var$getTypeName(action.type.ref);\n    return void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getActionType, \"getActionType\");\nfunction $1d44efb04eab6ceb$var$getRuleType(rule) {\n    var _a, _b, _c;\n    if ($1d44efb04eab6ceb$var$isTerminalRule(rule)) return (_b = (_a = rule.type) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : \"string\";\n    else return $1d44efb04eab6ceb$var$isDataTypeRule(rule) ? rule.name : (_c = $1d44efb04eab6ceb$var$getExplicitRuleType(rule)) !== null && _c !== void 0 ? _c : rule.name;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getRuleType, \"getRuleType\");\nfunction $1d44efb04eab6ceb$var$terminalRegex(terminalRule) {\n    const flags = {\n        s: false,\n        i: false,\n        u: false\n    };\n    const source = $1d44efb04eab6ceb$var$abstractElementToRegex(terminalRule.definition, flags);\n    const flagText = Object.entries(flags).filter(([, value])=>value).map(([name])=>name).join(\"\");\n    return new RegExp(source, flagText);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$terminalRegex, \"terminalRegex\");\nvar $1d44efb04eab6ceb$var$WILDCARD = /[\\s\\S]/.source;\nfunction $1d44efb04eab6ceb$var$abstractElementToRegex(element, flags) {\n    if ($1d44efb04eab6ceb$var$isTerminalAlternatives(element)) return $1d44efb04eab6ceb$var$terminalAlternativesToRegex(element);\n    else if ($1d44efb04eab6ceb$var$isTerminalGroup(element)) return $1d44efb04eab6ceb$var$terminalGroupToRegex(element);\n    else if ($1d44efb04eab6ceb$var$isCharacterRange(element)) return $1d44efb04eab6ceb$var$characterRangeToRegex(element);\n    else if ($1d44efb04eab6ceb$var$isTerminalRuleCall(element)) {\n        const rule = element.rule.ref;\n        if (!rule) throw new Error(\"Missing rule reference.\");\n        return $1d44efb04eab6ceb$var$withCardinality($1d44efb04eab6ceb$var$abstractElementToRegex(rule.definition), {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead\n        });\n    } else if ($1d44efb04eab6ceb$var$isNegatedToken(element)) return $1d44efb04eab6ceb$var$negateTokenToRegex(element);\n    else if ($1d44efb04eab6ceb$var$isUntilToken(element)) return $1d44efb04eab6ceb$var$untilTokenToRegex(element);\n    else if ($1d44efb04eab6ceb$var$isRegexToken(element)) {\n        const lastSlash = element.regex.lastIndexOf(\"/\");\n        const source = element.regex.substring(1, lastSlash);\n        const regexFlags = element.regex.substring(lastSlash + 1);\n        if (flags) {\n            flags.i = regexFlags.includes(\"i\");\n            flags.s = regexFlags.includes(\"s\");\n            flags.u = regexFlags.includes(\"u\");\n        }\n        return $1d44efb04eab6ceb$var$withCardinality(source, {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead,\n            wrap: false\n        });\n    } else if ($1d44efb04eab6ceb$var$isWildcard(element)) return $1d44efb04eab6ceb$var$withCardinality($1d44efb04eab6ceb$var$WILDCARD, {\n        cardinality: element.cardinality,\n        lookahead: element.lookahead\n    });\n    else throw new Error(`Invalid terminal element: ${element === null || element === void 0 ? void 0 : element.$type}`);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$abstractElementToRegex, \"abstractElementToRegex\");\nfunction $1d44efb04eab6ceb$var$terminalAlternativesToRegex(alternatives) {\n    return $1d44efb04eab6ceb$var$withCardinality(alternatives.elements.map((e)=>$1d44efb04eab6ceb$var$abstractElementToRegex(e)).join(\"|\"), {\n        cardinality: alternatives.cardinality,\n        lookahead: alternatives.lookahead\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$terminalAlternativesToRegex, \"terminalAlternativesToRegex\");\nfunction $1d44efb04eab6ceb$var$terminalGroupToRegex(group) {\n    return $1d44efb04eab6ceb$var$withCardinality(group.elements.map((e)=>$1d44efb04eab6ceb$var$abstractElementToRegex(e)).join(\"\"), {\n        cardinality: group.cardinality,\n        lookahead: group.lookahead\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$terminalGroupToRegex, \"terminalGroupToRegex\");\nfunction $1d44efb04eab6ceb$var$untilTokenToRegex(until) {\n    return $1d44efb04eab6ceb$var$withCardinality(`${$1d44efb04eab6ceb$var$WILDCARD}*?${$1d44efb04eab6ceb$var$abstractElementToRegex(until.terminal)}`, {\n        cardinality: until.cardinality,\n        lookahead: until.lookahead\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$untilTokenToRegex, \"untilTokenToRegex\");\nfunction $1d44efb04eab6ceb$var$negateTokenToRegex(negate) {\n    return $1d44efb04eab6ceb$var$withCardinality(`(?!${$1d44efb04eab6ceb$var$abstractElementToRegex(negate.terminal)})${$1d44efb04eab6ceb$var$WILDCARD}*?`, {\n        cardinality: negate.cardinality,\n        lookahead: negate.lookahead\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$negateTokenToRegex, \"negateTokenToRegex\");\nfunction $1d44efb04eab6ceb$var$characterRangeToRegex(range) {\n    if (range.right) return $1d44efb04eab6ceb$var$withCardinality(`[${$1d44efb04eab6ceb$var$keywordToRegex(range.left)}-${$1d44efb04eab6ceb$var$keywordToRegex(range.right)}]`, {\n        cardinality: range.cardinality,\n        lookahead: range.lookahead,\n        wrap: false\n    });\n    return $1d44efb04eab6ceb$var$withCardinality($1d44efb04eab6ceb$var$keywordToRegex(range.left), {\n        cardinality: range.cardinality,\n        lookahead: range.lookahead,\n        wrap: false\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$characterRangeToRegex, \"characterRangeToRegex\");\nfunction $1d44efb04eab6ceb$var$keywordToRegex(keyword) {\n    return $1d44efb04eab6ceb$var$escapeRegExp(keyword.value);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$keywordToRegex, \"keywordToRegex\");\nfunction $1d44efb04eab6ceb$var$withCardinality(regex, options) {\n    var _a;\n    if (options.wrap !== false || options.lookahead) regex = `(${(_a = options.lookahead) !== null && _a !== void 0 ? _a : \"\"}${regex})`;\n    if (options.cardinality) return `${regex}${options.cardinality}`;\n    return regex;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$withCardinality, \"withCardinality\");\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/languages/grammar-config.js\nfunction $1d44efb04eab6ceb$var$createGrammarConfig(services) {\n    const rules = [];\n    const grammar = services.Grammar;\n    for (const rule of grammar.rules)if ($1d44efb04eab6ceb$var$isTerminalRule(rule) && $1d44efb04eab6ceb$var$isCommentTerminal(rule) && $1d44efb04eab6ceb$var$isMultilineComment($1d44efb04eab6ceb$var$terminalRegex(rule))) rules.push(rule.name);\n    return {\n        multilineCommentRules: rules,\n        nameRegexp: $1d44efb04eab6ceb$var$DefaultNameRegexp\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$createGrammarConfig, \"createGrammarConfig\");\n// ../../node_modules/.pnpm/@chevrotain+utils@11.0.3/node_modules/@chevrotain/utils/lib/src/print.js\nfunction $1d44efb04eab6ceb$var$PRINT_ERROR(msg) {\n    if (console && console.error) console.error(`Error: ${msg}`);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$PRINT_ERROR, \"PRINT_ERROR\");\nfunction $1d44efb04eab6ceb$var$PRINT_WARNING(msg) {\n    if (console && console.warn) console.warn(`Warning: ${msg}`);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$PRINT_WARNING, \"PRINT_WARNING\");\n// ../../node_modules/.pnpm/@chevrotain+utils@11.0.3/node_modules/@chevrotain/utils/lib/src/timer.js\nfunction $1d44efb04eab6ceb$var$timer(func) {\n    const start = /* @__PURE__ */ new Date().getTime();\n    const val = func();\n    const end = /* @__PURE__ */ new Date().getTime();\n    const total = end - start;\n    return {\n        time: total,\n        value: val\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$timer, \"timer\");\n// ../../node_modules/.pnpm/@chevrotain+utils@11.0.3/node_modules/@chevrotain/utils/lib/src/to-fast-properties.js\nfunction $1d44efb04eab6ceb$var$toFastProperties(toBecomeFast) {\n    function FakeConstructor() {}\n    (0, $7xxrv.__name)(FakeConstructor, \"FakeConstructor\");\n    FakeConstructor.prototype = toBecomeFast;\n    const fakeInstance = new FakeConstructor();\n    function fakeAccess() {\n        return typeof fakeInstance.bar;\n    }\n    (0, $7xxrv.__name)(fakeAccess, \"fakeAccess\");\n    fakeAccess();\n    fakeAccess();\n    return toBecomeFast;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$toFastProperties, \"toFastProperties\");\n// ../../node_modules/.pnpm/@chevrotain+gast@11.0.3/node_modules/@chevrotain/gast/lib/src/model.js\nfunction $1d44efb04eab6ceb$var$tokenLabel(tokType) {\n    if ($1d44efb04eab6ceb$var$hasTokenLabel(tokType)) return tokType.LABEL;\n    else return tokType.name;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$tokenLabel, \"tokenLabel\");\nfunction $1d44efb04eab6ceb$var$hasTokenLabel(obj) {\n    return (0, $76RTQ.isString_default)(obj.LABEL) && obj.LABEL !== \"\";\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$hasTokenLabel, \"hasTokenLabel\");\nvar $1d44efb04eab6ceb$var$AbstractProduction = class {\n    static{\n        (0, $7xxrv.__name)(this, \"AbstractProduction\");\n    }\n    get definition() {\n        return this._definition;\n    }\n    set definition(value) {\n        this._definition = value;\n    }\n    constructor(_definition){\n        this._definition = _definition;\n    }\n    accept(visitor2) {\n        visitor2.visit(this);\n        (0, $76RTQ.forEach_default)(this.definition, (prod)=>{\n            prod.accept(visitor2);\n        });\n    }\n};\nvar $1d44efb04eab6ceb$var$NonTerminal = class extends $1d44efb04eab6ceb$var$AbstractProduction {\n    static{\n        (0, $7xxrv.__name)(this, \"NonTerminal\");\n    }\n    constructor(options){\n        super([]);\n        this.idx = 1;\n        (0, $76RTQ.assign_default)(this, (0, $76RTQ.pickBy_default)(options, (v)=>v !== void 0));\n    }\n    set definition(definition) {}\n    get definition() {\n        if (this.referencedRule !== void 0) return this.referencedRule.definition;\n        return [];\n    }\n    accept(visitor2) {\n        visitor2.visit(this);\n    }\n};\nvar $1d44efb04eab6ceb$var$Rule = class extends $1d44efb04eab6ceb$var$AbstractProduction {\n    static{\n        (0, $7xxrv.__name)(this, \"Rule\");\n    }\n    constructor(options){\n        super(options.definition);\n        this.orgText = \"\";\n        (0, $76RTQ.assign_default)(this, (0, $76RTQ.pickBy_default)(options, (v)=>v !== void 0));\n    }\n};\nvar $1d44efb04eab6ceb$var$Alternative = class extends $1d44efb04eab6ceb$var$AbstractProduction {\n    static{\n        (0, $7xxrv.__name)(this, \"Alternative\");\n    }\n    constructor(options){\n        super(options.definition);\n        this.ignoreAmbiguities = false;\n        (0, $76RTQ.assign_default)(this, (0, $76RTQ.pickBy_default)(options, (v)=>v !== void 0));\n    }\n};\nvar $1d44efb04eab6ceb$var$Option = class extends $1d44efb04eab6ceb$var$AbstractProduction {\n    static{\n        (0, $7xxrv.__name)(this, \"Option\");\n    }\n    constructor(options){\n        super(options.definition);\n        this.idx = 1;\n        (0, $76RTQ.assign_default)(this, (0, $76RTQ.pickBy_default)(options, (v)=>v !== void 0));\n    }\n};\nvar $1d44efb04eab6ceb$var$RepetitionMandatory = class extends $1d44efb04eab6ceb$var$AbstractProduction {\n    static{\n        (0, $7xxrv.__name)(this, \"RepetitionMandatory\");\n    }\n    constructor(options){\n        super(options.definition);\n        this.idx = 1;\n        (0, $76RTQ.assign_default)(this, (0, $76RTQ.pickBy_default)(options, (v)=>v !== void 0));\n    }\n};\nvar $1d44efb04eab6ceb$var$RepetitionMandatoryWithSeparator = class extends $1d44efb04eab6ceb$var$AbstractProduction {\n    static{\n        (0, $7xxrv.__name)(this, \"RepetitionMandatoryWithSeparator\");\n    }\n    constructor(options){\n        super(options.definition);\n        this.idx = 1;\n        (0, $76RTQ.assign_default)(this, (0, $76RTQ.pickBy_default)(options, (v)=>v !== void 0));\n    }\n};\nvar $1d44efb04eab6ceb$var$Repetition = class extends $1d44efb04eab6ceb$var$AbstractProduction {\n    static{\n        (0, $7xxrv.__name)(this, \"Repetition\");\n    }\n    constructor(options){\n        super(options.definition);\n        this.idx = 1;\n        (0, $76RTQ.assign_default)(this, (0, $76RTQ.pickBy_default)(options, (v)=>v !== void 0));\n    }\n};\nvar $1d44efb04eab6ceb$var$RepetitionWithSeparator = class extends $1d44efb04eab6ceb$var$AbstractProduction {\n    static{\n        (0, $7xxrv.__name)(this, \"RepetitionWithSeparator\");\n    }\n    constructor(options){\n        super(options.definition);\n        this.idx = 1;\n        (0, $76RTQ.assign_default)(this, (0, $76RTQ.pickBy_default)(options, (v)=>v !== void 0));\n    }\n};\nvar $1d44efb04eab6ceb$var$Alternation = class extends $1d44efb04eab6ceb$var$AbstractProduction {\n    static{\n        (0, $7xxrv.__name)(this, \"Alternation\");\n    }\n    get definition() {\n        return this._definition;\n    }\n    set definition(value) {\n        this._definition = value;\n    }\n    constructor(options){\n        super(options.definition);\n        this.idx = 1;\n        this.ignoreAmbiguities = false;\n        this.hasPredicates = false;\n        (0, $76RTQ.assign_default)(this, (0, $76RTQ.pickBy_default)(options, (v)=>v !== void 0));\n    }\n};\nvar $1d44efb04eab6ceb$var$Terminal = class {\n    static{\n        (0, $7xxrv.__name)(this, \"Terminal\");\n    }\n    constructor(options){\n        this.idx = 1;\n        (0, $76RTQ.assign_default)(this, (0, $76RTQ.pickBy_default)(options, (v)=>v !== void 0));\n    }\n    accept(visitor2) {\n        visitor2.visit(this);\n    }\n};\nfunction $1d44efb04eab6ceb$var$serializeGrammar(topRules) {\n    return (0, $76RTQ.map_default)(topRules, $1d44efb04eab6ceb$var$serializeProduction);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$serializeGrammar, \"serializeGrammar\");\nfunction $1d44efb04eab6ceb$var$serializeProduction(node) {\n    function convertDefinition(definition) {\n        return (0, $76RTQ.map_default)(definition, $1d44efb04eab6ceb$var$serializeProduction);\n    }\n    (0, $7xxrv.__name)(convertDefinition, \"convertDefinition\");\n    if (node instanceof $1d44efb04eab6ceb$var$NonTerminal) {\n        const serializedNonTerminal = {\n            type: \"NonTerminal\",\n            name: node.nonTerminalName,\n            idx: node.idx\n        };\n        if ((0, $76RTQ.isString_default)(node.label)) serializedNonTerminal.label = node.label;\n        return serializedNonTerminal;\n    } else if (node instanceof $1d44efb04eab6ceb$var$Alternative) return {\n        type: \"Alternative\",\n        definition: convertDefinition(node.definition)\n    };\n    else if (node instanceof $1d44efb04eab6ceb$var$Option) return {\n        type: \"Option\",\n        idx: node.idx,\n        definition: convertDefinition(node.definition)\n    };\n    else if (node instanceof $1d44efb04eab6ceb$var$RepetitionMandatory) return {\n        type: \"RepetitionMandatory\",\n        idx: node.idx,\n        definition: convertDefinition(node.definition)\n    };\n    else if (node instanceof $1d44efb04eab6ceb$var$RepetitionMandatoryWithSeparator) return {\n        type: \"RepetitionMandatoryWithSeparator\",\n        idx: node.idx,\n        separator: $1d44efb04eab6ceb$var$serializeProduction(new $1d44efb04eab6ceb$var$Terminal({\n            terminalType: node.separator\n        })),\n        definition: convertDefinition(node.definition)\n    };\n    else if (node instanceof $1d44efb04eab6ceb$var$RepetitionWithSeparator) return {\n        type: \"RepetitionWithSeparator\",\n        idx: node.idx,\n        separator: $1d44efb04eab6ceb$var$serializeProduction(new $1d44efb04eab6ceb$var$Terminal({\n            terminalType: node.separator\n        })),\n        definition: convertDefinition(node.definition)\n    };\n    else if (node instanceof $1d44efb04eab6ceb$var$Repetition) return {\n        type: \"Repetition\",\n        idx: node.idx,\n        definition: convertDefinition(node.definition)\n    };\n    else if (node instanceof $1d44efb04eab6ceb$var$Alternation) return {\n        type: \"Alternation\",\n        idx: node.idx,\n        definition: convertDefinition(node.definition)\n    };\n    else if (node instanceof $1d44efb04eab6ceb$var$Terminal) {\n        const serializedTerminal = {\n            type: \"Terminal\",\n            name: node.terminalType.name,\n            label: $1d44efb04eab6ceb$var$tokenLabel(node.terminalType),\n            idx: node.idx\n        };\n        if ((0, $76RTQ.isString_default)(node.label)) serializedTerminal.terminalLabel = node.label;\n        const pattern = node.terminalType.PATTERN;\n        if (node.terminalType.PATTERN) serializedTerminal.pattern = (0, $76RTQ.isRegExp_default)(pattern) ? pattern.source : pattern;\n        return serializedTerminal;\n    } else if (node instanceof $1d44efb04eab6ceb$var$Rule) return {\n        type: \"Rule\",\n        name: node.name,\n        orgText: node.orgText,\n        definition: convertDefinition(node.definition)\n    };\n    else throw Error(\"non exhaustive match\");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$serializeProduction, \"serializeProduction\");\n// ../../node_modules/.pnpm/@chevrotain+gast@11.0.3/node_modules/@chevrotain/gast/lib/src/visitor.js\nvar $1d44efb04eab6ceb$var$GAstVisitor = class {\n    static{\n        (0, $7xxrv.__name)(this, \"GAstVisitor\");\n    }\n    visit(node) {\n        const nodeAny = node;\n        switch(nodeAny.constructor){\n            case $1d44efb04eab6ceb$var$NonTerminal:\n                return this.visitNonTerminal(nodeAny);\n            case $1d44efb04eab6ceb$var$Alternative:\n                return this.visitAlternative(nodeAny);\n            case $1d44efb04eab6ceb$var$Option:\n                return this.visitOption(nodeAny);\n            case $1d44efb04eab6ceb$var$RepetitionMandatory:\n                return this.visitRepetitionMandatory(nodeAny);\n            case $1d44efb04eab6ceb$var$RepetitionMandatoryWithSeparator:\n                return this.visitRepetitionMandatoryWithSeparator(nodeAny);\n            case $1d44efb04eab6ceb$var$RepetitionWithSeparator:\n                return this.visitRepetitionWithSeparator(nodeAny);\n            case $1d44efb04eab6ceb$var$Repetition:\n                return this.visitRepetition(nodeAny);\n            case $1d44efb04eab6ceb$var$Alternation:\n                return this.visitAlternation(nodeAny);\n            case $1d44efb04eab6ceb$var$Terminal:\n                return this.visitTerminal(nodeAny);\n            case $1d44efb04eab6ceb$var$Rule:\n                return this.visitRule(nodeAny);\n            default:\n                throw Error(\"non exhaustive match\");\n        }\n    }\n    /* c8 ignore next */ visitNonTerminal(node) {}\n    /* c8 ignore next */ visitAlternative(node) {}\n    /* c8 ignore next */ visitOption(node) {}\n    /* c8 ignore next */ visitRepetition(node) {}\n    /* c8 ignore next */ visitRepetitionMandatory(node) {}\n    /* c8 ignore next 3 */ visitRepetitionMandatoryWithSeparator(node) {}\n    /* c8 ignore next */ visitRepetitionWithSeparator(node) {}\n    /* c8 ignore next */ visitAlternation(node) {}\n    /* c8 ignore next */ visitTerminal(node) {}\n    /* c8 ignore next */ visitRule(node) {}\n};\n// ../../node_modules/.pnpm/@chevrotain+gast@11.0.3/node_modules/@chevrotain/gast/lib/src/helpers.js\nfunction $1d44efb04eab6ceb$var$isSequenceProd(prod) {\n    return prod instanceof $1d44efb04eab6ceb$var$Alternative || prod instanceof $1d44efb04eab6ceb$var$Option || prod instanceof $1d44efb04eab6ceb$var$Repetition || prod instanceof $1d44efb04eab6ceb$var$RepetitionMandatory || prod instanceof $1d44efb04eab6ceb$var$RepetitionMandatoryWithSeparator || prod instanceof $1d44efb04eab6ceb$var$RepetitionWithSeparator || prod instanceof $1d44efb04eab6ceb$var$Terminal || prod instanceof $1d44efb04eab6ceb$var$Rule;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isSequenceProd, \"isSequenceProd\");\nfunction $1d44efb04eab6ceb$var$isOptionalProd(prod, alreadyVisited = []) {\n    const isDirectlyOptional = prod instanceof $1d44efb04eab6ceb$var$Option || prod instanceof $1d44efb04eab6ceb$var$Repetition || prod instanceof $1d44efb04eab6ceb$var$RepetitionWithSeparator;\n    if (isDirectlyOptional) return true;\n    if (prod instanceof $1d44efb04eab6ceb$var$Alternation) return (0, $76RTQ.some_default)(prod.definition, (subProd)=>{\n        return $1d44efb04eab6ceb$var$isOptionalProd(subProd, alreadyVisited);\n    });\n    else if (prod instanceof $1d44efb04eab6ceb$var$NonTerminal && (0, $76RTQ.includes_default)(alreadyVisited, prod)) return false;\n    else if (prod instanceof $1d44efb04eab6ceb$var$AbstractProduction) {\n        if (prod instanceof $1d44efb04eab6ceb$var$NonTerminal) alreadyVisited.push(prod);\n        return (0, $76RTQ.every_default)(prod.definition, (subProd)=>{\n            return $1d44efb04eab6ceb$var$isOptionalProd(subProd, alreadyVisited);\n        });\n    } else return false;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isOptionalProd, \"isOptionalProd\");\nfunction $1d44efb04eab6ceb$var$isBranchingProd(prod) {\n    return prod instanceof $1d44efb04eab6ceb$var$Alternation;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isBranchingProd, \"isBranchingProd\");\nfunction $1d44efb04eab6ceb$var$getProductionDslName(prod) {\n    if (prod instanceof $1d44efb04eab6ceb$var$NonTerminal) return \"SUBRULE\";\n    else if (prod instanceof $1d44efb04eab6ceb$var$Option) return \"OPTION\";\n    else if (prod instanceof $1d44efb04eab6ceb$var$Alternation) return \"OR\";\n    else if (prod instanceof $1d44efb04eab6ceb$var$RepetitionMandatory) return \"AT_LEAST_ONE\";\n    else if (prod instanceof $1d44efb04eab6ceb$var$RepetitionMandatoryWithSeparator) return \"AT_LEAST_ONE_SEP\";\n    else if (prod instanceof $1d44efb04eab6ceb$var$RepetitionWithSeparator) return \"MANY_SEP\";\n    else if (prod instanceof $1d44efb04eab6ceb$var$Repetition) return \"MANY\";\n    else if (prod instanceof $1d44efb04eab6ceb$var$Terminal) return \"CONSUME\";\n    else throw Error(\"non exhaustive match\");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getProductionDslName, \"getProductionDslName\");\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/grammar/rest.js\nvar $1d44efb04eab6ceb$var$RestWalker = class {\n    static{\n        (0, $7xxrv.__name)(this, \"RestWalker\");\n    }\n    walk(prod, prevRest = []) {\n        (0, $76RTQ.forEach_default)(prod.definition, (subProd, index)=>{\n            const currRest = (0, $76RTQ.drop_default)(prod.definition, index + 1);\n            if (subProd instanceof $1d44efb04eab6ceb$var$NonTerminal) this.walkProdRef(subProd, currRest, prevRest);\n            else if (subProd instanceof $1d44efb04eab6ceb$var$Terminal) this.walkTerminal(subProd, currRest, prevRest);\n            else if (subProd instanceof $1d44efb04eab6ceb$var$Alternative) this.walkFlat(subProd, currRest, prevRest);\n            else if (subProd instanceof $1d44efb04eab6ceb$var$Option) this.walkOption(subProd, currRest, prevRest);\n            else if (subProd instanceof $1d44efb04eab6ceb$var$RepetitionMandatory) this.walkAtLeastOne(subProd, currRest, prevRest);\n            else if (subProd instanceof $1d44efb04eab6ceb$var$RepetitionMandatoryWithSeparator) this.walkAtLeastOneSep(subProd, currRest, prevRest);\n            else if (subProd instanceof $1d44efb04eab6ceb$var$RepetitionWithSeparator) this.walkManySep(subProd, currRest, prevRest);\n            else if (subProd instanceof $1d44efb04eab6ceb$var$Repetition) this.walkMany(subProd, currRest, prevRest);\n            else if (subProd instanceof $1d44efb04eab6ceb$var$Alternation) this.walkOr(subProd, currRest, prevRest);\n            else throw Error(\"non exhaustive match\");\n        });\n    }\n    walkTerminal(terminal, currRest, prevRest) {}\n    walkProdRef(refProd, currRest, prevRest) {}\n    walkFlat(flatProd, currRest, prevRest) {\n        const fullOrRest = currRest.concat(prevRest);\n        this.walk(flatProd, fullOrRest);\n    }\n    walkOption(optionProd, currRest, prevRest) {\n        const fullOrRest = currRest.concat(prevRest);\n        this.walk(optionProd, fullOrRest);\n    }\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n        const fullAtLeastOneRest = [\n            new $1d44efb04eab6ceb$var$Option({\n                definition: atLeastOneProd.definition\n            })\n        ].concat(currRest, prevRest);\n        this.walk(atLeastOneProd, fullAtLeastOneRest);\n    }\n    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n        const fullAtLeastOneSepRest = $1d44efb04eab6ceb$var$restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n    }\n    walkMany(manyProd, currRest, prevRest) {\n        const fullManyRest = [\n            new $1d44efb04eab6ceb$var$Option({\n                definition: manyProd.definition\n            })\n        ].concat(currRest, prevRest);\n        this.walk(manyProd, fullManyRest);\n    }\n    walkManySep(manySepProd, currRest, prevRest) {\n        const fullManySepRest = $1d44efb04eab6ceb$var$restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n        this.walk(manySepProd, fullManySepRest);\n    }\n    walkOr(orProd, currRest, prevRest) {\n        const fullOrRest = currRest.concat(prevRest);\n        (0, $76RTQ.forEach_default)(orProd.definition, (alt)=>{\n            const prodWrapper = new $1d44efb04eab6ceb$var$Alternative({\n                definition: [\n                    alt\n                ]\n            });\n            this.walk(prodWrapper, fullOrRest);\n        });\n    }\n};\nfunction $1d44efb04eab6ceb$var$restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n    const repSepRest = [\n        new $1d44efb04eab6ceb$var$Option({\n            definition: [\n                new $1d44efb04eab6ceb$var$Terminal({\n                    terminalType: repSepProd.separator\n                })\n            ].concat(repSepProd.definition)\n        })\n    ];\n    const fullRepSepRest = repSepRest.concat(currRest, prevRest);\n    return fullRepSepRest;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$restForRepetitionWithSeparator, \"restForRepetitionWithSeparator\");\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/grammar/first.js\nfunction $1d44efb04eab6ceb$var$first(prod) {\n    if (prod instanceof $1d44efb04eab6ceb$var$NonTerminal) return $1d44efb04eab6ceb$var$first(prod.referencedRule);\n    else if (prod instanceof $1d44efb04eab6ceb$var$Terminal) return $1d44efb04eab6ceb$var$firstForTerminal(prod);\n    else if ($1d44efb04eab6ceb$var$isSequenceProd(prod)) return $1d44efb04eab6ceb$var$firstForSequence(prod);\n    else if ($1d44efb04eab6ceb$var$isBranchingProd(prod)) return $1d44efb04eab6ceb$var$firstForBranching(prod);\n    else throw Error(\"non exhaustive match\");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$first, \"first\");\nfunction $1d44efb04eab6ceb$var$firstForSequence(prod) {\n    let firstSet = [];\n    const seq = prod.definition;\n    let nextSubProdIdx = 0;\n    let hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    let currSubProd;\n    let isLastInnerProdOptional = true;\n    while(hasInnerProdsRemaining && isLastInnerProdOptional){\n        currSubProd = seq[nextSubProdIdx];\n        isLastInnerProdOptional = $1d44efb04eab6ceb$var$isOptionalProd(currSubProd);\n        firstSet = firstSet.concat($1d44efb04eab6ceb$var$first(currSubProd));\n        nextSubProdIdx = nextSubProdIdx + 1;\n        hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    }\n    return (0, $76RTQ.uniq_default)(firstSet);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$firstForSequence, \"firstForSequence\");\nfunction $1d44efb04eab6ceb$var$firstForBranching(prod) {\n    const allAlternativesFirsts = (0, $76RTQ.map_default)(prod.definition, (innerProd)=>{\n        return $1d44efb04eab6ceb$var$first(innerProd);\n    });\n    return (0, $76RTQ.uniq_default)((0, $76RTQ.flatten_default)(allAlternativesFirsts));\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$firstForBranching, \"firstForBranching\");\nfunction $1d44efb04eab6ceb$var$firstForTerminal(terminal) {\n    return [\n        terminal.terminalType\n    ];\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$firstForTerminal, \"firstForTerminal\");\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/constants.js\nvar $1d44efb04eab6ceb$var$IN = \"_~IN~_\";\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/grammar/follow.js\nvar $1d44efb04eab6ceb$var$ResyncFollowsWalker = class extends $1d44efb04eab6ceb$var$RestWalker {\n    static{\n        (0, $7xxrv.__name)(this, \"ResyncFollowsWalker\");\n    }\n    constructor(topProd){\n        super();\n        this.topProd = topProd;\n        this.follows = {};\n    }\n    startWalking() {\n        this.walk(this.topProd);\n        return this.follows;\n    }\n    walkTerminal(terminal, currRest, prevRest) {}\n    walkProdRef(refProd, currRest, prevRest) {\n        const followName = $1d44efb04eab6ceb$var$buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name;\n        const fullRest = currRest.concat(prevRest);\n        const restProd = new $1d44efb04eab6ceb$var$Alternative({\n            definition: fullRest\n        });\n        const t_in_topProd_follows = $1d44efb04eab6ceb$var$first(restProd);\n        this.follows[followName] = t_in_topProd_follows;\n    }\n};\nfunction $1d44efb04eab6ceb$var$computeAllProdsFollows(topProductions) {\n    const reSyncFollows = {};\n    (0, $76RTQ.forEach_default)(topProductions, (topProd)=>{\n        const currRefsFollow = new $1d44efb04eab6ceb$var$ResyncFollowsWalker(topProd).startWalking();\n        (0, $76RTQ.assign_default)(reSyncFollows, currRefsFollow);\n    });\n    return reSyncFollows;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$computeAllProdsFollows, \"computeAllProdsFollows\");\nfunction $1d44efb04eab6ceb$var$buildBetweenProdsFollowPrefix(inner, occurenceInParent) {\n    return inner.name + occurenceInParent + $1d44efb04eab6ceb$var$IN;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildBetweenProdsFollowPrefix, \"buildBetweenProdsFollowPrefix\");\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/scan/reg_exp_parser.js\nvar $1d44efb04eab6ceb$var$regExpAstCache = {};\nvar $1d44efb04eab6ceb$var$regExpParser = new $1d44efb04eab6ceb$var$RegExpParser();\nfunction $1d44efb04eab6ceb$var$getRegExpAst(regExp) {\n    const regExpStr = regExp.toString();\n    if ($1d44efb04eab6ceb$var$regExpAstCache.hasOwnProperty(regExpStr)) return $1d44efb04eab6ceb$var$regExpAstCache[regExpStr];\n    else {\n        const regExpAst = $1d44efb04eab6ceb$var$regExpParser.pattern(regExpStr);\n        $1d44efb04eab6ceb$var$regExpAstCache[regExpStr] = regExpAst;\n        return regExpAst;\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getRegExpAst, \"getRegExpAst\");\nfunction $1d44efb04eab6ceb$var$clearRegExpParserCache() {\n    $1d44efb04eab6ceb$var$regExpAstCache = {};\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$clearRegExpParserCache, \"clearRegExpParserCache\");\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/scan/reg_exp.js\nvar $1d44efb04eab6ceb$var$complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nvar $1d44efb04eab6ceb$var$failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nfunction $1d44efb04eab6ceb$var$getOptimizedStartCodesIndices(regExp, ensureOptimizations = false) {\n    try {\n        const ast = $1d44efb04eab6ceb$var$getRegExpAst(regExp);\n        const firstChars = $1d44efb04eab6ceb$var$firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n        return firstChars;\n    } catch (e) {\n        if (e.message === $1d44efb04eab6ceb$var$complementErrorMessage) {\n            if (ensureOptimizations) $1d44efb04eab6ceb$var$PRINT_WARNING(`${$1d44efb04eab6ceb$var$failedOptimizationPrefixMsg}\tUnable to optimize: < ${regExp.toString()} >\n\tComplement Sets cannot be automatically optimized.\n\tThis will disable the lexer's first char optimizations.\n\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);\n        } else {\n            let msgSuffix = \"\";\n            if (ensureOptimizations) msgSuffix = \"\\n\tThis will disable the lexer's first char optimizations.\\n\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n            $1d44efb04eab6ceb$var$PRINT_ERROR(`${$1d44efb04eab6ceb$var$failedOptimizationPrefixMsg}\n\tFailed parsing: < ${regExp.toString()} >\n\tUsing the @chevrotain/regexp-to-ast library\n\tPlease open an issue at: https://github.com/chevrotain/chevrotain/issues` + msgSuffix);\n        }\n    }\n    return [];\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getOptimizedStartCodesIndices, \"getOptimizedStartCodesIndices\");\nfunction $1d44efb04eab6ceb$var$firstCharOptimizedIndices(ast, result, ignoreCase) {\n    switch(ast.type){\n        case \"Disjunction\":\n            for(let i = 0; i < ast.value.length; i++)$1d44efb04eab6ceb$var$firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n            break;\n        case \"Alternative\":\n            const terms = ast.value;\n            for(let i = 0; i < terms.length; i++){\n                const term = terms[i];\n                switch(term.type){\n                    case \"EndAnchor\":\n                    case \"GroupBackReference\":\n                    case \"Lookahead\":\n                    case \"NegativeLookahead\":\n                    case \"StartAnchor\":\n                    case \"WordBoundary\":\n                    case \"NonWordBoundary\":\n                        continue;\n                }\n                const atom2 = term;\n                switch(atom2.type){\n                    case \"Character\":\n                        $1d44efb04eab6ceb$var$addOptimizedIdxToResult(atom2.value, result, ignoreCase);\n                        break;\n                    case \"Set\":\n                        if (atom2.complement === true) throw Error($1d44efb04eab6ceb$var$complementErrorMessage);\n                        (0, $76RTQ.forEach_default)(atom2.value, (code)=>{\n                            if (typeof code === \"number\") $1d44efb04eab6ceb$var$addOptimizedIdxToResult(code, result, ignoreCase);\n                            else {\n                                const range = code;\n                                if (ignoreCase === true) for(let rangeCode = range.from; rangeCode <= range.to; rangeCode++)$1d44efb04eab6ceb$var$addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                else {\n                                    for(let rangeCode = range.from; rangeCode <= range.to && rangeCode < $1d44efb04eab6ceb$var$minOptimizationVal; rangeCode++)$1d44efb04eab6ceb$var$addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    if (range.to >= $1d44efb04eab6ceb$var$minOptimizationVal) {\n                                        const minUnOptVal = range.from >= $1d44efb04eab6ceb$var$minOptimizationVal ? range.from : $1d44efb04eab6ceb$var$minOptimizationVal;\n                                        const maxUnOptVal = range.to;\n                                        const minOptIdx = $1d44efb04eab6ceb$var$charCodeToOptimizedIndex(minUnOptVal);\n                                        const maxOptIdx = $1d44efb04eab6ceb$var$charCodeToOptimizedIndex(maxUnOptVal);\n                                        for(let currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++)result[currOptIdx] = currOptIdx;\n                                    }\n                                }\n                            }\n                        });\n                        break;\n                    case \"Group\":\n                        $1d44efb04eab6ceb$var$firstCharOptimizedIndices(atom2.value, result, ignoreCase);\n                        break;\n                    default:\n                        throw Error(\"Non Exhaustive Match\");\n                }\n                const isOptionalQuantifier = atom2.quantifier !== void 0 && atom2.quantifier.atLeast === 0;\n                if (// A group may be optional due to empty contents /(?:)/\n                // or if everything inside it is optional /((a)?)/\n                atom2.type === \"Group\" && $1d44efb04eab6ceb$var$isWholeOptional(atom2) === false || // If this term is not a group it may only be optional if it has an optional quantifier\n                atom2.type !== \"Group\" && isOptionalQuantifier === false) break;\n            }\n            break;\n        default:\n            throw Error(\"non exhaustive match!\");\n    }\n    return (0, $76RTQ.values_default)(result);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$firstCharOptimizedIndices, \"firstCharOptimizedIndices\");\nfunction $1d44efb04eab6ceb$var$addOptimizedIdxToResult(code, result, ignoreCase) {\n    const optimizedCharIdx = $1d44efb04eab6ceb$var$charCodeToOptimizedIndex(code);\n    result[optimizedCharIdx] = optimizedCharIdx;\n    if (ignoreCase === true) $1d44efb04eab6ceb$var$handleIgnoreCase(code, result);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$addOptimizedIdxToResult, \"addOptimizedIdxToResult\");\nfunction $1d44efb04eab6ceb$var$handleIgnoreCase(code, result) {\n    const char = String.fromCharCode(code);\n    const upperChar = char.toUpperCase();\n    if (upperChar !== char) {\n        const optimizedCharIdx = $1d44efb04eab6ceb$var$charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n        result[optimizedCharIdx] = optimizedCharIdx;\n    } else {\n        const lowerChar = char.toLowerCase();\n        if (lowerChar !== char) {\n            const optimizedCharIdx = $1d44efb04eab6ceb$var$charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\n            result[optimizedCharIdx] = optimizedCharIdx;\n        }\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$handleIgnoreCase, \"handleIgnoreCase\");\nfunction $1d44efb04eab6ceb$var$findCode(setNode, targetCharCodes) {\n    return (0, $76RTQ.find_default)(setNode.value, (codeOrRange)=>{\n        if (typeof codeOrRange === \"number\") return (0, $76RTQ.includes_default)(targetCharCodes, codeOrRange);\n        else {\n            const range = codeOrRange;\n            return (0, $76RTQ.find_default)(targetCharCodes, (targetCode)=>range.from <= targetCode && targetCode <= range.to) !== void 0;\n        }\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findCode, \"findCode\");\nfunction $1d44efb04eab6ceb$var$isWholeOptional(ast) {\n    const quantifier = ast.quantifier;\n    if (quantifier && quantifier.atLeast === 0) return true;\n    if (!ast.value) return false;\n    return (0, $2266r.isArray_default)(ast.value) ? (0, $76RTQ.every_default)(ast.value, $1d44efb04eab6ceb$var$isWholeOptional) : $1d44efb04eab6ceb$var$isWholeOptional(ast.value);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isWholeOptional, \"isWholeOptional\");\nvar $1d44efb04eab6ceb$var$CharCodeFinder = class extends $1d44efb04eab6ceb$var$BaseRegExpVisitor {\n    static{\n        (0, $7xxrv.__name)(this, \"CharCodeFinder\");\n    }\n    constructor(targetCharCodes){\n        super();\n        this.targetCharCodes = targetCharCodes;\n        this.found = false;\n    }\n    visitChildren(node) {\n        if (this.found === true) return;\n        switch(node.type){\n            case \"Lookahead\":\n                this.visitLookahead(node);\n                return;\n            case \"NegativeLookahead\":\n                this.visitNegativeLookahead(node);\n                return;\n        }\n        super.visitChildren(node);\n    }\n    visitCharacter(node) {\n        if ((0, $76RTQ.includes_default)(this.targetCharCodes, node.value)) this.found = true;\n    }\n    visitSet(node) {\n        if (node.complement) {\n            if ($1d44efb04eab6ceb$var$findCode(node, this.targetCharCodes) === void 0) this.found = true;\n        } else if ($1d44efb04eab6ceb$var$findCode(node, this.targetCharCodes) !== void 0) this.found = true;\n    }\n};\nfunction $1d44efb04eab6ceb$var$canMatchCharCode(charCodes, pattern) {\n    if (pattern instanceof RegExp) {\n        const ast = $1d44efb04eab6ceb$var$getRegExpAst(pattern);\n        const charCodeFinder = new $1d44efb04eab6ceb$var$CharCodeFinder(charCodes);\n        charCodeFinder.visit(ast);\n        return charCodeFinder.found;\n    } else return (0, $76RTQ.find_default)(pattern, (char)=>{\n        return (0, $76RTQ.includes_default)(charCodes, char.charCodeAt(0));\n    }) !== void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$canMatchCharCode, \"canMatchCharCode\");\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/scan/lexer.js\nvar $1d44efb04eab6ceb$var$PATTERN = \"PATTERN\";\nvar $1d44efb04eab6ceb$var$DEFAULT_MODE = \"defaultMode\";\nvar $1d44efb04eab6ceb$var$MODES = \"modes\";\nvar $1d44efb04eab6ceb$var$SUPPORT_STICKY = typeof new RegExp(\"(?:)\").sticky === \"boolean\";\nfunction $1d44efb04eab6ceb$var$analyzeTokenTypes(tokenTypes, options) {\n    options = (0, $76RTQ.defaults_default)(options, {\n        useSticky: $1d44efb04eab6ceb$var$SUPPORT_STICKY,\n        debug: false,\n        safeMode: false,\n        positionTracking: \"full\",\n        lineTerminatorCharacters: [\n            \"\\r\",\n            \"\\n\"\n        ],\n        tracer: /* @__PURE__ */ (0, $7xxrv.__name)((msg, action)=>action(), \"tracer\")\n    });\n    const tracer = options.tracer;\n    tracer(\"initCharCodeToOptimizedIndexMap\", ()=>{\n        $1d44efb04eab6ceb$var$initCharCodeToOptimizedIndexMap();\n    });\n    let onlyRelevantTypes;\n    tracer(\"Reject Lexer.NA\", ()=>{\n        onlyRelevantTypes = (0, $76RTQ.reject_default)(tokenTypes, (currType)=>{\n            return currType[$1d44efb04eab6ceb$var$PATTERN] === $1d44efb04eab6ceb$var$Lexer.NA;\n        });\n    });\n    let hasCustom = false;\n    let allTransformedPatterns;\n    tracer(\"Transform Patterns\", ()=>{\n        hasCustom = false;\n        allTransformedPatterns = (0, $76RTQ.map_default)(onlyRelevantTypes, (currType)=>{\n            const currPattern = currType[$1d44efb04eab6ceb$var$PATTERN];\n            if ((0, $76RTQ.isRegExp_default)(currPattern)) {\n                const regExpSource = currPattern.source;\n                if (regExpSource.length === 1 && // only these regExp meta characters which can appear in a length one regExp\n                regExpSource !== \"^\" && regExpSource !== \"$\" && regExpSource !== \".\" && !currPattern.ignoreCase) return regExpSource;\n                else if (regExpSource.length === 2 && regExpSource[0] === \"\\\\\" && // not a meta character\n                !(0, $76RTQ.includes_default)([\n                    \"d\",\n                    \"D\",\n                    \"s\",\n                    \"S\",\n                    \"t\",\n                    \"r\",\n                    \"n\",\n                    \"t\",\n                    \"0\",\n                    \"c\",\n                    \"b\",\n                    \"B\",\n                    \"f\",\n                    \"v\",\n                    \"w\",\n                    \"W\"\n                ], regExpSource[1])) return regExpSource[1];\n                else return options.useSticky ? $1d44efb04eab6ceb$var$addStickyFlag(currPattern) : $1d44efb04eab6ceb$var$addStartOfInput(currPattern);\n            } else if ((0, $2266r.isFunction_default)(currPattern)) {\n                hasCustom = true;\n                return {\n                    exec: currPattern\n                };\n            } else if (typeof currPattern === \"object\") {\n                hasCustom = true;\n                return currPattern;\n            } else if (typeof currPattern === \"string\") {\n                if (currPattern.length === 1) return currPattern;\n                else {\n                    const escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n                    const wrappedRegExp = new RegExp(escapedRegExpString);\n                    return options.useSticky ? $1d44efb04eab6ceb$var$addStickyFlag(wrappedRegExp) : $1d44efb04eab6ceb$var$addStartOfInput(wrappedRegExp);\n                }\n            } else throw Error(\"non exhaustive match\");\n        });\n    });\n    let patternIdxToType;\n    let patternIdxToGroup;\n    let patternIdxToLongerAltIdxArr;\n    let patternIdxToPushMode;\n    let patternIdxToPopMode;\n    tracer(\"misc mapping\", ()=>{\n        patternIdxToType = (0, $76RTQ.map_default)(onlyRelevantTypes, (currType)=>currType.tokenTypeIdx);\n        patternIdxToGroup = (0, $76RTQ.map_default)(onlyRelevantTypes, (clazz)=>{\n            const groupName = clazz.GROUP;\n            if (groupName === $1d44efb04eab6ceb$var$Lexer.SKIPPED) return void 0;\n            else if ((0, $76RTQ.isString_default)(groupName)) return groupName;\n            else if ((0, $76RTQ.isUndefined_default)(groupName)) return false;\n            else throw Error(\"non exhaustive match\");\n        });\n        patternIdxToLongerAltIdxArr = (0, $76RTQ.map_default)(onlyRelevantTypes, (clazz)=>{\n            const longerAltType = clazz.LONGER_ALT;\n            if (longerAltType) {\n                const longerAltIdxArr = (0, $2266r.isArray_default)(longerAltType) ? (0, $76RTQ.map_default)(longerAltType, (type)=>(0, $76RTQ.indexOf_default)(onlyRelevantTypes, type)) : [\n                    (0, $76RTQ.indexOf_default)(onlyRelevantTypes, longerAltType)\n                ];\n                return longerAltIdxArr;\n            }\n        });\n        patternIdxToPushMode = (0, $76RTQ.map_default)(onlyRelevantTypes, (clazz)=>clazz.PUSH_MODE);\n        patternIdxToPopMode = (0, $76RTQ.map_default)(onlyRelevantTypes, (clazz)=>(0, $76RTQ.has_default)(clazz, \"POP_MODE\"));\n    });\n    let patternIdxToCanLineTerminator;\n    tracer(\"Line Terminator Handling\", ()=>{\n        const lineTerminatorCharCodes = $1d44efb04eab6ceb$var$getCharCodes(options.lineTerminatorCharacters);\n        patternIdxToCanLineTerminator = (0, $76RTQ.map_default)(onlyRelevantTypes, (tokType)=>false);\n        if (options.positionTracking !== \"onlyOffset\") patternIdxToCanLineTerminator = (0, $76RTQ.map_default)(onlyRelevantTypes, (tokType)=>{\n            if ((0, $76RTQ.has_default)(tokType, \"LINE_BREAKS\")) return !!tokType.LINE_BREAKS;\n            else return $1d44efb04eab6ceb$var$checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false && $1d44efb04eab6ceb$var$canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n        });\n    });\n    let patternIdxToIsCustom;\n    let patternIdxToShort;\n    let emptyGroups;\n    let patternIdxToConfig;\n    tracer(\"Misc Mapping #2\", ()=>{\n        patternIdxToIsCustom = (0, $76RTQ.map_default)(onlyRelevantTypes, $1d44efb04eab6ceb$var$isCustomPattern);\n        patternIdxToShort = (0, $76RTQ.map_default)(allTransformedPatterns, $1d44efb04eab6ceb$var$isShortPattern);\n        emptyGroups = (0, $76RTQ.reduce_default)(onlyRelevantTypes, (acc, clazz)=>{\n            const groupName = clazz.GROUP;\n            if ((0, $76RTQ.isString_default)(groupName) && !(groupName === $1d44efb04eab6ceb$var$Lexer.SKIPPED)) acc[groupName] = [];\n            return acc;\n        }, {});\n        patternIdxToConfig = (0, $76RTQ.map_default)(allTransformedPatterns, (x, idx)=>{\n            return {\n                pattern: allTransformedPatterns[idx],\n                longerAlt: patternIdxToLongerAltIdxArr[idx],\n                canLineTerminator: patternIdxToCanLineTerminator[idx],\n                isCustom: patternIdxToIsCustom[idx],\n                short: patternIdxToShort[idx],\n                group: patternIdxToGroup[idx],\n                push: patternIdxToPushMode[idx],\n                pop: patternIdxToPopMode[idx],\n                tokenTypeIdx: patternIdxToType[idx],\n                tokenType: onlyRelevantTypes[idx]\n            };\n        });\n    });\n    let canBeOptimized = true;\n    let charCodeToPatternIdxToConfig = [];\n    if (!options.safeMode) tracer(\"First Char Optimization\", ()=>{\n        charCodeToPatternIdxToConfig = (0, $76RTQ.reduce_default)(onlyRelevantTypes, (result, currTokType, idx)=>{\n            if (typeof currTokType.PATTERN === \"string\") {\n                const charCode = currTokType.PATTERN.charCodeAt(0);\n                const optimizedIdx = $1d44efb04eab6ceb$var$charCodeToOptimizedIndex(charCode);\n                $1d44efb04eab6ceb$var$addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n            } else if ((0, $2266r.isArray_default)(currTokType.START_CHARS_HINT)) {\n                let lastOptimizedIdx;\n                (0, $76RTQ.forEach_default)(currTokType.START_CHARS_HINT, (charOrInt)=>{\n                    const charCode = typeof charOrInt === \"string\" ? charOrInt.charCodeAt(0) : charOrInt;\n                    const currOptimizedIdx = $1d44efb04eab6ceb$var$charCodeToOptimizedIndex(charCode);\n                    if (lastOptimizedIdx !== currOptimizedIdx) {\n                        lastOptimizedIdx = currOptimizedIdx;\n                        $1d44efb04eab6ceb$var$addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n                    }\n                });\n            } else if ((0, $76RTQ.isRegExp_default)(currTokType.PATTERN)) {\n                if (currTokType.PATTERN.unicode) {\n                    canBeOptimized = false;\n                    if (options.ensureOptimizations) $1d44efb04eab6ceb$var$PRINT_ERROR(`${$1d44efb04eab6ceb$var$failedOptimizationPrefixMsg}\tUnable to analyze < ${currTokType.PATTERN.toString()} > pattern.\n\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`);\n                } else {\n                    const optimizedCodes = $1d44efb04eab6ceb$var$getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);\n                    if ((0, $f34bP.isEmpty_default)(optimizedCodes)) canBeOptimized = false;\n                    (0, $76RTQ.forEach_default)(optimizedCodes, (code)=>{\n                        $1d44efb04eab6ceb$var$addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n                    });\n                }\n            } else {\n                if (options.ensureOptimizations) $1d44efb04eab6ceb$var$PRINT_ERROR(`${$1d44efb04eab6ceb$var$failedOptimizationPrefixMsg}\tTokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`);\n                canBeOptimized = false;\n            }\n            return result;\n        }, []);\n    });\n    return {\n        emptyGroups: emptyGroups,\n        patternIdxToConfig: patternIdxToConfig,\n        charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n        hasCustom: hasCustom,\n        canBeOptimized: canBeOptimized\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$analyzeTokenTypes, \"analyzeTokenTypes\");\nfunction $1d44efb04eab6ceb$var$validatePatterns(tokenTypes, validModesNames) {\n    let errors = [];\n    const missingResult = $1d44efb04eab6ceb$var$findMissingPatterns(tokenTypes);\n    errors = errors.concat(missingResult.errors);\n    const invalidResult = $1d44efb04eab6ceb$var$findInvalidPatterns(missingResult.valid);\n    const validTokenTypes = invalidResult.valid;\n    errors = errors.concat(invalidResult.errors);\n    errors = errors.concat($1d44efb04eab6ceb$var$validateRegExpPattern(validTokenTypes));\n    errors = errors.concat($1d44efb04eab6ceb$var$findInvalidGroupType(validTokenTypes));\n    errors = errors.concat($1d44efb04eab6ceb$var$findModesThatDoNotExist(validTokenTypes, validModesNames));\n    errors = errors.concat($1d44efb04eab6ceb$var$findUnreachablePatterns(validTokenTypes));\n    return errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$validatePatterns, \"validatePatterns\");\nfunction $1d44efb04eab6ceb$var$validateRegExpPattern(tokenTypes) {\n    let errors = [];\n    const withRegExpPatterns = (0, $76RTQ.filter_default)(tokenTypes, (currTokType)=>(0, $76RTQ.isRegExp_default)(currTokType[$1d44efb04eab6ceb$var$PATTERN]));\n    errors = errors.concat($1d44efb04eab6ceb$var$findEndOfInputAnchor(withRegExpPatterns));\n    errors = errors.concat($1d44efb04eab6ceb$var$findStartOfInputAnchor(withRegExpPatterns));\n    errors = errors.concat($1d44efb04eab6ceb$var$findUnsupportedFlags(withRegExpPatterns));\n    errors = errors.concat($1d44efb04eab6ceb$var$findDuplicatePatterns(withRegExpPatterns));\n    errors = errors.concat($1d44efb04eab6ceb$var$findEmptyMatchRegExps(withRegExpPatterns));\n    return errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$validateRegExpPattern, \"validateRegExpPattern\");\nfunction $1d44efb04eab6ceb$var$findMissingPatterns(tokenTypes) {\n    const tokenTypesWithMissingPattern = (0, $76RTQ.filter_default)(tokenTypes, (currType)=>{\n        return !(0, $76RTQ.has_default)(currType, $1d44efb04eab6ceb$var$PATTERN);\n    });\n    const errors = (0, $76RTQ.map_default)(tokenTypesWithMissingPattern, (currType)=>{\n        return {\n            message: \"Token Type: ->\" + currType.name + \"<- missing static 'PATTERN' property\",\n            type: $1d44efb04eab6ceb$var$LexerDefinitionErrorType.MISSING_PATTERN,\n            tokenTypes: [\n                currType\n            ]\n        };\n    });\n    const valid = (0, $76RTQ.difference_default)(tokenTypes, tokenTypesWithMissingPattern);\n    return {\n        errors: errors,\n        valid: valid\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findMissingPatterns, \"findMissingPatterns\");\nfunction $1d44efb04eab6ceb$var$findInvalidPatterns(tokenTypes) {\n    const tokenTypesWithInvalidPattern = (0, $76RTQ.filter_default)(tokenTypes, (currType)=>{\n        const pattern = currType[$1d44efb04eab6ceb$var$PATTERN];\n        return !(0, $76RTQ.isRegExp_default)(pattern) && !(0, $2266r.isFunction_default)(pattern) && !(0, $76RTQ.has_default)(pattern, \"exec\") && !(0, $76RTQ.isString_default)(pattern);\n    });\n    const errors = (0, $76RTQ.map_default)(tokenTypesWithInvalidPattern, (currType)=>{\n        return {\n            message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n            type: $1d44efb04eab6ceb$var$LexerDefinitionErrorType.INVALID_PATTERN,\n            tokenTypes: [\n                currType\n            ]\n        };\n    });\n    const valid = (0, $76RTQ.difference_default)(tokenTypes, tokenTypesWithInvalidPattern);\n    return {\n        errors: errors,\n        valid: valid\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findInvalidPatterns, \"findInvalidPatterns\");\nvar $1d44efb04eab6ceb$var$end_of_input = /[^\\\\][$]/;\nfunction $1d44efb04eab6ceb$var$findEndOfInputAnchor(tokenTypes) {\n    class EndAnchorFinder extends $1d44efb04eab6ceb$var$BaseRegExpVisitor {\n        static{\n            (0, $7xxrv.__name)(this, \"EndAnchorFinder\");\n        }\n        constructor(){\n            super(...arguments);\n            this.found = false;\n        }\n        visitEndAnchor(node) {\n            this.found = true;\n        }\n    }\n    const invalidRegex = (0, $76RTQ.filter_default)(tokenTypes, (currType)=>{\n        const pattern = currType.PATTERN;\n        try {\n            const regexpAst = $1d44efb04eab6ceb$var$getRegExpAst(pattern);\n            const endAnchorVisitor = new EndAnchorFinder();\n            endAnchorVisitor.visit(regexpAst);\n            return endAnchorVisitor.found;\n        } catch (e) {\n            return $1d44efb04eab6ceb$var$end_of_input.test(pattern.source);\n        }\n    });\n    const errors = (0, $76RTQ.map_default)(invalidRegex, (currType)=>{\n        return {\n            message: \"Unexpected RegExp Anchor Error:\\n\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.\",\n            type: $1d44efb04eab6ceb$var$LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n            tokenTypes: [\n                currType\n            ]\n        };\n    });\n    return errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findEndOfInputAnchor, \"findEndOfInputAnchor\");\nfunction $1d44efb04eab6ceb$var$findEmptyMatchRegExps(tokenTypes) {\n    const matchesEmptyString = (0, $76RTQ.filter_default)(tokenTypes, (currType)=>{\n        const pattern = currType.PATTERN;\n        return pattern.test(\"\");\n    });\n    const errors = (0, $76RTQ.map_default)(matchesEmptyString, (currType)=>{\n        return {\n            message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' must not match an empty string\",\n            type: $1d44efb04eab6ceb$var$LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n            tokenTypes: [\n                currType\n            ]\n        };\n    });\n    return errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findEmptyMatchRegExps, \"findEmptyMatchRegExps\");\nvar $1d44efb04eab6ceb$var$start_of_input = /[^\\\\[][\\^]|^\\^/;\nfunction $1d44efb04eab6ceb$var$findStartOfInputAnchor(tokenTypes) {\n    class StartAnchorFinder extends $1d44efb04eab6ceb$var$BaseRegExpVisitor {\n        static{\n            (0, $7xxrv.__name)(this, \"StartAnchorFinder\");\n        }\n        constructor(){\n            super(...arguments);\n            this.found = false;\n        }\n        visitStartAnchor(node) {\n            this.found = true;\n        }\n    }\n    const invalidRegex = (0, $76RTQ.filter_default)(tokenTypes, (currType)=>{\n        const pattern = currType.PATTERN;\n        try {\n            const regexpAst = $1d44efb04eab6ceb$var$getRegExpAst(pattern);\n            const startAnchorVisitor = new StartAnchorFinder();\n            startAnchorVisitor.visit(regexpAst);\n            return startAnchorVisitor.found;\n        } catch (e) {\n            return $1d44efb04eab6ceb$var$start_of_input.test(pattern.source);\n        }\n    });\n    const errors = (0, $76RTQ.map_default)(invalidRegex, (currType)=>{\n        return {\n            message: \"Unexpected RegExp Anchor Error:\\n\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.\",\n            type: $1d44efb04eab6ceb$var$LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n            tokenTypes: [\n                currType\n            ]\n        };\n    });\n    return errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findStartOfInputAnchor, \"findStartOfInputAnchor\");\nfunction $1d44efb04eab6ceb$var$findUnsupportedFlags(tokenTypes) {\n    const invalidFlags = (0, $76RTQ.filter_default)(tokenTypes, (currType)=>{\n        const pattern = currType[$1d44efb04eab6ceb$var$PATTERN];\n        return pattern instanceof RegExp && (pattern.multiline || pattern.global);\n    });\n    const errors = (0, $76RTQ.map_default)(invalidFlags, (currType)=>{\n        return {\n            message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n            type: $1d44efb04eab6ceb$var$LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n            tokenTypes: [\n                currType\n            ]\n        };\n    });\n    return errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findUnsupportedFlags, \"findUnsupportedFlags\");\nfunction $1d44efb04eab6ceb$var$findDuplicatePatterns(tokenTypes) {\n    const found = [];\n    let identicalPatterns = (0, $76RTQ.map_default)(tokenTypes, (outerType)=>{\n        return (0, $76RTQ.reduce_default)(tokenTypes, (result, innerType)=>{\n            if (outerType.PATTERN.source === innerType.PATTERN.source && !(0, $76RTQ.includes_default)(found, innerType) && innerType.PATTERN !== $1d44efb04eab6ceb$var$Lexer.NA) {\n                found.push(innerType);\n                result.push(innerType);\n                return result;\n            }\n            return result;\n        }, []);\n    });\n    identicalPatterns = (0, $76RTQ.compact_default)(identicalPatterns);\n    const duplicatePatterns = (0, $76RTQ.filter_default)(identicalPatterns, (currIdenticalSet)=>{\n        return currIdenticalSet.length > 1;\n    });\n    const errors = (0, $76RTQ.map_default)(duplicatePatterns, (setOfIdentical)=>{\n        const tokenTypeNames = (0, $76RTQ.map_default)(setOfIdentical, (currType)=>{\n            return currType.name;\n        });\n        const dupPatternSrc = (0, $76RTQ.head_default)(setOfIdentical).PATTERN;\n        return {\n            message: `The same RegExp pattern ->${dupPatternSrc}<-has been used in all of the following Token Types: ${tokenTypeNames.join(\", \")} <-`,\n            type: $1d44efb04eab6ceb$var$LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n            tokenTypes: setOfIdentical\n        };\n    });\n    return errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findDuplicatePatterns, \"findDuplicatePatterns\");\nfunction $1d44efb04eab6ceb$var$findInvalidGroupType(tokenTypes) {\n    const invalidTypes = (0, $76RTQ.filter_default)(tokenTypes, (clazz)=>{\n        if (!(0, $76RTQ.has_default)(clazz, \"GROUP\")) return false;\n        const group = clazz.GROUP;\n        return group !== $1d44efb04eab6ceb$var$Lexer.SKIPPED && group !== $1d44efb04eab6ceb$var$Lexer.NA && !(0, $76RTQ.isString_default)(group);\n    });\n    const errors = (0, $76RTQ.map_default)(invalidTypes, (currType)=>{\n        return {\n            message: \"Token Type: ->\" + currType.name + \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n            type: $1d44efb04eab6ceb$var$LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n            tokenTypes: [\n                currType\n            ]\n        };\n    });\n    return errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findInvalidGroupType, \"findInvalidGroupType\");\nfunction $1d44efb04eab6ceb$var$findModesThatDoNotExist(tokenTypes, validModes) {\n    const invalidModes = (0, $76RTQ.filter_default)(tokenTypes, (clazz)=>{\n        return clazz.PUSH_MODE !== void 0 && !(0, $76RTQ.includes_default)(validModes, clazz.PUSH_MODE);\n    });\n    const errors = (0, $76RTQ.map_default)(invalidModes, (tokType)=>{\n        const msg = `Token Type: ->${tokType.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-which does not exist`;\n        return {\n            message: msg,\n            type: $1d44efb04eab6ceb$var$LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n            tokenTypes: [\n                tokType\n            ]\n        };\n    });\n    return errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findModesThatDoNotExist, \"findModesThatDoNotExist\");\nfunction $1d44efb04eab6ceb$var$findUnreachablePatterns(tokenTypes) {\n    const errors = [];\n    const canBeTested = (0, $76RTQ.reduce_default)(tokenTypes, (result, tokType, idx)=>{\n        const pattern = tokType.PATTERN;\n        if (pattern === $1d44efb04eab6ceb$var$Lexer.NA) return result;\n        if ((0, $76RTQ.isString_default)(pattern)) result.push({\n            str: pattern,\n            idx: idx,\n            tokenType: tokType\n        });\n        else if ((0, $76RTQ.isRegExp_default)(pattern) && $1d44efb04eab6ceb$var$noMetaChar(pattern)) result.push({\n            str: pattern.source,\n            idx: idx,\n            tokenType: tokType\n        });\n        return result;\n    }, []);\n    (0, $76RTQ.forEach_default)(tokenTypes, (tokType, testIdx)=>{\n        (0, $76RTQ.forEach_default)(canBeTested, ({ str: str, idx: idx, tokenType: tokenType })=>{\n            if (testIdx < idx && $1d44efb04eab6ceb$var$testTokenType(str, tokType.PATTERN)) {\n                const msg = `Token: ->${tokenType.name}<- can never be matched.\nBecause it appears AFTER the Token Type ->${tokType.name}<-in the lexer's definition.\nSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;\n                errors.push({\n                    message: msg,\n                    type: $1d44efb04eab6ceb$var$LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n                    tokenTypes: [\n                        tokType,\n                        tokenType\n                    ]\n                });\n            }\n        });\n    });\n    return errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$findUnreachablePatterns, \"findUnreachablePatterns\");\nfunction $1d44efb04eab6ceb$var$testTokenType(str, pattern) {\n    if ((0, $76RTQ.isRegExp_default)(pattern)) {\n        const regExpArray = pattern.exec(str);\n        return regExpArray !== null && regExpArray.index === 0;\n    } else if ((0, $2266r.isFunction_default)(pattern)) return pattern(str, 0, [], {});\n    else if ((0, $76RTQ.has_default)(pattern, \"exec\")) return pattern.exec(str, 0, [], {});\n    else if (typeof pattern === \"string\") return pattern === str;\n    else throw Error(\"non exhaustive match\");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$testTokenType, \"testTokenType\");\nfunction $1d44efb04eab6ceb$var$noMetaChar(regExp) {\n    const metaChars = [\n        \".\",\n        \"\\\\\",\n        \"[\",\n        \"]\",\n        \"|\",\n        \"^\",\n        \"$\",\n        \"(\",\n        \")\",\n        \"?\",\n        \"*\",\n        \"+\",\n        \"{\"\n    ];\n    return (0, $76RTQ.find_default)(metaChars, (char)=>regExp.source.indexOf(char) !== -1) === void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$noMetaChar, \"noMetaChar\");\nfunction $1d44efb04eab6ceb$var$addStartOfInput(pattern) {\n    const flags = pattern.ignoreCase ? \"i\" : \"\";\n    return new RegExp(`^(?:${pattern.source})`, flags);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$addStartOfInput, \"addStartOfInput\");\nfunction $1d44efb04eab6ceb$var$addStickyFlag(pattern) {\n    const flags = pattern.ignoreCase ? \"iy\" : \"y\";\n    return new RegExp(`${pattern.source}`, flags);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$addStickyFlag, \"addStickyFlag\");\nfunction $1d44efb04eab6ceb$var$performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    const errors = [];\n    if (!(0, $76RTQ.has_default)(lexerDefinition, $1d44efb04eab6ceb$var$DEFAULT_MODE)) errors.push({\n        message: \"A MultiMode Lexer cannot be initialized without a <\" + $1d44efb04eab6ceb$var$DEFAULT_MODE + \"> property in its definition\\n\",\n        type: $1d44efb04eab6ceb$var$LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n    });\n    if (!(0, $76RTQ.has_default)(lexerDefinition, $1d44efb04eab6ceb$var$MODES)) errors.push({\n        message: \"A MultiMode Lexer cannot be initialized without a <\" + $1d44efb04eab6ceb$var$MODES + \"> property in its definition\\n\",\n        type: $1d44efb04eab6ceb$var$LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n    });\n    if ((0, $76RTQ.has_default)(lexerDefinition, $1d44efb04eab6ceb$var$MODES) && (0, $76RTQ.has_default)(lexerDefinition, $1d44efb04eab6ceb$var$DEFAULT_MODE) && !(0, $76RTQ.has_default)(lexerDefinition.modes, lexerDefinition.defaultMode)) errors.push({\n        message: `A MultiMode Lexer cannot be initialized with a ${$1d44efb04eab6ceb$var$DEFAULT_MODE}: <${lexerDefinition.defaultMode}>which does not exist\n`,\n        type: $1d44efb04eab6ceb$var$LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n    });\n    if ((0, $76RTQ.has_default)(lexerDefinition, $1d44efb04eab6ceb$var$MODES)) (0, $76RTQ.forEach_default)(lexerDefinition.modes, (currModeValue, currModeName)=>{\n        (0, $76RTQ.forEach_default)(currModeValue, (currTokType, currIdx)=>{\n            if ((0, $76RTQ.isUndefined_default)(currTokType)) errors.push({\n                message: `A Lexer cannot be initialized using an undefined Token Type. Mode:<${currModeName}> at index: <${currIdx}>\n`,\n                type: $1d44efb04eab6ceb$var$LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n            });\n            else if ((0, $76RTQ.has_default)(currTokType, \"LONGER_ALT\")) {\n                const longerAlt = (0, $2266r.isArray_default)(currTokType.LONGER_ALT) ? currTokType.LONGER_ALT : [\n                    currTokType.LONGER_ALT\n                ];\n                (0, $76RTQ.forEach_default)(longerAlt, (currLongerAlt)=>{\n                    if (!(0, $76RTQ.isUndefined_default)(currLongerAlt) && !(0, $76RTQ.includes_default)(currModeValue, currLongerAlt)) errors.push({\n                        message: `A MultiMode Lexer cannot be initialized with a longer_alt <${currLongerAlt.name}> on token <${currTokType.name}> outside of mode <${currModeName}>\n`,\n                        type: $1d44efb04eab6ceb$var$LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\n                    });\n                });\n            }\n        });\n    });\n    return errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$performRuntimeChecks, \"performRuntimeChecks\");\nfunction $1d44efb04eab6ceb$var$performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    const warnings = [];\n    let hasAnyLineBreak = false;\n    const allTokenTypes = (0, $76RTQ.compact_default)((0, $76RTQ.flatten_default)((0, $76RTQ.values_default)(lexerDefinition.modes)));\n    const concreteTokenTypes = (0, $76RTQ.reject_default)(allTokenTypes, (currType)=>currType[$1d44efb04eab6ceb$var$PATTERN] === $1d44efb04eab6ceb$var$Lexer.NA);\n    const terminatorCharCodes = $1d44efb04eab6ceb$var$getCharCodes(lineTerminatorCharacters);\n    if (trackLines) (0, $76RTQ.forEach_default)(concreteTokenTypes, (tokType)=>{\n        const currIssue = $1d44efb04eab6ceb$var$checkLineBreaksIssues(tokType, terminatorCharCodes);\n        if (currIssue !== false) {\n            const message = $1d44efb04eab6ceb$var$buildLineBreakIssueMessage(tokType, currIssue);\n            const warningDescriptor = {\n                message: message,\n                type: currIssue.issue,\n                tokenType: tokType\n            };\n            warnings.push(warningDescriptor);\n        } else {\n            if ((0, $76RTQ.has_default)(tokType, \"LINE_BREAKS\")) {\n                if (tokType.LINE_BREAKS === true) hasAnyLineBreak = true;\n            } else if ($1d44efb04eab6ceb$var$canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) hasAnyLineBreak = true;\n        }\n    });\n    if (trackLines && !hasAnyLineBreak) warnings.push({\n        message: \"Warning: No LINE_BREAKS Found.\\n\tThis Lexer has been defined to track line and column information,\\n\tBut none of the Token Types can be identified as matching a line terminator.\\n\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\tfor details.\",\n        type: $1d44efb04eab6ceb$var$LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS\n    });\n    return warnings;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$performWarningRuntimeChecks, \"performWarningRuntimeChecks\");\nfunction $1d44efb04eab6ceb$var$cloneEmptyGroups(emptyGroups) {\n    const clonedResult = {};\n    const groupKeys = (0, $76RTQ.keys_default)(emptyGroups);\n    (0, $76RTQ.forEach_default)(groupKeys, (currKey)=>{\n        const currGroupValue = emptyGroups[currKey];\n        if ((0, $2266r.isArray_default)(currGroupValue)) clonedResult[currKey] = [];\n        else throw Error(\"non exhaustive match\");\n    });\n    return clonedResult;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$cloneEmptyGroups, \"cloneEmptyGroups\");\nfunction $1d44efb04eab6ceb$var$isCustomPattern(tokenType) {\n    const pattern = tokenType.PATTERN;\n    if ((0, $76RTQ.isRegExp_default)(pattern)) return false;\n    else if ((0, $2266r.isFunction_default)(pattern)) return true;\n    else if ((0, $76RTQ.has_default)(pattern, \"exec\")) return true;\n    else if ((0, $76RTQ.isString_default)(pattern)) return false;\n    else throw Error(\"non exhaustive match\");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isCustomPattern, \"isCustomPattern\");\nfunction $1d44efb04eab6ceb$var$isShortPattern(pattern) {\n    if ((0, $76RTQ.isString_default)(pattern) && pattern.length === 1) return pattern.charCodeAt(0);\n    else return false;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isShortPattern, \"isShortPattern\");\nvar $1d44efb04eab6ceb$var$LineTerminatorOptimizedTester = {\n    // implements /\\n|\\r\\n?/g.test\n    test: /* @__PURE__ */ (0, $7xxrv.__name)(function(text) {\n        const len = text.length;\n        for(let i = this.lastIndex; i < len; i++){\n            const c = text.charCodeAt(i);\n            if (c === 10) {\n                this.lastIndex = i + 1;\n                return true;\n            } else if (c === 13) {\n                if (text.charCodeAt(i + 1) === 10) this.lastIndex = i + 2;\n                else this.lastIndex = i + 1;\n                return true;\n            }\n        }\n        return false;\n    }, \"test\"),\n    lastIndex: 0\n};\nfunction $1d44efb04eab6ceb$var$checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n    if ((0, $76RTQ.has_default)(tokType, \"LINE_BREAKS\")) return false;\n    else {\n        if ((0, $76RTQ.isRegExp_default)(tokType.PATTERN)) {\n            try {\n                $1d44efb04eab6ceb$var$canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n            } catch (e) {\n                return {\n                    issue: $1d44efb04eab6ceb$var$LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n                    errMsg: e.message\n                };\n            }\n            return false;\n        } else if ((0, $76RTQ.isString_default)(tokType.PATTERN)) return false;\n        else if ($1d44efb04eab6ceb$var$isCustomPattern(tokType)) return {\n            issue: $1d44efb04eab6ceb$var$LexerDefinitionErrorType.CUSTOM_LINE_BREAK\n        };\n        else throw Error(\"non exhaustive match\");\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$checkLineBreaksIssues, \"checkLineBreaksIssues\");\nfunction $1d44efb04eab6ceb$var$buildLineBreakIssueMessage(tokType, details) {\n    if (details.issue === $1d44efb04eab6ceb$var$LexerDefinitionErrorType.IDENTIFY_TERMINATOR) return `Warning: unable to identify line terminator usage in pattern.\n\tThe problem is in the <${tokType.name}> Token Type\n\t Root cause: ${details.errMsg}.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR`;\n    else if (details.issue === $1d44efb04eab6ceb$var$LexerDefinitionErrorType.CUSTOM_LINE_BREAK) return `Warning: A Custom Token Pattern should specify the <line_breaks> option.\n\tThe problem is in the <${tokType.name}> Token Type\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK`;\n    else throw Error(\"non exhaustive match\");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildLineBreakIssueMessage, \"buildLineBreakIssueMessage\");\nfunction $1d44efb04eab6ceb$var$getCharCodes(charsOrCodes) {\n    const charCodes = (0, $76RTQ.map_default)(charsOrCodes, (numOrString)=>{\n        if ((0, $76RTQ.isString_default)(numOrString)) return numOrString.charCodeAt(0);\n        else return numOrString;\n    });\n    return charCodes;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getCharCodes, \"getCharCodes\");\nfunction $1d44efb04eab6ceb$var$addToMapOfArrays(map, key, value) {\n    if (map[key] === void 0) map[key] = [\n        value\n    ];\n    else map[key].push(value);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$addToMapOfArrays, \"addToMapOfArrays\");\nvar $1d44efb04eab6ceb$var$minOptimizationVal = 256;\nvar $1d44efb04eab6ceb$var$charCodeToOptimizedIdxMap = [];\nfunction $1d44efb04eab6ceb$var$charCodeToOptimizedIndex(charCode) {\n    return charCode < $1d44efb04eab6ceb$var$minOptimizationVal ? charCode : $1d44efb04eab6ceb$var$charCodeToOptimizedIdxMap[charCode];\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$charCodeToOptimizedIndex, \"charCodeToOptimizedIndex\");\nfunction $1d44efb04eab6ceb$var$initCharCodeToOptimizedIndexMap() {\n    if ((0, $f34bP.isEmpty_default)($1d44efb04eab6ceb$var$charCodeToOptimizedIdxMap)) {\n        $1d44efb04eab6ceb$var$charCodeToOptimizedIdxMap = new Array(65536);\n        for(let i = 0; i < 65536; i++)$1d44efb04eab6ceb$var$charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$initCharCodeToOptimizedIndexMap, \"initCharCodeToOptimizedIndexMap\");\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/scan/tokens.js\nfunction $1d44efb04eab6ceb$var$tokenStructuredMatcher(tokInstance, tokConstructor) {\n    const instanceType = tokInstance.tokenTypeIdx;\n    if (instanceType === tokConstructor.tokenTypeIdx) return true;\n    else return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$tokenStructuredMatcher, \"tokenStructuredMatcher\");\nfunction $1d44efb04eab6ceb$var$tokenStructuredMatcherNoCategories(token, tokType) {\n    return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$tokenStructuredMatcherNoCategories, \"tokenStructuredMatcherNoCategories\");\nvar $1d44efb04eab6ceb$var$tokenShortNameIdx = 1;\nvar $1d44efb04eab6ceb$var$tokenIdxToClass = {};\nfunction $1d44efb04eab6ceb$var$augmentTokenTypes(tokenTypes) {\n    const tokenTypesAndParents = $1d44efb04eab6ceb$var$expandCategories(tokenTypes);\n    $1d44efb04eab6ceb$var$assignTokenDefaultProps(tokenTypesAndParents);\n    $1d44efb04eab6ceb$var$assignCategoriesMapProp(tokenTypesAndParents);\n    $1d44efb04eab6ceb$var$assignCategoriesTokensProp(tokenTypesAndParents);\n    (0, $76RTQ.forEach_default)(tokenTypesAndParents, (tokType)=>{\n        tokType.isParent = tokType.categoryMatches.length > 0;\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$augmentTokenTypes, \"augmentTokenTypes\");\nfunction $1d44efb04eab6ceb$var$expandCategories(tokenTypes) {\n    let result = (0, $76RTQ.clone_default)(tokenTypes);\n    let categories = tokenTypes;\n    let searching = true;\n    while(searching){\n        categories = (0, $76RTQ.compact_default)((0, $76RTQ.flatten_default)((0, $76RTQ.map_default)(categories, (currTokType)=>currTokType.CATEGORIES)));\n        const newCategories = (0, $76RTQ.difference_default)(categories, result);\n        result = result.concat(newCategories);\n        if ((0, $f34bP.isEmpty_default)(newCategories)) searching = false;\n        else categories = newCategories;\n    }\n    return result;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$expandCategories, \"expandCategories\");\nfunction $1d44efb04eab6ceb$var$assignTokenDefaultProps(tokenTypes) {\n    (0, $76RTQ.forEach_default)(tokenTypes, (currTokType)=>{\n        if (!$1d44efb04eab6ceb$var$hasShortKeyProperty(currTokType)) {\n            $1d44efb04eab6ceb$var$tokenIdxToClass[$1d44efb04eab6ceb$var$tokenShortNameIdx] = currTokType;\n            currTokType.tokenTypeIdx = $1d44efb04eab6ceb$var$tokenShortNameIdx++;\n        }\n        if ($1d44efb04eab6ceb$var$hasCategoriesProperty(currTokType) && !(0, $2266r.isArray_default)(currTokType.CATEGORIES)) currTokType.CATEGORIES = [\n            currTokType.CATEGORIES\n        ];\n        if (!$1d44efb04eab6ceb$var$hasCategoriesProperty(currTokType)) currTokType.CATEGORIES = [];\n        if (!$1d44efb04eab6ceb$var$hasExtendingTokensTypesProperty(currTokType)) currTokType.categoryMatches = [];\n        if (!$1d44efb04eab6ceb$var$hasExtendingTokensTypesMapProperty(currTokType)) currTokType.categoryMatchesMap = {};\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$assignTokenDefaultProps, \"assignTokenDefaultProps\");\nfunction $1d44efb04eab6ceb$var$assignCategoriesTokensProp(tokenTypes) {\n    (0, $76RTQ.forEach_default)(tokenTypes, (currTokType)=>{\n        currTokType.categoryMatches = [];\n        (0, $76RTQ.forEach_default)(currTokType.categoryMatchesMap, (val, key)=>{\n            currTokType.categoryMatches.push($1d44efb04eab6ceb$var$tokenIdxToClass[key].tokenTypeIdx);\n        });\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$assignCategoriesTokensProp, \"assignCategoriesTokensProp\");\nfunction $1d44efb04eab6ceb$var$assignCategoriesMapProp(tokenTypes) {\n    (0, $76RTQ.forEach_default)(tokenTypes, (currTokType)=>{\n        $1d44efb04eab6ceb$var$singleAssignCategoriesToksMap([], currTokType);\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$assignCategoriesMapProp, \"assignCategoriesMapProp\");\nfunction $1d44efb04eab6ceb$var$singleAssignCategoriesToksMap(path, nextNode) {\n    (0, $76RTQ.forEach_default)(path, (pathNode)=>{\n        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n    });\n    (0, $76RTQ.forEach_default)(nextNode.CATEGORIES, (nextCategory)=>{\n        const newPath = path.concat(nextNode);\n        if (!(0, $76RTQ.includes_default)(newPath, nextCategory)) $1d44efb04eab6ceb$var$singleAssignCategoriesToksMap(newPath, nextCategory);\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$singleAssignCategoriesToksMap, \"singleAssignCategoriesToksMap\");\nfunction $1d44efb04eab6ceb$var$hasShortKeyProperty(tokType) {\n    return (0, $76RTQ.has_default)(tokType, \"tokenTypeIdx\");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$hasShortKeyProperty, \"hasShortKeyProperty\");\nfunction $1d44efb04eab6ceb$var$hasCategoriesProperty(tokType) {\n    return (0, $76RTQ.has_default)(tokType, \"CATEGORIES\");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$hasCategoriesProperty, \"hasCategoriesProperty\");\nfunction $1d44efb04eab6ceb$var$hasExtendingTokensTypesProperty(tokType) {\n    return (0, $76RTQ.has_default)(tokType, \"categoryMatches\");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$hasExtendingTokensTypesProperty, \"hasExtendingTokensTypesProperty\");\nfunction $1d44efb04eab6ceb$var$hasExtendingTokensTypesMapProperty(tokType) {\n    return (0, $76RTQ.has_default)(tokType, \"categoryMatchesMap\");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$hasExtendingTokensTypesMapProperty, \"hasExtendingTokensTypesMapProperty\");\nfunction $1d44efb04eab6ceb$var$isTokenType(tokType) {\n    return (0, $76RTQ.has_default)(tokType, \"tokenTypeIdx\");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isTokenType, \"isTokenType\");\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/scan/lexer_errors_public.js\nvar $1d44efb04eab6ceb$var$defaultLexerErrorProvider = {\n    buildUnableToPopLexerModeMessage (token) {\n        return `Unable to pop Lexer Mode after encountering Token ->${token.image}<- The Mode Stack is empty`;\n    },\n    buildUnexpectedCharactersMessage (fullText, startOffset, length, line, column) {\n        return `unexpected character: ->${fullText.charAt(startOffset)}<- at offset: ${startOffset}, skipped ${length} characters.`;\n    }\n};\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/scan/lexer_public.js\nvar $1d44efb04eab6ceb$var$LexerDefinitionErrorType;\n(function(LexerDefinitionErrorType2) {\n    LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n    LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n    LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n    LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n    LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n    LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n    LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n    LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n    LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n    LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n    LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n    LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n    LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n    LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\"] = 17] = \"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\";\n})($1d44efb04eab6ceb$var$LexerDefinitionErrorType || ($1d44efb04eab6ceb$var$LexerDefinitionErrorType = {}));\nvar $1d44efb04eab6ceb$var$DEFAULT_LEXER_CONFIG = {\n    deferDefinitionErrorsHandling: false,\n    positionTracking: \"full\",\n    lineTerminatorsPattern: /\\n|\\r\\n?/g,\n    lineTerminatorCharacters: [\n        \"\\n\",\n        \"\\r\"\n    ],\n    ensureOptimizations: false,\n    safeMode: false,\n    errorMessageProvider: $1d44efb04eab6ceb$var$defaultLexerErrorProvider,\n    traceInitPerf: false,\n    skipValidations: false,\n    recoveryEnabled: true\n};\nObject.freeze($1d44efb04eab6ceb$var$DEFAULT_LEXER_CONFIG);\nvar $1d44efb04eab6ceb$var$Lexer = class {\n    static{\n        (0, $7xxrv.__name)(this, \"Lexer\");\n    }\n    constructor(lexerDefinition, config = $1d44efb04eab6ceb$var$DEFAULT_LEXER_CONFIG){\n        this.lexerDefinition = lexerDefinition;\n        this.lexerDefinitionErrors = [];\n        this.lexerDefinitionWarning = [];\n        this.patternIdxToConfig = {};\n        this.charCodeToPatternIdxToConfig = {};\n        this.modes = [];\n        this.emptyGroups = {};\n        this.trackStartLines = true;\n        this.trackEndLines = true;\n        this.hasCustom = false;\n        this.canModeBeOptimized = {};\n        this.TRACE_INIT = (phaseDesc, phaseImpl)=>{\n            if (this.traceInitPerf === true) {\n                this.traceInitIndent++;\n                const indent = new Array(this.traceInitIndent + 1).join(\"\t\");\n                if (this.traceInitIndent < this.traceInitMaxIdent) console.log(`${indent}--> <${phaseDesc}>`);\n                const { time: time, value: value } = $1d44efb04eab6ceb$var$timer(phaseImpl);\n                const traceMethod = time > 10 ? console.warn : console.log;\n                if (this.traceInitIndent < this.traceInitMaxIdent) traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n                this.traceInitIndent--;\n                return value;\n            } else return phaseImpl();\n        };\n        if (typeof config === \"boolean\") throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\na boolean 2nd argument is no longer supported\");\n        this.config = (0, $76RTQ.assign_default)({}, $1d44efb04eab6ceb$var$DEFAULT_LEXER_CONFIG, config);\n        const traceInitVal = this.config.traceInitPerf;\n        if (traceInitVal === true) {\n            this.traceInitMaxIdent = Infinity;\n            this.traceInitPerf = true;\n        } else if (typeof traceInitVal === \"number\") {\n            this.traceInitMaxIdent = traceInitVal;\n            this.traceInitPerf = true;\n        }\n        this.traceInitIndent = -1;\n        this.TRACE_INIT(\"Lexer Constructor\", ()=>{\n            let actualDefinition;\n            let hasOnlySingleMode = true;\n            this.TRACE_INIT(\"Lexer Config handling\", ()=>{\n                if (this.config.lineTerminatorsPattern === $1d44efb04eab6ceb$var$DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) this.config.lineTerminatorsPattern = $1d44efb04eab6ceb$var$LineTerminatorOptimizedTester;\n                else {\n                    if (this.config.lineTerminatorCharacters === $1d44efb04eab6ceb$var$DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n                }\n                if (config.safeMode && config.ensureOptimizations) throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n                this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking);\n                this.trackEndLines = /full/i.test(this.config.positionTracking);\n                if ((0, $2266r.isArray_default)(lexerDefinition)) actualDefinition = {\n                    modes: {\n                        defaultMode: (0, $76RTQ.clone_default)(lexerDefinition)\n                    },\n                    defaultMode: $1d44efb04eab6ceb$var$DEFAULT_MODE\n                };\n                else {\n                    hasOnlySingleMode = false;\n                    actualDefinition = (0, $76RTQ.clone_default)(lexerDefinition);\n                }\n            });\n            if (this.config.skipValidations === false) {\n                this.TRACE_INIT(\"performRuntimeChecks\", ()=>{\n                    this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat($1d44efb04eab6ceb$var$performRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));\n                });\n                this.TRACE_INIT(\"performWarningRuntimeChecks\", ()=>{\n                    this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat($1d44efb04eab6ceb$var$performWarningRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));\n                });\n            }\n            actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};\n            (0, $76RTQ.forEach_default)(actualDefinition.modes, (currModeValue, currModeName)=>{\n                actualDefinition.modes[currModeName] = (0, $76RTQ.reject_default)(currModeValue, (currTokType)=>(0, $76RTQ.isUndefined_default)(currTokType));\n            });\n            const allModeNames = (0, $76RTQ.keys_default)(actualDefinition.modes);\n            (0, $76RTQ.forEach_default)(actualDefinition.modes, (currModDef, currModName)=>{\n                this.TRACE_INIT(`Mode: <${currModName}> processing`, ()=>{\n                    this.modes.push(currModName);\n                    if (this.config.skipValidations === false) this.TRACE_INIT(`validatePatterns`, ()=>{\n                        this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat($1d44efb04eab6ceb$var$validatePatterns(currModDef, allModeNames));\n                    });\n                    if ((0, $f34bP.isEmpty_default)(this.lexerDefinitionErrors)) {\n                        $1d44efb04eab6ceb$var$augmentTokenTypes(currModDef);\n                        let currAnalyzeResult;\n                        this.TRACE_INIT(`analyzeTokenTypes`, ()=>{\n                            currAnalyzeResult = $1d44efb04eab6ceb$var$analyzeTokenTypes(currModDef, {\n                                lineTerminatorCharacters: this.config.lineTerminatorCharacters,\n                                positionTracking: config.positionTracking,\n                                ensureOptimizations: config.ensureOptimizations,\n                                safeMode: config.safeMode,\n                                tracer: this.TRACE_INIT\n                            });\n                        });\n                        this.patternIdxToConfig[currModName] = currAnalyzeResult.patternIdxToConfig;\n                        this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult.charCodeToPatternIdxToConfig;\n                        this.emptyGroups = (0, $76RTQ.assign_default)({}, this.emptyGroups, currAnalyzeResult.emptyGroups);\n                        this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom;\n                        this.canModeBeOptimized[currModName] = currAnalyzeResult.canBeOptimized;\n                    }\n                });\n            });\n            this.defaultMode = actualDefinition.defaultMode;\n            if (!(0, $f34bP.isEmpty_default)(this.lexerDefinitionErrors) && !this.config.deferDefinitionErrorsHandling) {\n                const allErrMessages = (0, $76RTQ.map_default)(this.lexerDefinitionErrors, (error)=>{\n                    return error.message;\n                });\n                const allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n                throw new Error(\"Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n            }\n            (0, $76RTQ.forEach_default)(this.lexerDefinitionWarning, (warningDescriptor)=>{\n                $1d44efb04eab6ceb$var$PRINT_WARNING(warningDescriptor.message);\n            });\n            this.TRACE_INIT(\"Choosing sub-methods implementations\", ()=>{\n                if ($1d44efb04eab6ceb$var$SUPPORT_STICKY) {\n                    this.chopInput = (0, $2266r.identity_default);\n                    this.match = this.matchWithTest;\n                } else {\n                    this.updateLastIndex = (0, $76RTQ.noop_default);\n                    this.match = this.matchWithExec;\n                }\n                if (hasOnlySingleMode) this.handleModes = (0, $76RTQ.noop_default);\n                if (this.trackStartLines === false) this.computeNewColumn = (0, $2266r.identity_default);\n                if (this.trackEndLines === false) this.updateTokenEndLineColumnLocation = (0, $76RTQ.noop_default);\n                if (/full/i.test(this.config.positionTracking)) this.createTokenInstance = this.createFullToken;\n                else if (/onlyStart/i.test(this.config.positionTracking)) this.createTokenInstance = this.createStartOnlyToken;\n                else if (/onlyOffset/i.test(this.config.positionTracking)) this.createTokenInstance = this.createOffsetOnlyToken;\n                else throw Error(`Invalid <positionTracking> config option: \"${this.config.positionTracking}\"`);\n                if (this.hasCustom) {\n                    this.addToken = this.addTokenUsingPush;\n                    this.handlePayload = this.handlePayloadWithCustom;\n                } else {\n                    this.addToken = this.addTokenUsingMemberAccess;\n                    this.handlePayload = this.handlePayloadNoCustom;\n                }\n            });\n            this.TRACE_INIT(\"Failed Optimization Warnings\", ()=>{\n                const unOptimizedModes = (0, $76RTQ.reduce_default)(this.canModeBeOptimized, (cannotBeOptimized, canBeOptimized, modeName)=>{\n                    if (canBeOptimized === false) cannotBeOptimized.push(modeName);\n                    return cannotBeOptimized;\n                }, []);\n                if (config.ensureOptimizations && !(0, $f34bP.isEmpty_default)(unOptimizedModes)) throw Error(`Lexer Modes: < ${unOptimizedModes.join(\", \")} > cannot be optimized.\n\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n\t Or inspect the console log for details on how to resolve these issues.`);\n            });\n            this.TRACE_INIT(\"clearRegExpParserCache\", ()=>{\n                $1d44efb04eab6ceb$var$clearRegExpParserCache();\n            });\n            this.TRACE_INIT(\"toFastProperties\", ()=>{\n                $1d44efb04eab6ceb$var$toFastProperties(this);\n            });\n        });\n    }\n    tokenize(text, initialMode = this.defaultMode) {\n        if (!(0, $f34bP.isEmpty_default)(this.lexerDefinitionErrors)) {\n            const allErrMessages = (0, $76RTQ.map_default)(this.lexerDefinitionErrors, (error)=>{\n                return error.message;\n            });\n            const allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n            throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n        }\n        return this.tokenizeInternal(text, initialMode);\n    }\n    // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n    // This is intentional due to performance considerations.\n    // this method also used quite a bit of `!` none null assertions because it is too optimized\n    // for `tsc` to always understand it is \"safe\"\n    tokenizeInternal(text, initialMode) {\n        let i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n        const orgText = text;\n        const orgLength = orgText.length;\n        let offset = 0;\n        let matchedTokensIndex = 0;\n        const guessedNumberOfTokens = this.hasCustom ? 0 : Math.floor(text.length / 10);\n        const matchedTokens = new Array(guessedNumberOfTokens);\n        const errors = [];\n        let line = this.trackStartLines ? 1 : void 0;\n        let column = this.trackStartLines ? 1 : void 0;\n        const groups = $1d44efb04eab6ceb$var$cloneEmptyGroups(this.emptyGroups);\n        const trackLines = this.trackStartLines;\n        const lineTerminatorPattern = this.config.lineTerminatorsPattern;\n        let currModePatternsLength = 0;\n        let patternIdxToConfig = [];\n        let currCharCodeToPatternIdxToConfig = [];\n        const modeStack = [];\n        const emptyArray = [];\n        Object.freeze(emptyArray);\n        let getPossiblePatterns;\n        function getPossiblePatternsSlow() {\n            return patternIdxToConfig;\n        }\n        (0, $7xxrv.__name)(getPossiblePatternsSlow, \"getPossiblePatternsSlow\");\n        function getPossiblePatternsOptimized(charCode) {\n            const optimizedCharIdx = $1d44efb04eab6ceb$var$charCodeToOptimizedIndex(charCode);\n            const possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n            if (possiblePatterns === void 0) return emptyArray;\n            else return possiblePatterns;\n        }\n        (0, $7xxrv.__name)(getPossiblePatternsOptimized, \"getPossiblePatternsOptimized\");\n        const pop_mode = /* @__PURE__ */ (0, $7xxrv.__name)((popToken)=>{\n            if (modeStack.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n            // So no error should occur.\n            popToken.tokenType.PUSH_MODE === void 0) {\n                const msg2 = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n                errors.push({\n                    offset: popToken.startOffset,\n                    line: popToken.startLine,\n                    column: popToken.startColumn,\n                    length: popToken.image.length,\n                    message: msg2\n                });\n            } else {\n                modeStack.pop();\n                const newMode = (0, $76RTQ.last_default)(modeStack);\n                patternIdxToConfig = this.patternIdxToConfig[newMode];\n                currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];\n                currModePatternsLength = patternIdxToConfig.length;\n                const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n                if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) getPossiblePatterns = getPossiblePatternsOptimized;\n                else getPossiblePatterns = getPossiblePatternsSlow;\n            }\n        }, \"pop_mode\");\n        function push_mode(newMode) {\n            modeStack.push(newMode);\n            currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];\n            patternIdxToConfig = this.patternIdxToConfig[newMode];\n            currModePatternsLength = patternIdxToConfig.length;\n            currModePatternsLength = patternIdxToConfig.length;\n            const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) getPossiblePatterns = getPossiblePatternsOptimized;\n            else getPossiblePatterns = getPossiblePatternsSlow;\n        }\n        (0, $7xxrv.__name)(push_mode, \"push_mode\");\n        push_mode.call(this, initialMode);\n        let currConfig;\n        const recoveryEnabled = this.config.recoveryEnabled;\n        while(offset < orgLength){\n            matchedImage = null;\n            const nextCharCode = orgText.charCodeAt(offset);\n            const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n            const chosenPatternsLength = chosenPatternIdxToConfig.length;\n            for(i = 0; i < chosenPatternsLength; i++){\n                currConfig = chosenPatternIdxToConfig[i];\n                const currPattern = currConfig.pattern;\n                payload = null;\n                const singleCharCode = currConfig.short;\n                if (singleCharCode !== false) {\n                    if (nextCharCode === singleCharCode) matchedImage = currPattern;\n                } else if (currConfig.isCustom === true) {\n                    match = currPattern.exec(orgText, offset, matchedTokens, groups);\n                    if (match !== null) {\n                        matchedImage = match[0];\n                        if (match.payload !== void 0) payload = match.payload;\n                    } else matchedImage = null;\n                } else {\n                    this.updateLastIndex(currPattern, offset);\n                    matchedImage = this.match(currPattern, text, offset);\n                }\n                if (matchedImage !== null) {\n                    longerAlt = currConfig.longerAlt;\n                    if (longerAlt !== void 0) {\n                        const longerAltLength = longerAlt.length;\n                        for(k = 0; k < longerAltLength; k++){\n                            const longerAltConfig = patternIdxToConfig[longerAlt[k]];\n                            const longerAltPattern = longerAltConfig.pattern;\n                            altPayload = null;\n                            if (longerAltConfig.isCustom === true) {\n                                match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n                                if (match !== null) {\n                                    matchAltImage = match[0];\n                                    if (match.payload !== void 0) altPayload = match.payload;\n                                } else matchAltImage = null;\n                            } else {\n                                this.updateLastIndex(longerAltPattern, offset);\n                                matchAltImage = this.match(longerAltPattern, text, offset);\n                            }\n                            if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                                matchedImage = matchAltImage;\n                                payload = altPayload;\n                                currConfig = longerAltConfig;\n                                break;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            if (matchedImage !== null) {\n                imageLength = matchedImage.length;\n                group = currConfig.group;\n                if (group !== void 0) {\n                    tokType = currConfig.tokenTypeIdx;\n                    newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n                    this.handlePayload(newToken, payload);\n                    if (group === false) matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n                    else groups[group].push(newToken);\n                }\n                text = this.chopInput(text, imageLength);\n                offset = offset + imageLength;\n                column = this.computeNewColumn(column, imageLength);\n                if (trackLines === true && currConfig.canLineTerminator === true) {\n                    let numOfLTsInMatch = 0;\n                    let foundTerminator;\n                    let lastLTEndOffset;\n                    lineTerminatorPattern.lastIndex = 0;\n                    do {\n                        foundTerminator = lineTerminatorPattern.test(matchedImage);\n                        if (foundTerminator === true) {\n                            lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n                            numOfLTsInMatch++;\n                        }\n                    }while (foundTerminator === true);\n                    if (numOfLTsInMatch !== 0) {\n                        line = line + numOfLTsInMatch;\n                        column = imageLength - lastLTEndOffset;\n                        this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n                    }\n                }\n                this.handleModes(currConfig, pop_mode, push_mode, newToken);\n            } else {\n                const errorStartOffset = offset;\n                const errorLine = line;\n                const errorColumn = column;\n                let foundResyncPoint = recoveryEnabled === false;\n                while(foundResyncPoint === false && offset < orgLength){\n                    text = this.chopInput(text, 1);\n                    offset++;\n                    for(j = 0; j < currModePatternsLength; j++){\n                        const currConfig2 = patternIdxToConfig[j];\n                        const currPattern = currConfig2.pattern;\n                        const singleCharCode = currConfig2.short;\n                        if (singleCharCode !== false) {\n                            if (orgText.charCodeAt(offset) === singleCharCode) foundResyncPoint = true;\n                        } else if (currConfig2.isCustom === true) foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n                        else {\n                            this.updateLastIndex(currPattern, offset);\n                            foundResyncPoint = currPattern.exec(text) !== null;\n                        }\n                        if (foundResyncPoint === true) break;\n                    }\n                }\n                errLength = offset - errorStartOffset;\n                column = this.computeNewColumn(column, errLength);\n                msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n                errors.push({\n                    offset: errorStartOffset,\n                    line: errorLine,\n                    column: errorColumn,\n                    length: errLength,\n                    message: msg\n                });\n                if (recoveryEnabled === false) break;\n            }\n        }\n        if (!this.hasCustom) matchedTokens.length = matchedTokensIndex;\n        return {\n            tokens: matchedTokens,\n            groups: groups,\n            errors: errors\n        };\n    }\n    handleModes(config, pop_mode, push_mode, newToken) {\n        if (config.pop === true) {\n            const pushMode = config.push;\n            pop_mode(newToken);\n            if (pushMode !== void 0) push_mode.call(this, pushMode);\n        } else if (config.push !== void 0) push_mode.call(this, config.push);\n    }\n    chopInput(text, length) {\n        return text.substring(length);\n    }\n    updateLastIndex(regExp, newLastIndex) {\n        regExp.lastIndex = newLastIndex;\n    }\n    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n    updateTokenEndLineColumnLocation(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n        let lastCharIsLT, fixForEndingInLT;\n        if (group !== void 0) {\n            lastCharIsLT = lastLTIdx === imageLength - 1;\n            fixForEndingInLT = lastCharIsLT ? -1 : 0;\n            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n                newToken.endLine = line + fixForEndingInLT;\n                newToken.endColumn = column - 1 + -fixForEndingInLT;\n            }\n        }\n    }\n    computeNewColumn(oldColumn, imageLength) {\n        return oldColumn + imageLength;\n    }\n    createOffsetOnlyToken(image, startOffset, tokenTypeIdx, tokenType) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    }\n    createStartOnlyToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            startLine: startLine,\n            startColumn: startColumn,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    }\n    createFullToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            endOffset: startOffset + imageLength - 1,\n            startLine: startLine,\n            endLine: startLine,\n            startColumn: startColumn,\n            endColumn: startColumn + imageLength - 1,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    }\n    addTokenUsingPush(tokenVector, index, tokenToAdd) {\n        tokenVector.push(tokenToAdd);\n        return index;\n    }\n    addTokenUsingMemberAccess(tokenVector, index, tokenToAdd) {\n        tokenVector[index] = tokenToAdd;\n        index++;\n        return index;\n    }\n    handlePayloadNoCustom(token, payload) {}\n    handlePayloadWithCustom(token, payload) {\n        if (payload !== null) token.payload = payload;\n    }\n    matchWithTest(pattern, text, offset) {\n        const found = pattern.test(text);\n        if (found === true) return text.substring(offset, pattern.lastIndex);\n        return null;\n    }\n    matchWithExec(pattern, text) {\n        const regExpArray = pattern.exec(text);\n        return regExpArray !== null ? regExpArray[0] : null;\n    }\n};\n$1d44efb04eab6ceb$var$Lexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\n$1d44efb04eab6ceb$var$Lexer.NA = /NOT_APPLICABLE/;\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/scan/tokens_public.js\nfunction $1d44efb04eab6ceb$var$tokenLabel2(tokType) {\n    if ($1d44efb04eab6ceb$var$hasTokenLabel2(tokType)) return tokType.LABEL;\n    else return tokType.name;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$tokenLabel2, \"tokenLabel\");\nfunction $1d44efb04eab6ceb$var$hasTokenLabel2(obj) {\n    return (0, $76RTQ.isString_default)(obj.LABEL) && obj.LABEL !== \"\";\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$hasTokenLabel2, \"hasTokenLabel\");\nvar $1d44efb04eab6ceb$var$PARENT = \"parent\";\nvar $1d44efb04eab6ceb$var$CATEGORIES = \"categories\";\nvar $1d44efb04eab6ceb$var$LABEL = \"label\";\nvar $1d44efb04eab6ceb$var$GROUP = \"group\";\nvar $1d44efb04eab6ceb$var$PUSH_MODE = \"push_mode\";\nvar $1d44efb04eab6ceb$var$POP_MODE = \"pop_mode\";\nvar $1d44efb04eab6ceb$var$LONGER_ALT = \"longer_alt\";\nvar $1d44efb04eab6ceb$var$LINE_BREAKS = \"line_breaks\";\nvar $1d44efb04eab6ceb$var$START_CHARS_HINT = \"start_chars_hint\";\nfunction $1d44efb04eab6ceb$var$createToken(config) {\n    return $1d44efb04eab6ceb$var$createTokenInternal(config);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$createToken, \"createToken\");\nfunction $1d44efb04eab6ceb$var$createTokenInternal(config) {\n    const pattern = config.pattern;\n    const tokenType = {};\n    tokenType.name = config.name;\n    if (!(0, $76RTQ.isUndefined_default)(pattern)) tokenType.PATTERN = pattern;\n    if ((0, $76RTQ.has_default)(config, $1d44efb04eab6ceb$var$PARENT)) throw \"The parent property is no longer supported.\\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.\";\n    if ((0, $76RTQ.has_default)(config, $1d44efb04eab6ceb$var$CATEGORIES)) tokenType.CATEGORIES = config[$1d44efb04eab6ceb$var$CATEGORIES];\n    $1d44efb04eab6ceb$var$augmentTokenTypes([\n        tokenType\n    ]);\n    if ((0, $76RTQ.has_default)(config, $1d44efb04eab6ceb$var$LABEL)) tokenType.LABEL = config[$1d44efb04eab6ceb$var$LABEL];\n    if ((0, $76RTQ.has_default)(config, $1d44efb04eab6ceb$var$GROUP)) tokenType.GROUP = config[$1d44efb04eab6ceb$var$GROUP];\n    if ((0, $76RTQ.has_default)(config, $1d44efb04eab6ceb$var$POP_MODE)) tokenType.POP_MODE = config[$1d44efb04eab6ceb$var$POP_MODE];\n    if ((0, $76RTQ.has_default)(config, $1d44efb04eab6ceb$var$PUSH_MODE)) tokenType.PUSH_MODE = config[$1d44efb04eab6ceb$var$PUSH_MODE];\n    if ((0, $76RTQ.has_default)(config, $1d44efb04eab6ceb$var$LONGER_ALT)) tokenType.LONGER_ALT = config[$1d44efb04eab6ceb$var$LONGER_ALT];\n    if ((0, $76RTQ.has_default)(config, $1d44efb04eab6ceb$var$LINE_BREAKS)) tokenType.LINE_BREAKS = config[$1d44efb04eab6ceb$var$LINE_BREAKS];\n    if ((0, $76RTQ.has_default)(config, $1d44efb04eab6ceb$var$START_CHARS_HINT)) tokenType.START_CHARS_HINT = config[$1d44efb04eab6ceb$var$START_CHARS_HINT];\n    return tokenType;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$createTokenInternal, \"createTokenInternal\");\nvar $1d44efb04eab6ceb$var$EOF = $1d44efb04eab6ceb$var$createToken({\n    name: \"EOF\",\n    pattern: $1d44efb04eab6ceb$var$Lexer.NA\n});\n$1d44efb04eab6ceb$var$augmentTokenTypes([\n    $1d44efb04eab6ceb$var$EOF\n]);\nfunction $1d44efb04eab6ceb$var$createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {\n    return {\n        image: image,\n        startOffset: startOffset,\n        endOffset: endOffset,\n        startLine: startLine,\n        endLine: endLine,\n        startColumn: startColumn,\n        endColumn: endColumn,\n        tokenTypeIdx: tokType.tokenTypeIdx,\n        tokenType: tokType\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$createTokenInstance, \"createTokenInstance\");\nfunction $1d44efb04eab6ceb$var$tokenMatcher(token, tokType) {\n    return $1d44efb04eab6ceb$var$tokenStructuredMatcher(token, tokType);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$tokenMatcher, \"tokenMatcher\");\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/errors_public.js\nvar $1d44efb04eab6ceb$var$defaultParserErrorProvider = {\n    buildMismatchTokenMessage ({ expected: expected, actual: actual, previous: previous, ruleName: ruleName }) {\n        const hasLabel = $1d44efb04eab6ceb$var$hasTokenLabel2(expected);\n        const expectedMsg = hasLabel ? `--> ${$1d44efb04eab6ceb$var$tokenLabel2(expected)} <--` : `token of type --> ${expected.name} <--`;\n        const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`;\n        return msg;\n    },\n    buildNotAllInputParsedMessage ({ firstRedundant: firstRedundant, ruleName: ruleName }) {\n        return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n    },\n    buildNoViableAltMessage ({ expectedPathsPerAlt: expectedPathsPerAlt, actual: actual, previous: previous, customUserDescription: customUserDescription, ruleName: ruleName }) {\n        const errPrefix = \"Expecting: \";\n        const actualText = (0, $76RTQ.head_default)(actual).image;\n        const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) return errPrefix + customUserDescription + errSuffix;\n        else {\n            const allLookAheadPaths = (0, $76RTQ.reduce_default)(expectedPathsPerAlt, (result, currAltPaths)=>result.concat(currAltPaths), []);\n            const nextValidTokenSequences = (0, $76RTQ.map_default)(allLookAheadPaths, (currPath)=>`[${(0, $76RTQ.map_default)(currPath, (currTokenType)=>$1d44efb04eab6ceb$var$tokenLabel2(currTokenType)).join(\", \")}]`);\n            const nextValidSequenceItems = (0, $76RTQ.map_default)(nextValidTokenSequences, (itemMsg, idx)=>`  ${idx + 1}. ${itemMsg}`);\n            const calculatedDescription = `one of these possible Token sequences:\n${nextValidSequenceItems.join(\"\\n\")}`;\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    },\n    buildEarlyExitMessage ({ expectedIterationPaths: expectedIterationPaths, actual: actual, customUserDescription: customUserDescription, ruleName: ruleName }) {\n        const errPrefix = \"Expecting: \";\n        const actualText = (0, $76RTQ.head_default)(actual).image;\n        const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) return errPrefix + customUserDescription + errSuffix;\n        else {\n            const nextValidTokenSequences = (0, $76RTQ.map_default)(expectedIterationPaths, (currPath)=>`[${(0, $76RTQ.map_default)(currPath, (currTokenType)=>$1d44efb04eab6ceb$var$tokenLabel2(currTokenType)).join(\",\")}]`);\n            const calculatedDescription = `expecting at least one iteration which starts with one of these possible Token sequences::\n  <${nextValidTokenSequences.join(\" ,\")}>`;\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    }\n};\nObject.freeze($1d44efb04eab6ceb$var$defaultParserErrorProvider);\nvar $1d44efb04eab6ceb$var$defaultGrammarResolverErrorProvider = {\n    buildRuleNotFoundError (topLevelRule, undefinedRule) {\n        const msg = \"Invalid grammar, reference to a rule which is not defined: ->\" + undefinedRule.nonTerminalName + \"<-\\ninside top level rule: ->\" + topLevelRule.name + \"<-\";\n        return msg;\n    }\n};\nvar $1d44efb04eab6ceb$var$defaultGrammarValidatorErrorProvider = {\n    buildDuplicateFoundError (topLevelRule, duplicateProds) {\n        function getExtraProductionArgument2(prod) {\n            if (prod instanceof $1d44efb04eab6ceb$var$Terminal) return prod.terminalType.name;\n            else if (prod instanceof $1d44efb04eab6ceb$var$NonTerminal) return prod.nonTerminalName;\n            else return \"\";\n        }\n        (0, $7xxrv.__name)(getExtraProductionArgument2, \"getExtraProductionArgument\");\n        const topLevelName = topLevelRule.name;\n        const duplicateProd = (0, $76RTQ.head_default)(duplicateProds);\n        const index = duplicateProd.idx;\n        const dslName = $1d44efb04eab6ceb$var$getProductionDslName(duplicateProd);\n        const extraArgument = getExtraProductionArgument2(duplicateProd);\n        const hasExplicitIndex = index > 0;\n        let msg = `->${dslName}${hasExplicitIndex ? index : \"\"}<- ${extraArgument ? `with argument: ->${extraArgument}<-` : \"\"}\n                  appears more than once (${duplicateProds.length} times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `;\n        msg = msg.replace(/[ \\t]+/g, \" \");\n        msg = msg.replace(/\\s\\s+/g, \"\\n\");\n        return msg;\n    },\n    buildNamespaceConflictError (rule) {\n        const errMsg = `Namespace conflict found in grammar.\nThe grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\nTo resolve this make sure each Terminal and Non-Terminal names are unique\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\nand Non-Terminal names start with a lower case letter.`;\n        return errMsg;\n    },\n    buildAlternationPrefixAmbiguityError (options) {\n        const pathMsg = (0, $76RTQ.map_default)(options.prefixPath, (currTok)=>$1d44efb04eab6ceb$var$tokenLabel2(currTok)).join(\", \");\n        const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        const errMsg = `Ambiguous alternatives: <${options.ambiguityIndices.join(\" ,\")}> due to common lookahead prefix\nin <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\n<${pathMsg}> may appears as a prefix path in all these alternatives.\nSee: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\nFor Further details.`;\n        return errMsg;\n    },\n    buildAlternationAmbiguityError (options) {\n        const pathMsg = (0, $76RTQ.map_default)(options.prefixPath, (currtok)=>$1d44efb04eab6ceb$var$tokenLabel2(currtok)).join(\", \");\n        const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\" ,\")}> in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\n<${pathMsg}> may appears as a prefix path in all these alternatives.\n`;\n        currMessage = currMessage + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\nFor Further details.`;\n        return currMessage;\n    },\n    buildEmptyRepetitionError (options) {\n        let dslName = $1d44efb04eab6ceb$var$getProductionDslName(options.repetition);\n        if (options.repetition.idx !== 0) dslName += options.repetition.idx;\n        const errMsg = `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\nThis could lead to an infinite loop.`;\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError (options) {\n        return \"deprecated\";\n    },\n    buildEmptyAlternationError (options) {\n        const errMsg = `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}> in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\nOnly the last alternative may be an empty alternative.`;\n        return errMsg;\n    },\n    buildTooManyAlternativesError (options) {\n        const errMsg = `An Alternation cannot have more than 256 alternatives:\n<OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\n has ${options.alternation.definition.length + 1} alternatives.`;\n        return errMsg;\n    },\n    buildLeftRecursionError (options) {\n        const ruleName = options.topLevelRule.name;\n        const pathNames = (0, $76RTQ.map_default)(options.leftRecursionPath, (currRule)=>currRule.name);\n        const leftRecursivePath = `${ruleName} --> ${pathNames.concat([\n            ruleName\n        ]).join(\" --> \")}`;\n        const errMsg = `Left Recursion found in grammar.\nrule: <${ruleName}> can be invoked from itself (directly or indirectly)\nwithout consuming any Tokens. The grammar path that causes this is: \n ${leftRecursivePath}\n To fix this refactor your grammar to remove the left recursion.\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError (options) {\n        return \"deprecated\";\n    },\n    buildDuplicateRuleNameError (options) {\n        let ruleName;\n        if (options.topLevelRule instanceof $1d44efb04eab6ceb$var$Rule) ruleName = options.topLevelRule.name;\n        else ruleName = options.topLevelRule;\n        const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`;\n        return errMsg;\n    }\n};\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/grammar/resolver.js\nfunction $1d44efb04eab6ceb$var$resolveGrammar(topLevels, errMsgProvider) {\n    const refResolver = new $1d44efb04eab6ceb$var$GastRefResolverVisitor(topLevels, errMsgProvider);\n    refResolver.resolveRefs();\n    return refResolver.errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$resolveGrammar, \"resolveGrammar\");\nvar $1d44efb04eab6ceb$var$GastRefResolverVisitor = class extends $1d44efb04eab6ceb$var$GAstVisitor {\n    static{\n        (0, $7xxrv.__name)(this, \"GastRefResolverVisitor\");\n    }\n    constructor(nameToTopRule, errMsgProvider){\n        super();\n        this.nameToTopRule = nameToTopRule;\n        this.errMsgProvider = errMsgProvider;\n        this.errors = [];\n    }\n    resolveRefs() {\n        (0, $76RTQ.forEach_default)((0, $76RTQ.values_default)(this.nameToTopRule), (prod)=>{\n            this.currTopLevel = prod;\n            prod.accept(this);\n        });\n    }\n    visitNonTerminal(node) {\n        const ref = this.nameToTopRule[node.nonTerminalName];\n        if (!ref) {\n            const msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);\n            this.errors.push({\n                message: msg,\n                type: $1d44efb04eab6ceb$var$ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n                ruleName: this.currTopLevel.name,\n                unresolvedRefName: node.nonTerminalName\n            });\n        } else node.referencedRule = ref;\n    }\n};\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/grammar/interpreter.js\nvar $1d44efb04eab6ceb$var$AbstractNextPossibleTokensWalker = class extends $1d44efb04eab6ceb$var$RestWalker {\n    static{\n        (0, $7xxrv.__name)(this, \"AbstractNextPossibleTokensWalker\");\n    }\n    constructor(topProd, path){\n        super();\n        this.topProd = topProd;\n        this.path = path;\n        this.possibleTokTypes = [];\n        this.nextProductionName = \"\";\n        this.nextProductionOccurrence = 0;\n        this.found = false;\n        this.isAtEndOfPath = false;\n    }\n    startWalking() {\n        this.found = false;\n        if (this.path.ruleStack[0] !== this.topProd.name) throw Error(\"The path does not start with the walker's top Rule!\");\n        this.ruleStack = (0, $76RTQ.clone_default)(this.path.ruleStack).reverse();\n        this.occurrenceStack = (0, $76RTQ.clone_default)(this.path.occurrenceStack).reverse();\n        this.ruleStack.pop();\n        this.occurrenceStack.pop();\n        this.updateExpectedNext();\n        this.walk(this.topProd);\n        return this.possibleTokTypes;\n    }\n    walk(prod, prevRest = []) {\n        if (!this.found) super.walk(prod, prevRest);\n    }\n    walkProdRef(refProd, currRest, prevRest) {\n        if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {\n            const fullRest = currRest.concat(prevRest);\n            this.updateExpectedNext();\n            this.walk(refProd.referencedRule, fullRest);\n        }\n    }\n    updateExpectedNext() {\n        if ((0, $f34bP.isEmpty_default)(this.ruleStack)) {\n            this.nextProductionName = \"\";\n            this.nextProductionOccurrence = 0;\n            this.isAtEndOfPath = true;\n        } else {\n            this.nextProductionName = this.ruleStack.pop();\n            this.nextProductionOccurrence = this.occurrenceStack.pop();\n        }\n    }\n};\nvar $1d44efb04eab6ceb$var$NextAfterTokenWalker = class extends $1d44efb04eab6ceb$var$AbstractNextPossibleTokensWalker {\n    static{\n        (0, $7xxrv.__name)(this, \"NextAfterTokenWalker\");\n    }\n    constructor(topProd, path){\n        super(topProd, path);\n        this.path = path;\n        this.nextTerminalName = \"\";\n        this.nextTerminalOccurrence = 0;\n        this.nextTerminalName = this.path.lastTok.name;\n        this.nextTerminalOccurrence = this.path.lastTokOccurrence;\n    }\n    walkTerminal(terminal, currRest, prevRest) {\n        if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {\n            const fullRest = currRest.concat(prevRest);\n            const restProd = new $1d44efb04eab6ceb$var$Alternative({\n                definition: fullRest\n            });\n            this.possibleTokTypes = $1d44efb04eab6ceb$var$first(restProd);\n            this.found = true;\n        }\n    }\n};\nvar $1d44efb04eab6ceb$var$AbstractNextTerminalAfterProductionWalker = class extends $1d44efb04eab6ceb$var$RestWalker {\n    static{\n        (0, $7xxrv.__name)(this, \"AbstractNextTerminalAfterProductionWalker\");\n    }\n    constructor(topRule, occurrence){\n        super();\n        this.topRule = topRule;\n        this.occurrence = occurrence;\n        this.result = {\n            token: void 0,\n            occurrence: void 0,\n            isEndOfRule: void 0\n        };\n    }\n    startWalking() {\n        this.walk(this.topRule);\n        return this.result;\n    }\n};\nvar $1d44efb04eab6ceb$var$NextTerminalAfterManyWalker = class extends $1d44efb04eab6ceb$var$AbstractNextTerminalAfterProductionWalker {\n    static{\n        (0, $7xxrv.__name)(this, \"NextTerminalAfterManyWalker\");\n    }\n    walkMany(manyProd, currRest, prevRest) {\n        if (manyProd.idx === this.occurrence) {\n            const firstAfterMany = (0, $76RTQ.head_default)(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterMany === void 0;\n            if (firstAfterMany instanceof $1d44efb04eab6ceb$var$Terminal) {\n                this.result.token = firstAfterMany.terminalType;\n                this.result.occurrence = firstAfterMany.idx;\n            }\n        } else super.walkMany(manyProd, currRest, prevRest);\n    }\n};\nvar $1d44efb04eab6ceb$var$NextTerminalAfterManySepWalker = class extends $1d44efb04eab6ceb$var$AbstractNextTerminalAfterProductionWalker {\n    static{\n        (0, $7xxrv.__name)(this, \"NextTerminalAfterManySepWalker\");\n    }\n    walkManySep(manySepProd, currRest, prevRest) {\n        if (manySepProd.idx === this.occurrence) {\n            const firstAfterManySep = (0, $76RTQ.head_default)(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterManySep === void 0;\n            if (firstAfterManySep instanceof $1d44efb04eab6ceb$var$Terminal) {\n                this.result.token = firstAfterManySep.terminalType;\n                this.result.occurrence = firstAfterManySep.idx;\n            }\n        } else super.walkManySep(manySepProd, currRest, prevRest);\n    }\n};\nvar $1d44efb04eab6ceb$var$NextTerminalAfterAtLeastOneWalker = class extends $1d44efb04eab6ceb$var$AbstractNextTerminalAfterProductionWalker {\n    static{\n        (0, $7xxrv.__name)(this, \"NextTerminalAfterAtLeastOneWalker\");\n    }\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n        if (atLeastOneProd.idx === this.occurrence) {\n            const firstAfterAtLeastOne = (0, $76RTQ.head_default)(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterAtLeastOne === void 0;\n            if (firstAfterAtLeastOne instanceof $1d44efb04eab6ceb$var$Terminal) {\n                this.result.token = firstAfterAtLeastOne.terminalType;\n                this.result.occurrence = firstAfterAtLeastOne.idx;\n            }\n        } else super.walkAtLeastOne(atLeastOneProd, currRest, prevRest);\n    }\n};\nvar $1d44efb04eab6ceb$var$NextTerminalAfterAtLeastOneSepWalker = class extends $1d44efb04eab6ceb$var$AbstractNextTerminalAfterProductionWalker {\n    static{\n        (0, $7xxrv.__name)(this, \"NextTerminalAfterAtLeastOneSepWalker\");\n    }\n    walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest) {\n        if (atleastOneSepProd.idx === this.occurrence) {\n            const firstAfterfirstAfterAtLeastOneSep = (0, $76RTQ.head_default)(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === void 0;\n            if (firstAfterfirstAfterAtLeastOneSep instanceof $1d44efb04eab6ceb$var$Terminal) {\n                this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n            }\n        } else super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest);\n    }\n};\nfunction $1d44efb04eab6ceb$var$possiblePathsFrom(targetDef, maxLength, currPath = []) {\n    currPath = (0, $76RTQ.clone_default)(currPath);\n    let result = [];\n    let i = 0;\n    function remainingPathWith(nextDef) {\n        return nextDef.concat((0, $76RTQ.drop_default)(targetDef, i + 1));\n    }\n    (0, $7xxrv.__name)(remainingPathWith, \"remainingPathWith\");\n    function getAlternativesForProd(definition) {\n        const alternatives = $1d44efb04eab6ceb$var$possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n        return result.concat(alternatives);\n    }\n    (0, $7xxrv.__name)(getAlternativesForProd, \"getAlternativesForProd\");\n    while(currPath.length < maxLength && i < targetDef.length){\n        const prod = targetDef[i];\n        if (prod instanceof $1d44efb04eab6ceb$var$Alternative) return getAlternativesForProd(prod.definition);\n        else if (prod instanceof $1d44efb04eab6ceb$var$NonTerminal) return getAlternativesForProd(prod.definition);\n        else if (prod instanceof $1d44efb04eab6ceb$var$Option) result = getAlternativesForProd(prod.definition);\n        else if (prod instanceof $1d44efb04eab6ceb$var$RepetitionMandatory) {\n            const newDef = prod.definition.concat([\n                new $1d44efb04eab6ceb$var$Repetition({\n                    definition: prod.definition\n                })\n            ]);\n            return getAlternativesForProd(newDef);\n        } else if (prod instanceof $1d44efb04eab6ceb$var$RepetitionMandatoryWithSeparator) {\n            const newDef = [\n                new $1d44efb04eab6ceb$var$Alternative({\n                    definition: prod.definition\n                }),\n                new $1d44efb04eab6ceb$var$Repetition({\n                    definition: [\n                        new $1d44efb04eab6ceb$var$Terminal({\n                            terminalType: prod.separator\n                        })\n                    ].concat(prod.definition)\n                })\n            ];\n            return getAlternativesForProd(newDef);\n        } else if (prod instanceof $1d44efb04eab6ceb$var$RepetitionWithSeparator) {\n            const newDef = prod.definition.concat([\n                new $1d44efb04eab6ceb$var$Repetition({\n                    definition: [\n                        new $1d44efb04eab6ceb$var$Terminal({\n                            terminalType: prod.separator\n                        })\n                    ].concat(prod.definition)\n                })\n            ]);\n            result = getAlternativesForProd(newDef);\n        } else if (prod instanceof $1d44efb04eab6ceb$var$Repetition) {\n            const newDef = prod.definition.concat([\n                new $1d44efb04eab6ceb$var$Repetition({\n                    definition: prod.definition\n                })\n            ]);\n            result = getAlternativesForProd(newDef);\n        } else if (prod instanceof $1d44efb04eab6ceb$var$Alternation) {\n            (0, $76RTQ.forEach_default)(prod.definition, (currAlt)=>{\n                if ((0, $f34bP.isEmpty_default)(currAlt.definition) === false) result = getAlternativesForProd(currAlt.definition);\n            });\n            return result;\n        } else if (prod instanceof $1d44efb04eab6ceb$var$Terminal) currPath.push(prod.terminalType);\n        else throw Error(\"non exhaustive match\");\n        i++;\n    }\n    result.push({\n        partialPath: currPath,\n        suffixDef: (0, $76RTQ.drop_default)(targetDef, i)\n    });\n    return result;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$possiblePathsFrom, \"possiblePathsFrom\");\nfunction $1d44efb04eab6ceb$var$nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n    const EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n    const EXIT_NON_TERMINAL_ARR = [\n        EXIT_NON_TERMINAL\n    ];\n    const EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n    let foundCompletePath = false;\n    const tokenVectorLength = tokenVector.length;\n    const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n    const result = [];\n    const possiblePaths = [];\n    possiblePaths.push({\n        idx: -1,\n        def: initialDef,\n        ruleStack: [],\n        occurrenceStack: []\n    });\n    while(!(0, $f34bP.isEmpty_default)(possiblePaths)){\n        const currPath = possiblePaths.pop();\n        if (currPath === EXIT_ALTERNATIVE) {\n            if (foundCompletePath && (0, $76RTQ.last_default)(possiblePaths).idx <= minimalAlternativesIndex) possiblePaths.pop();\n            continue;\n        }\n        const currDef = currPath.def;\n        const currIdx = currPath.idx;\n        const currRuleStack = currPath.ruleStack;\n        const currOccurrenceStack = currPath.occurrenceStack;\n        if ((0, $f34bP.isEmpty_default)(currDef)) continue;\n        const prod = currDef[0];\n        if (prod === EXIT_NON_TERMINAL) {\n            const nextPath = {\n                idx: currIdx,\n                def: (0, $76RTQ.drop_default)(currDef),\n                ruleStack: (0, $76RTQ.dropRight_default)(currRuleStack),\n                occurrenceStack: (0, $76RTQ.dropRight_default)(currOccurrenceStack)\n            };\n            possiblePaths.push(nextPath);\n        } else if (prod instanceof $1d44efb04eab6ceb$var$Terminal) {\n            if (currIdx < tokenVectorLength - 1) {\n                const nextIdx = currIdx + 1;\n                const actualToken = tokenVector[nextIdx];\n                if (tokMatcher(actualToken, prod.terminalType)) {\n                    const nextPath = {\n                        idx: nextIdx,\n                        def: (0, $76RTQ.drop_default)(currDef),\n                        ruleStack: currRuleStack,\n                        occurrenceStack: currOccurrenceStack\n                    };\n                    possiblePaths.push(nextPath);\n                }\n            } else if (currIdx === tokenVectorLength - 1) {\n                result.push({\n                    nextTokenType: prod.terminalType,\n                    nextTokenOccurrence: prod.idx,\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack\n                });\n                foundCompletePath = true;\n            } else throw Error(\"non exhaustive match\");\n        } else if (prod instanceof $1d44efb04eab6ceb$var$NonTerminal) {\n            const newRuleStack = (0, $76RTQ.clone_default)(currRuleStack);\n            newRuleStack.push(prod.nonTerminalName);\n            const newOccurrenceStack = (0, $76RTQ.clone_default)(currOccurrenceStack);\n            newOccurrenceStack.push(prod.idx);\n            const nextPath = {\n                idx: currIdx,\n                def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, (0, $76RTQ.drop_default)(currDef)),\n                ruleStack: newRuleStack,\n                occurrenceStack: newOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        } else if (prod instanceof $1d44efb04eab6ceb$var$Option) {\n            const nextPathWithout = {\n                idx: currIdx,\n                def: (0, $76RTQ.drop_default)(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            const nextPathWith = {\n                idx: currIdx,\n                def: prod.definition.concat((0, $76RTQ.drop_default)(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        } else if (prod instanceof $1d44efb04eab6ceb$var$RepetitionMandatory) {\n            const secondIteration = new $1d44efb04eab6ceb$var$Repetition({\n                definition: prod.definition,\n                idx: prod.idx\n            });\n            const nextDef = prod.definition.concat([\n                secondIteration\n            ], (0, $76RTQ.drop_default)(currDef));\n            const nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        } else if (prod instanceof $1d44efb04eab6ceb$var$RepetitionMandatoryWithSeparator) {\n            const separatorGast = new $1d44efb04eab6ceb$var$Terminal({\n                terminalType: prod.separator\n            });\n            const secondIteration = new $1d44efb04eab6ceb$var$Repetition({\n                definition: [\n                    separatorGast\n                ].concat(prod.definition),\n                idx: prod.idx\n            });\n            const nextDef = prod.definition.concat([\n                secondIteration\n            ], (0, $76RTQ.drop_default)(currDef));\n            const nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        } else if (prod instanceof $1d44efb04eab6ceb$var$RepetitionWithSeparator) {\n            const nextPathWithout = {\n                idx: currIdx,\n                def: (0, $76RTQ.drop_default)(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            const separatorGast = new $1d44efb04eab6ceb$var$Terminal({\n                terminalType: prod.separator\n            });\n            const nthRepetition = new $1d44efb04eab6ceb$var$Repetition({\n                definition: [\n                    separatorGast\n                ].concat(prod.definition),\n                idx: prod.idx\n            });\n            const nextDef = prod.definition.concat([\n                nthRepetition\n            ], (0, $76RTQ.drop_default)(currDef));\n            const nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        } else if (prod instanceof $1d44efb04eab6ceb$var$Repetition) {\n            const nextPathWithout = {\n                idx: currIdx,\n                def: (0, $76RTQ.drop_default)(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            const nthRepetition = new $1d44efb04eab6ceb$var$Repetition({\n                definition: prod.definition,\n                idx: prod.idx\n            });\n            const nextDef = prod.definition.concat([\n                nthRepetition\n            ], (0, $76RTQ.drop_default)(currDef));\n            const nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        } else if (prod instanceof $1d44efb04eab6ceb$var$Alternation) for(let i = prod.definition.length - 1; i >= 0; i--){\n            const currAlt = prod.definition[i];\n            const currAltPath = {\n                idx: currIdx,\n                def: currAlt.definition.concat((0, $76RTQ.drop_default)(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(currAltPath);\n            possiblePaths.push(EXIT_ALTERNATIVE);\n        }\n        else if (prod instanceof $1d44efb04eab6ceb$var$Alternative) possiblePaths.push({\n            idx: currIdx,\n            def: prod.definition.concat((0, $76RTQ.drop_default)(currDef)),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n        });\n        else if (prod instanceof $1d44efb04eab6ceb$var$Rule) possiblePaths.push($1d44efb04eab6ceb$var$expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n        else throw Error(\"non exhaustive match\");\n    }\n    return result;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$nextPossibleTokensAfter, \"nextPossibleTokensAfter\");\nfunction $1d44efb04eab6ceb$var$expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n    const newRuleStack = (0, $76RTQ.clone_default)(currRuleStack);\n    newRuleStack.push(topRule.name);\n    const newCurrOccurrenceStack = (0, $76RTQ.clone_default)(currOccurrenceStack);\n    newCurrOccurrenceStack.push(1);\n    return {\n        idx: currIdx,\n        def: topRule.definition,\n        ruleStack: newRuleStack,\n        occurrenceStack: newCurrOccurrenceStack\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$expandTopLevelRule, \"expandTopLevelRule\");\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/grammar/lookahead.js\nvar $1d44efb04eab6ceb$var$PROD_TYPE;\n(function(PROD_TYPE2) {\n    PROD_TYPE2[PROD_TYPE2[\"OPTION\"] = 0] = \"OPTION\";\n    PROD_TYPE2[PROD_TYPE2[\"REPETITION\"] = 1] = \"REPETITION\";\n    PROD_TYPE2[PROD_TYPE2[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n    PROD_TYPE2[PROD_TYPE2[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n    PROD_TYPE2[PROD_TYPE2[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n    PROD_TYPE2[PROD_TYPE2[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})($1d44efb04eab6ceb$var$PROD_TYPE || ($1d44efb04eab6ceb$var$PROD_TYPE = {}));\nfunction $1d44efb04eab6ceb$var$getProdType(prod) {\n    if (prod instanceof $1d44efb04eab6ceb$var$Option || prod === \"Option\") return $1d44efb04eab6ceb$var$PROD_TYPE.OPTION;\n    else if (prod instanceof $1d44efb04eab6ceb$var$Repetition || prod === \"Repetition\") return $1d44efb04eab6ceb$var$PROD_TYPE.REPETITION;\n    else if (prod instanceof $1d44efb04eab6ceb$var$RepetitionMandatory || prod === \"RepetitionMandatory\") return $1d44efb04eab6ceb$var$PROD_TYPE.REPETITION_MANDATORY;\n    else if (prod instanceof $1d44efb04eab6ceb$var$RepetitionMandatoryWithSeparator || prod === \"RepetitionMandatoryWithSeparator\") return $1d44efb04eab6ceb$var$PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n    else if (prod instanceof $1d44efb04eab6ceb$var$RepetitionWithSeparator || prod === \"RepetitionWithSeparator\") return $1d44efb04eab6ceb$var$PROD_TYPE.REPETITION_WITH_SEPARATOR;\n    else if (prod instanceof $1d44efb04eab6ceb$var$Alternation || prod === \"Alternation\") return $1d44efb04eab6ceb$var$PROD_TYPE.ALTERNATION;\n    else throw Error(\"non exhaustive match\");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getProdType, \"getProdType\");\nfunction $1d44efb04eab6ceb$var$getLookaheadPaths(options) {\n    const { occurrence: occurrence, rule: rule, prodType: prodType, maxLookahead: maxLookahead } = options;\n    const type = $1d44efb04eab6ceb$var$getProdType(prodType);\n    if (type === $1d44efb04eab6ceb$var$PROD_TYPE.ALTERNATION) return $1d44efb04eab6ceb$var$getLookaheadPathsForOr(occurrence, rule, maxLookahead);\n    else return $1d44efb04eab6ceb$var$getLookaheadPathsForOptionalProd(occurrence, rule, type, maxLookahead);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getLookaheadPaths, \"getLookaheadPaths\");\nfunction $1d44efb04eab6ceb$var$buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n    const lookAheadPaths = $1d44efb04eab6ceb$var$getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n    const tokenMatcher2 = $1d44efb04eab6ceb$var$areTokenCategoriesNotUsed(lookAheadPaths) ? $1d44efb04eab6ceb$var$tokenStructuredMatcherNoCategories : $1d44efb04eab6ceb$var$tokenStructuredMatcher;\n    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher2, dynamicTokensEnabled);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildLookaheadFuncForOr, \"buildLookaheadFuncForOr\");\nfunction $1d44efb04eab6ceb$var$buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n    const lookAheadPaths = $1d44efb04eab6ceb$var$getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n    const tokenMatcher2 = $1d44efb04eab6ceb$var$areTokenCategoriesNotUsed(lookAheadPaths) ? $1d44efb04eab6ceb$var$tokenStructuredMatcherNoCategories : $1d44efb04eab6ceb$var$tokenStructuredMatcher;\n    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher2, dynamicTokensEnabled);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildLookaheadFuncForOptionalProd, \"buildLookaheadFuncForOptionalProd\");\nfunction $1d44efb04eab6ceb$var$buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher2, dynamicTokensEnabled) {\n    const numOfAlts = alts.length;\n    const areAllOneTokenLookahead = (0, $76RTQ.every_default)(alts, (currAlt)=>{\n        return (0, $76RTQ.every_default)(currAlt, (currPath)=>{\n            return currPath.length === 1;\n        });\n    });\n    if (hasPredicates) return function(orAlts) {\n        const predicates = (0, $76RTQ.map_default)(orAlts, (currAlt)=>currAlt.GATE);\n        for(let t = 0; t < numOfAlts; t++){\n            const currAlt = alts[t];\n            const currNumOfPaths = currAlt.length;\n            const currPredicate = predicates[t];\n            if (currPredicate !== void 0 && currPredicate.call(this) === false) continue;\n            nextPath: for(let j = 0; j < currNumOfPaths; j++){\n                const currPath = currAlt[j];\n                const currPathLength = currPath.length;\n                for(let i = 0; i < currPathLength; i++){\n                    const nextToken = this.LA(i + 1);\n                    if (tokenMatcher2(nextToken, currPath[i]) === false) continue nextPath;\n                }\n                return t;\n            }\n        }\n        return void 0;\n    };\n    else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        const singleTokenAlts = (0, $76RTQ.map_default)(alts, (currAlt)=>{\n            return (0, $76RTQ.flatten_default)(currAlt);\n        });\n        const choiceToAlt = (0, $76RTQ.reduce_default)(singleTokenAlts, (result, currAlt, idx)=>{\n            (0, $76RTQ.forEach_default)(currAlt, (currTokType)=>{\n                if (!(0, $76RTQ.has_default)(result, currTokType.tokenTypeIdx)) result[currTokType.tokenTypeIdx] = idx;\n                (0, $76RTQ.forEach_default)(currTokType.categoryMatches, (currExtendingType)=>{\n                    if (!(0, $76RTQ.has_default)(result, currExtendingType)) result[currExtendingType] = idx;\n                });\n            });\n            return result;\n        }, {});\n        return function() {\n            const nextToken = this.LA(1);\n            return choiceToAlt[nextToken.tokenTypeIdx];\n        };\n    } else return function() {\n        for(let t = 0; t < numOfAlts; t++){\n            const currAlt = alts[t];\n            const currNumOfPaths = currAlt.length;\n            nextPath: for(let j = 0; j < currNumOfPaths; j++){\n                const currPath = currAlt[j];\n                const currPathLength = currPath.length;\n                for(let i = 0; i < currPathLength; i++){\n                    const nextToken = this.LA(i + 1);\n                    if (tokenMatcher2(nextToken, currPath[i]) === false) continue nextPath;\n                }\n                return t;\n            }\n        }\n        return void 0;\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildAlternativesLookAheadFunc, \"buildAlternativesLookAheadFunc\");\nfunction $1d44efb04eab6ceb$var$buildSingleAlternativeLookaheadFunction(alt, tokenMatcher2, dynamicTokensEnabled) {\n    const areAllOneTokenLookahead = (0, $76RTQ.every_default)(alt, (currPath)=>{\n        return currPath.length === 1;\n    });\n    const numOfPaths = alt.length;\n    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        const singleTokensTypes = (0, $76RTQ.flatten_default)(alt);\n        if (singleTokensTypes.length === 1 && (0, $f34bP.isEmpty_default)(singleTokensTypes[0].categoryMatches)) {\n            const expectedTokenType = singleTokensTypes[0];\n            const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;\n            return function() {\n                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n            };\n        } else {\n            const choiceToAlt = (0, $76RTQ.reduce_default)(singleTokensTypes, (result, currTokType, idx)=>{\n                result[currTokType.tokenTypeIdx] = true;\n                (0, $76RTQ.forEach_default)(currTokType.categoryMatches, (currExtendingType)=>{\n                    result[currExtendingType] = true;\n                });\n                return result;\n            }, []);\n            return function() {\n                const nextToken = this.LA(1);\n                return choiceToAlt[nextToken.tokenTypeIdx] === true;\n            };\n        }\n    } else return function() {\n        nextPath: for(let j = 0; j < numOfPaths; j++){\n            const currPath = alt[j];\n            const currPathLength = currPath.length;\n            for(let i = 0; i < currPathLength; i++){\n                const nextToken = this.LA(i + 1);\n                if (tokenMatcher2(nextToken, currPath[i]) === false) continue nextPath;\n            }\n            return true;\n        }\n        return false;\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildSingleAlternativeLookaheadFunction, \"buildSingleAlternativeLookaheadFunction\");\nvar $1d44efb04eab6ceb$var$RestDefinitionFinderWalker = class extends $1d44efb04eab6ceb$var$RestWalker {\n    static{\n        (0, $7xxrv.__name)(this, \"RestDefinitionFinderWalker\");\n    }\n    constructor(topProd, targetOccurrence, targetProdType){\n        super();\n        this.topProd = topProd;\n        this.targetOccurrence = targetOccurrence;\n        this.targetProdType = targetProdType;\n    }\n    startWalking() {\n        this.walk(this.topProd);\n        return this.restDef;\n    }\n    checkIsTarget(node, expectedProdType, currRest, prevRest) {\n        if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {\n            this.restDef = currRest.concat(prevRest);\n            return true;\n        }\n        return false;\n    }\n    walkOption(optionProd, currRest, prevRest) {\n        if (!this.checkIsTarget(optionProd, $1d44efb04eab6ceb$var$PROD_TYPE.OPTION, currRest, prevRest)) super.walkOption(optionProd, currRest, prevRest);\n    }\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneProd, $1d44efb04eab6ceb$var$PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) super.walkOption(atLeastOneProd, currRest, prevRest);\n    }\n    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneSepProd, $1d44efb04eab6ceb$var$PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) super.walkOption(atLeastOneSepProd, currRest, prevRest);\n    }\n    walkMany(manyProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manyProd, $1d44efb04eab6ceb$var$PROD_TYPE.REPETITION, currRest, prevRest)) super.walkOption(manyProd, currRest, prevRest);\n    }\n    walkManySep(manySepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manySepProd, $1d44efb04eab6ceb$var$PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) super.walkOption(manySepProd, currRest, prevRest);\n    }\n};\nvar $1d44efb04eab6ceb$var$InsideDefinitionFinderVisitor = class extends $1d44efb04eab6ceb$var$GAstVisitor {\n    static{\n        (0, $7xxrv.__name)(this, \"InsideDefinitionFinderVisitor\");\n    }\n    constructor(targetOccurrence, targetProdType, targetRef){\n        super();\n        this.targetOccurrence = targetOccurrence;\n        this.targetProdType = targetProdType;\n        this.targetRef = targetRef;\n        this.result = [];\n    }\n    checkIsTarget(node, expectedProdName) {\n        if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === void 0 || node === this.targetRef)) this.result = node.definition;\n    }\n    visitOption(node) {\n        this.checkIsTarget(node, $1d44efb04eab6ceb$var$PROD_TYPE.OPTION);\n    }\n    visitRepetition(node) {\n        this.checkIsTarget(node, $1d44efb04eab6ceb$var$PROD_TYPE.REPETITION);\n    }\n    visitRepetitionMandatory(node) {\n        this.checkIsTarget(node, $1d44efb04eab6ceb$var$PROD_TYPE.REPETITION_MANDATORY);\n    }\n    visitRepetitionMandatoryWithSeparator(node) {\n        this.checkIsTarget(node, $1d44efb04eab6ceb$var$PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n    }\n    visitRepetitionWithSeparator(node) {\n        this.checkIsTarget(node, $1d44efb04eab6ceb$var$PROD_TYPE.REPETITION_WITH_SEPARATOR);\n    }\n    visitAlternation(node) {\n        this.checkIsTarget(node, $1d44efb04eab6ceb$var$PROD_TYPE.ALTERNATION);\n    }\n};\nfunction $1d44efb04eab6ceb$var$initializeArrayOfArrays(size) {\n    const result = new Array(size);\n    for(let i = 0; i < size; i++)result[i] = [];\n    return result;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$initializeArrayOfArrays, \"initializeArrayOfArrays\");\nfunction $1d44efb04eab6ceb$var$pathToHashKeys(path) {\n    let keys = [\n        \"\"\n    ];\n    for(let i = 0; i < path.length; i++){\n        const tokType = path[i];\n        const longerKeys = [];\n        for(let j = 0; j < keys.length; j++){\n            const currShorterKey = keys[j];\n            longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n            for(let t = 0; t < tokType.categoryMatches.length; t++){\n                const categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n                longerKeys.push(currShorterKey + categoriesKeySuffix);\n            }\n        }\n        keys = longerKeys;\n    }\n    return keys;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$pathToHashKeys, \"pathToHashKeys\");\nfunction $1d44efb04eab6ceb$var$isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n    for(let currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++){\n        if (currAltIdx === idx) continue;\n        const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n        for(let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++){\n            const searchKey = searchPathKeys[searchIdx];\n            if (otherAltKnownPathsKeys[searchKey] === true) return false;\n        }\n    }\n    return true;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isUniquePrefixHash, \"isUniquePrefixHash\");\nfunction $1d44efb04eab6ceb$var$lookAheadSequenceFromAlternatives(altsDefs, k) {\n    const partialAlts = (0, $76RTQ.map_default)(altsDefs, (currAlt)=>$1d44efb04eab6ceb$var$possiblePathsFrom([\n            currAlt\n        ], 1));\n    const finalResult = $1d44efb04eab6ceb$var$initializeArrayOfArrays(partialAlts.length);\n    const altsHashes = (0, $76RTQ.map_default)(partialAlts, (currAltPaths)=>{\n        const dict = {};\n        (0, $76RTQ.forEach_default)(currAltPaths, (item)=>{\n            const keys = $1d44efb04eab6ceb$var$pathToHashKeys(item.partialPath);\n            (0, $76RTQ.forEach_default)(keys, (currKey)=>{\n                dict[currKey] = true;\n            });\n        });\n        return dict;\n    });\n    let newData = partialAlts;\n    for(let pathLength = 1; pathLength <= k; pathLength++){\n        const currDataset = newData;\n        newData = $1d44efb04eab6ceb$var$initializeArrayOfArrays(currDataset.length);\n        for(let altIdx = 0; altIdx < currDataset.length; altIdx++){\n            const currAltPathsAndSuffixes = currDataset[altIdx];\n            for(let currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++){\n                const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n                const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n                const prefixKeys = $1d44efb04eab6ceb$var$pathToHashKeys(currPathPrefix);\n                const isUnique = $1d44efb04eab6ceb$var$isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n                if (isUnique || (0, $f34bP.isEmpty_default)(suffixDef) || currPathPrefix.length === k) {\n                    const currAltResult = finalResult[altIdx];\n                    if ($1d44efb04eab6ceb$var$containsPath(currAltResult, currPathPrefix) === false) {\n                        currAltResult.push(currPathPrefix);\n                        for(let j = 0; j < prefixKeys.length; j++){\n                            const currKey = prefixKeys[j];\n                            altsHashes[altIdx][currKey] = true;\n                        }\n                    }\n                } else {\n                    const newPartialPathsAndSuffixes = $1d44efb04eab6ceb$var$possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);\n                    newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n                    (0, $76RTQ.forEach_default)(newPartialPathsAndSuffixes, (item)=>{\n                        const prefixKeys2 = $1d44efb04eab6ceb$var$pathToHashKeys(item.partialPath);\n                        (0, $76RTQ.forEach_default)(prefixKeys2, (key)=>{\n                            altsHashes[altIdx][key] = true;\n                        });\n                    });\n                }\n            }\n        }\n    }\n    return finalResult;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$lookAheadSequenceFromAlternatives, \"lookAheadSequenceFromAlternatives\");\nfunction $1d44efb04eab6ceb$var$getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n    const visitor2 = new $1d44efb04eab6ceb$var$InsideDefinitionFinderVisitor(occurrence, $1d44efb04eab6ceb$var$PROD_TYPE.ALTERNATION, orProd);\n    ruleGrammar.accept(visitor2);\n    return $1d44efb04eab6ceb$var$lookAheadSequenceFromAlternatives(visitor2.result, k);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getLookaheadPathsForOr, \"getLookaheadPathsForOr\");\nfunction $1d44efb04eab6ceb$var$getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n    const insideDefVisitor = new $1d44efb04eab6ceb$var$InsideDefinitionFinderVisitor(occurrence, prodType);\n    ruleGrammar.accept(insideDefVisitor);\n    const insideDef = insideDefVisitor.result;\n    const afterDefWalker = new $1d44efb04eab6ceb$var$RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n    const afterDef = afterDefWalker.startWalking();\n    const insideFlat = new $1d44efb04eab6ceb$var$Alternative({\n        definition: insideDef\n    });\n    const afterFlat = new $1d44efb04eab6ceb$var$Alternative({\n        definition: afterDef\n    });\n    return $1d44efb04eab6ceb$var$lookAheadSequenceFromAlternatives([\n        insideFlat,\n        afterFlat\n    ], k);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getLookaheadPathsForOptionalProd, \"getLookaheadPathsForOptionalProd\");\nfunction $1d44efb04eab6ceb$var$containsPath(alternative, searchPath) {\n    compareOtherPath: for(let i = 0; i < alternative.length; i++){\n        const otherPath = alternative[i];\n        if (otherPath.length !== searchPath.length) continue;\n        for(let j = 0; j < otherPath.length; j++){\n            const searchTok = searchPath[j];\n            const otherTok = otherPath[j];\n            const matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== void 0;\n            if (matchingTokens === false) continue compareOtherPath;\n        }\n        return true;\n    }\n    return false;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$containsPath, \"containsPath\");\nfunction $1d44efb04eab6ceb$var$isStrictPrefixOfPath(prefix, other) {\n    return prefix.length < other.length && (0, $76RTQ.every_default)(prefix, (tokType, idx)=>{\n        const otherTokType = other[idx];\n        return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isStrictPrefixOfPath, \"isStrictPrefixOfPath\");\nfunction $1d44efb04eab6ceb$var$areTokenCategoriesNotUsed(lookAheadPaths) {\n    return (0, $76RTQ.every_default)(lookAheadPaths, (singleAltPaths)=>(0, $76RTQ.every_default)(singleAltPaths, (singlePath)=>(0, $76RTQ.every_default)(singlePath, (token)=>(0, $f34bP.isEmpty_default)(token.categoryMatches))));\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$areTokenCategoriesNotUsed, \"areTokenCategoriesNotUsed\");\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/grammar/checks.js\nfunction $1d44efb04eab6ceb$var$validateLookahead(options) {\n    const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n        rules: options.rules,\n        tokenTypes: options.tokenTypes,\n        grammarName: options.grammarName\n    });\n    return (0, $76RTQ.map_default)(lookaheadValidationErrorMessages, (errorMessage)=>Object.assign({\n            type: $1d44efb04eab6ceb$var$ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION\n        }, errorMessage));\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$validateLookahead, \"validateLookahead\");\nfunction $1d44efb04eab6ceb$var$validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {\n    const duplicateErrors = (0, $76RTQ.flatMap_default)(topLevels, (currTopLevel)=>$1d44efb04eab6ceb$var$validateDuplicateProductions(currTopLevel, errMsgProvider));\n    const termsNamespaceConflictErrors = $1d44efb04eab6ceb$var$checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n    const tooManyAltsErrors = (0, $76RTQ.flatMap_default)(topLevels, (curRule)=>$1d44efb04eab6ceb$var$validateTooManyAlts(curRule, errMsgProvider));\n    const duplicateRulesError = (0, $76RTQ.flatMap_default)(topLevels, (curRule)=>$1d44efb04eab6ceb$var$validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider));\n    return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$validateGrammar, \"validateGrammar\");\nfunction $1d44efb04eab6ceb$var$validateDuplicateProductions(topLevelRule, errMsgProvider) {\n    const collectorVisitor2 = new $1d44efb04eab6ceb$var$OccurrenceValidationCollector();\n    topLevelRule.accept(collectorVisitor2);\n    const allRuleProductions = collectorVisitor2.allProductions;\n    const productionGroups = (0, $76RTQ.groupBy_default)(allRuleProductions, $1d44efb04eab6ceb$var$identifyProductionForDuplicates);\n    const duplicates = (0, $76RTQ.pickBy_default)(productionGroups, (currGroup)=>{\n        return currGroup.length > 1;\n    });\n    const errors = (0, $76RTQ.map_default)((0, $76RTQ.values_default)(duplicates), (currDuplicates)=>{\n        const firstProd = (0, $76RTQ.head_default)(currDuplicates);\n        const msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n        const dslName = $1d44efb04eab6ceb$var$getProductionDslName(firstProd);\n        const defError = {\n            message: msg,\n            type: $1d44efb04eab6ceb$var$ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n            ruleName: topLevelRule.name,\n            dslName: dslName,\n            occurrence: firstProd.idx\n        };\n        const param = $1d44efb04eab6ceb$var$getExtraProductionArgument(firstProd);\n        if (param) defError.parameter = param;\n        return defError;\n    });\n    return errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$validateDuplicateProductions, \"validateDuplicateProductions\");\nfunction $1d44efb04eab6ceb$var$identifyProductionForDuplicates(prod) {\n    return `${$1d44efb04eab6ceb$var$getProductionDslName(prod)}_#_${prod.idx}_#_${$1d44efb04eab6ceb$var$getExtraProductionArgument(prod)}`;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$identifyProductionForDuplicates, \"identifyProductionForDuplicates\");\nfunction $1d44efb04eab6ceb$var$getExtraProductionArgument(prod) {\n    if (prod instanceof $1d44efb04eab6ceb$var$Terminal) return prod.terminalType.name;\n    else if (prod instanceof $1d44efb04eab6ceb$var$NonTerminal) return prod.nonTerminalName;\n    else return \"\";\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getExtraProductionArgument, \"getExtraProductionArgument\");\nvar $1d44efb04eab6ceb$var$OccurrenceValidationCollector = class extends $1d44efb04eab6ceb$var$GAstVisitor {\n    static{\n        (0, $7xxrv.__name)(this, \"OccurrenceValidationCollector\");\n    }\n    constructor(){\n        super(...arguments);\n        this.allProductions = [];\n    }\n    visitNonTerminal(subrule) {\n        this.allProductions.push(subrule);\n    }\n    visitOption(option2) {\n        this.allProductions.push(option2);\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.allProductions.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.allProductions.push(many);\n    }\n    visitAlternation(or) {\n        this.allProductions.push(or);\n    }\n    visitTerminal(terminal) {\n        this.allProductions.push(terminal);\n    }\n};\nfunction $1d44efb04eab6ceb$var$validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n    const errors = [];\n    const occurrences = (0, $76RTQ.reduce_default)(allRules, (result, curRule)=>{\n        if (curRule.name === rule.name) return result + 1;\n        return result;\n    }, 0);\n    if (occurrences > 1) {\n        const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n            topLevelRule: rule,\n            grammarName: className\n        });\n        errors.push({\n            message: errMsg,\n            type: $1d44efb04eab6ceb$var$ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n            ruleName: rule.name\n        });\n    }\n    return errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$validateRuleDoesNotAlreadyExist, \"validateRuleDoesNotAlreadyExist\");\nfunction $1d44efb04eab6ceb$var$validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n    const errors = [];\n    let errMsg;\n    if (!(0, $76RTQ.includes_default)(definedRulesNames, ruleName)) {\n        errMsg = `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-as it is not defined in any of the super grammars `;\n        errors.push({\n            message: errMsg,\n            type: $1d44efb04eab6ceb$var$ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n            ruleName: ruleName\n        });\n    }\n    return errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$validateRuleIsOverridden, \"validateRuleIsOverridden\");\nfunction $1d44efb04eab6ceb$var$validateNoLeftRecursion(topRule, currRule, errMsgProvider, path = []) {\n    const errors = [];\n    const nextNonTerminals = $1d44efb04eab6ceb$var$getFirstNoneTerminal(currRule.definition);\n    if ((0, $f34bP.isEmpty_default)(nextNonTerminals)) return [];\n    else {\n        const ruleName = topRule.name;\n        const foundLeftRecursion = (0, $76RTQ.includes_default)(nextNonTerminals, topRule);\n        if (foundLeftRecursion) errors.push({\n            message: errMsgProvider.buildLeftRecursionError({\n                topLevelRule: topRule,\n                leftRecursionPath: path\n            }),\n            type: $1d44efb04eab6ceb$var$ParserDefinitionErrorType.LEFT_RECURSION,\n            ruleName: ruleName\n        });\n        const validNextSteps = (0, $76RTQ.difference_default)(nextNonTerminals, path.concat([\n            topRule\n        ]));\n        const errorsFromNextSteps = (0, $76RTQ.flatMap_default)(validNextSteps, (currRefRule)=>{\n            const newPath = (0, $76RTQ.clone_default)(path);\n            newPath.push(currRefRule);\n            return $1d44efb04eab6ceb$var$validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n        });\n        return errors.concat(errorsFromNextSteps);\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$validateNoLeftRecursion, \"validateNoLeftRecursion\");\nfunction $1d44efb04eab6ceb$var$getFirstNoneTerminal(definition) {\n    let result = [];\n    if ((0, $f34bP.isEmpty_default)(definition)) return result;\n    const firstProd = (0, $76RTQ.head_default)(definition);\n    if (firstProd instanceof $1d44efb04eab6ceb$var$NonTerminal) result.push(firstProd.referencedRule);\n    else if (firstProd instanceof $1d44efb04eab6ceb$var$Alternative || firstProd instanceof $1d44efb04eab6ceb$var$Option || firstProd instanceof $1d44efb04eab6ceb$var$RepetitionMandatory || firstProd instanceof $1d44efb04eab6ceb$var$RepetitionMandatoryWithSeparator || firstProd instanceof $1d44efb04eab6ceb$var$RepetitionWithSeparator || firstProd instanceof $1d44efb04eab6ceb$var$Repetition) result = result.concat($1d44efb04eab6ceb$var$getFirstNoneTerminal(firstProd.definition));\n    else if (firstProd instanceof $1d44efb04eab6ceb$var$Alternation) result = (0, $76RTQ.flatten_default)((0, $76RTQ.map_default)(firstProd.definition, (currSubDef)=>$1d44efb04eab6ceb$var$getFirstNoneTerminal(currSubDef.definition)));\n    else if (firstProd instanceof $1d44efb04eab6ceb$var$Terminal) ;\n    else throw Error(\"non exhaustive match\");\n    const isFirstOptional = $1d44efb04eab6ceb$var$isOptionalProd(firstProd);\n    const hasMore = definition.length > 1;\n    if (isFirstOptional && hasMore) {\n        const rest = (0, $76RTQ.drop_default)(definition);\n        return result.concat($1d44efb04eab6ceb$var$getFirstNoneTerminal(rest));\n    } else return result;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getFirstNoneTerminal, \"getFirstNoneTerminal\");\nvar $1d44efb04eab6ceb$var$OrCollector = class extends $1d44efb04eab6ceb$var$GAstVisitor {\n    static{\n        (0, $7xxrv.__name)(this, \"OrCollector\");\n    }\n    constructor(){\n        super(...arguments);\n        this.alternations = [];\n    }\n    visitAlternation(node) {\n        this.alternations.push(node);\n    }\n};\nfunction $1d44efb04eab6ceb$var$validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n    const orCollector = new $1d44efb04eab6ceb$var$OrCollector();\n    topLevelRule.accept(orCollector);\n    const ors = orCollector.alternations;\n    const errors = (0, $76RTQ.flatMap_default)(ors, (currOr)=>{\n        const exceptLast = (0, $76RTQ.dropRight_default)(currOr.definition);\n        return (0, $76RTQ.flatMap_default)(exceptLast, (currAlternative, currAltIdx)=>{\n            const possibleFirstInAlt = $1d44efb04eab6ceb$var$nextPossibleTokensAfter([\n                currAlternative\n            ], [], $1d44efb04eab6ceb$var$tokenStructuredMatcher, 1);\n            if ((0, $f34bP.isEmpty_default)(possibleFirstInAlt)) return [\n                {\n                    message: errMsgProvider.buildEmptyAlternationError({\n                        topLevelRule: topLevelRule,\n                        alternation: currOr,\n                        emptyChoiceIdx: currAltIdx\n                    }),\n                    type: $1d44efb04eab6ceb$var$ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n                    ruleName: topLevelRule.name,\n                    occurrence: currOr.idx,\n                    alternative: currAltIdx + 1\n                }\n            ];\n            else return [];\n        });\n    });\n    return errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$validateEmptyOrAlternative, \"validateEmptyOrAlternative\");\nfunction $1d44efb04eab6ceb$var$validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n    const orCollector = new $1d44efb04eab6ceb$var$OrCollector();\n    topLevelRule.accept(orCollector);\n    let ors = orCollector.alternations;\n    ors = (0, $76RTQ.reject_default)(ors, (currOr)=>currOr.ignoreAmbiguities === true);\n    const errors = (0, $76RTQ.flatMap_default)(ors, (currOr)=>{\n        const currOccurrence = currOr.idx;\n        const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n        const alternatives = $1d44efb04eab6ceb$var$getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n        const altsAmbiguityErrors = $1d44efb04eab6ceb$var$checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        const altsPrefixAmbiguityErrors = $1d44efb04eab6ceb$var$checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n    });\n    return errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$validateAmbiguousAlternationAlternatives, \"validateAmbiguousAlternationAlternatives\");\nvar $1d44efb04eab6ceb$var$RepetitionCollector = class extends $1d44efb04eab6ceb$var$GAstVisitor {\n    static{\n        (0, $7xxrv.__name)(this, \"RepetitionCollector\");\n    }\n    constructor(){\n        super(...arguments);\n        this.allProductions = [];\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.allProductions.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.allProductions.push(many);\n    }\n};\nfunction $1d44efb04eab6ceb$var$validateTooManyAlts(topLevelRule, errMsgProvider) {\n    const orCollector = new $1d44efb04eab6ceb$var$OrCollector();\n    topLevelRule.accept(orCollector);\n    const ors = orCollector.alternations;\n    const errors = (0, $76RTQ.flatMap_default)(ors, (currOr)=>{\n        if (currOr.definition.length > 255) return [\n            {\n                message: errMsgProvider.buildTooManyAlternativesError({\n                    topLevelRule: topLevelRule,\n                    alternation: currOr\n                }),\n                type: $1d44efb04eab6ceb$var$ParserDefinitionErrorType.TOO_MANY_ALTS,\n                ruleName: topLevelRule.name,\n                occurrence: currOr.idx\n            }\n        ];\n        else return [];\n    });\n    return errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$validateTooManyAlts, \"validateTooManyAlts\");\nfunction $1d44efb04eab6ceb$var$validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n    const errors = [];\n    (0, $76RTQ.forEach_default)(topLevelRules, (currTopRule)=>{\n        const collectorVisitor2 = new $1d44efb04eab6ceb$var$RepetitionCollector();\n        currTopRule.accept(collectorVisitor2);\n        const allRuleProductions = collectorVisitor2.allProductions;\n        (0, $76RTQ.forEach_default)(allRuleProductions, (currProd)=>{\n            const prodType = $1d44efb04eab6ceb$var$getProdType(currProd);\n            const actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n            const currOccurrence = currProd.idx;\n            const paths = $1d44efb04eab6ceb$var$getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n            const pathsInsideProduction = paths[0];\n            if ((0, $f34bP.isEmpty_default)((0, $76RTQ.flatten_default)(pathsInsideProduction))) {\n                const errMsg = errMsgProvider.buildEmptyRepetitionError({\n                    topLevelRule: currTopRule,\n                    repetition: currProd\n                });\n                errors.push({\n                    message: errMsg,\n                    type: $1d44efb04eab6ceb$var$ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n                    ruleName: currTopRule.name\n                });\n            }\n        });\n    });\n    return errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$validateSomeNonEmptyLookaheadPath, \"validateSomeNonEmptyLookaheadPath\");\nfunction $1d44efb04eab6ceb$var$checkAlternativesAmbiguities(alternatives, alternation2, rule, errMsgProvider) {\n    const foundAmbiguousPaths = [];\n    const identicalAmbiguities = (0, $76RTQ.reduce_default)(alternatives, (result, currAlt, currAltIdx)=>{\n        if (alternation2.definition[currAltIdx].ignoreAmbiguities === true) return result;\n        (0, $76RTQ.forEach_default)(currAlt, (currPath)=>{\n            const altsCurrPathAppearsIn = [\n                currAltIdx\n            ];\n            (0, $76RTQ.forEach_default)(alternatives, (currOtherAlt, currOtherAltIdx)=>{\n                if (currAltIdx !== currOtherAltIdx && $1d44efb04eab6ceb$var$containsPath(currOtherAlt, currPath) && // ignore (skip) ambiguities with this \"other\" alternative\n                alternation2.definition[currOtherAltIdx].ignoreAmbiguities !== true) altsCurrPathAppearsIn.push(currOtherAltIdx);\n            });\n            if (altsCurrPathAppearsIn.length > 1 && !$1d44efb04eab6ceb$var$containsPath(foundAmbiguousPaths, currPath)) {\n                foundAmbiguousPaths.push(currPath);\n                result.push({\n                    alts: altsCurrPathAppearsIn,\n                    path: currPath\n                });\n            }\n        });\n        return result;\n    }, []);\n    const currErrors = (0, $76RTQ.map_default)(identicalAmbiguities, (currAmbDescriptor)=>{\n        const ambgIndices = (0, $76RTQ.map_default)(currAmbDescriptor.alts, (currAltIdx)=>currAltIdx + 1);\n        const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation2,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbDescriptor.path\n        });\n        return {\n            message: currMessage,\n            type: $1d44efb04eab6ceb$var$ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n            ruleName: rule.name,\n            occurrence: alternation2.idx,\n            alternatives: currAmbDescriptor.alts\n        };\n    });\n    return currErrors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$checkAlternativesAmbiguities, \"checkAlternativesAmbiguities\");\nfunction $1d44efb04eab6ceb$var$checkPrefixAlternativesAmbiguities(alternatives, alternation2, rule, errMsgProvider) {\n    const pathsAndIndices = (0, $76RTQ.reduce_default)(alternatives, (result, currAlt, idx)=>{\n        const currPathsAndIdx = (0, $76RTQ.map_default)(currAlt, (currPath)=>{\n            return {\n                idx: idx,\n                path: currPath\n            };\n        });\n        return result.concat(currPathsAndIdx);\n    }, []);\n    const errors = (0, $76RTQ.compact_default)((0, $76RTQ.flatMap_default)(pathsAndIndices, (currPathAndIdx)=>{\n        const alternativeGast = alternation2.definition[currPathAndIdx.idx];\n        if (alternativeGast.ignoreAmbiguities === true) return [];\n        const targetIdx = currPathAndIdx.idx;\n        const targetPath = currPathAndIdx.path;\n        const prefixAmbiguitiesPathsAndIndices = (0, $76RTQ.filter_default)(pathsAndIndices, (searchPathAndIdx)=>{\n            return(// ignore (skip) ambiguities with this \"other\" alternative\n            alternation2.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads\n            // will be be detected using a different validation.\n            $1d44efb04eab6ceb$var$isStrictPrefixOfPath(searchPathAndIdx.path, targetPath));\n        });\n        const currPathPrefixErrors = (0, $76RTQ.map_default)(prefixAmbiguitiesPathsAndIndices, (currAmbPathAndIdx)=>{\n            const ambgIndices = [\n                currAmbPathAndIdx.idx + 1,\n                targetIdx + 1\n            ];\n            const occurrence = alternation2.idx === 0 ? \"\" : alternation2.idx;\n            const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n                topLevelRule: rule,\n                alternation: alternation2,\n                ambiguityIndices: ambgIndices,\n                prefixPath: currAmbPathAndIdx.path\n            });\n            return {\n                message: message,\n                type: $1d44efb04eab6ceb$var$ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n                ruleName: rule.name,\n                occurrence: occurrence,\n                alternatives: ambgIndices\n            };\n        });\n        return currPathPrefixErrors;\n    }));\n    return errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$checkPrefixAlternativesAmbiguities, \"checkPrefixAlternativesAmbiguities\");\nfunction $1d44efb04eab6ceb$var$checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n    const errors = [];\n    const tokenNames = (0, $76RTQ.map_default)(tokenTypes, (currToken)=>currToken.name);\n    (0, $76RTQ.forEach_default)(topLevels, (currRule)=>{\n        const currRuleName = currRule.name;\n        if ((0, $76RTQ.includes_default)(tokenNames, currRuleName)) {\n            const errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n            errors.push({\n                message: errMsg,\n                type: $1d44efb04eab6ceb$var$ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n                ruleName: currRuleName\n            });\n        }\n    });\n    return errors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$checkTerminalAndNoneTerminalsNameSpace, \"checkTerminalAndNoneTerminalsNameSpace\");\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js\nfunction $1d44efb04eab6ceb$var$resolveGrammar2(options) {\n    const actualOptions = (0, $76RTQ.defaults_default)(options, {\n        errMsgProvider: $1d44efb04eab6ceb$var$defaultGrammarResolverErrorProvider\n    });\n    const topRulesTable = {};\n    (0, $76RTQ.forEach_default)(options.rules, (rule)=>{\n        topRulesTable[rule.name] = rule;\n    });\n    return $1d44efb04eab6ceb$var$resolveGrammar(topRulesTable, actualOptions.errMsgProvider);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$resolveGrammar2, \"resolveGrammar\");\nfunction $1d44efb04eab6ceb$var$validateGrammar2(options) {\n    options = (0, $76RTQ.defaults_default)(options, {\n        errMsgProvider: $1d44efb04eab6ceb$var$defaultGrammarValidatorErrorProvider\n    });\n    return $1d44efb04eab6ceb$var$validateGrammar(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$validateGrammar2, \"validateGrammar\");\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/exceptions_public.js\nvar $1d44efb04eab6ceb$var$MISMATCHED_TOKEN_EXCEPTION = \"MismatchedTokenException\";\nvar $1d44efb04eab6ceb$var$NO_VIABLE_ALT_EXCEPTION = \"NoViableAltException\";\nvar $1d44efb04eab6ceb$var$EARLY_EXIT_EXCEPTION = \"EarlyExitException\";\nvar $1d44efb04eab6ceb$var$NOT_ALL_INPUT_PARSED_EXCEPTION = \"NotAllInputParsedException\";\nvar $1d44efb04eab6ceb$var$RECOGNITION_EXCEPTION_NAMES = [\n    $1d44efb04eab6ceb$var$MISMATCHED_TOKEN_EXCEPTION,\n    $1d44efb04eab6ceb$var$NO_VIABLE_ALT_EXCEPTION,\n    $1d44efb04eab6ceb$var$EARLY_EXIT_EXCEPTION,\n    $1d44efb04eab6ceb$var$NOT_ALL_INPUT_PARSED_EXCEPTION\n];\nObject.freeze($1d44efb04eab6ceb$var$RECOGNITION_EXCEPTION_NAMES);\nfunction $1d44efb04eab6ceb$var$isRecognitionException(error) {\n    return (0, $76RTQ.includes_default)($1d44efb04eab6ceb$var$RECOGNITION_EXCEPTION_NAMES, error.name);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isRecognitionException, \"isRecognitionException\");\nvar $1d44efb04eab6ceb$var$RecognitionException = class extends Error {\n    static{\n        (0, $7xxrv.__name)(this, \"RecognitionException\");\n    }\n    constructor(message, token){\n        super(message);\n        this.token = token;\n        this.resyncedTokens = [];\n        Object.setPrototypeOf(this, new.target.prototype);\n        if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);\n    }\n};\nvar $1d44efb04eab6ceb$var$MismatchedTokenException = class extends $1d44efb04eab6ceb$var$RecognitionException {\n    static{\n        (0, $7xxrv.__name)(this, \"MismatchedTokenException\");\n    }\n    constructor(message, token, previousToken){\n        super(message, token);\n        this.previousToken = previousToken;\n        this.name = $1d44efb04eab6ceb$var$MISMATCHED_TOKEN_EXCEPTION;\n    }\n};\nvar $1d44efb04eab6ceb$var$NoViableAltException = class extends $1d44efb04eab6ceb$var$RecognitionException {\n    static{\n        (0, $7xxrv.__name)(this, \"NoViableAltException\");\n    }\n    constructor(message, token, previousToken){\n        super(message, token);\n        this.previousToken = previousToken;\n        this.name = $1d44efb04eab6ceb$var$NO_VIABLE_ALT_EXCEPTION;\n    }\n};\nvar $1d44efb04eab6ceb$var$NotAllInputParsedException = class extends $1d44efb04eab6ceb$var$RecognitionException {\n    static{\n        (0, $7xxrv.__name)(this, \"NotAllInputParsedException\");\n    }\n    constructor(message, token){\n        super(message, token);\n        this.name = $1d44efb04eab6ceb$var$NOT_ALL_INPUT_PARSED_EXCEPTION;\n    }\n};\nvar $1d44efb04eab6ceb$var$EarlyExitException = class extends $1d44efb04eab6ceb$var$RecognitionException {\n    static{\n        (0, $7xxrv.__name)(this, \"EarlyExitException\");\n    }\n    constructor(message, token, previousToken){\n        super(message, token);\n        this.previousToken = previousToken;\n        this.name = $1d44efb04eab6ceb$var$EARLY_EXIT_EXCEPTION;\n    }\n};\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js\nvar $1d44efb04eab6ceb$var$EOF_FOLLOW_KEY = {};\nvar $1d44efb04eab6ceb$var$IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nvar $1d44efb04eab6ceb$var$InRuleRecoveryException = class extends Error {\n    static{\n        (0, $7xxrv.__name)(this, \"InRuleRecoveryException\");\n    }\n    constructor(message){\n        super(message);\n        this.name = $1d44efb04eab6ceb$var$IN_RULE_RECOVERY_EXCEPTION;\n    }\n};\nvar $1d44efb04eab6ceb$var$Recoverable = class {\n    static{\n        (0, $7xxrv.__name)(this, \"Recoverable\");\n    }\n    initRecoverable(config) {\n        this.firstAfterRepMap = {};\n        this.resyncFollows = {};\n        this.recoveryEnabled = (0, $76RTQ.has_default)(config, \"recoveryEnabled\") ? config.recoveryEnabled : $1d44efb04eab6ceb$var$DEFAULT_PARSER_CONFIG.recoveryEnabled;\n        if (this.recoveryEnabled) this.attemptInRepetitionRecovery = $1d44efb04eab6ceb$var$attemptInRepetitionRecovery;\n    }\n    getTokenToInsert(tokType) {\n        const tokToInsert = $1d44efb04eab6ceb$var$createTokenInstance(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n        tokToInsert.isInsertedInRecovery = true;\n        return tokToInsert;\n    }\n    canTokenTypeBeInsertedInRecovery(tokType) {\n        return true;\n    }\n    canTokenTypeBeDeletedInRecovery(tokType) {\n        return true;\n    }\n    tryInRepetitionRecovery(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n        const reSyncTokType = this.findReSyncTokenType();\n        const savedLexerState = this.exportLexerState();\n        const resyncedTokens = [];\n        let passedResyncPoint = false;\n        const nextTokenWithoutResync = this.LA(1);\n        let currToken = this.LA(1);\n        const generateErrorMessage = /* @__PURE__ */ (0, $7xxrv.__name)(()=>{\n            const previousToken = this.LA(0);\n            const msg = this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: expectedTokType,\n                actual: nextTokenWithoutResync,\n                previous: previousToken,\n                ruleName: this.getCurrRuleFullName()\n            });\n            const error = new $1d44efb04eab6ceb$var$MismatchedTokenException(msg, nextTokenWithoutResync, this.LA(0));\n            error.resyncedTokens = (0, $76RTQ.dropRight_default)(resyncedTokens);\n            this.SAVE_ERROR(error);\n        }, \"generateErrorMessage\");\n        while(!passedResyncPoint){\n            if (this.tokenMatcher(currToken, expectedTokType)) {\n                generateErrorMessage();\n                return;\n            } else if (lookAheadFunc.call(this)) {\n                generateErrorMessage();\n                grammarRule.apply(this, grammarRuleArgs);\n                return;\n            } else if (this.tokenMatcher(currToken, reSyncTokType)) passedResyncPoint = true;\n            else {\n                currToken = this.SKIP_TOKEN();\n                this.addToResyncTokens(currToken, resyncedTokens);\n            }\n        }\n        this.importLexerState(savedLexerState);\n    }\n    shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck) {\n        if (notStuck === false) return false;\n        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) return false;\n        if (this.isBackTracking()) return false;\n        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) return false;\n        return true;\n    }\n    // Error Recovery functionality\n    getFollowsForInRuleRecovery(tokType, tokIdxInRule) {\n        const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n        const follows = this.getNextPossibleTokenTypes(grammarPath);\n        return follows;\n    }\n    tryInRuleRecovery(expectedTokType, follows) {\n        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n            const tokToInsert = this.getTokenToInsert(expectedTokType);\n            return tokToInsert;\n        }\n        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n            const nextTok = this.SKIP_TOKEN();\n            this.consumeToken();\n            return nextTok;\n        }\n        throw new $1d44efb04eab6ceb$var$InRuleRecoveryException(\"sad sad panda\");\n    }\n    canPerformInRuleRecovery(expectedToken, follows) {\n        return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);\n    }\n    canRecoverWithSingleTokenInsertion(expectedTokType, follows) {\n        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) return false;\n        if ((0, $f34bP.isEmpty_default)(follows)) return false;\n        const mismatchedTok = this.LA(1);\n        const isMisMatchedTokInFollows = (0, $76RTQ.find_default)(follows, (possibleFollowsTokType)=>{\n            return this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n        }) !== void 0;\n        return isMisMatchedTokInFollows;\n    }\n    canRecoverWithSingleTokenDeletion(expectedTokType) {\n        if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) return false;\n        const isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n        return isNextTokenWhatIsExpected;\n    }\n    isInCurrentRuleReSyncSet(tokenTypeIdx) {\n        const followKey = this.getCurrFollowKey();\n        const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n        return (0, $76RTQ.includes_default)(currentRuleReSyncSet, tokenTypeIdx);\n    }\n    findReSyncTokenType() {\n        const allPossibleReSyncTokTypes = this.flattenFollowSet();\n        let nextToken = this.LA(1);\n        let k = 2;\n        while(true){\n            const foundMatch = (0, $76RTQ.find_default)(allPossibleReSyncTokTypes, (resyncTokType)=>{\n                const canMatch = $1d44efb04eab6ceb$var$tokenMatcher(nextToken, resyncTokType);\n                return canMatch;\n            });\n            if (foundMatch !== void 0) return foundMatch;\n            nextToken = this.LA(k);\n            k++;\n        }\n    }\n    getCurrFollowKey() {\n        if (this.RULE_STACK.length === 1) return $1d44efb04eab6ceb$var$EOF_FOLLOW_KEY;\n        const currRuleShortName = this.getLastExplicitRuleShortName();\n        const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n        const prevRuleShortName = this.getPreviousExplicitRuleShortName();\n        return {\n            ruleName: this.shortRuleNameToFullName(currRuleShortName),\n            idxInCallingRule: currRuleIdx,\n            inRule: this.shortRuleNameToFullName(prevRuleShortName)\n        };\n    }\n    buildFullFollowKeyStack() {\n        const explicitRuleStack = this.RULE_STACK;\n        const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return (0, $76RTQ.map_default)(explicitRuleStack, (ruleName, idx)=>{\n            if (idx === 0) return $1d44efb04eab6ceb$var$EOF_FOLLOW_KEY;\n            return {\n                ruleName: this.shortRuleNameToFullName(ruleName),\n                idxInCallingRule: explicitOccurrenceStack[idx],\n                inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n            };\n        });\n    }\n    flattenFollowSet() {\n        const followStack = (0, $76RTQ.map_default)(this.buildFullFollowKeyStack(), (currKey)=>{\n            return this.getFollowSetFromFollowKey(currKey);\n        });\n        return (0, $76RTQ.flatten_default)(followStack);\n    }\n    getFollowSetFromFollowKey(followKey) {\n        if (followKey === $1d44efb04eab6ceb$var$EOF_FOLLOW_KEY) return [\n            $1d44efb04eab6ceb$var$EOF\n        ];\n        const followName = followKey.ruleName + followKey.idxInCallingRule + $1d44efb04eab6ceb$var$IN + followKey.inRule;\n        return this.resyncFollows[followName];\n    }\n    // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n    addToResyncTokens(token, resyncTokens) {\n        if (!this.tokenMatcher(token, $1d44efb04eab6ceb$var$EOF)) resyncTokens.push(token);\n        return resyncTokens;\n    }\n    reSyncTo(tokType) {\n        const resyncedTokens = [];\n        let nextTok = this.LA(1);\n        while(this.tokenMatcher(nextTok, tokType) === false){\n            nextTok = this.SKIP_TOKEN();\n            this.addToResyncTokens(nextTok, resyncedTokens);\n        }\n        return (0, $76RTQ.dropRight_default)(resyncedTokens);\n    }\n    attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {}\n    getCurrentGrammarPath(tokType, tokIdxInRule) {\n        const pathRuleStack = this.getHumanReadableRuleStack();\n        const pathOccurrenceStack = (0, $76RTQ.clone_default)(this.RULE_OCCURRENCE_STACK);\n        const grammarPath = {\n            ruleStack: pathRuleStack,\n            occurrenceStack: pathOccurrenceStack,\n            lastTok: tokType,\n            lastTokOccurrence: tokIdxInRule\n        };\n        return grammarPath;\n    }\n    getHumanReadableRuleStack() {\n        return (0, $76RTQ.map_default)(this.RULE_STACK, (currShortName)=>this.shortRuleNameToFullName(currShortName));\n    }\n};\nfunction $1d44efb04eab6ceb$var$attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n    const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n    let firstAfterRepInfo = this.firstAfterRepMap[key];\n    if (firstAfterRepInfo === void 0) {\n        const currRuleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[currRuleName];\n        const walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n        firstAfterRepInfo = walker.startWalking();\n        this.firstAfterRepMap[key] = firstAfterRepInfo;\n    }\n    let expectTokAfterLastMatch = firstAfterRepInfo.token;\n    let nextTokIdx = firstAfterRepInfo.occurrence;\n    const isEndOfRule = firstAfterRepInfo.isEndOfRule;\n    if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === void 0) {\n        expectTokAfterLastMatch = $1d44efb04eab6ceb$var$EOF;\n        nextTokIdx = 1;\n    }\n    if (expectTokAfterLastMatch === void 0 || nextTokIdx === void 0) return;\n    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$attemptInRepetitionRecovery, \"attemptInRepetitionRecovery\");\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/grammar/keys.js\nvar $1d44efb04eab6ceb$var$BITS_FOR_METHOD_TYPE = 4;\nvar $1d44efb04eab6ceb$var$BITS_FOR_OCCURRENCE_IDX = 8;\nvar $1d44efb04eab6ceb$var$BITS_FOR_ALT_IDX = 8;\nvar $1d44efb04eab6ceb$var$OR_IDX = 1 << $1d44efb04eab6ceb$var$BITS_FOR_OCCURRENCE_IDX;\nvar $1d44efb04eab6ceb$var$OPTION_IDX = 2 << $1d44efb04eab6ceb$var$BITS_FOR_OCCURRENCE_IDX;\nvar $1d44efb04eab6ceb$var$MANY_IDX = 3 << $1d44efb04eab6ceb$var$BITS_FOR_OCCURRENCE_IDX;\nvar $1d44efb04eab6ceb$var$AT_LEAST_ONE_IDX = 4 << $1d44efb04eab6ceb$var$BITS_FOR_OCCURRENCE_IDX;\nvar $1d44efb04eab6ceb$var$MANY_SEP_IDX = 5 << $1d44efb04eab6ceb$var$BITS_FOR_OCCURRENCE_IDX;\nvar $1d44efb04eab6ceb$var$AT_LEAST_ONE_SEP_IDX = 6 << $1d44efb04eab6ceb$var$BITS_FOR_OCCURRENCE_IDX;\nfunction $1d44efb04eab6ceb$var$getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {\n    return occurrence | dslMethodIdx | ruleIdx;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getKeyForAutomaticLookahead, \"getKeyForAutomaticLookahead\");\nvar $1d44efb04eab6ceb$var$BITS_START_FOR_ALT_IDX = 32 - $1d44efb04eab6ceb$var$BITS_FOR_ALT_IDX;\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js\nvar $1d44efb04eab6ceb$var$LLkLookaheadStrategy = class {\n    static{\n        (0, $7xxrv.__name)(this, \"LLkLookaheadStrategy\");\n    }\n    constructor(options){\n        var _a;\n        this.maxLookahead = (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : $1d44efb04eab6ceb$var$DEFAULT_PARSER_CONFIG.maxLookahead;\n    }\n    validate(options) {\n        const leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\n        if ((0, $f34bP.isEmpty_default)(leftRecursionErrors)) {\n            const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\n            const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);\n            const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);\n            const allErrors = [\n                ...leftRecursionErrors,\n                ...emptyAltErrors,\n                ...ambiguousAltsErrors,\n                ...emptyRepetitionErrors\n            ];\n            return allErrors;\n        }\n        return leftRecursionErrors;\n    }\n    validateNoLeftRecursion(rules) {\n        return (0, $76RTQ.flatMap_default)(rules, (currTopRule)=>$1d44efb04eab6ceb$var$validateNoLeftRecursion(currTopRule, currTopRule, $1d44efb04eab6ceb$var$defaultGrammarValidatorErrorProvider));\n    }\n    validateEmptyOrAlternatives(rules) {\n        return (0, $76RTQ.flatMap_default)(rules, (currTopRule)=>$1d44efb04eab6ceb$var$validateEmptyOrAlternative(currTopRule, $1d44efb04eab6ceb$var$defaultGrammarValidatorErrorProvider));\n    }\n    validateAmbiguousAlternationAlternatives(rules, maxLookahead) {\n        return (0, $76RTQ.flatMap_default)(rules, (currTopRule)=>$1d44efb04eab6ceb$var$validateAmbiguousAlternationAlternatives(currTopRule, maxLookahead, $1d44efb04eab6ceb$var$defaultGrammarValidatorErrorProvider));\n    }\n    validateSomeNonEmptyLookaheadPath(rules, maxLookahead) {\n        return $1d44efb04eab6ceb$var$validateSomeNonEmptyLookaheadPath(rules, maxLookahead, $1d44efb04eab6ceb$var$defaultGrammarValidatorErrorProvider);\n    }\n    buildLookaheadForAlternation(options) {\n        return $1d44efb04eab6ceb$var$buildLookaheadFuncForOr(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, $1d44efb04eab6ceb$var$buildAlternativesLookAheadFunc);\n    }\n    buildLookaheadForOptional(options) {\n        return $1d44efb04eab6ceb$var$buildLookaheadFuncForOptionalProd(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, $1d44efb04eab6ceb$var$getProdType(options.prodType), $1d44efb04eab6ceb$var$buildSingleAlternativeLookaheadFunction);\n    }\n};\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js\nvar $1d44efb04eab6ceb$var$LooksAhead = class {\n    static{\n        (0, $7xxrv.__name)(this, \"LooksAhead\");\n    }\n    initLooksAhead(config) {\n        this.dynamicTokensEnabled = (0, $76RTQ.has_default)(config, \"dynamicTokensEnabled\") ? config.dynamicTokensEnabled : $1d44efb04eab6ceb$var$DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n        this.maxLookahead = (0, $76RTQ.has_default)(config, \"maxLookahead\") ? config.maxLookahead : $1d44efb04eab6ceb$var$DEFAULT_PARSER_CONFIG.maxLookahead;\n        this.lookaheadStrategy = (0, $76RTQ.has_default)(config, \"lookaheadStrategy\") ? config.lookaheadStrategy : new $1d44efb04eab6ceb$var$LLkLookaheadStrategy({\n            maxLookahead: this.maxLookahead\n        });\n        this.lookAheadFuncsCache = /* @__PURE__ */ new Map();\n    }\n    preComputeLookaheadFunctions(rules) {\n        (0, $76RTQ.forEach_default)(rules, (currRule)=>{\n            this.TRACE_INIT(`${currRule.name} Rule Lookahead`, ()=>{\n                const { alternation: alternation2, repetition: repetition2, option: option2, repetitionMandatory: repetitionMandatory2, repetitionMandatoryWithSeparator: repetitionMandatoryWithSeparator, repetitionWithSeparator: repetitionWithSeparator } = $1d44efb04eab6ceb$var$collectMethods(currRule);\n                (0, $76RTQ.forEach_default)(alternation2, (currProd)=>{\n                    const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n                    this.TRACE_INIT(`${$1d44efb04eab6ceb$var$getProductionDslName(currProd)}${prodIdx}`, ()=>{\n                        const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({\n                            prodOccurrence: currProd.idx,\n                            rule: currRule,\n                            maxLookahead: currProd.maxLookahead || this.maxLookahead,\n                            hasPredicates: currProd.hasPredicates,\n                            dynamicTokensEnabled: this.dynamicTokensEnabled\n                        });\n                        const key = $1d44efb04eab6ceb$var$getKeyForAutomaticLookahead(this.fullRuleNameToShort[currRule.name], $1d44efb04eab6ceb$var$OR_IDX, currProd.idx);\n                        this.setLaFuncCache(key, laFunc);\n                    });\n                });\n                (0, $76RTQ.forEach_default)(repetition2, (currProd)=>{\n                    this.computeLookaheadFunc(currRule, currProd.idx, $1d44efb04eab6ceb$var$MANY_IDX, \"Repetition\", currProd.maxLookahead, $1d44efb04eab6ceb$var$getProductionDslName(currProd));\n                });\n                (0, $76RTQ.forEach_default)(option2, (currProd)=>{\n                    this.computeLookaheadFunc(currRule, currProd.idx, $1d44efb04eab6ceb$var$OPTION_IDX, \"Option\", currProd.maxLookahead, $1d44efb04eab6ceb$var$getProductionDslName(currProd));\n                });\n                (0, $76RTQ.forEach_default)(repetitionMandatory2, (currProd)=>{\n                    this.computeLookaheadFunc(currRule, currProd.idx, $1d44efb04eab6ceb$var$AT_LEAST_ONE_IDX, \"RepetitionMandatory\", currProd.maxLookahead, $1d44efb04eab6ceb$var$getProductionDslName(currProd));\n                });\n                (0, $76RTQ.forEach_default)(repetitionMandatoryWithSeparator, (currProd)=>{\n                    this.computeLookaheadFunc(currRule, currProd.idx, $1d44efb04eab6ceb$var$AT_LEAST_ONE_SEP_IDX, \"RepetitionMandatoryWithSeparator\", currProd.maxLookahead, $1d44efb04eab6ceb$var$getProductionDslName(currProd));\n                });\n                (0, $76RTQ.forEach_default)(repetitionWithSeparator, (currProd)=>{\n                    this.computeLookaheadFunc(currRule, currProd.idx, $1d44efb04eab6ceb$var$MANY_SEP_IDX, \"RepetitionWithSeparator\", currProd.maxLookahead, $1d44efb04eab6ceb$var$getProductionDslName(currProd));\n                });\n            });\n        });\n    }\n    computeLookaheadFunc(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n        this.TRACE_INIT(`${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`, ()=>{\n            const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({\n                prodOccurrence: prodOccurrence,\n                rule: rule,\n                maxLookahead: prodMaxLookahead || this.maxLookahead,\n                dynamicTokensEnabled: this.dynamicTokensEnabled,\n                prodType: prodType\n            });\n            const key = $1d44efb04eab6ceb$var$getKeyForAutomaticLookahead(this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n            this.setLaFuncCache(key, laFunc);\n        });\n    }\n    // this actually returns a number, but it is always used as a string (object prop key)\n    getKeyForAutomaticLookahead(dslMethodIdx, occurrence) {\n        const currRuleShortName = this.getLastExplicitRuleShortName();\n        return $1d44efb04eab6ceb$var$getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence);\n    }\n    getLaFuncFromCache(key) {\n        return this.lookAheadFuncsCache.get(key);\n    }\n    /* istanbul ignore next */ setLaFuncCache(key, value) {\n        this.lookAheadFuncsCache.set(key, value);\n    }\n};\nvar $1d44efb04eab6ceb$var$DslMethodsCollectorVisitor = class extends $1d44efb04eab6ceb$var$GAstVisitor {\n    static{\n        (0, $7xxrv.__name)(this, \"DslMethodsCollectorVisitor\");\n    }\n    constructor(){\n        super(...arguments);\n        this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: []\n        };\n    }\n    reset() {\n        this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: []\n        };\n    }\n    visitOption(option2) {\n        this.dslMethods.option.push(option2);\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.dslMethods.repetitionWithSeparator.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.dslMethods.repetitionMandatory.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.dslMethods.repetition.push(many);\n    }\n    visitAlternation(or) {\n        this.dslMethods.alternation.push(or);\n    }\n};\nvar $1d44efb04eab6ceb$var$collectorVisitor = new $1d44efb04eab6ceb$var$DslMethodsCollectorVisitor();\nfunction $1d44efb04eab6ceb$var$collectMethods(rule) {\n    $1d44efb04eab6ceb$var$collectorVisitor.reset();\n    rule.accept($1d44efb04eab6ceb$var$collectorVisitor);\n    const dslMethods = $1d44efb04eab6ceb$var$collectorVisitor.dslMethods;\n    $1d44efb04eab6ceb$var$collectorVisitor.reset();\n    return dslMethods;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$collectMethods, \"collectMethods\");\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/cst/cst.js\nfunction $1d44efb04eab6ceb$var$setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) currNodeLocation.endOffset = newLocationInfo.endOffset;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$setNodeLocationOnlyOffset, \"setNodeLocationOnlyOffset\");\nfunction $1d44efb04eab6ceb$var$setNodeLocationFull(currNodeLocation, newLocationInfo) {\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.startColumn = newLocationInfo.startColumn;\n        currNodeLocation.startLine = newLocationInfo.startLine;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$setNodeLocationFull, \"setNodeLocationFull\");\nfunction $1d44efb04eab6ceb$var$addTerminalToCst(node, token, tokenTypeName) {\n    if (node.children[tokenTypeName] === void 0) node.children[tokenTypeName] = [\n        token\n    ];\n    else node.children[tokenTypeName].push(token);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$addTerminalToCst, \"addTerminalToCst\");\nfunction $1d44efb04eab6ceb$var$addNoneTerminalToCst(node, ruleName, ruleResult) {\n    if (node.children[ruleName] === void 0) node.children[ruleName] = [\n        ruleResult\n    ];\n    else node.children[ruleName].push(ruleResult);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$addNoneTerminalToCst, \"addNoneTerminalToCst\");\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/lang/lang_extensions.js\nvar $1d44efb04eab6ceb$var$NAME = \"name\";\nfunction $1d44efb04eab6ceb$var$defineNameProp(obj, nameValue) {\n    Object.defineProperty(obj, $1d44efb04eab6ceb$var$NAME, {\n        enumerable: false,\n        configurable: true,\n        writable: false,\n        value: nameValue\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$defineNameProp, \"defineNameProp\");\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js\nfunction $1d44efb04eab6ceb$var$defaultVisit(ctx, param) {\n    const childrenNames = (0, $76RTQ.keys_default)(ctx);\n    const childrenNamesLength = childrenNames.length;\n    for(let i = 0; i < childrenNamesLength; i++){\n        const currChildName = childrenNames[i];\n        const currChildArray = ctx[currChildName];\n        const currChildArrayLength = currChildArray.length;\n        for(let j = 0; j < currChildArrayLength; j++){\n            const currChild = currChildArray[j];\n            if (currChild.tokenTypeIdx === void 0) this[currChild.name](currChild.children, param);\n        }\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$defaultVisit, \"defaultVisit\");\nfunction $1d44efb04eab6ceb$var$createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n    const derivedConstructor = /* @__PURE__ */ (0, $7xxrv.__name)(function() {}, \"derivedConstructor\");\n    $1d44efb04eab6ceb$var$defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\");\n    const semanticProto = {\n        visit: /* @__PURE__ */ (0, $7xxrv.__name)(function(cstNode, param) {\n            if ((0, $2266r.isArray_default)(cstNode)) cstNode = cstNode[0];\n            if ((0, $76RTQ.isUndefined_default)(cstNode)) return void 0;\n            return this[cstNode.name](cstNode.children, param);\n        }, \"visit\"),\n        validateVisitor: /* @__PURE__ */ (0, $7xxrv.__name)(function() {\n            const semanticDefinitionErrors = $1d44efb04eab6ceb$var$validateVisitor(this, ruleNames);\n            if (!(0, $f34bP.isEmpty_default)(semanticDefinitionErrors)) {\n                const errorMessages = (0, $76RTQ.map_default)(semanticDefinitionErrors, (currDefError)=>currDefError.msg);\n                throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:\n\t${errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\t\")}`);\n            }\n        }, \"validateVisitor\")\n    };\n    derivedConstructor.prototype = semanticProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    derivedConstructor._RULE_NAMES = ruleNames;\n    return derivedConstructor;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$createBaseSemanticVisitorConstructor, \"createBaseSemanticVisitorConstructor\");\nfunction $1d44efb04eab6ceb$var$createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n    const derivedConstructor = /* @__PURE__ */ (0, $7xxrv.__name)(function() {}, \"derivedConstructor\");\n    $1d44efb04eab6ceb$var$defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n    const withDefaultsProto = Object.create(baseConstructor.prototype);\n    (0, $76RTQ.forEach_default)(ruleNames, (ruleName)=>{\n        withDefaultsProto[ruleName] = $1d44efb04eab6ceb$var$defaultVisit;\n    });\n    derivedConstructor.prototype = withDefaultsProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    return derivedConstructor;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$createBaseVisitorConstructorWithDefaults, \"createBaseVisitorConstructorWithDefaults\");\nvar $1d44efb04eab6ceb$var$CstVisitorDefinitionError;\n(function(CstVisitorDefinitionError2) {\n    CstVisitorDefinitionError2[CstVisitorDefinitionError2[\"REDUNDANT_METHOD\"] = 0] = \"REDUNDANT_METHOD\";\n    CstVisitorDefinitionError2[CstVisitorDefinitionError2[\"MISSING_METHOD\"] = 1] = \"MISSING_METHOD\";\n})($1d44efb04eab6ceb$var$CstVisitorDefinitionError || ($1d44efb04eab6ceb$var$CstVisitorDefinitionError = {}));\nfunction $1d44efb04eab6ceb$var$validateVisitor(visitorInstance, ruleNames) {\n    const missingErrors = $1d44efb04eab6ceb$var$validateMissingCstMethods(visitorInstance, ruleNames);\n    return missingErrors;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$validateVisitor, \"validateVisitor\");\nfunction $1d44efb04eab6ceb$var$validateMissingCstMethods(visitorInstance, ruleNames) {\n    const missingRuleNames = (0, $76RTQ.filter_default)(ruleNames, (currRuleName)=>{\n        return (0, $2266r.isFunction_default)(visitorInstance[currRuleName]) === false;\n    });\n    const errors = (0, $76RTQ.map_default)(missingRuleNames, (currRuleName)=>{\n        return {\n            msg: `Missing visitor method: <${currRuleName}> on ${visitorInstance.constructor.name} CST Visitor.`,\n            type: $1d44efb04eab6ceb$var$CstVisitorDefinitionError.MISSING_METHOD,\n            methodName: currRuleName\n        };\n    });\n    return (0, $76RTQ.compact_default)(errors);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$validateMissingCstMethods, \"validateMissingCstMethods\");\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js\nvar $1d44efb04eab6ceb$var$TreeBuilder = class {\n    static{\n        (0, $7xxrv.__name)(this, \"TreeBuilder\");\n    }\n    initTreeBuilder(config) {\n        this.CST_STACK = [];\n        this.outputCst = config.outputCst;\n        this.nodeLocationTracking = (0, $76RTQ.has_default)(config, \"nodeLocationTracking\") ? config.nodeLocationTracking : $1d44efb04eab6ceb$var$DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n        if (!this.outputCst) {\n            this.cstInvocationStateUpdate = (0, $76RTQ.noop_default);\n            this.cstFinallyStateUpdate = (0, $76RTQ.noop_default);\n            this.cstPostTerminal = (0, $76RTQ.noop_default);\n            this.cstPostNonTerminal = (0, $76RTQ.noop_default);\n            this.cstPostRule = (0, $76RTQ.noop_default);\n        } else {\n            if (/full/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = $1d44efb04eab6ceb$var$setNodeLocationFull;\n                    this.setNodeLocationFromNode = $1d44efb04eab6ceb$var$setNodeLocationFull;\n                    this.cstPostRule = (0, $76RTQ.noop_default);\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n                } else {\n                    this.setNodeLocationFromToken = (0, $76RTQ.noop_default);\n                    this.setNodeLocationFromNode = (0, $76RTQ.noop_default);\n                    this.cstPostRule = this.cstPostRuleFull;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n                }\n            } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = $1d44efb04eab6ceb$var$setNodeLocationOnlyOffset;\n                    this.setNodeLocationFromNode = $1d44efb04eab6ceb$var$setNodeLocationOnlyOffset;\n                    this.cstPostRule = (0, $76RTQ.noop_default);\n                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n                } else {\n                    this.setNodeLocationFromToken = (0, $76RTQ.noop_default);\n                    this.setNodeLocationFromNode = (0, $76RTQ.noop_default);\n                    this.cstPostRule = this.cstPostRuleOnlyOffset;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n                }\n            } else if (/none/i.test(this.nodeLocationTracking)) {\n                this.setNodeLocationFromToken = (0, $76RTQ.noop_default);\n                this.setNodeLocationFromNode = (0, $76RTQ.noop_default);\n                this.cstPostRule = (0, $76RTQ.noop_default);\n                this.setInitialNodeLocation = (0, $76RTQ.noop_default);\n            } else throw Error(`Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`);\n        }\n    }\n    setInitialNodeLocationOnlyOffsetRecovery(cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            endOffset: NaN\n        };\n    }\n    setInitialNodeLocationOnlyOffsetRegular(cstNode) {\n        cstNode.location = {\n            // without error recovery the starting Location of a new CstNode is guaranteed\n            // To be the next Token's startOffset (for valid inputs).\n            // For invalid inputs there won't be any CSTOutput so this potential\n            // inaccuracy does not matter\n            startOffset: this.LA(1).startOffset,\n            endOffset: NaN\n        };\n    }\n    setInitialNodeLocationFullRecovery(cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            startLine: NaN,\n            startColumn: NaN,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n        };\n    }\n    /**\n       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n  \n       * @param cstNode\n       */ setInitialNodeLocationFullRegular(cstNode) {\n        const nextToken = this.LA(1);\n        cstNode.location = {\n            startOffset: nextToken.startOffset,\n            startLine: nextToken.startLine,\n            startColumn: nextToken.startColumn,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n        };\n    }\n    cstInvocationStateUpdate(fullRuleName) {\n        const cstNode = {\n            name: fullRuleName,\n            children: /* @__PURE__ */ Object.create(null)\n        };\n        this.setInitialNodeLocation(cstNode);\n        this.CST_STACK.push(cstNode);\n    }\n    cstFinallyStateUpdate() {\n        this.CST_STACK.pop();\n    }\n    cstPostRuleFull(ruleCstNode) {\n        const prevToken = this.LA(0);\n        const loc = ruleCstNode.location;\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n            loc.endLine = prevToken.endLine;\n            loc.endColumn = prevToken.endColumn;\n        } else {\n            loc.startOffset = NaN;\n            loc.startLine = NaN;\n            loc.startColumn = NaN;\n        }\n    }\n    cstPostRuleOnlyOffset(ruleCstNode) {\n        const prevToken = this.LA(0);\n        const loc = ruleCstNode.location;\n        if (loc.startOffset <= prevToken.startOffset === true) loc.endOffset = prevToken.endOffset;\n        else loc.startOffset = NaN;\n    }\n    cstPostTerminal(key, consumedToken) {\n        const rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n        $1d44efb04eab6ceb$var$addTerminalToCst(rootCst, consumedToken, key);\n        this.setNodeLocationFromToken(rootCst.location, consumedToken);\n    }\n    cstPostNonTerminal(ruleCstResult, ruleName) {\n        const preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n        $1d44efb04eab6ceb$var$addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n        this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n    }\n    getBaseCstVisitorConstructor() {\n        if ((0, $76RTQ.isUndefined_default)(this.baseCstVisitorConstructor)) {\n            const newBaseCstVisitorConstructor = $1d44efb04eab6ceb$var$createBaseSemanticVisitorConstructor(this.className, (0, $76RTQ.keys_default)(this.gastProductionsCache));\n            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n            return newBaseCstVisitorConstructor;\n        }\n        return this.baseCstVisitorConstructor;\n    }\n    getBaseCstVisitorConstructorWithDefaults() {\n        if ((0, $76RTQ.isUndefined_default)(this.baseCstVisitorWithDefaultsConstructor)) {\n            const newConstructor = $1d44efb04eab6ceb$var$createBaseVisitorConstructorWithDefaults(this.className, (0, $76RTQ.keys_default)(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n            this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n            return newConstructor;\n        }\n        return this.baseCstVisitorWithDefaultsConstructor;\n    }\n    getLastExplicitRuleShortName() {\n        const ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 1];\n    }\n    getPreviousExplicitRuleShortName() {\n        const ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 2];\n    }\n    getLastExplicitRuleOccurrenceIndex() {\n        const occurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return occurrenceStack[occurrenceStack.length - 1];\n    }\n};\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js\nvar $1d44efb04eab6ceb$var$LexerAdapter = class {\n    static{\n        (0, $7xxrv.__name)(this, \"LexerAdapter\");\n    }\n    initLexerAdapter() {\n        this.tokVector = [];\n        this.tokVectorLength = 0;\n        this.currIdx = -1;\n    }\n    set input(newInput) {\n        if (this.selfAnalysisDone !== true) throw Error(`Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`);\n        this.reset();\n        this.tokVector = newInput;\n        this.tokVectorLength = newInput.length;\n    }\n    get input() {\n        return this.tokVector;\n    }\n    // skips a token and returns the next token\n    SKIP_TOKEN() {\n        if (this.currIdx <= this.tokVector.length - 2) {\n            this.consumeToken();\n            return this.LA(1);\n        } else return $1d44efb04eab6ceb$var$END_OF_FILE;\n    }\n    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n    // or lexers dependent on parser context.\n    LA(howMuch) {\n        const soughtIdx = this.currIdx + howMuch;\n        if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) return $1d44efb04eab6ceb$var$END_OF_FILE;\n        else return this.tokVector[soughtIdx];\n    }\n    consumeToken() {\n        this.currIdx++;\n    }\n    exportLexerState() {\n        return this.currIdx;\n    }\n    importLexerState(newState2) {\n        this.currIdx = newState2;\n    }\n    resetLexerState() {\n        this.currIdx = -1;\n    }\n    moveToTerminatedState() {\n        this.currIdx = this.tokVector.length - 1;\n    }\n    getLexerPosition() {\n        return this.exportLexerState();\n    }\n};\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js\nvar $1d44efb04eab6ceb$var$RecognizerApi = class {\n    static{\n        (0, $7xxrv.__name)(this, \"RecognizerApi\");\n    }\n    ACTION(impl) {\n        return impl.call(this);\n    }\n    consume(idx, tokType, options) {\n        return this.consumeInternal(tokType, idx, options);\n    }\n    subrule(idx, ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, idx, options);\n    }\n    option(idx, actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, idx);\n    }\n    or(idx, altsOrOpts) {\n        return this.orInternal(altsOrOpts, idx);\n    }\n    many(idx, actionORMethodDef) {\n        return this.manyInternal(idx, actionORMethodDef);\n    }\n    atLeastOne(idx, actionORMethodDef) {\n        return this.atLeastOneInternal(idx, actionORMethodDef);\n    }\n    CONSUME(tokType, options) {\n        return this.consumeInternal(tokType, 0, options);\n    }\n    CONSUME1(tokType, options) {\n        return this.consumeInternal(tokType, 1, options);\n    }\n    CONSUME2(tokType, options) {\n        return this.consumeInternal(tokType, 2, options);\n    }\n    CONSUME3(tokType, options) {\n        return this.consumeInternal(tokType, 3, options);\n    }\n    CONSUME4(tokType, options) {\n        return this.consumeInternal(tokType, 4, options);\n    }\n    CONSUME5(tokType, options) {\n        return this.consumeInternal(tokType, 5, options);\n    }\n    CONSUME6(tokType, options) {\n        return this.consumeInternal(tokType, 6, options);\n    }\n    CONSUME7(tokType, options) {\n        return this.consumeInternal(tokType, 7, options);\n    }\n    CONSUME8(tokType, options) {\n        return this.consumeInternal(tokType, 8, options);\n    }\n    CONSUME9(tokType, options) {\n        return this.consumeInternal(tokType, 9, options);\n    }\n    SUBRULE(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 0, options);\n    }\n    SUBRULE1(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 1, options);\n    }\n    SUBRULE2(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 2, options);\n    }\n    SUBRULE3(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 3, options);\n    }\n    SUBRULE4(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 4, options);\n    }\n    SUBRULE5(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 5, options);\n    }\n    SUBRULE6(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 6, options);\n    }\n    SUBRULE7(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 7, options);\n    }\n    SUBRULE8(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 8, options);\n    }\n    SUBRULE9(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 9, options);\n    }\n    OPTION(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 0);\n    }\n    OPTION1(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 1);\n    }\n    OPTION2(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 2);\n    }\n    OPTION3(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 3);\n    }\n    OPTION4(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 4);\n    }\n    OPTION5(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 5);\n    }\n    OPTION6(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 6);\n    }\n    OPTION7(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 7);\n    }\n    OPTION8(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 8);\n    }\n    OPTION9(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 9);\n    }\n    OR(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 0);\n    }\n    OR1(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 1);\n    }\n    OR2(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 2);\n    }\n    OR3(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 3);\n    }\n    OR4(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 4);\n    }\n    OR5(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 5);\n    }\n    OR6(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 6);\n    }\n    OR7(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 7);\n    }\n    OR8(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 8);\n    }\n    OR9(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 9);\n    }\n    MANY(actionORMethodDef) {\n        this.manyInternal(0, actionORMethodDef);\n    }\n    MANY1(actionORMethodDef) {\n        this.manyInternal(1, actionORMethodDef);\n    }\n    MANY2(actionORMethodDef) {\n        this.manyInternal(2, actionORMethodDef);\n    }\n    MANY3(actionORMethodDef) {\n        this.manyInternal(3, actionORMethodDef);\n    }\n    MANY4(actionORMethodDef) {\n        this.manyInternal(4, actionORMethodDef);\n    }\n    MANY5(actionORMethodDef) {\n        this.manyInternal(5, actionORMethodDef);\n    }\n    MANY6(actionORMethodDef) {\n        this.manyInternal(6, actionORMethodDef);\n    }\n    MANY7(actionORMethodDef) {\n        this.manyInternal(7, actionORMethodDef);\n    }\n    MANY8(actionORMethodDef) {\n        this.manyInternal(8, actionORMethodDef);\n    }\n    MANY9(actionORMethodDef) {\n        this.manyInternal(9, actionORMethodDef);\n    }\n    MANY_SEP(options) {\n        this.manySepFirstInternal(0, options);\n    }\n    MANY_SEP1(options) {\n        this.manySepFirstInternal(1, options);\n    }\n    MANY_SEP2(options) {\n        this.manySepFirstInternal(2, options);\n    }\n    MANY_SEP3(options) {\n        this.manySepFirstInternal(3, options);\n    }\n    MANY_SEP4(options) {\n        this.manySepFirstInternal(4, options);\n    }\n    MANY_SEP5(options) {\n        this.manySepFirstInternal(5, options);\n    }\n    MANY_SEP6(options) {\n        this.manySepFirstInternal(6, options);\n    }\n    MANY_SEP7(options) {\n        this.manySepFirstInternal(7, options);\n    }\n    MANY_SEP8(options) {\n        this.manySepFirstInternal(8, options);\n    }\n    MANY_SEP9(options) {\n        this.manySepFirstInternal(9, options);\n    }\n    AT_LEAST_ONE(actionORMethodDef) {\n        this.atLeastOneInternal(0, actionORMethodDef);\n    }\n    AT_LEAST_ONE1(actionORMethodDef) {\n        return this.atLeastOneInternal(1, actionORMethodDef);\n    }\n    AT_LEAST_ONE2(actionORMethodDef) {\n        this.atLeastOneInternal(2, actionORMethodDef);\n    }\n    AT_LEAST_ONE3(actionORMethodDef) {\n        this.atLeastOneInternal(3, actionORMethodDef);\n    }\n    AT_LEAST_ONE4(actionORMethodDef) {\n        this.atLeastOneInternal(4, actionORMethodDef);\n    }\n    AT_LEAST_ONE5(actionORMethodDef) {\n        this.atLeastOneInternal(5, actionORMethodDef);\n    }\n    AT_LEAST_ONE6(actionORMethodDef) {\n        this.atLeastOneInternal(6, actionORMethodDef);\n    }\n    AT_LEAST_ONE7(actionORMethodDef) {\n        this.atLeastOneInternal(7, actionORMethodDef);\n    }\n    AT_LEAST_ONE8(actionORMethodDef) {\n        this.atLeastOneInternal(8, actionORMethodDef);\n    }\n    AT_LEAST_ONE9(actionORMethodDef) {\n        this.atLeastOneInternal(9, actionORMethodDef);\n    }\n    AT_LEAST_ONE_SEP(options) {\n        this.atLeastOneSepFirstInternal(0, options);\n    }\n    AT_LEAST_ONE_SEP1(options) {\n        this.atLeastOneSepFirstInternal(1, options);\n    }\n    AT_LEAST_ONE_SEP2(options) {\n        this.atLeastOneSepFirstInternal(2, options);\n    }\n    AT_LEAST_ONE_SEP3(options) {\n        this.atLeastOneSepFirstInternal(3, options);\n    }\n    AT_LEAST_ONE_SEP4(options) {\n        this.atLeastOneSepFirstInternal(4, options);\n    }\n    AT_LEAST_ONE_SEP5(options) {\n        this.atLeastOneSepFirstInternal(5, options);\n    }\n    AT_LEAST_ONE_SEP6(options) {\n        this.atLeastOneSepFirstInternal(6, options);\n    }\n    AT_LEAST_ONE_SEP7(options) {\n        this.atLeastOneSepFirstInternal(7, options);\n    }\n    AT_LEAST_ONE_SEP8(options) {\n        this.atLeastOneSepFirstInternal(8, options);\n    }\n    AT_LEAST_ONE_SEP9(options) {\n        this.atLeastOneSepFirstInternal(9, options);\n    }\n    RULE(name, implementation, config = $1d44efb04eab6ceb$var$DEFAULT_RULE_CONFIG) {\n        if ((0, $76RTQ.includes_default)(this.definedRulesNames, name)) {\n            const errMsg = $1d44efb04eab6ceb$var$defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\n                topLevelRule: name,\n                grammarName: this.className\n            });\n            const error = {\n                message: errMsg,\n                type: $1d44efb04eab6ceb$var$ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n                ruleName: name\n            };\n            this.definitionErrors.push(error);\n        }\n        this.definedRulesNames.push(name);\n        const ruleImplementation = this.defineRule(name, implementation, config);\n        this[name] = ruleImplementation;\n        return ruleImplementation;\n    }\n    OVERRIDE_RULE(name, impl, config = $1d44efb04eab6ceb$var$DEFAULT_RULE_CONFIG) {\n        const ruleErrors = $1d44efb04eab6ceb$var$validateRuleIsOverridden(name, this.definedRulesNames, this.className);\n        this.definitionErrors = this.definitionErrors.concat(ruleErrors);\n        const ruleImplementation = this.defineRule(name, impl, config);\n        this[name] = ruleImplementation;\n        return ruleImplementation;\n    }\n    BACKTRACK(grammarRule, args) {\n        return function() {\n            this.isBackTrackingStack.push(1);\n            const orgState = this.saveRecogState();\n            try {\n                grammarRule.apply(this, args);\n                return true;\n            } catch (e) {\n                if ($1d44efb04eab6ceb$var$isRecognitionException(e)) return false;\n                else throw e;\n            } finally{\n                this.reloadRecogState(orgState);\n                this.isBackTrackingStack.pop();\n            }\n        };\n    }\n    // GAST export APIs\n    getGAstProductions() {\n        return this.gastProductionsCache;\n    }\n    getSerializedGastProductions() {\n        return $1d44efb04eab6ceb$var$serializeGrammar((0, $76RTQ.values_default)(this.gastProductionsCache));\n    }\n};\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js\nvar $1d44efb04eab6ceb$var$RecognizerEngine = class {\n    static{\n        (0, $7xxrv.__name)(this, \"RecognizerEngine\");\n    }\n    initRecognizerEngine(tokenVocabulary, config) {\n        this.className = this.constructor.name;\n        this.shortRuleNameToFull = {};\n        this.fullRuleNameToShort = {};\n        this.ruleShortNameIdx = 256;\n        this.tokenMatcher = $1d44efb04eab6ceb$var$tokenStructuredMatcherNoCategories;\n        this.subruleIdx = 0;\n        this.definedRulesNames = [];\n        this.tokensMap = {};\n        this.isBackTrackingStack = [];\n        this.RULE_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n        this.gastProductionsCache = {};\n        if ((0, $76RTQ.has_default)(config, \"serializedGrammar\")) throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\tFor Further details.\");\n        if ((0, $2266r.isArray_default)(tokenVocabulary)) {\n            if ((0, $f34bP.isEmpty_default)(tokenVocabulary)) throw Error(\"A Token Vocabulary cannot be empty.\\n\tNote that the first argument for the parser constructor\\n\tis no longer a Token vector (since v4.0).\");\n            if (typeof tokenVocabulary[0].startOffset === \"number\") throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\tFor Further details.\");\n        }\n        if ((0, $2266r.isArray_default)(tokenVocabulary)) this.tokensMap = (0, $76RTQ.reduce_default)(tokenVocabulary, (acc, tokType)=>{\n            acc[tokType.name] = tokType;\n            return acc;\n        }, {});\n        else if ((0, $76RTQ.has_default)(tokenVocabulary, \"modes\") && (0, $76RTQ.every_default)((0, $76RTQ.flatten_default)((0, $76RTQ.values_default)(tokenVocabulary.modes)), $1d44efb04eab6ceb$var$isTokenType)) {\n            const allTokenTypes2 = (0, $76RTQ.flatten_default)((0, $76RTQ.values_default)(tokenVocabulary.modes));\n            const uniqueTokens = (0, $76RTQ.uniq_default)(allTokenTypes2);\n            this.tokensMap = (0, $76RTQ.reduce_default)(uniqueTokens, (acc, tokType)=>{\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        } else if ((0, $2266r.isObject_default)(tokenVocabulary)) this.tokensMap = (0, $76RTQ.clone_default)(tokenVocabulary);\n        else throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n        this.tokensMap[\"EOF\"] = $1d44efb04eab6ceb$var$EOF;\n        const allTokenTypes = (0, $76RTQ.has_default)(tokenVocabulary, \"modes\") ? (0, $76RTQ.flatten_default)((0, $76RTQ.values_default)(tokenVocabulary.modes)) : (0, $76RTQ.values_default)(tokenVocabulary);\n        const noTokenCategoriesUsed = (0, $76RTQ.every_default)(allTokenTypes, (tokenConstructor)=>(0, $f34bP.isEmpty_default)(tokenConstructor.categoryMatches));\n        this.tokenMatcher = noTokenCategoriesUsed ? $1d44efb04eab6ceb$var$tokenStructuredMatcherNoCategories : $1d44efb04eab6ceb$var$tokenStructuredMatcher;\n        $1d44efb04eab6ceb$var$augmentTokenTypes((0, $76RTQ.values_default)(this.tokensMap));\n    }\n    defineRule(ruleName, impl, config) {\n        if (this.selfAnalysisDone) throw Error(`Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\nMake sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);\n        const resyncEnabled = (0, $76RTQ.has_default)(config, \"resyncEnabled\") ? config.resyncEnabled : $1d44efb04eab6ceb$var$DEFAULT_RULE_CONFIG.resyncEnabled;\n        const recoveryValueFunc = (0, $76RTQ.has_default)(config, \"recoveryValueFunc\") ? config.recoveryValueFunc : $1d44efb04eab6ceb$var$DEFAULT_RULE_CONFIG.recoveryValueFunc;\n        const shortName = this.ruleShortNameIdx << $1d44efb04eab6ceb$var$BITS_FOR_METHOD_TYPE + $1d44efb04eab6ceb$var$BITS_FOR_OCCURRENCE_IDX;\n        this.ruleShortNameIdx++;\n        this.shortRuleNameToFull[shortName] = ruleName;\n        this.fullRuleNameToShort[ruleName] = shortName;\n        let invokeRuleWithTry;\n        if (this.outputCst === true) invokeRuleWithTry = /* @__PURE__ */ (0, $7xxrv.__name)(function invokeRuleWithTry2(...args) {\n            try {\n                this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                impl.apply(this, args);\n                const cst = this.CST_STACK[this.CST_STACK.length - 1];\n                this.cstPostRule(cst);\n                return cst;\n            } catch (e) {\n                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n            } finally{\n                this.ruleFinallyStateUpdate();\n            }\n        }, \"invokeRuleWithTry\");\n        else invokeRuleWithTry = /* @__PURE__ */ (0, $7xxrv.__name)(function invokeRuleWithTryCst(...args) {\n            try {\n                this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                return impl.apply(this, args);\n            } catch (e) {\n                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n            } finally{\n                this.ruleFinallyStateUpdate();\n            }\n        }, \"invokeRuleWithTryCst\");\n        const wrappedGrammarRule = Object.assign(invokeRuleWithTry, {\n            ruleName: ruleName,\n            originalGrammarAction: impl\n        });\n        return wrappedGrammarRule;\n    }\n    invokeRuleCatch(e, resyncEnabledConfig, recoveryValueFunc) {\n        const isFirstInvokedRule = this.RULE_STACK.length === 1;\n        const reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n        if ($1d44efb04eab6ceb$var$isRecognitionException(e)) {\n            const recogError = e;\n            if (reSyncEnabled) {\n                const reSyncTokType = this.findReSyncTokenType();\n                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n                    recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n                    if (this.outputCst) {\n                        const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        return partialCstResult;\n                    } else return recoveryValueFunc(e);\n                } else {\n                    if (this.outputCst) {\n                        const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        recogError.partialCstResult = partialCstResult;\n                    }\n                    throw recogError;\n                }\n            } else if (isFirstInvokedRule) {\n                this.moveToTerminatedState();\n                return recoveryValueFunc(e);\n            } else throw recogError;\n        } else throw e;\n    }\n    // Implementation of parsing DSL\n    optionInternal(actionORMethodDef, occurrence) {\n        const key = this.getKeyForAutomaticLookahead($1d44efb04eab6ceb$var$OPTION_IDX, occurrence);\n        return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n    }\n    optionInternalLogic(actionORMethodDef, occurrence, key) {\n        let lookAheadFunc = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            if (predicate !== void 0) {\n                const orgLookaheadFunction = lookAheadFunc;\n                lookAheadFunc = /* @__PURE__ */ (0, $7xxrv.__name)(()=>{\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                }, \"lookAheadFunc\");\n            }\n        } else action = actionORMethodDef;\n        if (lookAheadFunc.call(this) === true) return action.call(this);\n        return void 0;\n    }\n    atLeastOneInternal(prodOccurrence, actionORMethodDef) {\n        const laKey = this.getKeyForAutomaticLookahead($1d44efb04eab6ceb$var$AT_LEAST_ONE_IDX, prodOccurrence);\n        return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    }\n    atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key) {\n        let lookAheadFunc = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            if (predicate !== void 0) {\n                const orgLookaheadFunction = lookAheadFunc;\n                lookAheadFunc = /* @__PURE__ */ (0, $7xxrv.__name)(()=>{\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                }, \"lookAheadFunc\");\n            }\n        } else action = actionORMethodDef;\n        if (lookAheadFunc.call(this) === true) {\n            let notStuck = this.doSingleRepetition(action);\n            while(lookAheadFunc.call(this) === true && notStuck === true)notStuck = this.doSingleRepetition(action);\n        } else throw this.raiseEarlyExitException(prodOccurrence, $1d44efb04eab6ceb$var$PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [\n            prodOccurrence,\n            actionORMethodDef\n        ], lookAheadFunc, $1d44efb04eab6ceb$var$AT_LEAST_ONE_IDX, prodOccurrence, $1d44efb04eab6ceb$var$NextTerminalAfterAtLeastOneWalker);\n    }\n    atLeastOneSepFirstInternal(prodOccurrence, options) {\n        const laKey = this.getKeyForAutomaticLookahead($1d44efb04eab6ceb$var$AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n    }\n    atLeastOneSepFirstInternalLogic(prodOccurrence, options, key) {\n        const action = options.DEF;\n        const separator = options.SEP;\n        const firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n        if (firstIterationLookaheadFunc.call(this) === true) {\n            action.call(this);\n            const separatorLookAheadFunc = /* @__PURE__ */ (0, $7xxrv.__name)(()=>{\n                return this.tokenMatcher(this.LA(1), separator);\n            }, \"separatorLookAheadFunc\");\n            while(this.tokenMatcher(this.LA(1), separator) === true){\n                this.CONSUME(separator);\n                action.call(this);\n            }\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                $1d44efb04eab6ceb$var$NextTerminalAfterAtLeastOneSepWalker\n            ], separatorLookAheadFunc, $1d44efb04eab6ceb$var$AT_LEAST_ONE_SEP_IDX, prodOccurrence, $1d44efb04eab6ceb$var$NextTerminalAfterAtLeastOneSepWalker);\n        } else throw this.raiseEarlyExitException(prodOccurrence, $1d44efb04eab6ceb$var$PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n    }\n    manyInternal(prodOccurrence, actionORMethodDef) {\n        const laKey = this.getKeyForAutomaticLookahead($1d44efb04eab6ceb$var$MANY_IDX, prodOccurrence);\n        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    }\n    manyInternalLogic(prodOccurrence, actionORMethodDef, key) {\n        let lookaheadFunction = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            if (predicate !== void 0) {\n                const orgLookaheadFunction = lookaheadFunction;\n                lookaheadFunction = /* @__PURE__ */ (0, $7xxrv.__name)(()=>{\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                }, \"lookaheadFunction\");\n            }\n        } else action = actionORMethodDef;\n        let notStuck = true;\n        while(lookaheadFunction.call(this) === true && notStuck === true)notStuck = this.doSingleRepetition(action);\n        this.attemptInRepetitionRecovery(this.manyInternal, [\n            prodOccurrence,\n            actionORMethodDef\n        ], lookaheadFunction, $1d44efb04eab6ceb$var$MANY_IDX, prodOccurrence, $1d44efb04eab6ceb$var$NextTerminalAfterManyWalker, // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n        // An infinite loop cannot occur as:\n        // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n        notStuck);\n    }\n    manySepFirstInternal(prodOccurrence, options) {\n        const laKey = this.getKeyForAutomaticLookahead($1d44efb04eab6ceb$var$MANY_SEP_IDX, prodOccurrence);\n        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n    }\n    manySepFirstInternalLogic(prodOccurrence, options, key) {\n        const action = options.DEF;\n        const separator = options.SEP;\n        const firstIterationLaFunc = this.getLaFuncFromCache(key);\n        if (firstIterationLaFunc.call(this) === true) {\n            action.call(this);\n            const separatorLookAheadFunc = /* @__PURE__ */ (0, $7xxrv.__name)(()=>{\n                return this.tokenMatcher(this.LA(1), separator);\n            }, \"separatorLookAheadFunc\");\n            while(this.tokenMatcher(this.LA(1), separator) === true){\n                this.CONSUME(separator);\n                action.call(this);\n            }\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                $1d44efb04eab6ceb$var$NextTerminalAfterManySepWalker\n            ], separatorLookAheadFunc, $1d44efb04eab6ceb$var$MANY_SEP_IDX, prodOccurrence, $1d44efb04eab6ceb$var$NextTerminalAfterManySepWalker);\n        }\n    }\n    repetitionSepSecondInternal(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n        while(separatorLookAheadFunc()){\n            this.CONSUME(separator);\n            action.call(this);\n        }\n        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n            prodOccurrence,\n            separator,\n            separatorLookAheadFunc,\n            action,\n            nextTerminalAfterWalker\n        ], separatorLookAheadFunc, $1d44efb04eab6ceb$var$AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n    }\n    doSingleRepetition(action) {\n        const beforeIteration = this.getLexerPosition();\n        action.call(this);\n        const afterIteration = this.getLexerPosition();\n        return afterIteration > beforeIteration;\n    }\n    orInternal(altsOrOpts, occurrence) {\n        const laKey = this.getKeyForAutomaticLookahead($1d44efb04eab6ceb$var$OR_IDX, occurrence);\n        const alts = (0, $2266r.isArray_default)(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n        const laFunc = this.getLaFuncFromCache(laKey);\n        const altIdxToTake = laFunc.call(this, alts);\n        if (altIdxToTake !== void 0) {\n            const chosenAlternative = alts[altIdxToTake];\n            return chosenAlternative.ALT.call(this);\n        }\n        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n    }\n    ruleFinallyStateUpdate() {\n        this.RULE_STACK.pop();\n        this.RULE_OCCURRENCE_STACK.pop();\n        this.cstFinallyStateUpdate();\n        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n            const firstRedundantTok = this.LA(1);\n            const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n                firstRedundant: firstRedundantTok,\n                ruleName: this.getCurrRuleFullName()\n            });\n            this.SAVE_ERROR(new $1d44efb04eab6ceb$var$NotAllInputParsedException(errMsg, firstRedundantTok));\n        }\n    }\n    subruleInternal(ruleToCall, idx, options) {\n        let ruleResult;\n        try {\n            const args = options !== void 0 ? options.ARGS : void 0;\n            this.subruleIdx = idx;\n            ruleResult = ruleToCall.apply(this, args);\n            this.cstPostNonTerminal(ruleResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleToCall.ruleName);\n            return ruleResult;\n        } catch (e) {\n            throw this.subruleInternalError(e, options, ruleToCall.ruleName);\n        }\n    }\n    subruleInternalError(e, options, ruleName) {\n        if ($1d44efb04eab6ceb$var$isRecognitionException(e) && e.partialCstResult !== void 0) {\n            this.cstPostNonTerminal(e.partialCstResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleName);\n            delete e.partialCstResult;\n        }\n        throw e;\n    }\n    consumeInternal(tokType, idx, options) {\n        let consumedToken;\n        try {\n            const nextToken = this.LA(1);\n            if (this.tokenMatcher(nextToken, tokType) === true) {\n                this.consumeToken();\n                consumedToken = nextToken;\n            } else this.consumeInternalError(tokType, nextToken, options);\n        } catch (eFromConsumption) {\n            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n        }\n        this.cstPostTerminal(options !== void 0 && options.LABEL !== void 0 ? options.LABEL : tokType.name, consumedToken);\n        return consumedToken;\n    }\n    consumeInternalError(tokType, nextToken, options) {\n        let msg;\n        const previousToken = this.LA(0);\n        if (options !== void 0 && options.ERR_MSG) msg = options.ERR_MSG;\n        else msg = this.errorMessageProvider.buildMismatchTokenMessage({\n            expected: tokType,\n            actual: nextToken,\n            previous: previousToken,\n            ruleName: this.getCurrRuleFullName()\n        });\n        throw this.SAVE_ERROR(new $1d44efb04eab6ceb$var$MismatchedTokenException(msg, nextToken, previousToken));\n    }\n    consumeInternalRecovery(tokType, idx, eFromConsumption) {\n        if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n        eFromConsumption.name === \"MismatchedTokenException\" && !this.isBackTracking()) {\n            const follows = this.getFollowsForInRuleRecovery(tokType, idx);\n            try {\n                return this.tryInRuleRecovery(tokType, follows);\n            } catch (eFromInRuleRecovery) {\n                if (eFromInRuleRecovery.name === $1d44efb04eab6ceb$var$IN_RULE_RECOVERY_EXCEPTION) throw eFromConsumption;\n                else throw eFromInRuleRecovery;\n            }\n        } else throw eFromConsumption;\n    }\n    saveRecogState() {\n        const savedErrors = this.errors;\n        const savedRuleStack = (0, $76RTQ.clone_default)(this.RULE_STACK);\n        return {\n            errors: savedErrors,\n            lexerState: this.exportLexerState(),\n            RULE_STACK: savedRuleStack,\n            CST_STACK: this.CST_STACK\n        };\n    }\n    reloadRecogState(newState2) {\n        this.errors = newState2.errors;\n        this.importLexerState(newState2.lexerState);\n        this.RULE_STACK = newState2.RULE_STACK;\n    }\n    ruleInvocationStateUpdate(shortName, fullName, idxInCallingRule) {\n        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n        this.RULE_STACK.push(shortName);\n        this.cstInvocationStateUpdate(fullName);\n    }\n    isBackTracking() {\n        return this.isBackTrackingStack.length !== 0;\n    }\n    getCurrRuleFullName() {\n        const shortName = this.getLastExplicitRuleShortName();\n        return this.shortRuleNameToFull[shortName];\n    }\n    shortRuleNameToFullName(shortName) {\n        return this.shortRuleNameToFull[shortName];\n    }\n    isAtEndOfInput() {\n        return this.tokenMatcher(this.LA(1), $1d44efb04eab6ceb$var$EOF);\n    }\n    reset() {\n        this.resetLexerState();\n        this.subruleIdx = 0;\n        this.isBackTrackingStack = [];\n        this.errors = [];\n        this.RULE_STACK = [];\n        this.CST_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n    }\n};\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js\nvar $1d44efb04eab6ceb$var$ErrorHandler = class {\n    static{\n        (0, $7xxrv.__name)(this, \"ErrorHandler\");\n    }\n    initErrorHandler(config) {\n        this._errors = [];\n        this.errorMessageProvider = (0, $76RTQ.has_default)(config, \"errorMessageProvider\") ? config.errorMessageProvider : $1d44efb04eab6ceb$var$DEFAULT_PARSER_CONFIG.errorMessageProvider;\n    }\n    SAVE_ERROR(error) {\n        if ($1d44efb04eab6ceb$var$isRecognitionException(error)) {\n            error.context = {\n                ruleStack: this.getHumanReadableRuleStack(),\n                ruleOccurrenceStack: (0, $76RTQ.clone_default)(this.RULE_OCCURRENCE_STACK)\n            };\n            this._errors.push(error);\n            return error;\n        } else throw Error(\"Trying to save an Error which is not a RecognitionException\");\n    }\n    get errors() {\n        return (0, $76RTQ.clone_default)(this._errors);\n    }\n    set errors(newErrors) {\n        this._errors = newErrors;\n    }\n    // TODO: consider caching the error message computed information\n    raiseEarlyExitException(occurrence, prodType, userDefinedErrMsg) {\n        const ruleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[ruleName];\n        const lookAheadPathsPerAlternative = $1d44efb04eab6ceb$var$getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);\n        const insideProdPaths = lookAheadPathsPerAlternative[0];\n        const actualTokens = [];\n        for(let i = 1; i <= this.maxLookahead; i++)actualTokens.push(this.LA(i));\n        const msg = this.errorMessageProvider.buildEarlyExitMessage({\n            expectedIterationPaths: insideProdPaths,\n            actual: actualTokens,\n            previous: this.LA(0),\n            customUserDescription: userDefinedErrMsg,\n            ruleName: ruleName\n        });\n        throw this.SAVE_ERROR(new $1d44efb04eab6ceb$var$EarlyExitException(msg, this.LA(1), this.LA(0)));\n    }\n    // TODO: consider caching the error message computed information\n    raiseNoAltException(occurrence, errMsgTypes) {\n        const ruleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[ruleName];\n        const lookAheadPathsPerAlternative = $1d44efb04eab6ceb$var$getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);\n        const actualTokens = [];\n        for(let i = 1; i <= this.maxLookahead; i++)actualTokens.push(this.LA(i));\n        const previousToken = this.LA(0);\n        const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n            expectedPathsPerAlt: lookAheadPathsPerAlternative,\n            actual: actualTokens,\n            previous: previousToken,\n            customUserDescription: errMsgTypes,\n            ruleName: this.getCurrRuleFullName()\n        });\n        throw this.SAVE_ERROR(new $1d44efb04eab6ceb$var$NoViableAltException(errMsg, this.LA(1), previousToken));\n    }\n};\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js\nvar $1d44efb04eab6ceb$var$ContentAssist = class {\n    static{\n        (0, $7xxrv.__name)(this, \"ContentAssist\");\n    }\n    initContentAssist() {}\n    computeContentAssist(startRuleName, precedingInput) {\n        const startRuleGast = this.gastProductionsCache[startRuleName];\n        if ((0, $76RTQ.isUndefined_default)(startRuleGast)) throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`);\n        return $1d44efb04eab6ceb$var$nextPossibleTokensAfter([\n            startRuleGast\n        ], precedingInput, this.tokenMatcher, this.maxLookahead);\n    }\n    // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n    // TODO: should this be more explicitly part of the public API?\n    getNextPossibleTokenTypes(grammarPath) {\n        const topRuleName = (0, $76RTQ.head_default)(grammarPath.ruleStack);\n        const gastProductions = this.getGAstProductions();\n        const topProduction = gastProductions[topRuleName];\n        const nextPossibleTokenTypes = new $1d44efb04eab6ceb$var$NextAfterTokenWalker(topProduction, grammarPath).startWalking();\n        return nextPossibleTokenTypes;\n    }\n};\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js\nvar $1d44efb04eab6ceb$var$RECORDING_NULL_OBJECT = {\n    description: \"This Object indicates the Parser is during Recording Phase\"\n};\nObject.freeze($1d44efb04eab6ceb$var$RECORDING_NULL_OBJECT);\nvar $1d44efb04eab6ceb$var$HANDLE_SEPARATOR = true;\nvar $1d44efb04eab6ceb$var$MAX_METHOD_IDX = Math.pow(2, $1d44efb04eab6ceb$var$BITS_FOR_OCCURRENCE_IDX) - 1;\nvar $1d44efb04eab6ceb$var$RFT = $1d44efb04eab6ceb$var$createToken({\n    name: \"RECORDING_PHASE_TOKEN\",\n    pattern: $1d44efb04eab6ceb$var$Lexer.NA\n});\n$1d44efb04eab6ceb$var$augmentTokenTypes([\n    $1d44efb04eab6ceb$var$RFT\n]);\nvar $1d44efb04eab6ceb$var$RECORDING_PHASE_TOKEN = $1d44efb04eab6ceb$var$createTokenInstance($1d44efb04eab6ceb$var$RFT, \"This IToken indicates the Parser is in Recording Phase\\n\tSee: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\", // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze($1d44efb04eab6ceb$var$RECORDING_PHASE_TOKEN);\nvar $1d44efb04eab6ceb$var$RECORDING_PHASE_CSTNODE = {\n    name: \"This CSTNode indicates the Parser is in Recording Phase\\n\tSee: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n    children: {}\n};\nvar $1d44efb04eab6ceb$var$GastRecorder = class {\n    static{\n        (0, $7xxrv.__name)(this, \"GastRecorder\");\n    }\n    initGastRecorder(config) {\n        this.recordingProdStack = [];\n        this.RECORDING_PHASE = false;\n    }\n    enableRecording() {\n        this.RECORDING_PHASE = true;\n        this.TRACE_INIT(\"Enable Recording\", ()=>{\n            for(let i = 0; i < 10; i++){\n                const idx = i > 0 ? i : \"\";\n                this[`CONSUME${idx}`] = function(arg1, arg2) {\n                    return this.consumeInternalRecord(arg1, i, arg2);\n                };\n                this[`SUBRULE${idx}`] = function(arg1, arg2) {\n                    return this.subruleInternalRecord(arg1, i, arg2);\n                };\n                this[`OPTION${idx}`] = function(arg1) {\n                    return this.optionInternalRecord(arg1, i);\n                };\n                this[`OR${idx}`] = function(arg1) {\n                    return this.orInternalRecord(arg1, i);\n                };\n                this[`MANY${idx}`] = function(arg1) {\n                    this.manyInternalRecord(i, arg1);\n                };\n                this[`MANY_SEP${idx}`] = function(arg1) {\n                    this.manySepFirstInternalRecord(i, arg1);\n                };\n                this[`AT_LEAST_ONE${idx}`] = function(arg1) {\n                    this.atLeastOneInternalRecord(i, arg1);\n                };\n                this[`AT_LEAST_ONE_SEP${idx}`] = function(arg1) {\n                    this.atLeastOneSepFirstInternalRecord(i, arg1);\n                };\n            }\n            this[`consume`] = function(idx, arg1, arg2) {\n                return this.consumeInternalRecord(arg1, idx, arg2);\n            };\n            this[`subrule`] = function(idx, arg1, arg2) {\n                return this.subruleInternalRecord(arg1, idx, arg2);\n            };\n            this[`option`] = function(idx, arg1) {\n                return this.optionInternalRecord(arg1, idx);\n            };\n            this[`or`] = function(idx, arg1) {\n                return this.orInternalRecord(arg1, idx);\n            };\n            this[`many`] = function(idx, arg1) {\n                this.manyInternalRecord(idx, arg1);\n            };\n            this[`atLeastOne`] = function(idx, arg1) {\n                this.atLeastOneInternalRecord(idx, arg1);\n            };\n            this.ACTION = this.ACTION_RECORD;\n            this.BACKTRACK = this.BACKTRACK_RECORD;\n            this.LA = this.LA_RECORD;\n        });\n    }\n    disableRecording() {\n        this.RECORDING_PHASE = false;\n        this.TRACE_INIT(\"Deleting Recording methods\", ()=>{\n            const that = this;\n            for(let i = 0; i < 10; i++){\n                const idx = i > 0 ? i : \"\";\n                delete that[`CONSUME${idx}`];\n                delete that[`SUBRULE${idx}`];\n                delete that[`OPTION${idx}`];\n                delete that[`OR${idx}`];\n                delete that[`MANY${idx}`];\n                delete that[`MANY_SEP${idx}`];\n                delete that[`AT_LEAST_ONE${idx}`];\n                delete that[`AT_LEAST_ONE_SEP${idx}`];\n            }\n            delete that[`consume`];\n            delete that[`subrule`];\n            delete that[`option`];\n            delete that[`or`];\n            delete that[`many`];\n            delete that[`atLeastOne`];\n            delete that.ACTION;\n            delete that.BACKTRACK;\n            delete that.LA;\n        });\n    }\n    //   Parser methods are called inside an ACTION?\n    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n    // @ts-expect-error -- noop place holder\n    ACTION_RECORD(impl) {}\n    // Executing backtracking logic will break our recording logic assumptions\n    BACKTRACK_RECORD(grammarRule, args) {\n        return ()=>true;\n    }\n    // LA is part of the official API and may be used for custom lookahead logic\n    // by end users who may forget to wrap it in ACTION or inside a GATE\n    LA_RECORD(howMuch) {\n        return $1d44efb04eab6ceb$var$END_OF_FILE;\n    }\n    topLevelRuleRecord(name, def) {\n        try {\n            const newTopLevelRule = new $1d44efb04eab6ceb$var$Rule({\n                definition: [],\n                name: name\n            });\n            newTopLevelRule.name = name;\n            this.recordingProdStack.push(newTopLevelRule);\n            def.call(this);\n            this.recordingProdStack.pop();\n            return newTopLevelRule;\n        } catch (originalError) {\n            if (originalError.KNOWN_RECORDER_ERROR !== true) try {\n                originalError.message = originalError.message + '\\n\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\thttps://chevrotain.io/docs/guide/internals.html#grammar-recording';\n            } catch (mutabilityError) {\n                throw originalError;\n            }\n            throw originalError;\n        }\n    }\n    // Implementation of parsing DSL\n    optionInternalRecord(actionORMethodDef, occurrence) {\n        return $1d44efb04eab6ceb$var$recordProd.call(this, $1d44efb04eab6ceb$var$Option, actionORMethodDef, occurrence);\n    }\n    atLeastOneInternalRecord(occurrence, actionORMethodDef) {\n        $1d44efb04eab6ceb$var$recordProd.call(this, $1d44efb04eab6ceb$var$RepetitionMandatory, actionORMethodDef, occurrence);\n    }\n    atLeastOneSepFirstInternalRecord(occurrence, options) {\n        $1d44efb04eab6ceb$var$recordProd.call(this, $1d44efb04eab6ceb$var$RepetitionMandatoryWithSeparator, options, occurrence, $1d44efb04eab6ceb$var$HANDLE_SEPARATOR);\n    }\n    manyInternalRecord(occurrence, actionORMethodDef) {\n        $1d44efb04eab6ceb$var$recordProd.call(this, $1d44efb04eab6ceb$var$Repetition, actionORMethodDef, occurrence);\n    }\n    manySepFirstInternalRecord(occurrence, options) {\n        $1d44efb04eab6ceb$var$recordProd.call(this, $1d44efb04eab6ceb$var$RepetitionWithSeparator, options, occurrence, $1d44efb04eab6ceb$var$HANDLE_SEPARATOR);\n    }\n    orInternalRecord(altsOrOpts, occurrence) {\n        return $1d44efb04eab6ceb$var$recordOrProd.call(this, altsOrOpts, occurrence);\n    }\n    subruleInternalRecord(ruleToCall, occurrence, options) {\n        $1d44efb04eab6ceb$var$assertMethodIdxIsValid(occurrence);\n        if (!ruleToCall || (0, $76RTQ.has_default)(ruleToCall, \"ruleName\") === false) {\n            const error = new Error(`<SUBRULE${$1d44efb04eab6ceb$var$getIdxSuffix(occurrence)}> argument is invalid expecting a Parser method reference but got: <${JSON.stringify(ruleToCall)}>\n inside top level rule: <${this.recordingProdStack[0].name}>`);\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        const prevProd = (0, $76RTQ.last_default)(this.recordingProdStack);\n        const ruleName = ruleToCall.ruleName;\n        const newNoneTerminal = new $1d44efb04eab6ceb$var$NonTerminal({\n            idx: occurrence,\n            nonTerminalName: ruleName,\n            label: options === null || options === void 0 ? void 0 : options.LABEL,\n            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n            referencedRule: void 0\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return this.outputCst ? $1d44efb04eab6ceb$var$RECORDING_PHASE_CSTNODE : $1d44efb04eab6ceb$var$RECORDING_NULL_OBJECT;\n    }\n    consumeInternalRecord(tokType, occurrence, options) {\n        $1d44efb04eab6ceb$var$assertMethodIdxIsValid(occurrence);\n        if (!$1d44efb04eab6ceb$var$hasShortKeyProperty(tokType)) {\n            const error = new Error(`<CONSUME${$1d44efb04eab6ceb$var$getIdxSuffix(occurrence)}> argument is invalid expecting a TokenType reference but got: <${JSON.stringify(tokType)}>\n inside top level rule: <${this.recordingProdStack[0].name}>`);\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        const prevProd = (0, $76RTQ.last_default)(this.recordingProdStack);\n        const newNoneTerminal = new $1d44efb04eab6ceb$var$Terminal({\n            idx: occurrence,\n            terminalType: tokType,\n            label: options === null || options === void 0 ? void 0 : options.LABEL\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return $1d44efb04eab6ceb$var$RECORDING_PHASE_TOKEN;\n    }\n};\nfunction $1d44efb04eab6ceb$var$recordProd(prodConstructor, mainProdArg, occurrence, handleSep = false) {\n    $1d44efb04eab6ceb$var$assertMethodIdxIsValid(occurrence);\n    const prevProd = (0, $76RTQ.last_default)(this.recordingProdStack);\n    const grammarAction = (0, $2266r.isFunction_default)(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n    const newProd = new prodConstructor({\n        definition: [],\n        idx: occurrence\n    });\n    if (handleSep) newProd.separator = mainProdArg.SEP;\n    if ((0, $76RTQ.has_default)(mainProdArg, \"MAX_LOOKAHEAD\")) newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    this.recordingProdStack.push(newProd);\n    grammarAction.call(this);\n    prevProd.definition.push(newProd);\n    this.recordingProdStack.pop();\n    return $1d44efb04eab6ceb$var$RECORDING_NULL_OBJECT;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$recordProd, \"recordProd\");\nfunction $1d44efb04eab6ceb$var$recordOrProd(mainProdArg, occurrence) {\n    $1d44efb04eab6ceb$var$assertMethodIdxIsValid(occurrence);\n    const prevProd = (0, $76RTQ.last_default)(this.recordingProdStack);\n    const hasOptions = (0, $2266r.isArray_default)(mainProdArg) === false;\n    const alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n    const newOrProd = new $1d44efb04eab6ceb$var$Alternation({\n        definition: [],\n        idx: occurrence,\n        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n    });\n    if ((0, $76RTQ.has_default)(mainProdArg, \"MAX_LOOKAHEAD\")) newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    const hasPredicates = (0, $76RTQ.some_default)(alts, (currAlt)=>(0, $2266r.isFunction_default)(currAlt.GATE));\n    newOrProd.hasPredicates = hasPredicates;\n    prevProd.definition.push(newOrProd);\n    (0, $76RTQ.forEach_default)(alts, (currAlt)=>{\n        const currAltFlat = new $1d44efb04eab6ceb$var$Alternative({\n            definition: []\n        });\n        newOrProd.definition.push(currAltFlat);\n        if ((0, $76RTQ.has_default)(currAlt, \"IGNORE_AMBIGUITIES\")) currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;\n        else if ((0, $76RTQ.has_default)(currAlt, \"GATE\")) currAltFlat.ignoreAmbiguities = true;\n        this.recordingProdStack.push(currAltFlat);\n        currAlt.ALT.call(this);\n        this.recordingProdStack.pop();\n    });\n    return $1d44efb04eab6ceb$var$RECORDING_NULL_OBJECT;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$recordOrProd, \"recordOrProd\");\nfunction $1d44efb04eab6ceb$var$getIdxSuffix(idx) {\n    return idx === 0 ? \"\" : `${idx}`;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getIdxSuffix, \"getIdxSuffix\");\nfunction $1d44efb04eab6ceb$var$assertMethodIdxIsValid(idx) {\n    if (idx < 0 || idx > $1d44efb04eab6ceb$var$MAX_METHOD_IDX) {\n        const error = new Error(// The stack trace will contain all the needed details\n        `Invalid DSL Method idx value: <${idx}>\n\tIdx value must be a none negative value smaller than ${$1d44efb04eab6ceb$var$MAX_METHOD_IDX + 1}`);\n        error.KNOWN_RECORDER_ERROR = true;\n        throw error;\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$assertMethodIdxIsValid, \"assertMethodIdxIsValid\");\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js\nvar $1d44efb04eab6ceb$var$PerformanceTracer = class {\n    static{\n        (0, $7xxrv.__name)(this, \"PerformanceTracer\");\n    }\n    initPerformanceTracer(config) {\n        if ((0, $76RTQ.has_default)(config, \"traceInitPerf\")) {\n            const userTraceInitPerf = config.traceInitPerf;\n            const traceIsNumber = typeof userTraceInitPerf === \"number\";\n            this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity;\n            this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf;\n        } else {\n            this.traceInitMaxIdent = 0;\n            this.traceInitPerf = $1d44efb04eab6ceb$var$DEFAULT_PARSER_CONFIG.traceInitPerf;\n        }\n        this.traceInitIndent = -1;\n    }\n    TRACE_INIT(phaseDesc, phaseImpl) {\n        if (this.traceInitPerf === true) {\n            this.traceInitIndent++;\n            const indent = new Array(this.traceInitIndent + 1).join(\"\t\");\n            if (this.traceInitIndent < this.traceInitMaxIdent) console.log(`${indent}--> <${phaseDesc}>`);\n            const { time: time, value: value } = $1d44efb04eab6ceb$var$timer(phaseImpl);\n            const traceMethod = time > 10 ? console.warn : console.log;\n            if (this.traceInitIndent < this.traceInitMaxIdent) traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n            this.traceInitIndent--;\n            return value;\n        } else return phaseImpl();\n    }\n};\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js\nfunction $1d44efb04eab6ceb$var$applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach((baseCtor)=>{\n        const baseProto = baseCtor.prototype;\n        Object.getOwnPropertyNames(baseProto).forEach((propName)=>{\n            if (propName === \"constructor\") return;\n            const basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);\n            if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);\n            else derivedCtor.prototype[propName] = baseCtor.prototype[propName];\n        });\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$applyMixins, \"applyMixins\");\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/parser.js\nvar $1d44efb04eab6ceb$var$END_OF_FILE = $1d44efb04eab6ceb$var$createTokenInstance($1d44efb04eab6ceb$var$EOF, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\nObject.freeze($1d44efb04eab6ceb$var$END_OF_FILE);\nvar $1d44efb04eab6ceb$var$DEFAULT_PARSER_CONFIG = Object.freeze({\n    recoveryEnabled: false,\n    maxLookahead: 3,\n    dynamicTokensEnabled: false,\n    outputCst: true,\n    errorMessageProvider: $1d44efb04eab6ceb$var$defaultParserErrorProvider,\n    nodeLocationTracking: \"none\",\n    traceInitPerf: false,\n    skipValidations: false\n});\nvar $1d44efb04eab6ceb$var$DEFAULT_RULE_CONFIG = Object.freeze({\n    recoveryValueFunc: /* @__PURE__ */ (0, $7xxrv.__name)(()=>void 0, \"recoveryValueFunc\"),\n    resyncEnabled: true\n});\nvar $1d44efb04eab6ceb$var$ParserDefinitionErrorType;\n(function(ParserDefinitionErrorType2) {\n    ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"INVALID_RULE_NAME\"] = 0] = \"INVALID_RULE_NAME\";\n    ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"DUPLICATE_RULE_NAME\"] = 1] = \"DUPLICATE_RULE_NAME\";\n    ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"INVALID_RULE_OVERRIDE\"] = 2] = \"INVALID_RULE_OVERRIDE\";\n    ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"DUPLICATE_PRODUCTIONS\"] = 3] = \"DUPLICATE_PRODUCTIONS\";\n    ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"UNRESOLVED_SUBRULE_REF\"] = 4] = \"UNRESOLVED_SUBRULE_REF\";\n    ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"LEFT_RECURSION\"] = 5] = \"LEFT_RECURSION\";\n    ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"NONE_LAST_EMPTY_ALT\"] = 6] = \"NONE_LAST_EMPTY_ALT\";\n    ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"AMBIGUOUS_ALTS\"] = 7] = \"AMBIGUOUS_ALTS\";\n    ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"CONFLICT_TOKENS_RULES_NAMESPACE\"] = 8] = \"CONFLICT_TOKENS_RULES_NAMESPACE\";\n    ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"INVALID_TOKEN_NAME\"] = 9] = \"INVALID_TOKEN_NAME\";\n    ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"NO_NON_EMPTY_LOOKAHEAD\"] = 10] = \"NO_NON_EMPTY_LOOKAHEAD\";\n    ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"AMBIGUOUS_PREFIX_ALTS\"] = 11] = \"AMBIGUOUS_PREFIX_ALTS\";\n    ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"TOO_MANY_ALTS\"] = 12] = \"TOO_MANY_ALTS\";\n    ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"CUSTOM_LOOKAHEAD_VALIDATION\"] = 13] = \"CUSTOM_LOOKAHEAD_VALIDATION\";\n})($1d44efb04eab6ceb$var$ParserDefinitionErrorType || ($1d44efb04eab6ceb$var$ParserDefinitionErrorType = {}));\nfunction $1d44efb04eab6ceb$var$EMPTY_ALT(value) {\n    return function() {\n        return value;\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$EMPTY_ALT, \"EMPTY_ALT\");\nvar $1d44efb04eab6ceb$var$Parser = class _Parser {\n    static{\n        (0, $7xxrv.__name)(this, \"Parser\");\n    }\n    /**\n   *  @deprecated use the **instance** method with the same name instead\n   */ static performSelfAnalysis(parserInstance) {\n        throw Error(\"The **static** `performSelfAnalysis` method has been deprecated.\t\\nUse the **instance** method with the same name instead.\");\n    }\n    performSelfAnalysis() {\n        this.TRACE_INIT(\"performSelfAnalysis\", ()=>{\n            let defErrorsMsgs;\n            this.selfAnalysisDone = true;\n            const className = this.className;\n            this.TRACE_INIT(\"toFastProps\", ()=>{\n                $1d44efb04eab6ceb$var$toFastProperties(this);\n            });\n            this.TRACE_INIT(\"Grammar Recording\", ()=>{\n                try {\n                    this.enableRecording();\n                    (0, $76RTQ.forEach_default)(this.definedRulesNames, (currRuleName)=>{\n                        const wrappedRule = this[currRuleName];\n                        const originalGrammarAction = wrappedRule[\"originalGrammarAction\"];\n                        let recordedRuleGast;\n                        this.TRACE_INIT(`${currRuleName} Rule`, ()=>{\n                            recordedRuleGast = this.topLevelRuleRecord(currRuleName, originalGrammarAction);\n                        });\n                        this.gastProductionsCache[currRuleName] = recordedRuleGast;\n                    });\n                } finally{\n                    this.disableRecording();\n                }\n            });\n            let resolverErrors = [];\n            this.TRACE_INIT(\"Grammar Resolving\", ()=>{\n                resolverErrors = $1d44efb04eab6ceb$var$resolveGrammar2({\n                    rules: (0, $76RTQ.values_default)(this.gastProductionsCache)\n                });\n                this.definitionErrors = this.definitionErrors.concat(resolverErrors);\n            });\n            this.TRACE_INIT(\"Grammar Validations\", ()=>{\n                if ((0, $f34bP.isEmpty_default)(resolverErrors) && this.skipValidations === false) {\n                    const validationErrors = $1d44efb04eab6ceb$var$validateGrammar2({\n                        rules: (0, $76RTQ.values_default)(this.gastProductionsCache),\n                        tokenTypes: (0, $76RTQ.values_default)(this.tokensMap),\n                        errMsgProvider: $1d44efb04eab6ceb$var$defaultGrammarValidatorErrorProvider,\n                        grammarName: className\n                    });\n                    const lookaheadValidationErrors = $1d44efb04eab6ceb$var$validateLookahead({\n                        lookaheadStrategy: this.lookaheadStrategy,\n                        rules: (0, $76RTQ.values_default)(this.gastProductionsCache),\n                        tokenTypes: (0, $76RTQ.values_default)(this.tokensMap),\n                        grammarName: className\n                    });\n                    this.definitionErrors = this.definitionErrors.concat(validationErrors, lookaheadValidationErrors);\n                }\n            });\n            if ((0, $f34bP.isEmpty_default)(this.definitionErrors)) {\n                if (this.recoveryEnabled) this.TRACE_INIT(\"computeAllProdsFollows\", ()=>{\n                    const allFollows = $1d44efb04eab6ceb$var$computeAllProdsFollows((0, $76RTQ.values_default)(this.gastProductionsCache));\n                    this.resyncFollows = allFollows;\n                });\n                this.TRACE_INIT(\"ComputeLookaheadFunctions\", ()=>{\n                    var _a, _b;\n                    (_b = (_a = this.lookaheadStrategy).initialize) === null || _b === void 0 || _b.call(_a, {\n                        rules: (0, $76RTQ.values_default)(this.gastProductionsCache)\n                    });\n                    this.preComputeLookaheadFunctions((0, $76RTQ.values_default)(this.gastProductionsCache));\n                });\n            }\n            if (!_Parser.DEFER_DEFINITION_ERRORS_HANDLING && !(0, $f34bP.isEmpty_default)(this.definitionErrors)) {\n                defErrorsMsgs = (0, $76RTQ.map_default)(this.definitionErrors, (defError)=>defError.message);\n                throw new Error(`Parser Definition Errors detected:\n ${defErrorsMsgs.join(\"\\n-------------------------------\\n\")}`);\n            }\n        });\n    }\n    constructor(tokenVocabulary, config){\n        this.definitionErrors = [];\n        this.selfAnalysisDone = false;\n        const that = this;\n        that.initErrorHandler(config);\n        that.initLexerAdapter();\n        that.initLooksAhead(config);\n        that.initRecognizerEngine(tokenVocabulary, config);\n        that.initRecoverable(config);\n        that.initTreeBuilder(config);\n        that.initContentAssist();\n        that.initGastRecorder(config);\n        that.initPerformanceTracer(config);\n        if ((0, $76RTQ.has_default)(config, \"ignoredIssues\")) throw new Error(\"The <ignoredIssues> IParserConfig property has been deprecated.\\n\tPlease use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\tSee: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\tFor further details.\");\n        this.skipValidations = (0, $76RTQ.has_default)(config, \"skipValidations\") ? config.skipValidations : $1d44efb04eab6ceb$var$DEFAULT_PARSER_CONFIG.skipValidations;\n    }\n};\n$1d44efb04eab6ceb$var$Parser.DEFER_DEFINITION_ERRORS_HANDLING = false;\n$1d44efb04eab6ceb$var$applyMixins($1d44efb04eab6ceb$var$Parser, [\n    $1d44efb04eab6ceb$var$Recoverable,\n    $1d44efb04eab6ceb$var$LooksAhead,\n    $1d44efb04eab6ceb$var$TreeBuilder,\n    $1d44efb04eab6ceb$var$LexerAdapter,\n    $1d44efb04eab6ceb$var$RecognizerEngine,\n    $1d44efb04eab6ceb$var$RecognizerApi,\n    $1d44efb04eab6ceb$var$ErrorHandler,\n    $1d44efb04eab6ceb$var$ContentAssist,\n    $1d44efb04eab6ceb$var$GastRecorder,\n    $1d44efb04eab6ceb$var$PerformanceTracer\n]);\nvar $1d44efb04eab6ceb$var$EmbeddedActionsParser = class extends $1d44efb04eab6ceb$var$Parser {\n    static{\n        (0, $7xxrv.__name)(this, \"EmbeddedActionsParser\");\n    }\n    constructor(tokenVocabulary, config = $1d44efb04eab6ceb$var$DEFAULT_PARSER_CONFIG){\n        const configClone = (0, $76RTQ.clone_default)(config);\n        configClone.outputCst = false;\n        super(tokenVocabulary, configClone);\n    }\n};\n// ../../node_modules/.pnpm/chevrotain-allstar@0.3.1_chevrotain@11.0.3/node_modules/chevrotain-allstar/lib/atn.js\nfunction $1d44efb04eab6ceb$var$buildATNKey(rule, type, occurrence) {\n    return `${rule.name}_${type}_${occurrence}`;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildATNKey, \"buildATNKey\");\nvar $1d44efb04eab6ceb$var$ATN_BASIC = 1;\nvar $1d44efb04eab6ceb$var$ATN_RULE_START = 2;\nvar $1d44efb04eab6ceb$var$ATN_PLUS_BLOCK_START = 4;\nvar $1d44efb04eab6ceb$var$ATN_STAR_BLOCK_START = 5;\nvar $1d44efb04eab6ceb$var$ATN_RULE_STOP = 7;\nvar $1d44efb04eab6ceb$var$ATN_BLOCK_END = 8;\nvar $1d44efb04eab6ceb$var$ATN_STAR_LOOP_BACK = 9;\nvar $1d44efb04eab6ceb$var$ATN_STAR_LOOP_ENTRY = 10;\nvar $1d44efb04eab6ceb$var$ATN_PLUS_LOOP_BACK = 11;\nvar $1d44efb04eab6ceb$var$ATN_LOOP_END = 12;\nvar $1d44efb04eab6ceb$var$AbstractTransition = class {\n    static{\n        (0, $7xxrv.__name)(this, \"AbstractTransition\");\n    }\n    constructor(target){\n        this.target = target;\n    }\n    isEpsilon() {\n        return false;\n    }\n};\nvar $1d44efb04eab6ceb$var$AtomTransition = class extends $1d44efb04eab6ceb$var$AbstractTransition {\n    static{\n        (0, $7xxrv.__name)(this, \"AtomTransition\");\n    }\n    constructor(target, tokenType){\n        super(target);\n        this.tokenType = tokenType;\n    }\n};\nvar $1d44efb04eab6ceb$var$EpsilonTransition = class extends $1d44efb04eab6ceb$var$AbstractTransition {\n    static{\n        (0, $7xxrv.__name)(this, \"EpsilonTransition\");\n    }\n    constructor(target){\n        super(target);\n    }\n    isEpsilon() {\n        return true;\n    }\n};\nvar $1d44efb04eab6ceb$var$RuleTransition = class extends $1d44efb04eab6ceb$var$AbstractTransition {\n    static{\n        (0, $7xxrv.__name)(this, \"RuleTransition\");\n    }\n    constructor(ruleStart, rule, followState){\n        super(ruleStart);\n        this.rule = rule;\n        this.followState = followState;\n    }\n    isEpsilon() {\n        return true;\n    }\n};\nfunction $1d44efb04eab6ceb$var$createATN(rules) {\n    const atn = {\n        decisionMap: {},\n        decisionStates: [],\n        ruleToStartState: /* @__PURE__ */ new Map(),\n        ruleToStopState: /* @__PURE__ */ new Map(),\n        states: []\n    };\n    $1d44efb04eab6ceb$var$createRuleStartAndStopATNStates(atn, rules);\n    const ruleLength = rules.length;\n    for(let i = 0; i < ruleLength; i++){\n        const rule = rules[i];\n        const ruleBlock = $1d44efb04eab6ceb$var$block(atn, rule, rule);\n        if (ruleBlock === void 0) continue;\n        $1d44efb04eab6ceb$var$buildRuleHandle(atn, rule, ruleBlock);\n    }\n    return atn;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$createATN, \"createATN\");\nfunction $1d44efb04eab6ceb$var$createRuleStartAndStopATNStates(atn, rules) {\n    const ruleLength = rules.length;\n    for(let i = 0; i < ruleLength; i++){\n        const rule = rules[i];\n        const start = $1d44efb04eab6ceb$var$newState(atn, rule, void 0, {\n            type: $1d44efb04eab6ceb$var$ATN_RULE_START\n        });\n        const stop = $1d44efb04eab6ceb$var$newState(atn, rule, void 0, {\n            type: $1d44efb04eab6ceb$var$ATN_RULE_STOP\n        });\n        start.stop = stop;\n        atn.ruleToStartState.set(rule, start);\n        atn.ruleToStopState.set(rule, stop);\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$createRuleStartAndStopATNStates, \"createRuleStartAndStopATNStates\");\nfunction $1d44efb04eab6ceb$var$atom(atn, rule, production) {\n    if (production instanceof $1d44efb04eab6ceb$var$Terminal) return $1d44efb04eab6ceb$var$tokenRef(atn, rule, production.terminalType, production);\n    else if (production instanceof $1d44efb04eab6ceb$var$NonTerminal) return $1d44efb04eab6ceb$var$ruleRef(atn, rule, production);\n    else if (production instanceof $1d44efb04eab6ceb$var$Alternation) return $1d44efb04eab6ceb$var$alternation(atn, rule, production);\n    else if (production instanceof $1d44efb04eab6ceb$var$Option) return $1d44efb04eab6ceb$var$option(atn, rule, production);\n    else if (production instanceof $1d44efb04eab6ceb$var$Repetition) return $1d44efb04eab6ceb$var$repetition(atn, rule, production);\n    else if (production instanceof $1d44efb04eab6ceb$var$RepetitionWithSeparator) return $1d44efb04eab6ceb$var$repetitionSep(atn, rule, production);\n    else if (production instanceof $1d44efb04eab6ceb$var$RepetitionMandatory) return $1d44efb04eab6ceb$var$repetitionMandatory(atn, rule, production);\n    else if (production instanceof $1d44efb04eab6ceb$var$RepetitionMandatoryWithSeparator) return $1d44efb04eab6ceb$var$repetitionMandatorySep(atn, rule, production);\n    else return $1d44efb04eab6ceb$var$block(atn, rule, production);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$atom, \"atom\");\nfunction $1d44efb04eab6ceb$var$repetition(atn, rule, repetition2) {\n    const starState = $1d44efb04eab6ceb$var$newState(atn, rule, repetition2, {\n        type: $1d44efb04eab6ceb$var$ATN_STAR_BLOCK_START\n    });\n    $1d44efb04eab6ceb$var$defineDecisionState(atn, starState);\n    const handle = $1d44efb04eab6ceb$var$makeAlts(atn, rule, starState, repetition2, $1d44efb04eab6ceb$var$block(atn, rule, repetition2));\n    return $1d44efb04eab6ceb$var$star(atn, rule, repetition2, handle);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$repetition, \"repetition\");\nfunction $1d44efb04eab6ceb$var$repetitionSep(atn, rule, repetition2) {\n    const starState = $1d44efb04eab6ceb$var$newState(atn, rule, repetition2, {\n        type: $1d44efb04eab6ceb$var$ATN_STAR_BLOCK_START\n    });\n    $1d44efb04eab6ceb$var$defineDecisionState(atn, starState);\n    const handle = $1d44efb04eab6ceb$var$makeAlts(atn, rule, starState, repetition2, $1d44efb04eab6ceb$var$block(atn, rule, repetition2));\n    const sep = $1d44efb04eab6ceb$var$tokenRef(atn, rule, repetition2.separator, repetition2);\n    return $1d44efb04eab6ceb$var$star(atn, rule, repetition2, handle, sep);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$repetitionSep, \"repetitionSep\");\nfunction $1d44efb04eab6ceb$var$repetitionMandatory(atn, rule, repetition2) {\n    const plusState = $1d44efb04eab6ceb$var$newState(atn, rule, repetition2, {\n        type: $1d44efb04eab6ceb$var$ATN_PLUS_BLOCK_START\n    });\n    $1d44efb04eab6ceb$var$defineDecisionState(atn, plusState);\n    const handle = $1d44efb04eab6ceb$var$makeAlts(atn, rule, plusState, repetition2, $1d44efb04eab6ceb$var$block(atn, rule, repetition2));\n    return $1d44efb04eab6ceb$var$plus(atn, rule, repetition2, handle);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$repetitionMandatory, \"repetitionMandatory\");\nfunction $1d44efb04eab6ceb$var$repetitionMandatorySep(atn, rule, repetition2) {\n    const plusState = $1d44efb04eab6ceb$var$newState(atn, rule, repetition2, {\n        type: $1d44efb04eab6ceb$var$ATN_PLUS_BLOCK_START\n    });\n    $1d44efb04eab6ceb$var$defineDecisionState(atn, plusState);\n    const handle = $1d44efb04eab6ceb$var$makeAlts(atn, rule, plusState, repetition2, $1d44efb04eab6ceb$var$block(atn, rule, repetition2));\n    const sep = $1d44efb04eab6ceb$var$tokenRef(atn, rule, repetition2.separator, repetition2);\n    return $1d44efb04eab6ceb$var$plus(atn, rule, repetition2, handle, sep);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$repetitionMandatorySep, \"repetitionMandatorySep\");\nfunction $1d44efb04eab6ceb$var$alternation(atn, rule, alternation2) {\n    const start = $1d44efb04eab6ceb$var$newState(atn, rule, alternation2, {\n        type: $1d44efb04eab6ceb$var$ATN_BASIC\n    });\n    $1d44efb04eab6ceb$var$defineDecisionState(atn, start);\n    const alts = (0, $76RTQ.map_default)(alternation2.definition, (e)=>$1d44efb04eab6ceb$var$atom(atn, rule, e));\n    const handle = $1d44efb04eab6ceb$var$makeAlts(atn, rule, start, alternation2, ...alts);\n    return handle;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$alternation, \"alternation\");\nfunction $1d44efb04eab6ceb$var$option(atn, rule, option2) {\n    const start = $1d44efb04eab6ceb$var$newState(atn, rule, option2, {\n        type: $1d44efb04eab6ceb$var$ATN_BASIC\n    });\n    $1d44efb04eab6ceb$var$defineDecisionState(atn, start);\n    const handle = $1d44efb04eab6ceb$var$makeAlts(atn, rule, start, option2, $1d44efb04eab6ceb$var$block(atn, rule, option2));\n    return $1d44efb04eab6ceb$var$optional(atn, rule, option2, handle);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$option, \"option\");\nfunction $1d44efb04eab6ceb$var$block(atn, rule, block2) {\n    const handles = (0, $76RTQ.filter_default)((0, $76RTQ.map_default)(block2.definition, (e)=>$1d44efb04eab6ceb$var$atom(atn, rule, e)), (e)=>e !== void 0);\n    if (handles.length === 1) return handles[0];\n    else if (handles.length === 0) return void 0;\n    else return $1d44efb04eab6ceb$var$makeBlock(atn, handles);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$block, \"block\");\nfunction $1d44efb04eab6ceb$var$plus(atn, rule, plus2, handle, sep) {\n    const blkStart = handle.left;\n    const blkEnd = handle.right;\n    const loop = $1d44efb04eab6ceb$var$newState(atn, rule, plus2, {\n        type: $1d44efb04eab6ceb$var$ATN_PLUS_LOOP_BACK\n    });\n    $1d44efb04eab6ceb$var$defineDecisionState(atn, loop);\n    const end = $1d44efb04eab6ceb$var$newState(atn, rule, plus2, {\n        type: $1d44efb04eab6ceb$var$ATN_LOOP_END\n    });\n    blkStart.loopback = loop;\n    end.loopback = loop;\n    atn.decisionMap[$1d44efb04eab6ceb$var$buildATNKey(rule, sep ? \"RepetitionMandatoryWithSeparator\" : \"RepetitionMandatory\", plus2.idx)] = loop;\n    $1d44efb04eab6ceb$var$epsilon(blkEnd, loop);\n    if (sep === void 0) {\n        $1d44efb04eab6ceb$var$epsilon(loop, blkStart);\n        $1d44efb04eab6ceb$var$epsilon(loop, end);\n    } else {\n        $1d44efb04eab6ceb$var$epsilon(loop, end);\n        $1d44efb04eab6ceb$var$epsilon(loop, sep.left);\n        $1d44efb04eab6ceb$var$epsilon(sep.right, blkStart);\n    }\n    return {\n        left: blkStart,\n        right: end\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$plus, \"plus\");\nfunction $1d44efb04eab6ceb$var$star(atn, rule, star2, handle, sep) {\n    const start = handle.left;\n    const end = handle.right;\n    const entry = $1d44efb04eab6ceb$var$newState(atn, rule, star2, {\n        type: $1d44efb04eab6ceb$var$ATN_STAR_LOOP_ENTRY\n    });\n    $1d44efb04eab6ceb$var$defineDecisionState(atn, entry);\n    const loopEnd = $1d44efb04eab6ceb$var$newState(atn, rule, star2, {\n        type: $1d44efb04eab6ceb$var$ATN_LOOP_END\n    });\n    const loop = $1d44efb04eab6ceb$var$newState(atn, rule, star2, {\n        type: $1d44efb04eab6ceb$var$ATN_STAR_LOOP_BACK\n    });\n    entry.loopback = loop;\n    loopEnd.loopback = loop;\n    $1d44efb04eab6ceb$var$epsilon(entry, start);\n    $1d44efb04eab6ceb$var$epsilon(entry, loopEnd);\n    $1d44efb04eab6ceb$var$epsilon(end, loop);\n    if (sep !== void 0) {\n        $1d44efb04eab6ceb$var$epsilon(loop, loopEnd);\n        $1d44efb04eab6ceb$var$epsilon(loop, sep.left);\n        $1d44efb04eab6ceb$var$epsilon(sep.right, start);\n    } else $1d44efb04eab6ceb$var$epsilon(loop, entry);\n    atn.decisionMap[$1d44efb04eab6ceb$var$buildATNKey(rule, sep ? \"RepetitionWithSeparator\" : \"Repetition\", star2.idx)] = entry;\n    return {\n        left: entry,\n        right: loopEnd\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$star, \"star\");\nfunction $1d44efb04eab6ceb$var$optional(atn, rule, optional2, handle) {\n    const start = handle.left;\n    const end = handle.right;\n    $1d44efb04eab6ceb$var$epsilon(start, end);\n    atn.decisionMap[$1d44efb04eab6ceb$var$buildATNKey(rule, \"Option\", optional2.idx)] = start;\n    return handle;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$optional, \"optional\");\nfunction $1d44efb04eab6ceb$var$defineDecisionState(atn, state) {\n    atn.decisionStates.push(state);\n    state.decision = atn.decisionStates.length - 1;\n    return state.decision;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$defineDecisionState, \"defineDecisionState\");\nfunction $1d44efb04eab6ceb$var$makeAlts(atn, rule, start, production, ...alts) {\n    const end = $1d44efb04eab6ceb$var$newState(atn, rule, production, {\n        type: $1d44efb04eab6ceb$var$ATN_BLOCK_END,\n        start: start\n    });\n    start.end = end;\n    for (const alt of alts)if (alt !== void 0) {\n        $1d44efb04eab6ceb$var$epsilon(start, alt.left);\n        $1d44efb04eab6ceb$var$epsilon(alt.right, end);\n    } else $1d44efb04eab6ceb$var$epsilon(start, end);\n    const handle = {\n        left: start,\n        right: end\n    };\n    atn.decisionMap[$1d44efb04eab6ceb$var$buildATNKey(rule, $1d44efb04eab6ceb$var$getProdType2(production), production.idx)] = start;\n    return handle;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$makeAlts, \"makeAlts\");\nfunction $1d44efb04eab6ceb$var$getProdType2(production) {\n    if (production instanceof $1d44efb04eab6ceb$var$Alternation) return \"Alternation\";\n    else if (production instanceof $1d44efb04eab6ceb$var$Option) return \"Option\";\n    else if (production instanceof $1d44efb04eab6ceb$var$Repetition) return \"Repetition\";\n    else if (production instanceof $1d44efb04eab6ceb$var$RepetitionWithSeparator) return \"RepetitionWithSeparator\";\n    else if (production instanceof $1d44efb04eab6ceb$var$RepetitionMandatory) return \"RepetitionMandatory\";\n    else if (production instanceof $1d44efb04eab6ceb$var$RepetitionMandatoryWithSeparator) return \"RepetitionMandatoryWithSeparator\";\n    else throw new Error(\"Invalid production type encountered\");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getProdType2, \"getProdType\");\nfunction $1d44efb04eab6ceb$var$makeBlock(atn, alts) {\n    const altsLength = alts.length;\n    for(let i = 0; i < altsLength - 1; i++){\n        const handle = alts[i];\n        let transition;\n        if (handle.left.transitions.length === 1) transition = handle.left.transitions[0];\n        const isRuleTransition = transition instanceof $1d44efb04eab6ceb$var$RuleTransition;\n        const ruleTransition = transition;\n        const next = alts[i + 1].left;\n        if (handle.left.type === $1d44efb04eab6ceb$var$ATN_BASIC && handle.right.type === $1d44efb04eab6ceb$var$ATN_BASIC && transition !== void 0 && (isRuleTransition && ruleTransition.followState === handle.right || transition.target === handle.right)) {\n            if (isRuleTransition) ruleTransition.followState = next;\n            else transition.target = next;\n            $1d44efb04eab6ceb$var$removeState(atn, handle.right);\n        } else $1d44efb04eab6ceb$var$epsilon(handle.right, next);\n    }\n    const first2 = alts[0];\n    const last = alts[altsLength - 1];\n    return {\n        left: first2.left,\n        right: last.right\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$makeBlock, \"makeBlock\");\nfunction $1d44efb04eab6ceb$var$tokenRef(atn, rule, tokenType, production) {\n    const left = $1d44efb04eab6ceb$var$newState(atn, rule, production, {\n        type: $1d44efb04eab6ceb$var$ATN_BASIC\n    });\n    const right = $1d44efb04eab6ceb$var$newState(atn, rule, production, {\n        type: $1d44efb04eab6ceb$var$ATN_BASIC\n    });\n    $1d44efb04eab6ceb$var$addTransition(left, new $1d44efb04eab6ceb$var$AtomTransition(right, tokenType));\n    return {\n        left: left,\n        right: right\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$tokenRef, \"tokenRef\");\nfunction $1d44efb04eab6ceb$var$ruleRef(atn, currentRule, nonTerminal) {\n    const rule = nonTerminal.referencedRule;\n    const start = atn.ruleToStartState.get(rule);\n    const left = $1d44efb04eab6ceb$var$newState(atn, currentRule, nonTerminal, {\n        type: $1d44efb04eab6ceb$var$ATN_BASIC\n    });\n    const right = $1d44efb04eab6ceb$var$newState(atn, currentRule, nonTerminal, {\n        type: $1d44efb04eab6ceb$var$ATN_BASIC\n    });\n    const call = new $1d44efb04eab6ceb$var$RuleTransition(start, rule, right);\n    $1d44efb04eab6ceb$var$addTransition(left, call);\n    return {\n        left: left,\n        right: right\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$ruleRef, \"ruleRef\");\nfunction $1d44efb04eab6ceb$var$buildRuleHandle(atn, rule, block2) {\n    const start = atn.ruleToStartState.get(rule);\n    $1d44efb04eab6ceb$var$epsilon(start, block2.left);\n    const stop = atn.ruleToStopState.get(rule);\n    $1d44efb04eab6ceb$var$epsilon(block2.right, stop);\n    const handle = {\n        left: start,\n        right: stop\n    };\n    return handle;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildRuleHandle, \"buildRuleHandle\");\nfunction $1d44efb04eab6ceb$var$epsilon(a, b) {\n    const transition = new $1d44efb04eab6ceb$var$EpsilonTransition(b);\n    $1d44efb04eab6ceb$var$addTransition(a, transition);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$epsilon, \"epsilon\");\nfunction $1d44efb04eab6ceb$var$newState(atn, rule, production, partial) {\n    const t = Object.assign({\n        atn: atn,\n        production: production,\n        epsilonOnlyTransitions: false,\n        rule: rule,\n        transitions: [],\n        nextTokenWithinRule: [],\n        stateNumber: atn.states.length\n    }, partial);\n    atn.states.push(t);\n    return t;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$newState, \"newState\");\nfunction $1d44efb04eab6ceb$var$addTransition(state, transition) {\n    if (state.transitions.length === 0) state.epsilonOnlyTransitions = transition.isEpsilon();\n    state.transitions.push(transition);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$addTransition, \"addTransition\");\nfunction $1d44efb04eab6ceb$var$removeState(atn, state) {\n    atn.states.splice(atn.states.indexOf(state), 1);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$removeState, \"removeState\");\n// ../../node_modules/.pnpm/chevrotain-allstar@0.3.1_chevrotain@11.0.3/node_modules/chevrotain-allstar/lib/dfa.js\nvar $1d44efb04eab6ceb$var$DFA_ERROR = {};\nvar $1d44efb04eab6ceb$var$ATNConfigSet = class {\n    static{\n        (0, $7xxrv.__name)(this, \"ATNConfigSet\");\n    }\n    constructor(){\n        this.map = {};\n        this.configs = [];\n    }\n    get size() {\n        return this.configs.length;\n    }\n    finalize() {\n        this.map = {};\n    }\n    add(config) {\n        const key = $1d44efb04eab6ceb$var$getATNConfigKey(config);\n        if (!(key in this.map)) {\n            this.map[key] = this.configs.length;\n            this.configs.push(config);\n        }\n    }\n    get elements() {\n        return this.configs;\n    }\n    get alts() {\n        return (0, $76RTQ.map_default)(this.configs, (e)=>e.alt);\n    }\n    get key() {\n        let value = \"\";\n        for(const k in this.map)value += k + \":\";\n        return value;\n    }\n};\nfunction $1d44efb04eab6ceb$var$getATNConfigKey(config, alt = true) {\n    return `${alt ? `a${config.alt}` : \"\"}s${config.state.stateNumber}:${config.stack.map((e)=>e.stateNumber.toString()).join(\"_\")}`;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getATNConfigKey, \"getATNConfigKey\");\n// ../../node_modules/.pnpm/chevrotain-allstar@0.3.1_chevrotain@11.0.3/node_modules/chevrotain-allstar/lib/all-star-lookahead.js\nfunction $1d44efb04eab6ceb$var$createDFACache(startState, decision) {\n    const map = {};\n    return (predicateSet)=>{\n        const key = predicateSet.toString();\n        let existing = map[key];\n        if (existing !== void 0) return existing;\n        else {\n            existing = {\n                atnStartState: startState,\n                decision: decision,\n                states: {}\n            };\n            map[key] = existing;\n            return existing;\n        }\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$createDFACache, \"createDFACache\");\nvar $1d44efb04eab6ceb$var$PredicateSet = class {\n    static{\n        (0, $7xxrv.__name)(this, \"PredicateSet\");\n    }\n    constructor(){\n        this.predicates = [];\n    }\n    is(index) {\n        return index >= this.predicates.length || this.predicates[index];\n    }\n    set(index, value) {\n        this.predicates[index] = value;\n    }\n    toString() {\n        let value = \"\";\n        const size = this.predicates.length;\n        for(let i = 0; i < size; i++)value += this.predicates[i] === true ? \"1\" : \"0\";\n        return value;\n    }\n};\nvar $1d44efb04eab6ceb$var$EMPTY_PREDICATES = new $1d44efb04eab6ceb$var$PredicateSet();\nvar $1d44efb04eab6ceb$var$LLStarLookaheadStrategy = class extends $1d44efb04eab6ceb$var$LLkLookaheadStrategy {\n    static{\n        (0, $7xxrv.__name)(this, \"LLStarLookaheadStrategy\");\n    }\n    constructor(options){\n        var _a;\n        super();\n        this.logging = (_a = options === null || options === void 0 ? void 0 : options.logging) !== null && _a !== void 0 ? _a : (message)=>console.log(message);\n    }\n    initialize(options) {\n        this.atn = $1d44efb04eab6ceb$var$createATN(options.rules);\n        this.dfas = $1d44efb04eab6ceb$var$initATNSimulator(this.atn);\n    }\n    validateAmbiguousAlternationAlternatives() {\n        return [];\n    }\n    validateEmptyOrAlternatives() {\n        return [];\n    }\n    buildLookaheadForAlternation(options) {\n        const { prodOccurrence: prodOccurrence, rule: rule, hasPredicates: hasPredicates, dynamicTokensEnabled: dynamicTokensEnabled } = options;\n        const dfas = this.dfas;\n        const logging = this.logging;\n        const key = $1d44efb04eab6ceb$var$buildATNKey(rule, \"Alternation\", prodOccurrence);\n        const decisionState = this.atn.decisionMap[key];\n        const decisionIndex = decisionState.decision;\n        const partialAlts = (0, $76RTQ.map_default)($1d44efb04eab6ceb$var$getLookaheadPaths({\n            maxLookahead: 1,\n            occurrence: prodOccurrence,\n            prodType: \"Alternation\",\n            rule: rule\n        }), (currAlt)=>(0, $76RTQ.map_default)(currAlt, (path)=>path[0]));\n        if ($1d44efb04eab6ceb$var$isLL1Sequence(partialAlts, false) && !dynamicTokensEnabled) {\n            const choiceToAlt = (0, $76RTQ.reduce_default)(partialAlts, (result, currAlt, idx)=>{\n                (0, $76RTQ.forEach_default)(currAlt, (currTokType)=>{\n                    if (currTokType) {\n                        result[currTokType.tokenTypeIdx] = idx;\n                        (0, $76RTQ.forEach_default)(currTokType.categoryMatches, (currExtendingType)=>{\n                            result[currExtendingType] = idx;\n                        });\n                    }\n                });\n                return result;\n            }, {});\n            if (hasPredicates) return function(orAlts) {\n                var _a;\n                const nextToken = this.LA(1);\n                const prediction = choiceToAlt[nextToken.tokenTypeIdx];\n                if (orAlts !== void 0 && prediction !== void 0) {\n                    const gate = (_a = orAlts[prediction]) === null || _a === void 0 ? void 0 : _a.GATE;\n                    if (gate !== void 0 && gate.call(this) === false) return void 0;\n                }\n                return prediction;\n            };\n            else return function() {\n                const nextToken = this.LA(1);\n                return choiceToAlt[nextToken.tokenTypeIdx];\n            };\n        } else if (hasPredicates) return function(orAlts) {\n            const predicates = new $1d44efb04eab6ceb$var$PredicateSet();\n            const length = orAlts === void 0 ? 0 : orAlts.length;\n            for(let i = 0; i < length; i++){\n                const gate = orAlts === null || orAlts === void 0 ? void 0 : orAlts[i].GATE;\n                predicates.set(i, gate === void 0 || gate.call(this));\n            }\n            const result = $1d44efb04eab6ceb$var$adaptivePredict.call(this, dfas, decisionIndex, predicates, logging);\n            return typeof result === \"number\" ? result : void 0;\n        };\n        else return function() {\n            const result = $1d44efb04eab6ceb$var$adaptivePredict.call(this, dfas, decisionIndex, $1d44efb04eab6ceb$var$EMPTY_PREDICATES, logging);\n            return typeof result === \"number\" ? result : void 0;\n        };\n    }\n    buildLookaheadForOptional(options) {\n        const { prodOccurrence: prodOccurrence, rule: rule, prodType: prodType, dynamicTokensEnabled: dynamicTokensEnabled } = options;\n        const dfas = this.dfas;\n        const logging = this.logging;\n        const key = $1d44efb04eab6ceb$var$buildATNKey(rule, prodType, prodOccurrence);\n        const decisionState = this.atn.decisionMap[key];\n        const decisionIndex = decisionState.decision;\n        const alts = (0, $76RTQ.map_default)($1d44efb04eab6ceb$var$getLookaheadPaths({\n            maxLookahead: 1,\n            occurrence: prodOccurrence,\n            prodType: prodType,\n            rule: rule\n        }), (e)=>{\n            return (0, $76RTQ.map_default)(e, (g)=>g[0]);\n        });\n        if ($1d44efb04eab6ceb$var$isLL1Sequence(alts) && alts[0][0] && !dynamicTokensEnabled) {\n            const alt = alts[0];\n            const singleTokensTypes = (0, $76RTQ.flatten_default)(alt);\n            if (singleTokensTypes.length === 1 && (0, $f34bP.isEmpty_default)(singleTokensTypes[0].categoryMatches)) {\n                const expectedTokenType = singleTokensTypes[0];\n                const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;\n                return function() {\n                    return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n                };\n            } else {\n                const choiceToAlt = (0, $76RTQ.reduce_default)(singleTokensTypes, (result, currTokType)=>{\n                    if (currTokType !== void 0) {\n                        result[currTokType.tokenTypeIdx] = true;\n                        (0, $76RTQ.forEach_default)(currTokType.categoryMatches, (currExtendingType)=>{\n                            result[currExtendingType] = true;\n                        });\n                    }\n                    return result;\n                }, {});\n                return function() {\n                    const nextToken = this.LA(1);\n                    return choiceToAlt[nextToken.tokenTypeIdx] === true;\n                };\n            }\n        }\n        return function() {\n            const result = $1d44efb04eab6ceb$var$adaptivePredict.call(this, dfas, decisionIndex, $1d44efb04eab6ceb$var$EMPTY_PREDICATES, logging);\n            return typeof result === \"object\" ? false : result === 0;\n        };\n    }\n};\nfunction $1d44efb04eab6ceb$var$isLL1Sequence(sequences, allowEmpty = true) {\n    const fullSet = /* @__PURE__ */ new Set();\n    for (const alt of sequences){\n        const altSet = /* @__PURE__ */ new Set();\n        for (const tokType of alt){\n            if (tokType === void 0) {\n                if (allowEmpty) break;\n                else return false;\n            }\n            const indices = [\n                tokType.tokenTypeIdx\n            ].concat(tokType.categoryMatches);\n            for (const index of indices)if (fullSet.has(index)) {\n                if (!altSet.has(index)) return false;\n            } else {\n                fullSet.add(index);\n                altSet.add(index);\n            }\n        }\n    }\n    return true;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isLL1Sequence, \"isLL1Sequence\");\nfunction $1d44efb04eab6ceb$var$initATNSimulator(atn) {\n    const decisionLength = atn.decisionStates.length;\n    const decisionToDFA = Array(decisionLength);\n    for(let i = 0; i < decisionLength; i++)decisionToDFA[i] = $1d44efb04eab6ceb$var$createDFACache(atn.decisionStates[i], i);\n    return decisionToDFA;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$initATNSimulator, \"initATNSimulator\");\nfunction $1d44efb04eab6ceb$var$adaptivePredict(dfaCaches, decision, predicateSet, logging) {\n    const dfa = dfaCaches[decision](predicateSet);\n    let start = dfa.start;\n    if (start === void 0) {\n        const closure2 = $1d44efb04eab6ceb$var$computeStartState(dfa.atnStartState);\n        start = $1d44efb04eab6ceb$var$addDFAState(dfa, $1d44efb04eab6ceb$var$newDFAState(closure2));\n        dfa.start = start;\n    }\n    const alt = $1d44efb04eab6ceb$var$performLookahead.apply(this, [\n        dfa,\n        start,\n        predicateSet,\n        logging\n    ]);\n    return alt;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$adaptivePredict, \"adaptivePredict\");\nfunction $1d44efb04eab6ceb$var$performLookahead(dfa, s0, predicateSet, logging) {\n    let previousD = s0;\n    let i = 1;\n    const path = [];\n    let t = this.LA(i++);\n    while(true){\n        let d = $1d44efb04eab6ceb$var$getExistingTargetState(previousD, t);\n        if (d === void 0) d = $1d44efb04eab6ceb$var$computeLookaheadTarget.apply(this, [\n            dfa,\n            previousD,\n            t,\n            i,\n            predicateSet,\n            logging\n        ]);\n        if (d === $1d44efb04eab6ceb$var$DFA_ERROR) return $1d44efb04eab6ceb$var$buildAdaptivePredictError(path, previousD, t);\n        if (d.isAcceptState === true) return d.prediction;\n        previousD = d;\n        path.push(t);\n        t = this.LA(i++);\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$performLookahead, \"performLookahead\");\nfunction $1d44efb04eab6ceb$var$computeLookaheadTarget(dfa, previousD, token, lookahead, predicateSet, logging) {\n    const reach = $1d44efb04eab6ceb$var$computeReachSet(previousD.configs, token, predicateSet);\n    if (reach.size === 0) {\n        $1d44efb04eab6ceb$var$addDFAEdge(dfa, previousD, token, $1d44efb04eab6ceb$var$DFA_ERROR);\n        return $1d44efb04eab6ceb$var$DFA_ERROR;\n    }\n    let newState2 = $1d44efb04eab6ceb$var$newDFAState(reach);\n    const predictedAlt = $1d44efb04eab6ceb$var$getUniqueAlt(reach, predicateSet);\n    if (predictedAlt !== void 0) {\n        newState2.isAcceptState = true;\n        newState2.prediction = predictedAlt;\n        newState2.configs.uniqueAlt = predictedAlt;\n    } else if ($1d44efb04eab6ceb$var$hasConflictTerminatingPrediction(reach)) {\n        const prediction = (0, $76RTQ.min_default)(reach.alts);\n        newState2.isAcceptState = true;\n        newState2.prediction = prediction;\n        newState2.configs.uniqueAlt = prediction;\n        $1d44efb04eab6ceb$var$reportLookaheadAmbiguity.apply(this, [\n            dfa,\n            lookahead,\n            reach.alts,\n            logging\n        ]);\n    }\n    newState2 = $1d44efb04eab6ceb$var$addDFAEdge(dfa, previousD, token, newState2);\n    return newState2;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$computeLookaheadTarget, \"computeLookaheadTarget\");\nfunction $1d44efb04eab6ceb$var$reportLookaheadAmbiguity(dfa, lookahead, ambiguityIndices, logging) {\n    const prefixPath = [];\n    for(let i = 1; i <= lookahead; i++)prefixPath.push(this.LA(i).tokenType);\n    const atnState = dfa.atnStartState;\n    const topLevelRule = atnState.rule;\n    const production = atnState.production;\n    const message = $1d44efb04eab6ceb$var$buildAmbiguityError({\n        topLevelRule: topLevelRule,\n        ambiguityIndices: ambiguityIndices,\n        production: production,\n        prefixPath: prefixPath\n    });\n    logging(message);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$reportLookaheadAmbiguity, \"reportLookaheadAmbiguity\");\nfunction $1d44efb04eab6ceb$var$buildAmbiguityError(options) {\n    const pathMsg = (0, $76RTQ.map_default)(options.prefixPath, (currtok)=>$1d44efb04eab6ceb$var$tokenLabel2(currtok)).join(\", \");\n    const occurrence = options.production.idx === 0 ? \"\" : options.production.idx;\n    let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\", \")}> in <${$1d44efb04eab6ceb$var$getProductionDslName2(options.production)}${occurrence}> inside <${options.topLevelRule.name}> Rule,\n<${pathMsg}> may appears as a prefix path in all these alternatives.\n`;\n    currMessage = currMessage + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\nFor Further details.`;\n    return currMessage;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildAmbiguityError, \"buildAmbiguityError\");\nfunction $1d44efb04eab6ceb$var$getProductionDslName2(prod) {\n    if (prod instanceof $1d44efb04eab6ceb$var$NonTerminal) return \"SUBRULE\";\n    else if (prod instanceof $1d44efb04eab6ceb$var$Option) return \"OPTION\";\n    else if (prod instanceof $1d44efb04eab6ceb$var$Alternation) return \"OR\";\n    else if (prod instanceof $1d44efb04eab6ceb$var$RepetitionMandatory) return \"AT_LEAST_ONE\";\n    else if (prod instanceof $1d44efb04eab6ceb$var$RepetitionMandatoryWithSeparator) return \"AT_LEAST_ONE_SEP\";\n    else if (prod instanceof $1d44efb04eab6ceb$var$RepetitionWithSeparator) return \"MANY_SEP\";\n    else if (prod instanceof $1d44efb04eab6ceb$var$Repetition) return \"MANY\";\n    else if (prod instanceof $1d44efb04eab6ceb$var$Terminal) return \"CONSUME\";\n    else throw Error(\"non exhaustive match\");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getProductionDslName2, \"getProductionDslName\");\nfunction $1d44efb04eab6ceb$var$buildAdaptivePredictError(path, previous, current) {\n    const nextTransitions = (0, $76RTQ.flatMap_default)(previous.configs.elements, (e)=>e.state.transitions);\n    const nextTokenTypes = (0, $76RTQ.uniqBy_default)(nextTransitions.filter((e)=>e instanceof $1d44efb04eab6ceb$var$AtomTransition).map((e)=>e.tokenType), (e)=>e.tokenTypeIdx);\n    return {\n        actualToken: current,\n        possibleTokenTypes: nextTokenTypes,\n        tokenPath: path\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildAdaptivePredictError, \"buildAdaptivePredictError\");\nfunction $1d44efb04eab6ceb$var$getExistingTargetState(state, token) {\n    return state.edges[token.tokenTypeIdx];\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getExistingTargetState, \"getExistingTargetState\");\nfunction $1d44efb04eab6ceb$var$computeReachSet(configs, token, predicateSet) {\n    const intermediate = new $1d44efb04eab6ceb$var$ATNConfigSet();\n    const skippedStopStates = [];\n    for (const c of configs.elements){\n        if (predicateSet.is(c.alt) === false) continue;\n        if (c.state.type === $1d44efb04eab6ceb$var$ATN_RULE_STOP) {\n            skippedStopStates.push(c);\n            continue;\n        }\n        const transitionLength = c.state.transitions.length;\n        for(let i = 0; i < transitionLength; i++){\n            const transition = c.state.transitions[i];\n            const target = $1d44efb04eab6ceb$var$getReachableTarget(transition, token);\n            if (target !== void 0) intermediate.add({\n                state: target,\n                alt: c.alt,\n                stack: c.stack\n            });\n        }\n    }\n    let reach;\n    if (skippedStopStates.length === 0 && intermediate.size === 1) reach = intermediate;\n    if (reach === void 0) {\n        reach = new $1d44efb04eab6ceb$var$ATNConfigSet();\n        for (const c of intermediate.elements)$1d44efb04eab6ceb$var$closure(c, reach);\n    }\n    if (skippedStopStates.length > 0 && !$1d44efb04eab6ceb$var$hasConfigInRuleStopState(reach)) for (const c of skippedStopStates)reach.add(c);\n    return reach;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$computeReachSet, \"computeReachSet\");\nfunction $1d44efb04eab6ceb$var$getReachableTarget(transition, token) {\n    if (transition instanceof $1d44efb04eab6ceb$var$AtomTransition && $1d44efb04eab6ceb$var$tokenMatcher(token, transition.tokenType)) return transition.target;\n    return void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getReachableTarget, \"getReachableTarget\");\nfunction $1d44efb04eab6ceb$var$getUniqueAlt(configs, predicateSet) {\n    let alt;\n    for (const c of configs.elements)if (predicateSet.is(c.alt) === true) {\n        if (alt === void 0) alt = c.alt;\n        else if (alt !== c.alt) return void 0;\n    }\n    return alt;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getUniqueAlt, \"getUniqueAlt\");\nfunction $1d44efb04eab6ceb$var$newDFAState(closure2) {\n    return {\n        configs: closure2,\n        edges: {},\n        isAcceptState: false,\n        prediction: -1\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$newDFAState, \"newDFAState\");\nfunction $1d44efb04eab6ceb$var$addDFAEdge(dfa, from, token, to) {\n    to = $1d44efb04eab6ceb$var$addDFAState(dfa, to);\n    from.edges[token.tokenTypeIdx] = to;\n    return to;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$addDFAEdge, \"addDFAEdge\");\nfunction $1d44efb04eab6ceb$var$addDFAState(dfa, state) {\n    if (state === $1d44efb04eab6ceb$var$DFA_ERROR) return state;\n    const mapKey = state.configs.key;\n    const existing = dfa.states[mapKey];\n    if (existing !== void 0) return existing;\n    state.configs.finalize();\n    dfa.states[mapKey] = state;\n    return state;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$addDFAState, \"addDFAState\");\nfunction $1d44efb04eab6ceb$var$computeStartState(atnState) {\n    const configs = new $1d44efb04eab6ceb$var$ATNConfigSet();\n    const numberOfTransitions = atnState.transitions.length;\n    for(let i = 0; i < numberOfTransitions; i++){\n        const target = atnState.transitions[i].target;\n        const config = {\n            state: target,\n            alt: i,\n            stack: []\n        };\n        $1d44efb04eab6ceb$var$closure(config, configs);\n    }\n    return configs;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$computeStartState, \"computeStartState\");\nfunction $1d44efb04eab6ceb$var$closure(config, configs) {\n    const p = config.state;\n    if (p.type === $1d44efb04eab6ceb$var$ATN_RULE_STOP) {\n        if (config.stack.length > 0) {\n            const atnStack = [\n                ...config.stack\n            ];\n            const followState = atnStack.pop();\n            const followConfig = {\n                state: followState,\n                alt: config.alt,\n                stack: atnStack\n            };\n            $1d44efb04eab6ceb$var$closure(followConfig, configs);\n        } else configs.add(config);\n        return;\n    }\n    if (!p.epsilonOnlyTransitions) configs.add(config);\n    const transitionLength = p.transitions.length;\n    for(let i = 0; i < transitionLength; i++){\n        const transition = p.transitions[i];\n        const c = $1d44efb04eab6ceb$var$getEpsilonTarget(config, transition);\n        if (c !== void 0) $1d44efb04eab6ceb$var$closure(c, configs);\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$closure, \"closure\");\nfunction $1d44efb04eab6ceb$var$getEpsilonTarget(config, transition) {\n    if (transition instanceof $1d44efb04eab6ceb$var$EpsilonTransition) return {\n        state: transition.target,\n        alt: config.alt,\n        stack: config.stack\n    };\n    else if (transition instanceof $1d44efb04eab6ceb$var$RuleTransition) {\n        const stack = [\n            ...config.stack,\n            transition.followState\n        ];\n        return {\n            state: transition.target,\n            alt: config.alt,\n            stack: stack\n        };\n    }\n    return void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getEpsilonTarget, \"getEpsilonTarget\");\nfunction $1d44efb04eab6ceb$var$hasConfigInRuleStopState(configs) {\n    for (const c of configs.elements){\n        if (c.state.type === $1d44efb04eab6ceb$var$ATN_RULE_STOP) return true;\n    }\n    return false;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$hasConfigInRuleStopState, \"hasConfigInRuleStopState\");\nfunction $1d44efb04eab6ceb$var$allConfigsInRuleStopStates(configs) {\n    for (const c of configs.elements){\n        if (c.state.type !== $1d44efb04eab6ceb$var$ATN_RULE_STOP) return false;\n    }\n    return true;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$allConfigsInRuleStopStates, \"allConfigsInRuleStopStates\");\nfunction $1d44efb04eab6ceb$var$hasConflictTerminatingPrediction(configs) {\n    if ($1d44efb04eab6ceb$var$allConfigsInRuleStopStates(configs)) return true;\n    const altSets = $1d44efb04eab6ceb$var$getConflictingAltSets(configs.elements);\n    const heuristic = $1d44efb04eab6ceb$var$hasConflictingAltSet(altSets) && !$1d44efb04eab6ceb$var$hasStateAssociatedWithOneAlt(altSets);\n    return heuristic;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$hasConflictTerminatingPrediction, \"hasConflictTerminatingPrediction\");\nfunction $1d44efb04eab6ceb$var$getConflictingAltSets(configs) {\n    const configToAlts = /* @__PURE__ */ new Map();\n    for (const c of configs){\n        const key = $1d44efb04eab6ceb$var$getATNConfigKey(c, false);\n        let alts = configToAlts.get(key);\n        if (alts === void 0) {\n            alts = {};\n            configToAlts.set(key, alts);\n        }\n        alts[c.alt] = true;\n    }\n    return configToAlts;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getConflictingAltSets, \"getConflictingAltSets\");\nfunction $1d44efb04eab6ceb$var$hasConflictingAltSet(altSets) {\n    for (const value of Array.from(altSets.values())){\n        if (Object.keys(value).length > 1) return true;\n    }\n    return false;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$hasConflictingAltSet, \"hasConflictingAltSet\");\nfunction $1d44efb04eab6ceb$var$hasStateAssociatedWithOneAlt(altSets) {\n    for (const value of Array.from(altSets.values())){\n        if (Object.keys(value).length === 1) return true;\n    }\n    return false;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$hasStateAssociatedWithOneAlt, \"hasStateAssociatedWithOneAlt\");\n// ../../node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/esm/main.js\nvar $1d44efb04eab6ceb$var$DocumentUri;\n(function(DocumentUri2) {\n    function is(value) {\n        return typeof value === \"string\";\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    DocumentUri2.is = is;\n})($1d44efb04eab6ceb$var$DocumentUri || ($1d44efb04eab6ceb$var$DocumentUri = {}));\nvar $1d44efb04eab6ceb$var$URI;\n(function(URI3) {\n    function is(value) {\n        return typeof value === \"string\";\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    URI3.is = is;\n})($1d44efb04eab6ceb$var$URI || ($1d44efb04eab6ceb$var$URI = {}));\nvar $1d44efb04eab6ceb$var$integer;\n(function(integer2) {\n    integer2.MIN_VALUE = -2147483648;\n    integer2.MAX_VALUE = 2147483647;\n    function is(value) {\n        return typeof value === \"number\" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    integer2.is = is;\n})($1d44efb04eab6ceb$var$integer || ($1d44efb04eab6ceb$var$integer = {}));\nvar $1d44efb04eab6ceb$var$uinteger;\n(function(uinteger2) {\n    uinteger2.MIN_VALUE = 0;\n    uinteger2.MAX_VALUE = 2147483647;\n    function is(value) {\n        return typeof value === \"number\" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    uinteger2.is = is;\n})($1d44efb04eab6ceb$var$uinteger || ($1d44efb04eab6ceb$var$uinteger = {}));\nvar $1d44efb04eab6ceb$var$Position;\n(function(Position2) {\n    function create(line, character) {\n        if (line === Number.MAX_VALUE) line = $1d44efb04eab6ceb$var$uinteger.MAX_VALUE;\n        if (character === Number.MAX_VALUE) character = $1d44efb04eab6ceb$var$uinteger.MAX_VALUE;\n        return {\n            line: line,\n            character: character\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    Position2.create = create;\n    function is(value) {\n        let candidate = value;\n        return $1d44efb04eab6ceb$var$Is.objectLiteral(candidate) && $1d44efb04eab6ceb$var$Is.uinteger(candidate.line) && $1d44efb04eab6ceb$var$Is.uinteger(candidate.character);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    Position2.is = is;\n})($1d44efb04eab6ceb$var$Position || ($1d44efb04eab6ceb$var$Position = {}));\nvar $1d44efb04eab6ceb$var$Range;\n(function(Range2) {\n    function create(one, two, three, four) {\n        if ($1d44efb04eab6ceb$var$Is.uinteger(one) && $1d44efb04eab6ceb$var$Is.uinteger(two) && $1d44efb04eab6ceb$var$Is.uinteger(three) && $1d44efb04eab6ceb$var$Is.uinteger(four)) return {\n            start: $1d44efb04eab6ceb$var$Position.create(one, two),\n            end: $1d44efb04eab6ceb$var$Position.create(three, four)\n        };\n        else if ($1d44efb04eab6ceb$var$Position.is(one) && $1d44efb04eab6ceb$var$Position.is(two)) return {\n            start: one,\n            end: two\n        };\n        else throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    Range2.create = create;\n    function is(value) {\n        let candidate = value;\n        return $1d44efb04eab6ceb$var$Is.objectLiteral(candidate) && $1d44efb04eab6ceb$var$Position.is(candidate.start) && $1d44efb04eab6ceb$var$Position.is(candidate.end);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    Range2.is = is;\n})($1d44efb04eab6ceb$var$Range || ($1d44efb04eab6ceb$var$Range = {}));\nvar $1d44efb04eab6ceb$var$Location;\n(function(Location2) {\n    function create(uri, range) {\n        return {\n            uri: uri,\n            range: range\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    Location2.create = create;\n    function is(value) {\n        let candidate = value;\n        return $1d44efb04eab6ceb$var$Is.objectLiteral(candidate) && $1d44efb04eab6ceb$var$Range.is(candidate.range) && ($1d44efb04eab6ceb$var$Is.string(candidate.uri) || $1d44efb04eab6ceb$var$Is.undefined(candidate.uri));\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    Location2.is = is;\n})($1d44efb04eab6ceb$var$Location || ($1d44efb04eab6ceb$var$Location = {}));\nvar $1d44efb04eab6ceb$var$LocationLink;\n(function(LocationLink2) {\n    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n        return {\n            targetUri: targetUri,\n            targetRange: targetRange,\n            targetSelectionRange: targetSelectionRange,\n            originSelectionRange: originSelectionRange\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    LocationLink2.create = create;\n    function is(value) {\n        let candidate = value;\n        return $1d44efb04eab6ceb$var$Is.objectLiteral(candidate) && $1d44efb04eab6ceb$var$Range.is(candidate.targetRange) && $1d44efb04eab6ceb$var$Is.string(candidate.targetUri) && $1d44efb04eab6ceb$var$Range.is(candidate.targetSelectionRange) && ($1d44efb04eab6ceb$var$Range.is(candidate.originSelectionRange) || $1d44efb04eab6ceb$var$Is.undefined(candidate.originSelectionRange));\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    LocationLink2.is = is;\n})($1d44efb04eab6ceb$var$LocationLink || ($1d44efb04eab6ceb$var$LocationLink = {}));\nvar $1d44efb04eab6ceb$var$Color;\n(function(Color2) {\n    function create(red, green, blue, alpha) {\n        return {\n            red: red,\n            green: green,\n            blue: blue,\n            alpha: alpha\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    Color2.create = create;\n    function is(value) {\n        const candidate = value;\n        return $1d44efb04eab6ceb$var$Is.objectLiteral(candidate) && $1d44efb04eab6ceb$var$Is.numberRange(candidate.red, 0, 1) && $1d44efb04eab6ceb$var$Is.numberRange(candidate.green, 0, 1) && $1d44efb04eab6ceb$var$Is.numberRange(candidate.blue, 0, 1) && $1d44efb04eab6ceb$var$Is.numberRange(candidate.alpha, 0, 1);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    Color2.is = is;\n})($1d44efb04eab6ceb$var$Color || ($1d44efb04eab6ceb$var$Color = {}));\nvar $1d44efb04eab6ceb$var$ColorInformation;\n(function(ColorInformation2) {\n    function create(range, color) {\n        return {\n            range: range,\n            color: color\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    ColorInformation2.create = create;\n    function is(value) {\n        const candidate = value;\n        return $1d44efb04eab6ceb$var$Is.objectLiteral(candidate) && $1d44efb04eab6ceb$var$Range.is(candidate.range) && $1d44efb04eab6ceb$var$Color.is(candidate.color);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    ColorInformation2.is = is;\n})($1d44efb04eab6ceb$var$ColorInformation || ($1d44efb04eab6ceb$var$ColorInformation = {}));\nvar $1d44efb04eab6ceb$var$ColorPresentation;\n(function(ColorPresentation2) {\n    function create(label, textEdit, additionalTextEdits) {\n        return {\n            label: label,\n            textEdit: textEdit,\n            additionalTextEdits: additionalTextEdits\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    ColorPresentation2.create = create;\n    function is(value) {\n        const candidate = value;\n        return $1d44efb04eab6ceb$var$Is.objectLiteral(candidate) && $1d44efb04eab6ceb$var$Is.string(candidate.label) && ($1d44efb04eab6ceb$var$Is.undefined(candidate.textEdit) || $1d44efb04eab6ceb$var$TextEdit.is(candidate)) && ($1d44efb04eab6ceb$var$Is.undefined(candidate.additionalTextEdits) || $1d44efb04eab6ceb$var$Is.typedArray(candidate.additionalTextEdits, $1d44efb04eab6ceb$var$TextEdit.is));\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    ColorPresentation2.is = is;\n})($1d44efb04eab6ceb$var$ColorPresentation || ($1d44efb04eab6ceb$var$ColorPresentation = {}));\nvar $1d44efb04eab6ceb$var$FoldingRangeKind;\n(function(FoldingRangeKind2) {\n    FoldingRangeKind2.Comment = \"comment\";\n    FoldingRangeKind2.Imports = \"imports\";\n    FoldingRangeKind2.Region = \"region\";\n})($1d44efb04eab6ceb$var$FoldingRangeKind || ($1d44efb04eab6ceb$var$FoldingRangeKind = {}));\nvar $1d44efb04eab6ceb$var$FoldingRange;\n(function(FoldingRange2) {\n    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\n        const result = {\n            startLine: startLine,\n            endLine: endLine\n        };\n        if ($1d44efb04eab6ceb$var$Is.defined(startCharacter)) result.startCharacter = startCharacter;\n        if ($1d44efb04eab6ceb$var$Is.defined(endCharacter)) result.endCharacter = endCharacter;\n        if ($1d44efb04eab6ceb$var$Is.defined(kind)) result.kind = kind;\n        if ($1d44efb04eab6ceb$var$Is.defined(collapsedText)) result.collapsedText = collapsedText;\n        return result;\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    FoldingRange2.create = create;\n    function is(value) {\n        const candidate = value;\n        return $1d44efb04eab6ceb$var$Is.objectLiteral(candidate) && $1d44efb04eab6ceb$var$Is.uinteger(candidate.startLine) && $1d44efb04eab6ceb$var$Is.uinteger(candidate.startLine) && ($1d44efb04eab6ceb$var$Is.undefined(candidate.startCharacter) || $1d44efb04eab6ceb$var$Is.uinteger(candidate.startCharacter)) && ($1d44efb04eab6ceb$var$Is.undefined(candidate.endCharacter) || $1d44efb04eab6ceb$var$Is.uinteger(candidate.endCharacter)) && ($1d44efb04eab6ceb$var$Is.undefined(candidate.kind) || $1d44efb04eab6ceb$var$Is.string(candidate.kind));\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    FoldingRange2.is = is;\n})($1d44efb04eab6ceb$var$FoldingRange || ($1d44efb04eab6ceb$var$FoldingRange = {}));\nvar $1d44efb04eab6ceb$var$DiagnosticRelatedInformation;\n(function(DiagnosticRelatedInformation2) {\n    function create(location, message) {\n        return {\n            location: location,\n            message: message\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    DiagnosticRelatedInformation2.create = create;\n    function is(value) {\n        let candidate = value;\n        return $1d44efb04eab6ceb$var$Is.defined(candidate) && $1d44efb04eab6ceb$var$Location.is(candidate.location) && $1d44efb04eab6ceb$var$Is.string(candidate.message);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    DiagnosticRelatedInformation2.is = is;\n})($1d44efb04eab6ceb$var$DiagnosticRelatedInformation || ($1d44efb04eab6ceb$var$DiagnosticRelatedInformation = {}));\nvar $1d44efb04eab6ceb$var$DiagnosticSeverity;\n(function(DiagnosticSeverity2) {\n    DiagnosticSeverity2.Error = 1;\n    DiagnosticSeverity2.Warning = 2;\n    DiagnosticSeverity2.Information = 3;\n    DiagnosticSeverity2.Hint = 4;\n})($1d44efb04eab6ceb$var$DiagnosticSeverity || ($1d44efb04eab6ceb$var$DiagnosticSeverity = {}));\nvar $1d44efb04eab6ceb$var$DiagnosticTag;\n(function(DiagnosticTag2) {\n    DiagnosticTag2.Unnecessary = 1;\n    DiagnosticTag2.Deprecated = 2;\n})($1d44efb04eab6ceb$var$DiagnosticTag || ($1d44efb04eab6ceb$var$DiagnosticTag = {}));\nvar $1d44efb04eab6ceb$var$CodeDescription;\n(function(CodeDescription2) {\n    function is(value) {\n        const candidate = value;\n        return $1d44efb04eab6ceb$var$Is.objectLiteral(candidate) && $1d44efb04eab6ceb$var$Is.string(candidate.href);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    CodeDescription2.is = is;\n})($1d44efb04eab6ceb$var$CodeDescription || ($1d44efb04eab6ceb$var$CodeDescription = {}));\nvar $1d44efb04eab6ceb$var$Diagnostic;\n(function(Diagnostic2) {\n    function create(range, message, severity, code, source, relatedInformation) {\n        let result = {\n            range: range,\n            message: message\n        };\n        if ($1d44efb04eab6ceb$var$Is.defined(severity)) result.severity = severity;\n        if ($1d44efb04eab6ceb$var$Is.defined(code)) result.code = code;\n        if ($1d44efb04eab6ceb$var$Is.defined(source)) result.source = source;\n        if ($1d44efb04eab6ceb$var$Is.defined(relatedInformation)) result.relatedInformation = relatedInformation;\n        return result;\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    Diagnostic2.create = create;\n    function is(value) {\n        var _a;\n        let candidate = value;\n        return $1d44efb04eab6ceb$var$Is.defined(candidate) && $1d44efb04eab6ceb$var$Range.is(candidate.range) && $1d44efb04eab6ceb$var$Is.string(candidate.message) && ($1d44efb04eab6ceb$var$Is.number(candidate.severity) || $1d44efb04eab6ceb$var$Is.undefined(candidate.severity)) && ($1d44efb04eab6ceb$var$Is.integer(candidate.code) || $1d44efb04eab6ceb$var$Is.string(candidate.code) || $1d44efb04eab6ceb$var$Is.undefined(candidate.code)) && ($1d44efb04eab6ceb$var$Is.undefined(candidate.codeDescription) || $1d44efb04eab6ceb$var$Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && ($1d44efb04eab6ceb$var$Is.string(candidate.source) || $1d44efb04eab6ceb$var$Is.undefined(candidate.source)) && ($1d44efb04eab6ceb$var$Is.undefined(candidate.relatedInformation) || $1d44efb04eab6ceb$var$Is.typedArray(candidate.relatedInformation, $1d44efb04eab6ceb$var$DiagnosticRelatedInformation.is));\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    Diagnostic2.is = is;\n})($1d44efb04eab6ceb$var$Diagnostic || ($1d44efb04eab6ceb$var$Diagnostic = {}));\nvar $1d44efb04eab6ceb$var$Command;\n(function(Command2) {\n    function create(title, command, ...args) {\n        let result = {\n            title: title,\n            command: command\n        };\n        if ($1d44efb04eab6ceb$var$Is.defined(args) && args.length > 0) result.arguments = args;\n        return result;\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    Command2.create = create;\n    function is(value) {\n        let candidate = value;\n        return $1d44efb04eab6ceb$var$Is.defined(candidate) && $1d44efb04eab6ceb$var$Is.string(candidate.title) && $1d44efb04eab6ceb$var$Is.string(candidate.command);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    Command2.is = is;\n})($1d44efb04eab6ceb$var$Command || ($1d44efb04eab6ceb$var$Command = {}));\nvar $1d44efb04eab6ceb$var$TextEdit;\n(function(TextEdit2) {\n    function replace(range, newText) {\n        return {\n            range: range,\n            newText: newText\n        };\n    }\n    (0, $7xxrv.__name)(replace, \"replace\");\n    TextEdit2.replace = replace;\n    function insert(position, newText) {\n        return {\n            range: {\n                start: position,\n                end: position\n            },\n            newText: newText\n        };\n    }\n    (0, $7xxrv.__name)(insert, \"insert\");\n    TextEdit2.insert = insert;\n    function del(range) {\n        return {\n            range: range,\n            newText: \"\"\n        };\n    }\n    (0, $7xxrv.__name)(del, \"del\");\n    TextEdit2.del = del;\n    function is(value) {\n        const candidate = value;\n        return $1d44efb04eab6ceb$var$Is.objectLiteral(candidate) && $1d44efb04eab6ceb$var$Is.string(candidate.newText) && $1d44efb04eab6ceb$var$Range.is(candidate.range);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    TextEdit2.is = is;\n})($1d44efb04eab6ceb$var$TextEdit || ($1d44efb04eab6ceb$var$TextEdit = {}));\nvar $1d44efb04eab6ceb$var$ChangeAnnotation;\n(function(ChangeAnnotation2) {\n    function create(label, needsConfirmation, description) {\n        const result = {\n            label: label\n        };\n        if (needsConfirmation !== void 0) result.needsConfirmation = needsConfirmation;\n        if (description !== void 0) result.description = description;\n        return result;\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    ChangeAnnotation2.create = create;\n    function is(value) {\n        const candidate = value;\n        return $1d44efb04eab6ceb$var$Is.objectLiteral(candidate) && $1d44efb04eab6ceb$var$Is.string(candidate.label) && ($1d44efb04eab6ceb$var$Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && ($1d44efb04eab6ceb$var$Is.string(candidate.description) || candidate.description === void 0);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    ChangeAnnotation2.is = is;\n})($1d44efb04eab6ceb$var$ChangeAnnotation || ($1d44efb04eab6ceb$var$ChangeAnnotation = {}));\nvar $1d44efb04eab6ceb$var$ChangeAnnotationIdentifier;\n(function(ChangeAnnotationIdentifier2) {\n    function is(value) {\n        const candidate = value;\n        return $1d44efb04eab6ceb$var$Is.string(candidate);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    ChangeAnnotationIdentifier2.is = is;\n})($1d44efb04eab6ceb$var$ChangeAnnotationIdentifier || ($1d44efb04eab6ceb$var$ChangeAnnotationIdentifier = {}));\nvar $1d44efb04eab6ceb$var$AnnotatedTextEdit;\n(function(AnnotatedTextEdit2) {\n    function replace(range, newText, annotation) {\n        return {\n            range: range,\n            newText: newText,\n            annotationId: annotation\n        };\n    }\n    (0, $7xxrv.__name)(replace, \"replace\");\n    AnnotatedTextEdit2.replace = replace;\n    function insert(position, newText, annotation) {\n        return {\n            range: {\n                start: position,\n                end: position\n            },\n            newText: newText,\n            annotationId: annotation\n        };\n    }\n    (0, $7xxrv.__name)(insert, \"insert\");\n    AnnotatedTextEdit2.insert = insert;\n    function del(range, annotation) {\n        return {\n            range: range,\n            newText: \"\",\n            annotationId: annotation\n        };\n    }\n    (0, $7xxrv.__name)(del, \"del\");\n    AnnotatedTextEdit2.del = del;\n    function is(value) {\n        const candidate = value;\n        return $1d44efb04eab6ceb$var$TextEdit.is(candidate) && ($1d44efb04eab6ceb$var$ChangeAnnotation.is(candidate.annotationId) || $1d44efb04eab6ceb$var$ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    AnnotatedTextEdit2.is = is;\n})($1d44efb04eab6ceb$var$AnnotatedTextEdit || ($1d44efb04eab6ceb$var$AnnotatedTextEdit = {}));\nvar $1d44efb04eab6ceb$var$TextDocumentEdit;\n(function(TextDocumentEdit2) {\n    function create(textDocument, edits) {\n        return {\n            textDocument: textDocument,\n            edits: edits\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    TextDocumentEdit2.create = create;\n    function is(value) {\n        let candidate = value;\n        return $1d44efb04eab6ceb$var$Is.defined(candidate) && $1d44efb04eab6ceb$var$OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    TextDocumentEdit2.is = is;\n})($1d44efb04eab6ceb$var$TextDocumentEdit || ($1d44efb04eab6ceb$var$TextDocumentEdit = {}));\nvar $1d44efb04eab6ceb$var$CreateFile;\n(function(CreateFile2) {\n    function create(uri, options, annotation) {\n        let result = {\n            kind: \"create\",\n            uri: uri\n        };\n        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) result.options = options;\n        if (annotation !== void 0) result.annotationId = annotation;\n        return result;\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    CreateFile2.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === \"create\" && $1d44efb04eab6ceb$var$Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || $1d44efb04eab6ceb$var$Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || $1d44efb04eab6ceb$var$Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || $1d44efb04eab6ceb$var$ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    CreateFile2.is = is;\n})($1d44efb04eab6ceb$var$CreateFile || ($1d44efb04eab6ceb$var$CreateFile = {}));\nvar $1d44efb04eab6ceb$var$RenameFile;\n(function(RenameFile2) {\n    function create(oldUri, newUri, options, annotation) {\n        let result = {\n            kind: \"rename\",\n            oldUri: oldUri,\n            newUri: newUri\n        };\n        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) result.options = options;\n        if (annotation !== void 0) result.annotationId = annotation;\n        return result;\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    RenameFile2.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === \"rename\" && $1d44efb04eab6ceb$var$Is.string(candidate.oldUri) && $1d44efb04eab6ceb$var$Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || $1d44efb04eab6ceb$var$Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || $1d44efb04eab6ceb$var$Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || $1d44efb04eab6ceb$var$ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    RenameFile2.is = is;\n})($1d44efb04eab6ceb$var$RenameFile || ($1d44efb04eab6ceb$var$RenameFile = {}));\nvar $1d44efb04eab6ceb$var$DeleteFile;\n(function(DeleteFile2) {\n    function create(uri, options, annotation) {\n        let result = {\n            kind: \"delete\",\n            uri: uri\n        };\n        if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) result.options = options;\n        if (annotation !== void 0) result.annotationId = annotation;\n        return result;\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    DeleteFile2.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === \"delete\" && $1d44efb04eab6ceb$var$Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || $1d44efb04eab6ceb$var$Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || $1d44efb04eab6ceb$var$Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || $1d44efb04eab6ceb$var$ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    DeleteFile2.is = is;\n})($1d44efb04eab6ceb$var$DeleteFile || ($1d44efb04eab6ceb$var$DeleteFile = {}));\nvar $1d44efb04eab6ceb$var$WorkspaceEdit;\n(function(WorkspaceEdit2) {\n    function is(value) {\n        let candidate = value;\n        return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every((change)=>{\n            if ($1d44efb04eab6ceb$var$Is.string(change.kind)) return $1d44efb04eab6ceb$var$CreateFile.is(change) || $1d44efb04eab6ceb$var$RenameFile.is(change) || $1d44efb04eab6ceb$var$DeleteFile.is(change);\n            else return $1d44efb04eab6ceb$var$TextDocumentEdit.is(change);\n        }));\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    WorkspaceEdit2.is = is;\n})($1d44efb04eab6ceb$var$WorkspaceEdit || ($1d44efb04eab6ceb$var$WorkspaceEdit = {}));\nvar $1d44efb04eab6ceb$var$TextDocumentIdentifier;\n(function(TextDocumentIdentifier2) {\n    function create(uri) {\n        return {\n            uri: uri\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    TextDocumentIdentifier2.create = create;\n    function is(value) {\n        let candidate = value;\n        return $1d44efb04eab6ceb$var$Is.defined(candidate) && $1d44efb04eab6ceb$var$Is.string(candidate.uri);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    TextDocumentIdentifier2.is = is;\n})($1d44efb04eab6ceb$var$TextDocumentIdentifier || ($1d44efb04eab6ceb$var$TextDocumentIdentifier = {}));\nvar $1d44efb04eab6ceb$var$VersionedTextDocumentIdentifier;\n(function(VersionedTextDocumentIdentifier2) {\n    function create(uri, version) {\n        return {\n            uri: uri,\n            version: version\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    VersionedTextDocumentIdentifier2.create = create;\n    function is(value) {\n        let candidate = value;\n        return $1d44efb04eab6ceb$var$Is.defined(candidate) && $1d44efb04eab6ceb$var$Is.string(candidate.uri) && $1d44efb04eab6ceb$var$Is.integer(candidate.version);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    VersionedTextDocumentIdentifier2.is = is;\n})($1d44efb04eab6ceb$var$VersionedTextDocumentIdentifier || ($1d44efb04eab6ceb$var$VersionedTextDocumentIdentifier = {}));\nvar $1d44efb04eab6ceb$var$OptionalVersionedTextDocumentIdentifier;\n(function(OptionalVersionedTextDocumentIdentifier2) {\n    function create(uri, version) {\n        return {\n            uri: uri,\n            version: version\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    OptionalVersionedTextDocumentIdentifier2.create = create;\n    function is(value) {\n        let candidate = value;\n        return $1d44efb04eab6ceb$var$Is.defined(candidate) && $1d44efb04eab6ceb$var$Is.string(candidate.uri) && (candidate.version === null || $1d44efb04eab6ceb$var$Is.integer(candidate.version));\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    OptionalVersionedTextDocumentIdentifier2.is = is;\n})($1d44efb04eab6ceb$var$OptionalVersionedTextDocumentIdentifier || ($1d44efb04eab6ceb$var$OptionalVersionedTextDocumentIdentifier = {}));\nvar $1d44efb04eab6ceb$var$TextDocumentItem;\n(function(TextDocumentItem2) {\n    function create(uri, languageId, version, text) {\n        return {\n            uri: uri,\n            languageId: languageId,\n            version: version,\n            text: text\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    TextDocumentItem2.create = create;\n    function is(value) {\n        let candidate = value;\n        return $1d44efb04eab6ceb$var$Is.defined(candidate) && $1d44efb04eab6ceb$var$Is.string(candidate.uri) && $1d44efb04eab6ceb$var$Is.string(candidate.languageId) && $1d44efb04eab6ceb$var$Is.integer(candidate.version) && $1d44efb04eab6ceb$var$Is.string(candidate.text);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    TextDocumentItem2.is = is;\n})($1d44efb04eab6ceb$var$TextDocumentItem || ($1d44efb04eab6ceb$var$TextDocumentItem = {}));\nvar $1d44efb04eab6ceb$var$MarkupKind;\n(function(MarkupKind2) {\n    MarkupKind2.PlainText = \"plaintext\";\n    MarkupKind2.Markdown = \"markdown\";\n    function is(value) {\n        const candidate = value;\n        return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    MarkupKind2.is = is;\n})($1d44efb04eab6ceb$var$MarkupKind || ($1d44efb04eab6ceb$var$MarkupKind = {}));\nvar $1d44efb04eab6ceb$var$MarkupContent;\n(function(MarkupContent2) {\n    function is(value) {\n        const candidate = value;\n        return $1d44efb04eab6ceb$var$Is.objectLiteral(value) && $1d44efb04eab6ceb$var$MarkupKind.is(candidate.kind) && $1d44efb04eab6ceb$var$Is.string(candidate.value);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    MarkupContent2.is = is;\n})($1d44efb04eab6ceb$var$MarkupContent || ($1d44efb04eab6ceb$var$MarkupContent = {}));\nvar $1d44efb04eab6ceb$var$CompletionItemKind;\n(function(CompletionItemKind2) {\n    CompletionItemKind2.Text = 1;\n    CompletionItemKind2.Method = 2;\n    CompletionItemKind2.Function = 3;\n    CompletionItemKind2.Constructor = 4;\n    CompletionItemKind2.Field = 5;\n    CompletionItemKind2.Variable = 6;\n    CompletionItemKind2.Class = 7;\n    CompletionItemKind2.Interface = 8;\n    CompletionItemKind2.Module = 9;\n    CompletionItemKind2.Property = 10;\n    CompletionItemKind2.Unit = 11;\n    CompletionItemKind2.Value = 12;\n    CompletionItemKind2.Enum = 13;\n    CompletionItemKind2.Keyword = 14;\n    CompletionItemKind2.Snippet = 15;\n    CompletionItemKind2.Color = 16;\n    CompletionItemKind2.File = 17;\n    CompletionItemKind2.Reference = 18;\n    CompletionItemKind2.Folder = 19;\n    CompletionItemKind2.EnumMember = 20;\n    CompletionItemKind2.Constant = 21;\n    CompletionItemKind2.Struct = 22;\n    CompletionItemKind2.Event = 23;\n    CompletionItemKind2.Operator = 24;\n    CompletionItemKind2.TypeParameter = 25;\n})($1d44efb04eab6ceb$var$CompletionItemKind || ($1d44efb04eab6ceb$var$CompletionItemKind = {}));\nvar $1d44efb04eab6ceb$var$InsertTextFormat;\n(function(InsertTextFormat2) {\n    InsertTextFormat2.PlainText = 1;\n    InsertTextFormat2.Snippet = 2;\n})($1d44efb04eab6ceb$var$InsertTextFormat || ($1d44efb04eab6ceb$var$InsertTextFormat = {}));\nvar $1d44efb04eab6ceb$var$CompletionItemTag;\n(function(CompletionItemTag2) {\n    CompletionItemTag2.Deprecated = 1;\n})($1d44efb04eab6ceb$var$CompletionItemTag || ($1d44efb04eab6ceb$var$CompletionItemTag = {}));\nvar $1d44efb04eab6ceb$var$InsertReplaceEdit;\n(function(InsertReplaceEdit2) {\n    function create(newText, insert, replace) {\n        return {\n            newText: newText,\n            insert: insert,\n            replace: replace\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    InsertReplaceEdit2.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate && $1d44efb04eab6ceb$var$Is.string(candidate.newText) && $1d44efb04eab6ceb$var$Range.is(candidate.insert) && $1d44efb04eab6ceb$var$Range.is(candidate.replace);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    InsertReplaceEdit2.is = is;\n})($1d44efb04eab6ceb$var$InsertReplaceEdit || ($1d44efb04eab6ceb$var$InsertReplaceEdit = {}));\nvar $1d44efb04eab6ceb$var$InsertTextMode;\n(function(InsertTextMode2) {\n    InsertTextMode2.asIs = 1;\n    InsertTextMode2.adjustIndentation = 2;\n})($1d44efb04eab6ceb$var$InsertTextMode || ($1d44efb04eab6ceb$var$InsertTextMode = {}));\nvar $1d44efb04eab6ceb$var$CompletionItemLabelDetails;\n(function(CompletionItemLabelDetails2) {\n    function is(value) {\n        const candidate = value;\n        return candidate && ($1d44efb04eab6ceb$var$Is.string(candidate.detail) || candidate.detail === void 0) && ($1d44efb04eab6ceb$var$Is.string(candidate.description) || candidate.description === void 0);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    CompletionItemLabelDetails2.is = is;\n})($1d44efb04eab6ceb$var$CompletionItemLabelDetails || ($1d44efb04eab6ceb$var$CompletionItemLabelDetails = {}));\nvar $1d44efb04eab6ceb$var$CompletionItem;\n(function(CompletionItem2) {\n    function create(label) {\n        return {\n            label: label\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    CompletionItem2.create = create;\n})($1d44efb04eab6ceb$var$CompletionItem || ($1d44efb04eab6ceb$var$CompletionItem = {}));\nvar $1d44efb04eab6ceb$var$CompletionList;\n(function(CompletionList2) {\n    function create(items, isIncomplete) {\n        return {\n            items: items ? items : [],\n            isIncomplete: !!isIncomplete\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    CompletionList2.create = create;\n})($1d44efb04eab6ceb$var$CompletionList || ($1d44efb04eab6ceb$var$CompletionList = {}));\nvar $1d44efb04eab6ceb$var$MarkedString;\n(function(MarkedString2) {\n    function fromPlainText(plainText) {\n        return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, \"\\\\$&\");\n    }\n    (0, $7xxrv.__name)(fromPlainText, \"fromPlainText\");\n    MarkedString2.fromPlainText = fromPlainText;\n    function is(value) {\n        const candidate = value;\n        return $1d44efb04eab6ceb$var$Is.string(candidate) || $1d44efb04eab6ceb$var$Is.objectLiteral(candidate) && $1d44efb04eab6ceb$var$Is.string(candidate.language) && $1d44efb04eab6ceb$var$Is.string(candidate.value);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    MarkedString2.is = is;\n})($1d44efb04eab6ceb$var$MarkedString || ($1d44efb04eab6ceb$var$MarkedString = {}));\nvar $1d44efb04eab6ceb$var$Hover;\n(function(Hover2) {\n    function is(value) {\n        let candidate = value;\n        return !!candidate && $1d44efb04eab6ceb$var$Is.objectLiteral(candidate) && ($1d44efb04eab6ceb$var$MarkupContent.is(candidate.contents) || $1d44efb04eab6ceb$var$MarkedString.is(candidate.contents) || $1d44efb04eab6ceb$var$Is.typedArray(candidate.contents, $1d44efb04eab6ceb$var$MarkedString.is)) && (value.range === void 0 || $1d44efb04eab6ceb$var$Range.is(value.range));\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    Hover2.is = is;\n})($1d44efb04eab6ceb$var$Hover || ($1d44efb04eab6ceb$var$Hover = {}));\nvar $1d44efb04eab6ceb$var$ParameterInformation;\n(function(ParameterInformation2) {\n    function create(label, documentation) {\n        return documentation ? {\n            label: label,\n            documentation: documentation\n        } : {\n            label: label\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    ParameterInformation2.create = create;\n})($1d44efb04eab6ceb$var$ParameterInformation || ($1d44efb04eab6ceb$var$ParameterInformation = {}));\nvar $1d44efb04eab6ceb$var$SignatureInformation;\n(function(SignatureInformation2) {\n    function create(label, documentation, ...parameters) {\n        let result = {\n            label: label\n        };\n        if ($1d44efb04eab6ceb$var$Is.defined(documentation)) result.documentation = documentation;\n        if ($1d44efb04eab6ceb$var$Is.defined(parameters)) result.parameters = parameters;\n        else result.parameters = [];\n        return result;\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    SignatureInformation2.create = create;\n})($1d44efb04eab6ceb$var$SignatureInformation || ($1d44efb04eab6ceb$var$SignatureInformation = {}));\nvar $1d44efb04eab6ceb$var$DocumentHighlightKind;\n(function(DocumentHighlightKind2) {\n    DocumentHighlightKind2.Text = 1;\n    DocumentHighlightKind2.Read = 2;\n    DocumentHighlightKind2.Write = 3;\n})($1d44efb04eab6ceb$var$DocumentHighlightKind || ($1d44efb04eab6ceb$var$DocumentHighlightKind = {}));\nvar $1d44efb04eab6ceb$var$DocumentHighlight;\n(function(DocumentHighlight2) {\n    function create(range, kind) {\n        let result = {\n            range: range\n        };\n        if ($1d44efb04eab6ceb$var$Is.number(kind)) result.kind = kind;\n        return result;\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    DocumentHighlight2.create = create;\n})($1d44efb04eab6ceb$var$DocumentHighlight || ($1d44efb04eab6ceb$var$DocumentHighlight = {}));\nvar $1d44efb04eab6ceb$var$SymbolKind;\n(function(SymbolKind2) {\n    SymbolKind2.File = 1;\n    SymbolKind2.Module = 2;\n    SymbolKind2.Namespace = 3;\n    SymbolKind2.Package = 4;\n    SymbolKind2.Class = 5;\n    SymbolKind2.Method = 6;\n    SymbolKind2.Property = 7;\n    SymbolKind2.Field = 8;\n    SymbolKind2.Constructor = 9;\n    SymbolKind2.Enum = 10;\n    SymbolKind2.Interface = 11;\n    SymbolKind2.Function = 12;\n    SymbolKind2.Variable = 13;\n    SymbolKind2.Constant = 14;\n    SymbolKind2.String = 15;\n    SymbolKind2.Number = 16;\n    SymbolKind2.Boolean = 17;\n    SymbolKind2.Array = 18;\n    SymbolKind2.Object = 19;\n    SymbolKind2.Key = 20;\n    SymbolKind2.Null = 21;\n    SymbolKind2.EnumMember = 22;\n    SymbolKind2.Struct = 23;\n    SymbolKind2.Event = 24;\n    SymbolKind2.Operator = 25;\n    SymbolKind2.TypeParameter = 26;\n})($1d44efb04eab6ceb$var$SymbolKind || ($1d44efb04eab6ceb$var$SymbolKind = {}));\nvar $1d44efb04eab6ceb$var$SymbolTag;\n(function(SymbolTag2) {\n    SymbolTag2.Deprecated = 1;\n})($1d44efb04eab6ceb$var$SymbolTag || ($1d44efb04eab6ceb$var$SymbolTag = {}));\nvar $1d44efb04eab6ceb$var$SymbolInformation;\n(function(SymbolInformation2) {\n    function create(name, kind, range, uri, containerName) {\n        let result = {\n            name: name,\n            kind: kind,\n            location: {\n                uri: uri,\n                range: range\n            }\n        };\n        if (containerName) result.containerName = containerName;\n        return result;\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    SymbolInformation2.create = create;\n})($1d44efb04eab6ceb$var$SymbolInformation || ($1d44efb04eab6ceb$var$SymbolInformation = {}));\nvar $1d44efb04eab6ceb$var$WorkspaceSymbol;\n(function(WorkspaceSymbol2) {\n    function create(name, kind, uri, range) {\n        return range !== void 0 ? {\n            name: name,\n            kind: kind,\n            location: {\n                uri: uri,\n                range: range\n            }\n        } : {\n            name: name,\n            kind: kind,\n            location: {\n                uri: uri\n            }\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    WorkspaceSymbol2.create = create;\n})($1d44efb04eab6ceb$var$WorkspaceSymbol || ($1d44efb04eab6ceb$var$WorkspaceSymbol = {}));\nvar $1d44efb04eab6ceb$var$DocumentSymbol;\n(function(DocumentSymbol2) {\n    function create(name, detail, kind, range, selectionRange, children) {\n        let result = {\n            name: name,\n            detail: detail,\n            kind: kind,\n            range: range,\n            selectionRange: selectionRange\n        };\n        if (children !== void 0) result.children = children;\n        return result;\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    DocumentSymbol2.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && $1d44efb04eab6ceb$var$Is.string(candidate.name) && $1d44efb04eab6ceb$var$Is.number(candidate.kind) && $1d44efb04eab6ceb$var$Range.is(candidate.range) && $1d44efb04eab6ceb$var$Range.is(candidate.selectionRange) && (candidate.detail === void 0 || $1d44efb04eab6ceb$var$Is.string(candidate.detail)) && (candidate.deprecated === void 0 || $1d44efb04eab6ceb$var$Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    DocumentSymbol2.is = is;\n})($1d44efb04eab6ceb$var$DocumentSymbol || ($1d44efb04eab6ceb$var$DocumentSymbol = {}));\nvar $1d44efb04eab6ceb$var$CodeActionKind;\n(function(CodeActionKind2) {\n    CodeActionKind2.Empty = \"\";\n    CodeActionKind2.QuickFix = \"quickfix\";\n    CodeActionKind2.Refactor = \"refactor\";\n    CodeActionKind2.RefactorExtract = \"refactor.extract\";\n    CodeActionKind2.RefactorInline = \"refactor.inline\";\n    CodeActionKind2.RefactorRewrite = \"refactor.rewrite\";\n    CodeActionKind2.Source = \"source\";\n    CodeActionKind2.SourceOrganizeImports = \"source.organizeImports\";\n    CodeActionKind2.SourceFixAll = \"source.fixAll\";\n})($1d44efb04eab6ceb$var$CodeActionKind || ($1d44efb04eab6ceb$var$CodeActionKind = {}));\nvar $1d44efb04eab6ceb$var$CodeActionTriggerKind;\n(function(CodeActionTriggerKind2) {\n    CodeActionTriggerKind2.Invoked = 1;\n    CodeActionTriggerKind2.Automatic = 2;\n})($1d44efb04eab6ceb$var$CodeActionTriggerKind || ($1d44efb04eab6ceb$var$CodeActionTriggerKind = {}));\nvar $1d44efb04eab6ceb$var$CodeActionContext;\n(function(CodeActionContext2) {\n    function create(diagnostics, only, triggerKind) {\n        let result = {\n            diagnostics: diagnostics\n        };\n        if (only !== void 0 && only !== null) result.only = only;\n        if (triggerKind !== void 0 && triggerKind !== null) result.triggerKind = triggerKind;\n        return result;\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    CodeActionContext2.create = create;\n    function is(value) {\n        let candidate = value;\n        return $1d44efb04eab6ceb$var$Is.defined(candidate) && $1d44efb04eab6ceb$var$Is.typedArray(candidate.diagnostics, $1d44efb04eab6ceb$var$Diagnostic.is) && (candidate.only === void 0 || $1d44efb04eab6ceb$var$Is.typedArray(candidate.only, $1d44efb04eab6ceb$var$Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === $1d44efb04eab6ceb$var$CodeActionTriggerKind.Invoked || candidate.triggerKind === $1d44efb04eab6ceb$var$CodeActionTriggerKind.Automatic);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    CodeActionContext2.is = is;\n})($1d44efb04eab6ceb$var$CodeActionContext || ($1d44efb04eab6ceb$var$CodeActionContext = {}));\nvar $1d44efb04eab6ceb$var$CodeAction;\n(function(CodeAction2) {\n    function create(title, kindOrCommandOrEdit, kind) {\n        let result = {\n            title: title\n        };\n        let checkKind = true;\n        if (typeof kindOrCommandOrEdit === \"string\") {\n            checkKind = false;\n            result.kind = kindOrCommandOrEdit;\n        } else if ($1d44efb04eab6ceb$var$Command.is(kindOrCommandOrEdit)) result.command = kindOrCommandOrEdit;\n        else result.edit = kindOrCommandOrEdit;\n        if (checkKind && kind !== void 0) result.kind = kind;\n        return result;\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    CodeAction2.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && $1d44efb04eab6ceb$var$Is.string(candidate.title) && (candidate.diagnostics === void 0 || $1d44efb04eab6ceb$var$Is.typedArray(candidate.diagnostics, $1d44efb04eab6ceb$var$Diagnostic.is)) && (candidate.kind === void 0 || $1d44efb04eab6ceb$var$Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || $1d44efb04eab6ceb$var$Command.is(candidate.command)) && (candidate.isPreferred === void 0 || $1d44efb04eab6ceb$var$Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || $1d44efb04eab6ceb$var$WorkspaceEdit.is(candidate.edit));\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    CodeAction2.is = is;\n})($1d44efb04eab6ceb$var$CodeAction || ($1d44efb04eab6ceb$var$CodeAction = {}));\nvar $1d44efb04eab6ceb$var$CodeLens;\n(function(CodeLens2) {\n    function create(range, data) {\n        let result = {\n            range: range\n        };\n        if ($1d44efb04eab6ceb$var$Is.defined(data)) result.data = data;\n        return result;\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    CodeLens2.create = create;\n    function is(value) {\n        let candidate = value;\n        return $1d44efb04eab6ceb$var$Is.defined(candidate) && $1d44efb04eab6ceb$var$Range.is(candidate.range) && ($1d44efb04eab6ceb$var$Is.undefined(candidate.command) || $1d44efb04eab6ceb$var$Command.is(candidate.command));\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    CodeLens2.is = is;\n})($1d44efb04eab6ceb$var$CodeLens || ($1d44efb04eab6ceb$var$CodeLens = {}));\nvar $1d44efb04eab6ceb$var$FormattingOptions;\n(function(FormattingOptions2) {\n    function create(tabSize, insertSpaces) {\n        return {\n            tabSize: tabSize,\n            insertSpaces: insertSpaces\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    FormattingOptions2.create = create;\n    function is(value) {\n        let candidate = value;\n        return $1d44efb04eab6ceb$var$Is.defined(candidate) && $1d44efb04eab6ceb$var$Is.uinteger(candidate.tabSize) && $1d44efb04eab6ceb$var$Is.boolean(candidate.insertSpaces);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    FormattingOptions2.is = is;\n})($1d44efb04eab6ceb$var$FormattingOptions || ($1d44efb04eab6ceb$var$FormattingOptions = {}));\nvar $1d44efb04eab6ceb$var$DocumentLink;\n(function(DocumentLink2) {\n    function create(range, target, data) {\n        return {\n            range: range,\n            target: target,\n            data: data\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    DocumentLink2.create = create;\n    function is(value) {\n        let candidate = value;\n        return $1d44efb04eab6ceb$var$Is.defined(candidate) && $1d44efb04eab6ceb$var$Range.is(candidate.range) && ($1d44efb04eab6ceb$var$Is.undefined(candidate.target) || $1d44efb04eab6ceb$var$Is.string(candidate.target));\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    DocumentLink2.is = is;\n})($1d44efb04eab6ceb$var$DocumentLink || ($1d44efb04eab6ceb$var$DocumentLink = {}));\nvar $1d44efb04eab6ceb$var$SelectionRange;\n(function(SelectionRange2) {\n    function create(range, parent) {\n        return {\n            range: range,\n            parent: parent\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    SelectionRange2.create = create;\n    function is(value) {\n        let candidate = value;\n        return $1d44efb04eab6ceb$var$Is.objectLiteral(candidate) && $1d44efb04eab6ceb$var$Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    SelectionRange2.is = is;\n})($1d44efb04eab6ceb$var$SelectionRange || ($1d44efb04eab6ceb$var$SelectionRange = {}));\nvar $1d44efb04eab6ceb$var$SemanticTokenTypes;\n(function(SemanticTokenTypes2) {\n    SemanticTokenTypes2[\"namespace\"] = \"namespace\";\n    SemanticTokenTypes2[\"type\"] = \"type\";\n    SemanticTokenTypes2[\"class\"] = \"class\";\n    SemanticTokenTypes2[\"enum\"] = \"enum\";\n    SemanticTokenTypes2[\"interface\"] = \"interface\";\n    SemanticTokenTypes2[\"struct\"] = \"struct\";\n    SemanticTokenTypes2[\"typeParameter\"] = \"typeParameter\";\n    SemanticTokenTypes2[\"parameter\"] = \"parameter\";\n    SemanticTokenTypes2[\"variable\"] = \"variable\";\n    SemanticTokenTypes2[\"property\"] = \"property\";\n    SemanticTokenTypes2[\"enumMember\"] = \"enumMember\";\n    SemanticTokenTypes2[\"event\"] = \"event\";\n    SemanticTokenTypes2[\"function\"] = \"function\";\n    SemanticTokenTypes2[\"method\"] = \"method\";\n    SemanticTokenTypes2[\"macro\"] = \"macro\";\n    SemanticTokenTypes2[\"keyword\"] = \"keyword\";\n    SemanticTokenTypes2[\"modifier\"] = \"modifier\";\n    SemanticTokenTypes2[\"comment\"] = \"comment\";\n    SemanticTokenTypes2[\"string\"] = \"string\";\n    SemanticTokenTypes2[\"number\"] = \"number\";\n    SemanticTokenTypes2[\"regexp\"] = \"regexp\";\n    SemanticTokenTypes2[\"operator\"] = \"operator\";\n    SemanticTokenTypes2[\"decorator\"] = \"decorator\";\n})($1d44efb04eab6ceb$var$SemanticTokenTypes || ($1d44efb04eab6ceb$var$SemanticTokenTypes = {}));\nvar $1d44efb04eab6ceb$var$SemanticTokenModifiers;\n(function(SemanticTokenModifiers2) {\n    SemanticTokenModifiers2[\"declaration\"] = \"declaration\";\n    SemanticTokenModifiers2[\"definition\"] = \"definition\";\n    SemanticTokenModifiers2[\"readonly\"] = \"readonly\";\n    SemanticTokenModifiers2[\"static\"] = \"static\";\n    SemanticTokenModifiers2[\"deprecated\"] = \"deprecated\";\n    SemanticTokenModifiers2[\"abstract\"] = \"abstract\";\n    SemanticTokenModifiers2[\"async\"] = \"async\";\n    SemanticTokenModifiers2[\"modification\"] = \"modification\";\n    SemanticTokenModifiers2[\"documentation\"] = \"documentation\";\n    SemanticTokenModifiers2[\"defaultLibrary\"] = \"defaultLibrary\";\n})($1d44efb04eab6ceb$var$SemanticTokenModifiers || ($1d44efb04eab6ceb$var$SemanticTokenModifiers = {}));\nvar $1d44efb04eab6ceb$var$SemanticTokens;\n(function(SemanticTokens2) {\n    function is(value) {\n        const candidate = value;\n        return $1d44efb04eab6ceb$var$Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === \"string\") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === \"number\");\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    SemanticTokens2.is = is;\n})($1d44efb04eab6ceb$var$SemanticTokens || ($1d44efb04eab6ceb$var$SemanticTokens = {}));\nvar $1d44efb04eab6ceb$var$InlineValueText;\n(function(InlineValueText2) {\n    function create(range, text) {\n        return {\n            range: range,\n            text: text\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    InlineValueText2.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== void 0 && candidate !== null && $1d44efb04eab6ceb$var$Range.is(candidate.range) && $1d44efb04eab6ceb$var$Is.string(candidate.text);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    InlineValueText2.is = is;\n})($1d44efb04eab6ceb$var$InlineValueText || ($1d44efb04eab6ceb$var$InlineValueText = {}));\nvar $1d44efb04eab6ceb$var$InlineValueVariableLookup;\n(function(InlineValueVariableLookup2) {\n    function create(range, variableName, caseSensitiveLookup) {\n        return {\n            range: range,\n            variableName: variableName,\n            caseSensitiveLookup: caseSensitiveLookup\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    InlineValueVariableLookup2.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== void 0 && candidate !== null && $1d44efb04eab6ceb$var$Range.is(candidate.range) && $1d44efb04eab6ceb$var$Is.boolean(candidate.caseSensitiveLookup) && ($1d44efb04eab6ceb$var$Is.string(candidate.variableName) || candidate.variableName === void 0);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    InlineValueVariableLookup2.is = is;\n})($1d44efb04eab6ceb$var$InlineValueVariableLookup || ($1d44efb04eab6ceb$var$InlineValueVariableLookup = {}));\nvar $1d44efb04eab6ceb$var$InlineValueEvaluatableExpression;\n(function(InlineValueEvaluatableExpression2) {\n    function create(range, expression) {\n        return {\n            range: range,\n            expression: expression\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    InlineValueEvaluatableExpression2.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== void 0 && candidate !== null && $1d44efb04eab6ceb$var$Range.is(candidate.range) && ($1d44efb04eab6ceb$var$Is.string(candidate.expression) || candidate.expression === void 0);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    InlineValueEvaluatableExpression2.is = is;\n})($1d44efb04eab6ceb$var$InlineValueEvaluatableExpression || ($1d44efb04eab6ceb$var$InlineValueEvaluatableExpression = {}));\nvar $1d44efb04eab6ceb$var$InlineValueContext;\n(function(InlineValueContext2) {\n    function create(frameId, stoppedLocation) {\n        return {\n            frameId: frameId,\n            stoppedLocation: stoppedLocation\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    InlineValueContext2.create = create;\n    function is(value) {\n        const candidate = value;\n        return $1d44efb04eab6ceb$var$Is.defined(candidate) && $1d44efb04eab6ceb$var$Range.is(value.stoppedLocation);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    InlineValueContext2.is = is;\n})($1d44efb04eab6ceb$var$InlineValueContext || ($1d44efb04eab6ceb$var$InlineValueContext = {}));\nvar $1d44efb04eab6ceb$var$InlayHintKind;\n(function(InlayHintKind2) {\n    InlayHintKind2.Type = 1;\n    InlayHintKind2.Parameter = 2;\n    function is(value) {\n        return value === 1 || value === 2;\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    InlayHintKind2.is = is;\n})($1d44efb04eab6ceb$var$InlayHintKind || ($1d44efb04eab6ceb$var$InlayHintKind = {}));\nvar $1d44efb04eab6ceb$var$InlayHintLabelPart;\n(function(InlayHintLabelPart2) {\n    function create(value) {\n        return {\n            value: value\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    InlayHintLabelPart2.create = create;\n    function is(value) {\n        const candidate = value;\n        return $1d44efb04eab6ceb$var$Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || $1d44efb04eab6ceb$var$Is.string(candidate.tooltip) || $1d44efb04eab6ceb$var$MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || $1d44efb04eab6ceb$var$Location.is(candidate.location)) && (candidate.command === void 0 || $1d44efb04eab6ceb$var$Command.is(candidate.command));\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    InlayHintLabelPart2.is = is;\n})($1d44efb04eab6ceb$var$InlayHintLabelPart || ($1d44efb04eab6ceb$var$InlayHintLabelPart = {}));\nvar $1d44efb04eab6ceb$var$InlayHint;\n(function(InlayHint2) {\n    function create(position, label, kind) {\n        const result = {\n            position: position,\n            label: label\n        };\n        if (kind !== void 0) result.kind = kind;\n        return result;\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    InlayHint2.create = create;\n    function is(value) {\n        const candidate = value;\n        return $1d44efb04eab6ceb$var$Is.objectLiteral(candidate) && $1d44efb04eab6ceb$var$Position.is(candidate.position) && ($1d44efb04eab6ceb$var$Is.string(candidate.label) || $1d44efb04eab6ceb$var$Is.typedArray(candidate.label, $1d44efb04eab6ceb$var$InlayHintLabelPart.is)) && (candidate.kind === void 0 || $1d44efb04eab6ceb$var$InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || $1d44efb04eab6ceb$var$Is.typedArray(candidate.textEdits, $1d44efb04eab6ceb$var$TextEdit.is) && (candidate.tooltip === void 0 || $1d44efb04eab6ceb$var$Is.string(candidate.tooltip) || $1d44efb04eab6ceb$var$MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || $1d44efb04eab6ceb$var$Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || $1d44efb04eab6ceb$var$Is.boolean(candidate.paddingRight));\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    InlayHint2.is = is;\n})($1d44efb04eab6ceb$var$InlayHint || ($1d44efb04eab6ceb$var$InlayHint = {}));\nvar $1d44efb04eab6ceb$var$StringValue;\n(function(StringValue2) {\n    function createSnippet(value) {\n        return {\n            kind: \"snippet\",\n            value: value\n        };\n    }\n    (0, $7xxrv.__name)(createSnippet, \"createSnippet\");\n    StringValue2.createSnippet = createSnippet;\n})($1d44efb04eab6ceb$var$StringValue || ($1d44efb04eab6ceb$var$StringValue = {}));\nvar $1d44efb04eab6ceb$var$InlineCompletionItem;\n(function(InlineCompletionItem2) {\n    function create(insertText, filterText, range, command) {\n        return {\n            insertText: insertText,\n            filterText: filterText,\n            range: range,\n            command: command\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    InlineCompletionItem2.create = create;\n})($1d44efb04eab6ceb$var$InlineCompletionItem || ($1d44efb04eab6ceb$var$InlineCompletionItem = {}));\nvar $1d44efb04eab6ceb$var$InlineCompletionList;\n(function(InlineCompletionList2) {\n    function create(items) {\n        return {\n            items: items\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    InlineCompletionList2.create = create;\n})($1d44efb04eab6ceb$var$InlineCompletionList || ($1d44efb04eab6ceb$var$InlineCompletionList = {}));\nvar $1d44efb04eab6ceb$var$InlineCompletionTriggerKind;\n(function(InlineCompletionTriggerKind2) {\n    InlineCompletionTriggerKind2.Invoked = 0;\n    InlineCompletionTriggerKind2.Automatic = 1;\n})($1d44efb04eab6ceb$var$InlineCompletionTriggerKind || ($1d44efb04eab6ceb$var$InlineCompletionTriggerKind = {}));\nvar $1d44efb04eab6ceb$var$SelectedCompletionInfo;\n(function(SelectedCompletionInfo2) {\n    function create(range, text) {\n        return {\n            range: range,\n            text: text\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    SelectedCompletionInfo2.create = create;\n})($1d44efb04eab6ceb$var$SelectedCompletionInfo || ($1d44efb04eab6ceb$var$SelectedCompletionInfo = {}));\nvar $1d44efb04eab6ceb$var$InlineCompletionContext;\n(function(InlineCompletionContext2) {\n    function create(triggerKind, selectedCompletionInfo) {\n        return {\n            triggerKind: triggerKind,\n            selectedCompletionInfo: selectedCompletionInfo\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    InlineCompletionContext2.create = create;\n})($1d44efb04eab6ceb$var$InlineCompletionContext || ($1d44efb04eab6ceb$var$InlineCompletionContext = {}));\nvar $1d44efb04eab6ceb$var$WorkspaceFolder;\n(function(WorkspaceFolder2) {\n    function is(value) {\n        const candidate = value;\n        return $1d44efb04eab6ceb$var$Is.objectLiteral(candidate) && $1d44efb04eab6ceb$var$URI.is(candidate.uri) && $1d44efb04eab6ceb$var$Is.string(candidate.name);\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    WorkspaceFolder2.is = is;\n})($1d44efb04eab6ceb$var$WorkspaceFolder || ($1d44efb04eab6ceb$var$WorkspaceFolder = {}));\nvar $1d44efb04eab6ceb$var$TextDocument;\n(function(TextDocument3) {\n    function create(uri, languageId, version, content) {\n        return new $1d44efb04eab6ceb$var$FullTextDocument(uri, languageId, version, content);\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    TextDocument3.create = create;\n    function is(value) {\n        let candidate = value;\n        return $1d44efb04eab6ceb$var$Is.defined(candidate) && $1d44efb04eab6ceb$var$Is.string(candidate.uri) && ($1d44efb04eab6ceb$var$Is.undefined(candidate.languageId) || $1d44efb04eab6ceb$var$Is.string(candidate.languageId)) && $1d44efb04eab6ceb$var$Is.uinteger(candidate.lineCount) && $1d44efb04eab6ceb$var$Is.func(candidate.getText) && $1d44efb04eab6ceb$var$Is.func(candidate.positionAt) && $1d44efb04eab6ceb$var$Is.func(candidate.offsetAt) ? true : false;\n    }\n    (0, $7xxrv.__name)(is, \"is\");\n    TextDocument3.is = is;\n    function applyEdits(document, edits) {\n        let text = document.getText();\n        let sortedEdits = mergeSort2(edits, (a, b)=>{\n            let diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) return a.range.start.character - b.range.start.character;\n            return diff;\n        });\n        let lastModifiedOffset = text.length;\n        for(let i = sortedEdits.length - 1; i >= 0; i--){\n            let e = sortedEdits[i];\n            let startOffset = document.offsetAt(e.range.start);\n            let endOffset = document.offsetAt(e.range.end);\n            if (endOffset <= lastModifiedOffset) text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n            else throw new Error(\"Overlapping edit\");\n            lastModifiedOffset = startOffset;\n        }\n        return text;\n    }\n    (0, $7xxrv.__name)(applyEdits, \"applyEdits\");\n    TextDocument3.applyEdits = applyEdits;\n    function mergeSort2(data, compare) {\n        if (data.length <= 1) return data;\n        const p = data.length / 2 | 0;\n        const left = data.slice(0, p);\n        const right = data.slice(p);\n        mergeSort2(left, compare);\n        mergeSort2(right, compare);\n        let leftIdx = 0;\n        let rightIdx = 0;\n        let i = 0;\n        while(leftIdx < left.length && rightIdx < right.length){\n            let ret = compare(left[leftIdx], right[rightIdx]);\n            if (ret <= 0) data[i++] = left[leftIdx++];\n            else data[i++] = right[rightIdx++];\n        }\n        while(leftIdx < left.length)data[i++] = left[leftIdx++];\n        while(rightIdx < right.length)data[i++] = right[rightIdx++];\n        return data;\n    }\n    (0, $7xxrv.__name)(mergeSort2, \"mergeSort\");\n})($1d44efb04eab6ceb$var$TextDocument || ($1d44efb04eab6ceb$var$TextDocument = {}));\nvar $1d44efb04eab6ceb$var$FullTextDocument = class {\n    static{\n        (0, $7xxrv.__name)(this, \"FullTextDocument\");\n    }\n    constructor(uri, languageId, version, content){\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = void 0;\n    }\n    get uri() {\n        return this._uri;\n    }\n    get languageId() {\n        return this._languageId;\n    }\n    get version() {\n        return this._version;\n    }\n    getText(range) {\n        if (range) {\n            let start = this.offsetAt(range.start);\n            let end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    }\n    update(event, version) {\n        this._content = event.text;\n        this._version = version;\n        this._lineOffsets = void 0;\n    }\n    getLineOffsets() {\n        if (this._lineOffsets === void 0) {\n            let lineOffsets = [];\n            let text = this._content;\n            let isLineStart = true;\n            for(let i = 0; i < text.length; i++){\n                if (isLineStart) {\n                    lineOffsets.push(i);\n                    isLineStart = false;\n                }\n                let ch = text.charAt(i);\n                isLineStart = ch === \"\\r\" || ch === \"\\n\";\n                if (ch === \"\\r\" && i + 1 < text.length && text.charAt(i + 1) === \"\\n\") i++;\n            }\n            if (isLineStart && text.length > 0) lineOffsets.push(text.length);\n            this._lineOffsets = lineOffsets;\n        }\n        return this._lineOffsets;\n    }\n    positionAt(offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        let lineOffsets = this.getLineOffsets();\n        let low = 0, high = lineOffsets.length;\n        if (high === 0) return $1d44efb04eab6ceb$var$Position.create(0, offset);\n        while(low < high){\n            let mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) high = mid;\n            else low = mid + 1;\n        }\n        let line = low - 1;\n        return $1d44efb04eab6ceb$var$Position.create(line, offset - lineOffsets[line]);\n    }\n    offsetAt(position) {\n        let lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) return this._content.length;\n        else if (position.line < 0) return 0;\n        let lineOffset = lineOffsets[position.line];\n        let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    }\n    get lineCount() {\n        return this.getLineOffsets().length;\n    }\n};\nvar $1d44efb04eab6ceb$var$Is;\n(function(Is2) {\n    const toString2 = Object.prototype.toString;\n    function defined(value) {\n        return typeof value !== \"undefined\";\n    }\n    (0, $7xxrv.__name)(defined, \"defined\");\n    Is2.defined = defined;\n    function undefined2(value) {\n        return typeof value === \"undefined\";\n    }\n    (0, $7xxrv.__name)(undefined2, \"undefined\");\n    Is2.undefined = undefined2;\n    function boolean(value) {\n        return value === true || value === false;\n    }\n    (0, $7xxrv.__name)(boolean, \"boolean\");\n    Is2.boolean = boolean;\n    function string(value) {\n        return toString2.call(value) === \"[object String]\";\n    }\n    (0, $7xxrv.__name)(string, \"string\");\n    Is2.string = string;\n    function number(value) {\n        return toString2.call(value) === \"[object Number]\";\n    }\n    (0, $7xxrv.__name)(number, \"number\");\n    Is2.number = number;\n    function numberRange(value, min, max) {\n        return toString2.call(value) === \"[object Number]\" && min <= value && value <= max;\n    }\n    (0, $7xxrv.__name)(numberRange, \"numberRange\");\n    Is2.numberRange = numberRange;\n    function integer2(value) {\n        return toString2.call(value) === \"[object Number]\" && -2147483648 <= value && value <= 2147483647;\n    }\n    (0, $7xxrv.__name)(integer2, \"integer\");\n    Is2.integer = integer2;\n    function uinteger2(value) {\n        return toString2.call(value) === \"[object Number]\" && 0 <= value && value <= 2147483647;\n    }\n    (0, $7xxrv.__name)(uinteger2, \"uinteger\");\n    Is2.uinteger = uinteger2;\n    function func(value) {\n        return toString2.call(value) === \"[object Function]\";\n    }\n    (0, $7xxrv.__name)(func, \"func\");\n    Is2.func = func;\n    function objectLiteral(value) {\n        return value !== null && typeof value === \"object\";\n    }\n    (0, $7xxrv.__name)(objectLiteral, \"objectLiteral\");\n    Is2.objectLiteral = objectLiteral;\n    function typedArray(value, check) {\n        return Array.isArray(value) && value.every(check);\n    }\n    (0, $7xxrv.__name)(typedArray, \"typedArray\");\n    Is2.typedArray = typedArray;\n})($1d44efb04eab6ceb$var$Is || ($1d44efb04eab6ceb$var$Is = {}));\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/parser/cst-node-builder.js\nvar $1d44efb04eab6ceb$var$CstNodeBuilder = class {\n    static{\n        (0, $7xxrv.__name)(this, \"CstNodeBuilder\");\n    }\n    constructor(){\n        this.nodeStack = [];\n    }\n    get current() {\n        return this.nodeStack[this.nodeStack.length - 1];\n    }\n    buildRootNode(input) {\n        this.rootNode = new $1d44efb04eab6ceb$var$RootCstNodeImpl(input);\n        this.rootNode.root = this.rootNode;\n        this.nodeStack = [\n            this.rootNode\n        ];\n        return this.rootNode;\n    }\n    buildCompositeNode(feature) {\n        const compositeNode = new $1d44efb04eab6ceb$var$CompositeCstNodeImpl();\n        compositeNode.grammarSource = feature;\n        compositeNode.root = this.rootNode;\n        this.current.content.push(compositeNode);\n        this.nodeStack.push(compositeNode);\n        return compositeNode;\n    }\n    buildLeafNode(token, feature) {\n        const leafNode = new $1d44efb04eab6ceb$var$LeafCstNodeImpl(token.startOffset, token.image.length, $1d44efb04eab6ceb$var$tokenToRange(token), token.tokenType, false);\n        leafNode.grammarSource = feature;\n        leafNode.root = this.rootNode;\n        this.current.content.push(leafNode);\n        return leafNode;\n    }\n    removeNode(node) {\n        const parent = node.container;\n        if (parent) {\n            const index = parent.content.indexOf(node);\n            if (index >= 0) parent.content.splice(index, 1);\n        }\n    }\n    construct(item) {\n        const current = this.current;\n        if (typeof item.$type === \"string\") this.current.astNode = item;\n        item.$cstNode = current;\n        const node = this.nodeStack.pop();\n        if ((node === null || node === void 0 ? void 0 : node.content.length) === 0) this.removeNode(node);\n    }\n    addHiddenTokens(hiddenTokens) {\n        for (const token of hiddenTokens){\n            const hiddenNode = new $1d44efb04eab6ceb$var$LeafCstNodeImpl(token.startOffset, token.image.length, $1d44efb04eab6ceb$var$tokenToRange(token), token.tokenType, true);\n            hiddenNode.root = this.rootNode;\n            this.addHiddenToken(this.rootNode, hiddenNode);\n        }\n    }\n    addHiddenToken(node, token) {\n        const { offset: tokenStart, end: tokenEnd } = token;\n        for(let i = 0; i < node.content.length; i++){\n            const child = node.content[i];\n            const { offset: childStart, end: childEnd } = child;\n            if ($1d44efb04eab6ceb$var$isCompositeCstNode(child) && tokenStart > childStart && tokenEnd < childEnd) {\n                this.addHiddenToken(child, token);\n                return;\n            } else if (tokenEnd <= childStart) {\n                node.content.splice(i, 0, token);\n                return;\n            }\n        }\n        node.content.push(token);\n    }\n};\nvar $1d44efb04eab6ceb$var$AbstractCstNode = class {\n    static{\n        (0, $7xxrv.__name)(this, \"AbstractCstNode\");\n    }\n    /** @deprecated use `container` instead. */ get parent() {\n        return this.container;\n    }\n    /** @deprecated use `grammarSource` instead. */ get feature() {\n        return this.grammarSource;\n    }\n    get hidden() {\n        return false;\n    }\n    get astNode() {\n        var _a, _b;\n        const node = typeof ((_a = this._astNode) === null || _a === void 0 ? void 0 : _a.$type) === \"string\" ? this._astNode : (_b = this.container) === null || _b === void 0 ? void 0 : _b.astNode;\n        if (!node) throw new Error(\"This node has no associated AST element\");\n        return node;\n    }\n    set astNode(value) {\n        this._astNode = value;\n    }\n    /** @deprecated use `astNode` instead. */ get element() {\n        return this.astNode;\n    }\n    get text() {\n        return this.root.fullText.substring(this.offset, this.end);\n    }\n};\nvar $1d44efb04eab6ceb$var$LeafCstNodeImpl = class extends $1d44efb04eab6ceb$var$AbstractCstNode {\n    static{\n        (0, $7xxrv.__name)(this, \"LeafCstNodeImpl\");\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return this._length;\n    }\n    get end() {\n        return this._offset + this._length;\n    }\n    get hidden() {\n        return this._hidden;\n    }\n    get tokenType() {\n        return this._tokenType;\n    }\n    get range() {\n        return this._range;\n    }\n    constructor(offset, length, range, tokenType, hidden = false){\n        super();\n        this._hidden = hidden;\n        this._offset = offset;\n        this._tokenType = tokenType;\n        this._length = length;\n        this._range = range;\n    }\n};\nvar $1d44efb04eab6ceb$var$CompositeCstNodeImpl = class extends $1d44efb04eab6ceb$var$AbstractCstNode {\n    static{\n        (0, $7xxrv.__name)(this, \"CompositeCstNodeImpl\");\n    }\n    constructor(){\n        super(...arguments);\n        this.content = new $1d44efb04eab6ceb$var$CstNodeContainer(this);\n    }\n    /** @deprecated use `content` instead. */ get children() {\n        return this.content;\n    }\n    get offset() {\n        var _a, _b;\n        return (_b = (_a = this.firstNonHiddenNode) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0;\n    }\n    get length() {\n        return this.end - this.offset;\n    }\n    get end() {\n        var _a, _b;\n        return (_b = (_a = this.lastNonHiddenNode) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : 0;\n    }\n    get range() {\n        const firstNode = this.firstNonHiddenNode;\n        const lastNode = this.lastNonHiddenNode;\n        if (firstNode && lastNode) {\n            if (this._rangeCache === void 0) {\n                const { range: firstRange } = firstNode;\n                const { range: lastRange } = lastNode;\n                this._rangeCache = {\n                    start: firstRange.start,\n                    end: lastRange.end.line < firstRange.start.line ? firstRange.start : lastRange.end\n                };\n            }\n            return this._rangeCache;\n        } else return {\n            start: $1d44efb04eab6ceb$var$Position.create(0, 0),\n            end: $1d44efb04eab6ceb$var$Position.create(0, 0)\n        };\n    }\n    get firstNonHiddenNode() {\n        for (const child of this.content){\n            if (!child.hidden) return child;\n        }\n        return this.content[0];\n    }\n    get lastNonHiddenNode() {\n        for(let i = this.content.length - 1; i >= 0; i--){\n            const child = this.content[i];\n            if (!child.hidden) return child;\n        }\n        return this.content[this.content.length - 1];\n    }\n};\nvar $1d44efb04eab6ceb$var$CstNodeContainer = class _CstNodeContainer extends Array {\n    static{\n        (0, $7xxrv.__name)(this, \"CstNodeContainer\");\n    }\n    constructor(parent){\n        super();\n        this.parent = parent;\n        Object.setPrototypeOf(this, _CstNodeContainer.prototype);\n    }\n    push(...items) {\n        this.addParents(items);\n        return super.push(...items);\n    }\n    unshift(...items) {\n        this.addParents(items);\n        return super.unshift(...items);\n    }\n    splice(start, count, ...items) {\n        this.addParents(items);\n        return super.splice(start, count, ...items);\n    }\n    addParents(items) {\n        for (const item of items)item.container = this.parent;\n    }\n};\nvar $1d44efb04eab6ceb$var$RootCstNodeImpl = class extends $1d44efb04eab6ceb$var$CompositeCstNodeImpl {\n    static{\n        (0, $7xxrv.__name)(this, \"RootCstNodeImpl\");\n    }\n    get text() {\n        return this._text.substring(this.offset, this.end);\n    }\n    get fullText() {\n        return this._text;\n    }\n    constructor(input){\n        super();\n        this._text = \"\";\n        this._text = input !== null && input !== void 0 ? input : \"\";\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/parser/langium-parser.js\nvar $1d44efb04eab6ceb$var$DatatypeSymbol = Symbol(\"Datatype\");\nfunction $1d44efb04eab6ceb$var$isDataTypeNode(node) {\n    return node.$type === $1d44efb04eab6ceb$var$DatatypeSymbol;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isDataTypeNode, \"isDataTypeNode\");\nvar $1d44efb04eab6ceb$var$ruleSuffix = \"\\u200B\";\nvar $1d44efb04eab6ceb$var$withRuleSuffix = /* @__PURE__ */ (0, $7xxrv.__name)((name)=>name.endsWith($1d44efb04eab6ceb$var$ruleSuffix) ? name : name + $1d44efb04eab6ceb$var$ruleSuffix, \"withRuleSuffix\");\nvar $1d44efb04eab6ceb$var$AbstractLangiumParser = class {\n    static{\n        (0, $7xxrv.__name)(this, \"AbstractLangiumParser\");\n    }\n    constructor(services){\n        this._unorderedGroups = /* @__PURE__ */ new Map();\n        this.lexer = services.parser.Lexer;\n        const tokens = this.lexer.definition;\n        this.wrapper = new $1d44efb04eab6ceb$var$ChevrotainWrapper(tokens, Object.assign(Object.assign({}, services.parser.ParserConfig), {\n            errorMessageProvider: services.parser.ParserErrorMessageProvider\n        }));\n    }\n    alternatives(idx, choices) {\n        this.wrapper.wrapOr(idx, choices);\n    }\n    optional(idx, callback) {\n        this.wrapper.wrapOption(idx, callback);\n    }\n    many(idx, callback) {\n        this.wrapper.wrapMany(idx, callback);\n    }\n    atLeastOne(idx, callback) {\n        this.wrapper.wrapAtLeastOne(idx, callback);\n    }\n    isRecording() {\n        return this.wrapper.IS_RECORDING;\n    }\n    get unorderedGroups() {\n        return this._unorderedGroups;\n    }\n    getRuleStack() {\n        return this.wrapper.RULE_STACK;\n    }\n    finalize() {\n        this.wrapper.wrapSelfAnalysis();\n    }\n};\nvar $1d44efb04eab6ceb$var$LangiumParser = class extends $1d44efb04eab6ceb$var$AbstractLangiumParser {\n    static{\n        (0, $7xxrv.__name)(this, \"LangiumParser\");\n    }\n    get current() {\n        return this.stack[this.stack.length - 1];\n    }\n    constructor(services){\n        super(services);\n        this.nodeBuilder = new $1d44efb04eab6ceb$var$CstNodeBuilder();\n        this.stack = [];\n        this.assignmentMap = /* @__PURE__ */ new Map();\n        this.linker = services.references.Linker;\n        this.converter = services.parser.ValueConverter;\n        this.astReflection = services.shared.AstReflection;\n    }\n    rule(rule, impl) {\n        const type = rule.fragment ? void 0 : $1d44efb04eab6ceb$var$isDataTypeRule(rule) ? $1d44efb04eab6ceb$var$DatatypeSymbol : $1d44efb04eab6ceb$var$getTypeName(rule);\n        const ruleMethod = this.wrapper.DEFINE_RULE($1d44efb04eab6ceb$var$withRuleSuffix(rule.name), this.startImplementation(type, impl).bind(this));\n        if (rule.entry) this.mainRule = ruleMethod;\n        return ruleMethod;\n    }\n    parse(input) {\n        this.nodeBuilder.buildRootNode(input);\n        const lexerResult = this.lexer.tokenize(input);\n        this.wrapper.input = lexerResult.tokens;\n        const result = this.mainRule.call(this.wrapper, {});\n        this.nodeBuilder.addHiddenTokens(lexerResult.hidden);\n        this.unorderedGroups.clear();\n        return {\n            value: result,\n            lexerErrors: lexerResult.errors,\n            parserErrors: this.wrapper.errors\n        };\n    }\n    startImplementation($type, implementation) {\n        return (args)=>{\n            if (!this.isRecording()) {\n                const node = {\n                    $type: $type\n                };\n                this.stack.push(node);\n                if ($type === $1d44efb04eab6ceb$var$DatatypeSymbol) node.value = \"\";\n            }\n            let result;\n            try {\n                result = implementation(args);\n            } catch (err) {\n                result = void 0;\n            }\n            if (!this.isRecording() && result === void 0) result = this.construct();\n            return result;\n        };\n    }\n    consume(idx, tokenType, feature) {\n        const token = this.wrapper.wrapConsume(idx, tokenType);\n        if (!this.isRecording() && this.isValidToken(token)) {\n            const leafNode = this.nodeBuilder.buildLeafNode(token, feature);\n            const { assignment: assignment, isCrossRef: isCrossRef } = this.getAssignment(feature);\n            const current = this.current;\n            if (assignment) {\n                const convertedValue = $1d44efb04eab6ceb$var$isKeyword(feature) ? token.image : this.converter.convert(token.image, leafNode);\n                this.assign(assignment.operator, assignment.feature, convertedValue, leafNode, isCrossRef);\n            } else if ($1d44efb04eab6ceb$var$isDataTypeNode(current)) {\n                let text = token.image;\n                if (!$1d44efb04eab6ceb$var$isKeyword(feature)) text = this.converter.convert(text, leafNode).toString();\n                current.value += text;\n            }\n        }\n    }\n    /**\n   * Most consumed parser tokens are valid. However there are two cases in which they are not valid:\n   *\n   * 1. They were inserted during error recovery by the parser. These tokens don't really exist and should not be further processed\n   * 2. They contain invalid token ranges. This might include the special EOF token, or other tokens produced by invalid token builders.\n   */ isValidToken(token) {\n        return !token.isInsertedInRecovery && !isNaN(token.startOffset) && typeof token.endOffset === \"number\" && !isNaN(token.endOffset);\n    }\n    subrule(idx, rule, feature, args) {\n        let cstNode;\n        if (!this.isRecording()) cstNode = this.nodeBuilder.buildCompositeNode(feature);\n        const subruleResult = this.wrapper.wrapSubrule(idx, rule, args);\n        if (!this.isRecording() && cstNode && cstNode.length > 0) this.performSubruleAssignment(subruleResult, feature, cstNode);\n    }\n    performSubruleAssignment(result, feature, cstNode) {\n        const { assignment: assignment, isCrossRef: isCrossRef } = this.getAssignment(feature);\n        if (assignment) this.assign(assignment.operator, assignment.feature, result, cstNode, isCrossRef);\n        else if (!assignment) {\n            const current = this.current;\n            if ($1d44efb04eab6ceb$var$isDataTypeNode(current)) current.value += result.toString();\n            else if (typeof result === \"object\" && result) {\n                const resultKind = result.$type;\n                const object = this.assignWithoutOverride(result, current);\n                if (resultKind) object.$type = resultKind;\n                const newItem = object;\n                this.stack.pop();\n                this.stack.push(newItem);\n            }\n        }\n    }\n    action($type, action) {\n        if (!this.isRecording()) {\n            let last = this.current;\n            if (!last.$cstNode && action.feature && action.operator) {\n                last = this.construct(false);\n                const feature = last.$cstNode.feature;\n                this.nodeBuilder.buildCompositeNode(feature);\n            }\n            const newItem = {\n                $type: $type\n            };\n            this.stack.pop();\n            this.stack.push(newItem);\n            if (action.feature && action.operator) this.assign(action.operator, action.feature, last, last.$cstNode, false);\n        }\n    }\n    construct(pop = true) {\n        if (this.isRecording()) return void 0;\n        const obj = this.current;\n        $1d44efb04eab6ceb$var$linkContentToContainer(obj);\n        this.nodeBuilder.construct(obj);\n        if (pop) this.stack.pop();\n        if ($1d44efb04eab6ceb$var$isDataTypeNode(obj)) return this.converter.convert(obj.value, obj.$cstNode);\n        else $1d44efb04eab6ceb$var$assignMandatoryProperties(this.astReflection, obj);\n        return obj;\n    }\n    getAssignment(feature) {\n        if (!this.assignmentMap.has(feature)) {\n            const assignment = $1d44efb04eab6ceb$var$getContainerOfType(feature, $1d44efb04eab6ceb$var$isAssignment);\n            this.assignmentMap.set(feature, {\n                assignment: assignment,\n                isCrossRef: assignment ? $1d44efb04eab6ceb$var$isCrossReference(assignment.terminal) : false\n            });\n        }\n        return this.assignmentMap.get(feature);\n    }\n    assign(operator, feature, value, cstNode, isCrossRef) {\n        const obj = this.current;\n        let item;\n        if (isCrossRef && typeof value === \"string\") item = this.linker.buildReference(obj, feature, cstNode, value);\n        else item = value;\n        switch(operator){\n            case \"=\":\n                obj[feature] = item;\n                break;\n            case \"?=\":\n                obj[feature] = true;\n                break;\n            case \"+=\":\n                if (!Array.isArray(obj[feature])) obj[feature] = [];\n                obj[feature].push(item);\n        }\n    }\n    assignWithoutOverride(target, source) {\n        for (const [name, existingValue] of Object.entries(source)){\n            const newValue = target[name];\n            if (newValue === void 0) target[name] = existingValue;\n            else if (Array.isArray(newValue) && Array.isArray(existingValue)) {\n                existingValue.push(...newValue);\n                target[name] = existingValue;\n            }\n        }\n        return target;\n    }\n    get definitionErrors() {\n        return this.wrapper.definitionErrors;\n    }\n};\nvar $1d44efb04eab6ceb$var$AbstractParserErrorMessageProvider = class {\n    static{\n        (0, $7xxrv.__name)(this, \"AbstractParserErrorMessageProvider\");\n    }\n    buildMismatchTokenMessage(options) {\n        return $1d44efb04eab6ceb$var$defaultParserErrorProvider.buildMismatchTokenMessage(options);\n    }\n    buildNotAllInputParsedMessage(options) {\n        return $1d44efb04eab6ceb$var$defaultParserErrorProvider.buildNotAllInputParsedMessage(options);\n    }\n    buildNoViableAltMessage(options) {\n        return $1d44efb04eab6ceb$var$defaultParserErrorProvider.buildNoViableAltMessage(options);\n    }\n    buildEarlyExitMessage(options) {\n        return $1d44efb04eab6ceb$var$defaultParserErrorProvider.buildEarlyExitMessage(options);\n    }\n};\nvar $1d44efb04eab6ceb$var$LangiumParserErrorMessageProvider = class extends $1d44efb04eab6ceb$var$AbstractParserErrorMessageProvider {\n    static{\n        (0, $7xxrv.__name)(this, \"LangiumParserErrorMessageProvider\");\n    }\n    buildMismatchTokenMessage({ expected: expected, actual: actual }) {\n        const expectedMsg = expected.LABEL ? \"`\" + expected.LABEL + \"`\" : expected.name.endsWith(\":KW\") ? `keyword '${expected.name.substring(0, expected.name.length - 3)}'` : `token of type '${expected.name}'`;\n        return `Expecting ${expectedMsg} but found \\`${actual.image}\\`.`;\n    }\n    buildNotAllInputParsedMessage({ firstRedundant: firstRedundant }) {\n        return `Expecting end of file but found \\`${firstRedundant.image}\\`.`;\n    }\n};\nvar $1d44efb04eab6ceb$var$LangiumCompletionParser = class extends $1d44efb04eab6ceb$var$AbstractLangiumParser {\n    static{\n        (0, $7xxrv.__name)(this, \"LangiumCompletionParser\");\n    }\n    constructor(){\n        super(...arguments);\n        this.tokens = [];\n        this.elementStack = [];\n        this.lastElementStack = [];\n        this.nextTokenIndex = 0;\n        this.stackSize = 0;\n    }\n    action() {}\n    construct() {\n        return void 0;\n    }\n    parse(input) {\n        this.resetState();\n        const tokens = this.lexer.tokenize(input);\n        this.tokens = tokens.tokens;\n        this.wrapper.input = [\n            ...this.tokens\n        ];\n        this.mainRule.call(this.wrapper, {});\n        this.unorderedGroups.clear();\n        return {\n            tokens: this.tokens,\n            elementStack: [\n                ...this.lastElementStack\n            ],\n            tokenIndex: this.nextTokenIndex\n        };\n    }\n    rule(rule, impl) {\n        const ruleMethod = this.wrapper.DEFINE_RULE($1d44efb04eab6ceb$var$withRuleSuffix(rule.name), this.startImplementation(impl).bind(this));\n        if (rule.entry) this.mainRule = ruleMethod;\n        return ruleMethod;\n    }\n    resetState() {\n        this.elementStack = [];\n        this.lastElementStack = [];\n        this.nextTokenIndex = 0;\n        this.stackSize = 0;\n    }\n    startImplementation(implementation) {\n        return (args)=>{\n            const size = this.keepStackSize();\n            try {\n                implementation(args);\n            } finally{\n                this.resetStackSize(size);\n            }\n        };\n    }\n    removeUnexpectedElements() {\n        this.elementStack.splice(this.stackSize);\n    }\n    keepStackSize() {\n        const size = this.elementStack.length;\n        this.stackSize = size;\n        return size;\n    }\n    resetStackSize(size) {\n        this.removeUnexpectedElements();\n        this.stackSize = size;\n    }\n    consume(idx, tokenType, feature) {\n        this.wrapper.wrapConsume(idx, tokenType);\n        if (!this.isRecording()) {\n            this.lastElementStack = [\n                ...this.elementStack,\n                feature\n            ];\n            this.nextTokenIndex = this.currIdx + 1;\n        }\n    }\n    subrule(idx, rule, feature, args) {\n        this.before(feature);\n        this.wrapper.wrapSubrule(idx, rule, args);\n        this.after(feature);\n    }\n    before(element) {\n        if (!this.isRecording()) this.elementStack.push(element);\n    }\n    after(element) {\n        if (!this.isRecording()) {\n            const index = this.elementStack.lastIndexOf(element);\n            if (index >= 0) this.elementStack.splice(index);\n        }\n    }\n    get currIdx() {\n        return this.wrapper.currIdx;\n    }\n};\nvar $1d44efb04eab6ceb$var$defaultConfig = {\n    recoveryEnabled: true,\n    nodeLocationTracking: \"full\",\n    skipValidations: true,\n    errorMessageProvider: new $1d44efb04eab6ceb$var$LangiumParserErrorMessageProvider()\n};\nvar $1d44efb04eab6ceb$var$ChevrotainWrapper = class extends $1d44efb04eab6ceb$var$EmbeddedActionsParser {\n    static{\n        (0, $7xxrv.__name)(this, \"ChevrotainWrapper\");\n    }\n    constructor(tokens, config){\n        const useDefaultLookahead = config && \"maxLookahead\" in config;\n        super(tokens, Object.assign(Object.assign(Object.assign({}, $1d44efb04eab6ceb$var$defaultConfig), {\n            lookaheadStrategy: useDefaultLookahead ? new $1d44efb04eab6ceb$var$LLkLookaheadStrategy({\n                maxLookahead: config.maxLookahead\n            }) : new $1d44efb04eab6ceb$var$LLStarLookaheadStrategy()\n        }), config));\n    }\n    get IS_RECORDING() {\n        return this.RECORDING_PHASE;\n    }\n    DEFINE_RULE(name, impl) {\n        return this.RULE(name, impl);\n    }\n    wrapSelfAnalysis() {\n        this.performSelfAnalysis();\n    }\n    wrapConsume(idx, tokenType) {\n        return this.consume(idx, tokenType);\n    }\n    wrapSubrule(idx, rule, args) {\n        return this.subrule(idx, rule, {\n            ARGS: [\n                args\n            ]\n        });\n    }\n    wrapOr(idx, choices) {\n        this.or(idx, choices);\n    }\n    wrapOption(idx, callback) {\n        this.option(idx, callback);\n    }\n    wrapMany(idx, callback) {\n        this.many(idx, callback);\n    }\n    wrapAtLeastOne(idx, callback) {\n        this.atLeastOne(idx, callback);\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/parser/parser-builder-base.js\nfunction $1d44efb04eab6ceb$var$createParser(grammar, parser, tokens) {\n    const rules = /* @__PURE__ */ new Map();\n    const parserContext = {\n        parser: parser,\n        tokens: tokens,\n        rules: rules,\n        ruleNames: /* @__PURE__ */ new Map()\n    };\n    $1d44efb04eab6ceb$var$buildRules(parserContext, grammar);\n    return parser;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$createParser, \"createParser\");\nfunction $1d44efb04eab6ceb$var$buildRules(parserContext, grammar) {\n    const reachable = $1d44efb04eab6ceb$var$getAllReachableRules(grammar, false);\n    const parserRules = $1d44efb04eab6ceb$var$stream(grammar.rules).filter($1d44efb04eab6ceb$var$isParserRule).filter((rule)=>reachable.has(rule));\n    for (const rule of parserRules){\n        const ctx = Object.assign(Object.assign({}, parserContext), {\n            consume: 1,\n            optional: 1,\n            subrule: 1,\n            many: 1,\n            or: 1\n        });\n        ctx.rules.set(rule.name, parserContext.parser.rule(rule, $1d44efb04eab6ceb$var$buildElement(ctx, rule.definition)));\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildRules, \"buildRules\");\nfunction $1d44efb04eab6ceb$var$buildElement(ctx, element, ignoreGuard = false) {\n    let method;\n    if ($1d44efb04eab6ceb$var$isKeyword(element)) method = $1d44efb04eab6ceb$var$buildKeyword(ctx, element);\n    else if ($1d44efb04eab6ceb$var$isAction(element)) method = $1d44efb04eab6ceb$var$buildAction(ctx, element);\n    else if ($1d44efb04eab6ceb$var$isAssignment(element)) method = $1d44efb04eab6ceb$var$buildElement(ctx, element.terminal);\n    else if ($1d44efb04eab6ceb$var$isCrossReference(element)) method = $1d44efb04eab6ceb$var$buildCrossReference(ctx, element);\n    else if ($1d44efb04eab6ceb$var$isRuleCall(element)) method = $1d44efb04eab6ceb$var$buildRuleCall(ctx, element);\n    else if ($1d44efb04eab6ceb$var$isAlternatives(element)) method = $1d44efb04eab6ceb$var$buildAlternatives(ctx, element);\n    else if ($1d44efb04eab6ceb$var$isUnorderedGroup(element)) method = $1d44efb04eab6ceb$var$buildUnorderedGroup(ctx, element);\n    else if ($1d44efb04eab6ceb$var$isGroup(element)) method = $1d44efb04eab6ceb$var$buildGroup(ctx, element);\n    else if ($1d44efb04eab6ceb$var$isEndOfFile(element)) {\n        const idx = ctx.consume++;\n        method = /* @__PURE__ */ (0, $7xxrv.__name)(()=>ctx.parser.consume(idx, $1d44efb04eab6ceb$var$EOF, element), \"method\");\n    } else throw new $1d44efb04eab6ceb$var$ErrorWithLocation(element.$cstNode, `Unexpected element type: ${element.$type}`);\n    return $1d44efb04eab6ceb$var$wrap(ctx, ignoreGuard ? void 0 : $1d44efb04eab6ceb$var$getGuardCondition(element), method, element.cardinality);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildElement, \"buildElement\");\nfunction $1d44efb04eab6ceb$var$buildAction(ctx, action) {\n    const actionType = $1d44efb04eab6ceb$var$getTypeName(action);\n    return ()=>ctx.parser.action(actionType, action);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildAction, \"buildAction\");\nfunction $1d44efb04eab6ceb$var$buildRuleCall(ctx, ruleCall) {\n    const rule = ruleCall.rule.ref;\n    if ($1d44efb04eab6ceb$var$isParserRule(rule)) {\n        const idx = ctx.subrule++;\n        const predicate = ruleCall.arguments.length > 0 ? $1d44efb04eab6ceb$var$buildRuleCallPredicate(rule, ruleCall.arguments) : ()=>({});\n        return (args)=>ctx.parser.subrule(idx, $1d44efb04eab6ceb$var$getRule(ctx, rule), ruleCall, predicate(args));\n    } else if ($1d44efb04eab6ceb$var$isTerminalRule(rule)) {\n        const idx = ctx.consume++;\n        const method = $1d44efb04eab6ceb$var$getToken(ctx, rule.name);\n        return ()=>ctx.parser.consume(idx, method, ruleCall);\n    } else if (!rule) throw new $1d44efb04eab6ceb$var$ErrorWithLocation(ruleCall.$cstNode, `Undefined rule type: ${ruleCall.$type}`);\n    else $1d44efb04eab6ceb$var$assertUnreachable(rule);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildRuleCall, \"buildRuleCall\");\nfunction $1d44efb04eab6ceb$var$buildRuleCallPredicate(rule, namedArgs) {\n    const predicates = namedArgs.map((e)=>$1d44efb04eab6ceb$var$buildPredicate(e.value));\n    return (args)=>{\n        const ruleArgs = {};\n        for(let i = 0; i < predicates.length; i++){\n            const ruleTarget = rule.parameters[i];\n            const predicate = predicates[i];\n            ruleArgs[ruleTarget.name] = predicate(args);\n        }\n        return ruleArgs;\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildRuleCallPredicate, \"buildRuleCallPredicate\");\nfunction $1d44efb04eab6ceb$var$buildPredicate(condition) {\n    if ($1d44efb04eab6ceb$var$isDisjunction(condition)) {\n        const left = $1d44efb04eab6ceb$var$buildPredicate(condition.left);\n        const right = $1d44efb04eab6ceb$var$buildPredicate(condition.right);\n        return (args)=>left(args) || right(args);\n    } else if ($1d44efb04eab6ceb$var$isConjunction(condition)) {\n        const left = $1d44efb04eab6ceb$var$buildPredicate(condition.left);\n        const right = $1d44efb04eab6ceb$var$buildPredicate(condition.right);\n        return (args)=>left(args) && right(args);\n    } else if ($1d44efb04eab6ceb$var$isNegation(condition)) {\n        const value = $1d44efb04eab6ceb$var$buildPredicate(condition.value);\n        return (args)=>!value(args);\n    } else if ($1d44efb04eab6ceb$var$isParameterReference(condition)) {\n        const name = condition.parameter.ref.name;\n        return (args)=>args !== void 0 && args[name] === true;\n    } else if ($1d44efb04eab6ceb$var$isBooleanLiteral(condition)) {\n        const value = Boolean(condition.true);\n        return ()=>value;\n    }\n    $1d44efb04eab6ceb$var$assertUnreachable(condition);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildPredicate, \"buildPredicate\");\nfunction $1d44efb04eab6ceb$var$buildAlternatives(ctx, alternatives) {\n    if (alternatives.elements.length === 1) return $1d44efb04eab6ceb$var$buildElement(ctx, alternatives.elements[0]);\n    else {\n        const methods = [];\n        for (const element of alternatives.elements){\n            const predicatedMethod = {\n                // Since we handle the guard condition in the alternative already\n                // We can ignore the group guard condition inside\n                ALT: $1d44efb04eab6ceb$var$buildElement(ctx, element, true)\n            };\n            const guard = $1d44efb04eab6ceb$var$getGuardCondition(element);\n            if (guard) predicatedMethod.GATE = $1d44efb04eab6ceb$var$buildPredicate(guard);\n            methods.push(predicatedMethod);\n        }\n        const idx = ctx.or++;\n        return (args)=>ctx.parser.alternatives(idx, methods.map((method)=>{\n                const alt = {\n                    ALT: /* @__PURE__ */ (0, $7xxrv.__name)(()=>method.ALT(args), \"ALT\")\n                };\n                const gate = method.GATE;\n                if (gate) alt.GATE = ()=>gate(args);\n                return alt;\n            }));\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildAlternatives, \"buildAlternatives\");\nfunction $1d44efb04eab6ceb$var$buildUnorderedGroup(ctx, group) {\n    if (group.elements.length === 1) return $1d44efb04eab6ceb$var$buildElement(ctx, group.elements[0]);\n    const methods = [];\n    for (const element of group.elements){\n        const predicatedMethod = {\n            // Since we handle the guard condition in the alternative already\n            // We can ignore the group guard condition inside\n            ALT: $1d44efb04eab6ceb$var$buildElement(ctx, element, true)\n        };\n        const guard = $1d44efb04eab6ceb$var$getGuardCondition(element);\n        if (guard) predicatedMethod.GATE = $1d44efb04eab6ceb$var$buildPredicate(guard);\n        methods.push(predicatedMethod);\n    }\n    const orIdx = ctx.or++;\n    const idFunc = /* @__PURE__ */ (0, $7xxrv.__name)((groupIdx, lParser)=>{\n        const stackId = lParser.getRuleStack().join(\"-\");\n        return `uGroup_${groupIdx}_${stackId}`;\n    }, \"idFunc\");\n    const alternatives = /* @__PURE__ */ (0, $7xxrv.__name)((args)=>ctx.parser.alternatives(orIdx, methods.map((method, idx)=>{\n            const alt = {\n                ALT: /* @__PURE__ */ (0, $7xxrv.__name)(()=>true, \"ALT\")\n            };\n            const parser = ctx.parser;\n            alt.ALT = ()=>{\n                method.ALT(args);\n                if (!parser.isRecording()) {\n                    const key = idFunc(orIdx, parser);\n                    if (!parser.unorderedGroups.get(key)) parser.unorderedGroups.set(key, []);\n                    const groupState = parser.unorderedGroups.get(key);\n                    if (typeof (groupState === null || groupState === void 0 ? void 0 : groupState[idx]) === \"undefined\") groupState[idx] = true;\n                }\n            };\n            const gate = method.GATE;\n            if (gate) alt.GATE = ()=>gate(args);\n            else alt.GATE = ()=>{\n                const trackedAlternatives = parser.unorderedGroups.get(idFunc(orIdx, parser));\n                const allow = !(trackedAlternatives === null || trackedAlternatives === void 0 ? void 0 : trackedAlternatives[idx]);\n                return allow;\n            };\n            return alt;\n        })), \"alternatives\");\n    const wrapped = $1d44efb04eab6ceb$var$wrap(ctx, $1d44efb04eab6ceb$var$getGuardCondition(group), alternatives, \"*\");\n    return (args)=>{\n        wrapped(args);\n        if (!ctx.parser.isRecording()) ctx.parser.unorderedGroups.delete(idFunc(orIdx, ctx.parser));\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildUnorderedGroup, \"buildUnorderedGroup\");\nfunction $1d44efb04eab6ceb$var$buildGroup(ctx, group) {\n    const methods = group.elements.map((e)=>$1d44efb04eab6ceb$var$buildElement(ctx, e));\n    return (args)=>methods.forEach((method)=>method(args));\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildGroup, \"buildGroup\");\nfunction $1d44efb04eab6ceb$var$getGuardCondition(element) {\n    if ($1d44efb04eab6ceb$var$isGroup(element)) return element.guardCondition;\n    return void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getGuardCondition, \"getGuardCondition\");\nfunction $1d44efb04eab6ceb$var$buildCrossReference(ctx, crossRef, terminal = crossRef.terminal) {\n    if (!terminal) {\n        if (!crossRef.type.ref) throw new Error(\"Could not resolve reference to type: \" + crossRef.type.$refText);\n        const assignment = $1d44efb04eab6ceb$var$findNameAssignment(crossRef.type.ref);\n        const assignTerminal = assignment === null || assignment === void 0 ? void 0 : assignment.terminal;\n        if (!assignTerminal) throw new Error(\"Could not find name assignment for type: \" + $1d44efb04eab6ceb$var$getTypeName(crossRef.type.ref));\n        return $1d44efb04eab6ceb$var$buildCrossReference(ctx, crossRef, assignTerminal);\n    } else if ($1d44efb04eab6ceb$var$isRuleCall(terminal) && $1d44efb04eab6ceb$var$isParserRule(terminal.rule.ref)) {\n        const idx = ctx.subrule++;\n        return (args)=>ctx.parser.subrule(idx, $1d44efb04eab6ceb$var$getRule(ctx, terminal.rule.ref), crossRef, args);\n    } else if ($1d44efb04eab6ceb$var$isRuleCall(terminal) && $1d44efb04eab6ceb$var$isTerminalRule(terminal.rule.ref)) {\n        const idx = ctx.consume++;\n        const terminalRule = $1d44efb04eab6ceb$var$getToken(ctx, terminal.rule.ref.name);\n        return ()=>ctx.parser.consume(idx, terminalRule, crossRef);\n    } else if ($1d44efb04eab6ceb$var$isKeyword(terminal)) {\n        const idx = ctx.consume++;\n        const keyword = $1d44efb04eab6ceb$var$getToken(ctx, terminal.value);\n        return ()=>ctx.parser.consume(idx, keyword, crossRef);\n    } else throw new Error(\"Could not build cross reference parser\");\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildCrossReference, \"buildCrossReference\");\nfunction $1d44efb04eab6ceb$var$buildKeyword(ctx, keyword) {\n    const idx = ctx.consume++;\n    const token = ctx.tokens[keyword.value];\n    if (!token) throw new Error(\"Could not find token for keyword: \" + keyword.value);\n    return ()=>ctx.parser.consume(idx, token, keyword);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildKeyword, \"buildKeyword\");\nfunction $1d44efb04eab6ceb$var$wrap(ctx, guard, method, cardinality) {\n    const gate = guard && $1d44efb04eab6ceb$var$buildPredicate(guard);\n    if (!cardinality) {\n        if (gate) {\n            const idx = ctx.or++;\n            return (args)=>ctx.parser.alternatives(idx, [\n                    {\n                        ALT: /* @__PURE__ */ (0, $7xxrv.__name)(()=>method(args), \"ALT\"),\n                        GATE: /* @__PURE__ */ (0, $7xxrv.__name)(()=>gate(args), \"GATE\")\n                    },\n                    {\n                        ALT: $1d44efb04eab6ceb$var$EMPTY_ALT(),\n                        GATE: /* @__PURE__ */ (0, $7xxrv.__name)(()=>!gate(args), \"GATE\")\n                    }\n                ]);\n        } else return method;\n    }\n    if (cardinality === \"*\") {\n        const idx = ctx.many++;\n        return (args)=>ctx.parser.many(idx, {\n                DEF: /* @__PURE__ */ (0, $7xxrv.__name)(()=>method(args), \"DEF\"),\n                GATE: gate ? ()=>gate(args) : void 0\n            });\n    } else if (cardinality === \"+\") {\n        const idx = ctx.many++;\n        if (gate) {\n            const orIdx = ctx.or++;\n            return (args)=>ctx.parser.alternatives(orIdx, [\n                    {\n                        ALT: /* @__PURE__ */ (0, $7xxrv.__name)(()=>ctx.parser.atLeastOne(idx, {\n                                DEF: /* @__PURE__ */ (0, $7xxrv.__name)(()=>method(args), \"DEF\")\n                            }), \"ALT\"),\n                        GATE: /* @__PURE__ */ (0, $7xxrv.__name)(()=>gate(args), \"GATE\")\n                    },\n                    {\n                        ALT: $1d44efb04eab6ceb$var$EMPTY_ALT(),\n                        GATE: /* @__PURE__ */ (0, $7xxrv.__name)(()=>!gate(args), \"GATE\")\n                    }\n                ]);\n        } else return (args)=>ctx.parser.atLeastOne(idx, {\n                DEF: /* @__PURE__ */ (0, $7xxrv.__name)(()=>method(args), \"DEF\")\n            });\n    } else if (cardinality === \"?\") {\n        const idx = ctx.optional++;\n        return (args)=>ctx.parser.optional(idx, {\n                DEF: /* @__PURE__ */ (0, $7xxrv.__name)(()=>method(args), \"DEF\"),\n                GATE: gate ? ()=>gate(args) : void 0\n            });\n    } else $1d44efb04eab6ceb$var$assertUnreachable(cardinality);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$wrap, \"wrap\");\nfunction $1d44efb04eab6ceb$var$getRule(ctx, element) {\n    const name = $1d44efb04eab6ceb$var$getRuleName(ctx, element);\n    const rule = ctx.rules.get(name);\n    if (!rule) throw new Error(`Rule \"${name}\" not found.\"`);\n    return rule;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getRule, \"getRule\");\nfunction $1d44efb04eab6ceb$var$getRuleName(ctx, element) {\n    if ($1d44efb04eab6ceb$var$isParserRule(element)) return element.name;\n    else if (ctx.ruleNames.has(element)) return ctx.ruleNames.get(element);\n    else {\n        let item = element;\n        let parent = item.$container;\n        let ruleName = element.$type;\n        while(!$1d44efb04eab6ceb$var$isParserRule(parent)){\n            if ($1d44efb04eab6ceb$var$isGroup(parent) || $1d44efb04eab6ceb$var$isAlternatives(parent) || $1d44efb04eab6ceb$var$isUnorderedGroup(parent)) {\n                const index = parent.elements.indexOf(item);\n                ruleName = index.toString() + \":\" + ruleName;\n            }\n            item = parent;\n            parent = parent.$container;\n        }\n        const rule = parent;\n        ruleName = rule.name + \":\" + ruleName;\n        ctx.ruleNames.set(element, ruleName);\n        return ruleName;\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getRuleName, \"getRuleName\");\nfunction $1d44efb04eab6ceb$var$getToken(ctx, name) {\n    const token = ctx.tokens[name];\n    if (!token) throw new Error(`Token \"${name}\" not found.\"`);\n    return token;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getToken, \"getToken\");\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/parser/completion-parser-builder.js\nfunction $1d44efb04eab6ceb$var$createCompletionParser(services) {\n    const grammar = services.Grammar;\n    const lexer = services.parser.Lexer;\n    const parser = new $1d44efb04eab6ceb$var$LangiumCompletionParser(services);\n    $1d44efb04eab6ceb$var$createParser(grammar, parser, lexer.definition);\n    parser.finalize();\n    return parser;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$createCompletionParser, \"createCompletionParser\");\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/parser/langium-parser-builder.js\nfunction $1d44efb04eab6ceb$var$createLangiumParser(services) {\n    const parser = $1d44efb04eab6ceb$var$prepareLangiumParser(services);\n    parser.finalize();\n    return parser;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$createLangiumParser, \"createLangiumParser\");\nfunction $1d44efb04eab6ceb$var$prepareLangiumParser(services) {\n    const grammar = services.Grammar;\n    const lexer = services.parser.Lexer;\n    const parser = new $1d44efb04eab6ceb$var$LangiumParser(services);\n    return $1d44efb04eab6ceb$var$createParser(grammar, parser, lexer.definition);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$prepareLangiumParser, \"prepareLangiumParser\");\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/parser/token-builder.js\nvar $1d44efb04eab6ceb$var$DefaultTokenBuilder = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultTokenBuilder\");\n    }\n    buildTokens(grammar, options) {\n        const reachableRules = $1d44efb04eab6ceb$var$stream($1d44efb04eab6ceb$var$getAllReachableRules(grammar, false));\n        const terminalTokens = this.buildTerminalTokens(reachableRules);\n        const tokens = this.buildKeywordTokens(reachableRules, terminalTokens, options);\n        terminalTokens.forEach((terminalToken)=>{\n            const pattern = terminalToken.PATTERN;\n            if (typeof pattern === \"object\" && pattern && \"test\" in pattern && $1d44efb04eab6ceb$var$isWhitespace(pattern)) tokens.unshift(terminalToken);\n            else tokens.push(terminalToken);\n        });\n        return tokens;\n    }\n    buildTerminalTokens(rules) {\n        return rules.filter($1d44efb04eab6ceb$var$isTerminalRule).filter((e)=>!e.fragment).map((terminal)=>this.buildTerminalToken(terminal)).toArray();\n    }\n    buildTerminalToken(terminal) {\n        const regex = $1d44efb04eab6ceb$var$terminalRegex(terminal);\n        const pattern = this.requiresCustomPattern(regex) ? this.regexPatternFunction(regex) : regex;\n        const tokenType = {\n            name: terminal.name,\n            PATTERN: pattern,\n            LINE_BREAKS: true\n        };\n        if (terminal.hidden) tokenType.GROUP = $1d44efb04eab6ceb$var$isWhitespace(regex) ? $1d44efb04eab6ceb$var$Lexer.SKIPPED : \"hidden\";\n        return tokenType;\n    }\n    requiresCustomPattern(regex) {\n        if (regex.flags.includes(\"u\")) return true;\n        else if (regex.source.includes(\"?<=\") || regex.source.includes(\"?<!\")) return true;\n        else return false;\n    }\n    regexPatternFunction(regex) {\n        const stickyRegex = new RegExp(regex, regex.flags + \"y\");\n        return (text, offset)=>{\n            stickyRegex.lastIndex = offset;\n            const execResult = stickyRegex.exec(text);\n            return execResult;\n        };\n    }\n    buildKeywordTokens(rules, terminalTokens, options) {\n        return rules.filter($1d44efb04eab6ceb$var$isParserRule).flatMap((rule)=>$1d44efb04eab6ceb$var$streamAllContents(rule).filter($1d44efb04eab6ceb$var$isKeyword)).distinct((e)=>e.value).toArray().sort((a, b)=>b.value.length - a.value.length).map((keyword)=>this.buildKeywordToken(keyword, terminalTokens, Boolean(options === null || options === void 0 ? void 0 : options.caseInsensitive)));\n    }\n    buildKeywordToken(keyword, terminalTokens, caseInsensitive) {\n        return {\n            name: keyword.value,\n            PATTERN: this.buildKeywordPattern(keyword, caseInsensitive),\n            LONGER_ALT: this.findLongerAlt(keyword, terminalTokens)\n        };\n    }\n    buildKeywordPattern(keyword, caseInsensitive) {\n        return caseInsensitive ? new RegExp($1d44efb04eab6ceb$var$getCaseInsensitivePattern(keyword.value)) : keyword.value;\n    }\n    findLongerAlt(keyword, terminalTokens) {\n        return terminalTokens.reduce((longerAlts, token)=>{\n            const pattern = token === null || token === void 0 ? void 0 : token.PATTERN;\n            if ((pattern === null || pattern === void 0 ? void 0 : pattern.source) && $1d44efb04eab6ceb$var$partialMatches(\"^\" + pattern.source + \"$\", keyword.value)) longerAlts.push(token);\n            return longerAlts;\n        }, []);\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/parser/value-converter.js\nvar $1d44efb04eab6ceb$var$DefaultValueConverter = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultValueConverter\");\n    }\n    convert(input, cstNode) {\n        let feature = cstNode.grammarSource;\n        if ($1d44efb04eab6ceb$var$isCrossReference(feature)) feature = $1d44efb04eab6ceb$var$getCrossReferenceTerminal(feature);\n        if ($1d44efb04eab6ceb$var$isRuleCall(feature)) {\n            const rule = feature.rule.ref;\n            if (!rule) throw new Error(\"This cst node was not parsed by a rule.\");\n            return this.runConverter(rule, input, cstNode);\n        }\n        return input;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    runConverter(rule, input, cstNode) {\n        var _a;\n        switch(rule.name.toUpperCase()){\n            case \"INT\":\n                return $1d44efb04eab6ceb$var$ValueConverter.convertInt(input);\n            case \"STRING\":\n                return $1d44efb04eab6ceb$var$ValueConverter.convertString(input);\n            case \"ID\":\n                return $1d44efb04eab6ceb$var$ValueConverter.convertID(input);\n        }\n        switch((_a = $1d44efb04eab6ceb$var$getRuleType(rule)) === null || _a === void 0 ? void 0 : _a.toLowerCase()){\n            case \"number\":\n                return $1d44efb04eab6ceb$var$ValueConverter.convertNumber(input);\n            case \"boolean\":\n                return $1d44efb04eab6ceb$var$ValueConverter.convertBoolean(input);\n            case \"bigint\":\n                return $1d44efb04eab6ceb$var$ValueConverter.convertBigint(input);\n            case \"date\":\n                return $1d44efb04eab6ceb$var$ValueConverter.convertDate(input);\n            default:\n                return input;\n        }\n    }\n};\nvar $1d44efb04eab6ceb$var$ValueConverter;\n(function(ValueConverter2) {\n    function convertString(input) {\n        let result = \"\";\n        for(let i = 1; i < input.length - 1; i++){\n            const c = input.charAt(i);\n            if (c === \"\\\\\") {\n                const c1 = input.charAt(++i);\n                result += convertEscapeCharacter(c1);\n            } else result += c;\n        }\n        return result;\n    }\n    (0, $7xxrv.__name)(convertString, \"convertString\");\n    ValueConverter2.convertString = convertString;\n    function convertEscapeCharacter(char) {\n        switch(char){\n            case \"b\":\n                return \"\\b\";\n            case \"f\":\n                return \"\\f\";\n            case \"n\":\n                return \"\\n\";\n            case \"r\":\n                return \"\\r\";\n            case \"t\":\n                return \"\t\";\n            case \"v\":\n                return \"\\v\";\n            case \"0\":\n                return \"\\0\";\n            default:\n                return char;\n        }\n    }\n    (0, $7xxrv.__name)(convertEscapeCharacter, \"convertEscapeCharacter\");\n    function convertID(input) {\n        if (input.charAt(0) === \"^\") return input.substring(1);\n        else return input;\n    }\n    (0, $7xxrv.__name)(convertID, \"convertID\");\n    ValueConverter2.convertID = convertID;\n    function convertInt(input) {\n        return parseInt(input);\n    }\n    (0, $7xxrv.__name)(convertInt, \"convertInt\");\n    ValueConverter2.convertInt = convertInt;\n    function convertBigint(input) {\n        return BigInt(input);\n    }\n    (0, $7xxrv.__name)(convertBigint, \"convertBigint\");\n    ValueConverter2.convertBigint = convertBigint;\n    function convertDate(input) {\n        return new Date(input);\n    }\n    (0, $7xxrv.__name)(convertDate, \"convertDate\");\n    ValueConverter2.convertDate = convertDate;\n    function convertNumber(input) {\n        return Number(input);\n    }\n    (0, $7xxrv.__name)(convertNumber, \"convertNumber\");\n    ValueConverter2.convertNumber = convertNumber;\n    function convertBoolean(input) {\n        return input.toLowerCase() === \"true\";\n    }\n    (0, $7xxrv.__name)(convertBoolean, \"convertBoolean\");\n    ValueConverter2.convertBoolean = convertBoolean;\n})($1d44efb04eab6ceb$var$ValueConverter || ($1d44efb04eab6ceb$var$ValueConverter = {}));\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/cancellation.js\nvar $1d44efb04eab6ceb$var$cancellation_exports = {};\n(0, $7xxrv.__reExport)($1d44efb04eab6ceb$var$cancellation_exports, (0, $7xxrv.__toESM)($1d44efb04eab6ceb$var$require_cancellation(), 1));\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/promise-utils.js\nfunction $1d44efb04eab6ceb$var$delayNextTick() {\n    return new Promise((resolve)=>{\n        if (typeof setImmediate === \"undefined\") setTimeout(resolve, 0);\n        else setImmediate(resolve);\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$delayNextTick, \"delayNextTick\");\nvar $1d44efb04eab6ceb$var$lastTick = 0;\nvar $1d44efb04eab6ceb$var$globalInterruptionPeriod = 10;\nfunction $1d44efb04eab6ceb$var$startCancelableOperation() {\n    $1d44efb04eab6ceb$var$lastTick = Date.now();\n    return new $1d44efb04eab6ceb$var$cancellation_exports.CancellationTokenSource();\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$startCancelableOperation, \"startCancelableOperation\");\nfunction $1d44efb04eab6ceb$var$setInterruptionPeriod(period) {\n    $1d44efb04eab6ceb$var$globalInterruptionPeriod = period;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$setInterruptionPeriod, \"setInterruptionPeriod\");\nvar $1d44efb04eab6ceb$var$OperationCancelled = Symbol(\"OperationCancelled\");\nfunction $1d44efb04eab6ceb$var$isOperationCancelled(err) {\n    return err === $1d44efb04eab6ceb$var$OperationCancelled;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isOperationCancelled, \"isOperationCancelled\");\nasync function $1d44efb04eab6ceb$var$interruptAndCheck(token) {\n    if (token === $1d44efb04eab6ceb$var$cancellation_exports.CancellationToken.None) return;\n    const current = Date.now();\n    if (current - $1d44efb04eab6ceb$var$lastTick >= $1d44efb04eab6ceb$var$globalInterruptionPeriod) {\n        $1d44efb04eab6ceb$var$lastTick = current;\n        await $1d44efb04eab6ceb$var$delayNextTick();\n    }\n    if (token.isCancellationRequested) throw $1d44efb04eab6ceb$var$OperationCancelled;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$interruptAndCheck, \"interruptAndCheck\");\nvar $1d44efb04eab6ceb$var$Deferred = class {\n    static{\n        (0, $7xxrv.__name)(this, \"Deferred\");\n    }\n    constructor(){\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = (arg)=>{\n                resolve(arg);\n                return this;\n            };\n            this.reject = (err)=>{\n                reject(err);\n                return this;\n            };\n        });\n    }\n};\n// ../../node_modules/.pnpm/vscode-languageserver-textdocument@1.0.12/node_modules/vscode-languageserver-textdocument/lib/esm/main.js\nvar $1d44efb04eab6ceb$var$FullTextDocument2 = class _FullTextDocument {\n    static{\n        (0, $7xxrv.__name)(this, \"FullTextDocument\");\n    }\n    constructor(uri, languageId, version, content){\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = void 0;\n    }\n    get uri() {\n        return this._uri;\n    }\n    get languageId() {\n        return this._languageId;\n    }\n    get version() {\n        return this._version;\n    }\n    getText(range) {\n        if (range) {\n            const start = this.offsetAt(range.start);\n            const end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    }\n    update(changes, version) {\n        for (const change of changes){\n            if (_FullTextDocument.isIncremental(change)) {\n                const range = $1d44efb04eab6ceb$var$getWellformedRange(change.range);\n                const startOffset = this.offsetAt(range.start);\n                const endOffset = this.offsetAt(range.end);\n                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n                const startLine = Math.max(range.start.line, 0);\n                const endLine = Math.max(range.end.line, 0);\n                let lineOffsets = this._lineOffsets;\n                const addedLineOffsets = $1d44efb04eab6ceb$var$computeLineOffsets(change.text, false, startOffset);\n                if (endLine - startLine === addedLineOffsets.length) for(let i = 0, len = addedLineOffsets.length; i < len; i++)lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n                else if (addedLineOffsets.length < 1e4) lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);\n                else this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n                const diff = change.text.length - (endOffset - startOffset);\n                if (diff !== 0) for(let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++)lineOffsets[i] = lineOffsets[i] + diff;\n            } else if (_FullTextDocument.isFull(change)) {\n                this._content = change.text;\n                this._lineOffsets = void 0;\n            } else throw new Error(\"Unknown change event received\");\n        }\n        this._version = version;\n    }\n    getLineOffsets() {\n        if (this._lineOffsets === void 0) this._lineOffsets = $1d44efb04eab6ceb$var$computeLineOffsets(this._content, true);\n        return this._lineOffsets;\n    }\n    positionAt(offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        const lineOffsets = this.getLineOffsets();\n        let low = 0, high = lineOffsets.length;\n        if (high === 0) return {\n            line: 0,\n            character: offset\n        };\n        while(low < high){\n            const mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) high = mid;\n            else low = mid + 1;\n        }\n        const line = low - 1;\n        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);\n        return {\n            line: line,\n            character: offset - lineOffsets[line]\n        };\n    }\n    offsetAt(position) {\n        const lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) return this._content.length;\n        else if (position.line < 0) return 0;\n        const lineOffset = lineOffsets[position.line];\n        if (position.character <= 0) return lineOffset;\n        const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;\n        const offset = Math.min(lineOffset + position.character, nextLineOffset);\n        return this.ensureBeforeEOL(offset, lineOffset);\n    }\n    ensureBeforeEOL(offset, lineOffset) {\n        while(offset > lineOffset && $1d44efb04eab6ceb$var$isEOL(this._content.charCodeAt(offset - 1)))offset--;\n        return offset;\n    }\n    get lineCount() {\n        return this.getLineOffsets().length;\n    }\n    static isIncremental(event) {\n        const candidate = event;\n        return candidate !== void 0 && candidate !== null && typeof candidate.text === \"string\" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === \"number\");\n    }\n    static isFull(event) {\n        const candidate = event;\n        return candidate !== void 0 && candidate !== null && typeof candidate.text === \"string\" && candidate.range === void 0 && candidate.rangeLength === void 0;\n    }\n};\nvar $1d44efb04eab6ceb$var$TextDocument2;\n(function(TextDocument3) {\n    function create(uri, languageId, version, content) {\n        return new $1d44efb04eab6ceb$var$FullTextDocument2(uri, languageId, version, content);\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    TextDocument3.create = create;\n    function update(document, changes, version) {\n        if (document instanceof $1d44efb04eab6ceb$var$FullTextDocument2) {\n            document.update(changes, version);\n            return document;\n        } else throw new Error(\"TextDocument.update: document must be created by TextDocument.create\");\n    }\n    (0, $7xxrv.__name)(update, \"update\");\n    TextDocument3.update = update;\n    function applyEdits(document, edits) {\n        const text = document.getText();\n        const sortedEdits = $1d44efb04eab6ceb$var$mergeSort(edits.map($1d44efb04eab6ceb$var$getWellformedEdit), (a, b)=>{\n            const diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) return a.range.start.character - b.range.start.character;\n            return diff;\n        });\n        let lastModifiedOffset = 0;\n        const spans = [];\n        for (const e of sortedEdits){\n            const startOffset = document.offsetAt(e.range.start);\n            if (startOffset < lastModifiedOffset) throw new Error(\"Overlapping edit\");\n            else if (startOffset > lastModifiedOffset) spans.push(text.substring(lastModifiedOffset, startOffset));\n            if (e.newText.length) spans.push(e.newText);\n            lastModifiedOffset = document.offsetAt(e.range.end);\n        }\n        spans.push(text.substr(lastModifiedOffset));\n        return spans.join(\"\");\n    }\n    (0, $7xxrv.__name)(applyEdits, \"applyEdits\");\n    TextDocument3.applyEdits = applyEdits;\n})($1d44efb04eab6ceb$var$TextDocument2 || ($1d44efb04eab6ceb$var$TextDocument2 = {}));\nfunction $1d44efb04eab6ceb$var$mergeSort(data, compare) {\n    if (data.length <= 1) return data;\n    const p = data.length / 2 | 0;\n    const left = data.slice(0, p);\n    const right = data.slice(p);\n    $1d44efb04eab6ceb$var$mergeSort(left, compare);\n    $1d44efb04eab6ceb$var$mergeSort(right, compare);\n    let leftIdx = 0;\n    let rightIdx = 0;\n    let i = 0;\n    while(leftIdx < left.length && rightIdx < right.length){\n        const ret = compare(left[leftIdx], right[rightIdx]);\n        if (ret <= 0) data[i++] = left[leftIdx++];\n        else data[i++] = right[rightIdx++];\n    }\n    while(leftIdx < left.length)data[i++] = left[leftIdx++];\n    while(rightIdx < right.length)data[i++] = right[rightIdx++];\n    return data;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$mergeSort, \"mergeSort\");\nfunction $1d44efb04eab6ceb$var$computeLineOffsets(text, isAtLineStart, textOffset = 0) {\n    const result = isAtLineStart ? [\n        textOffset\n    ] : [];\n    for(let i = 0; i < text.length; i++){\n        const ch = text.charCodeAt(i);\n        if ($1d44efb04eab6ceb$var$isEOL(ch)) {\n            if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) i++;\n            result.push(textOffset + i + 1);\n        }\n    }\n    return result;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$computeLineOffsets, \"computeLineOffsets\");\nfunction $1d44efb04eab6ceb$var$isEOL(char) {\n    return char === 13 || char === 10;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isEOL, \"isEOL\");\nfunction $1d44efb04eab6ceb$var$getWellformedRange(range) {\n    const start = range.start;\n    const end = range.end;\n    if (start.line > end.line || start.line === end.line && start.character > end.character) return {\n        start: end,\n        end: start\n    };\n    return range;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getWellformedRange, \"getWellformedRange\");\nfunction $1d44efb04eab6ceb$var$getWellformedEdit(textEdit) {\n    const range = $1d44efb04eab6ceb$var$getWellformedRange(textEdit.range);\n    if (range !== textEdit.range) return {\n        newText: textEdit.newText,\n        range: range\n    };\n    return textEdit;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getWellformedEdit, \"getWellformedEdit\");\n// ../../node_modules/.pnpm/vscode-uri@3.0.8/node_modules/vscode-uri/lib/esm/index.mjs\nvar $1d44efb04eab6ceb$var$LIB;\n(()=>{\n    \"use strict\";\n    var t = {\n        470: (t2)=>{\n            function e2(t3) {\n                if (\"string\" != typeof t3) throw new TypeError(\"Path must be a string. Received \" + JSON.stringify(t3));\n            }\n            (0, $7xxrv.__name)(e2, \"e\");\n            function r2(t3, e3) {\n                for(var r3, n3 = \"\", i = 0, o = -1, s = 0, h = 0; h <= t3.length; ++h){\n                    if (h < t3.length) r3 = t3.charCodeAt(h);\n                    else {\n                        if (47 === r3) break;\n                        r3 = 47;\n                    }\n                    if (47 === r3) {\n                        if (o === h - 1 || 1 === s) ;\n                        else if (o !== h - 1 && 2 === s) {\n                            if (n3.length < 2 || 2 !== i || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {\n                                if (n3.length > 2) {\n                                    var a = n3.lastIndexOf(\"/\");\n                                    if (a !== n3.length - 1) {\n                                        -1 === a ? (n3 = \"\", i = 0) : i = (n3 = n3.slice(0, a)).length - 1 - n3.lastIndexOf(\"/\"), o = h, s = 0;\n                                        continue;\n                                    }\n                                } else if (2 === n3.length || 1 === n3.length) {\n                                    n3 = \"\", i = 0, o = h, s = 0;\n                                    continue;\n                                }\n                            }\n                            e3 && (n3.length > 0 ? n3 += \"/..\" : n3 = \"..\", i = 2);\n                        } else n3.length > 0 ? n3 += \"/\" + t3.slice(o + 1, h) : n3 = t3.slice(o + 1, h), i = h - o - 1;\n                        o = h, s = 0;\n                    } else 46 === r3 && -1 !== s ? ++s : s = -1;\n                }\n                return n3;\n            }\n            (0, $7xxrv.__name)(r2, \"r\");\n            var n2 = {\n                resolve: /* @__PURE__ */ (0, $7xxrv.__name)(function() {\n                    for(var t3, n3 = \"\", i = false, o = arguments.length - 1; o >= -1 && !i; o--){\n                        var s;\n                        o >= 0 ? s = arguments[o] : (void 0 === t3 && (t3 = $hPtJY.cwd()), s = t3), e2(s), 0 !== s.length && (n3 = s + \"/\" + n3, i = 47 === s.charCodeAt(0));\n                    }\n                    return n3 = r2(n3, !i), i ? n3.length > 0 ? \"/\" + n3 : \"/\" : n3.length > 0 ? n3 : \".\";\n                }, \"resolve\"),\n                normalize: /* @__PURE__ */ (0, $7xxrv.__name)(function(t3) {\n                    if (e2(t3), 0 === t3.length) return \".\";\n                    var n3 = 47 === t3.charCodeAt(0), i = 47 === t3.charCodeAt(t3.length - 1);\n                    return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = \".\"), t3.length > 0 && i && (t3 += \"/\"), n3 ? \"/\" + t3 : t3;\n                }, \"normalize\"),\n                isAbsolute: /* @__PURE__ */ (0, $7xxrv.__name)(function(t3) {\n                    return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);\n                }, \"isAbsolute\"),\n                join: /* @__PURE__ */ (0, $7xxrv.__name)(function() {\n                    if (0 === arguments.length) return \".\";\n                    for(var t3, r3 = 0; r3 < arguments.length; ++r3){\n                        var i = arguments[r3];\n                        e2(i), i.length > 0 && (void 0 === t3 ? t3 = i : t3 += \"/\" + i);\n                    }\n                    return void 0 === t3 ? \".\" : n2.normalize(t3);\n                }, \"join\"),\n                relative: /* @__PURE__ */ (0, $7xxrv.__name)(function(t3, r3) {\n                    if (e2(t3), e2(r3), t3 === r3) return \"\";\n                    if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3))) return \"\";\n                    for(var i = 1; i < t3.length && 47 === t3.charCodeAt(i); ++i);\n                    for(var o = t3.length, s = o - i, h = 1; h < r3.length && 47 === r3.charCodeAt(h); ++h);\n                    for(var a = r3.length - h, c = s < a ? s : a, f = -1, u = 0; u <= c; ++u){\n                        if (u === c) {\n                            if (a > c) {\n                                if (47 === r3.charCodeAt(h + u)) return r3.slice(h + u + 1);\n                                if (0 === u) return r3.slice(h + u);\n                            } else s > c && (47 === t3.charCodeAt(i + u) ? f = u : 0 === u && (f = 0));\n                            break;\n                        }\n                        var l = t3.charCodeAt(i + u);\n                        if (l !== r3.charCodeAt(h + u)) break;\n                        47 === l && (f = u);\n                    }\n                    var g = \"\";\n                    for(u = i + f + 1; u <= o; ++u)u !== o && 47 !== t3.charCodeAt(u) || (0 === g.length ? g += \"..\" : g += \"/..\");\n                    return g.length > 0 ? g + r3.slice(h + f) : (h += f, 47 === r3.charCodeAt(h) && ++h, r3.slice(h));\n                }, \"relative\"),\n                _makeLong: /* @__PURE__ */ (0, $7xxrv.__name)(function(t3) {\n                    return t3;\n                }, \"_makeLong\"),\n                dirname: /* @__PURE__ */ (0, $7xxrv.__name)(function(t3) {\n                    if (e2(t3), 0 === t3.length) return \".\";\n                    for(var r3 = t3.charCodeAt(0), n3 = 47 === r3, i = -1, o = true, s = t3.length - 1; s >= 1; --s)if (47 === (r3 = t3.charCodeAt(s))) {\n                        if (!o) {\n                            i = s;\n                            break;\n                        }\n                    } else o = false;\n                    return -1 === i ? n3 ? \"/\" : \".\" : n3 && 1 === i ? \"//\" : t3.slice(0, i);\n                }, \"dirname\"),\n                basename: /* @__PURE__ */ (0, $7xxrv.__name)(function(t3, r3) {\n                    if (void 0 !== r3 && \"string\" != typeof r3) throw new TypeError('\"ext\" argument must be a string');\n                    e2(t3);\n                    var n3, i = 0, o = -1, s = true;\n                    if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {\n                        if (r3.length === t3.length && r3 === t3) return \"\";\n                        var h = r3.length - 1, a = -1;\n                        for(n3 = t3.length - 1; n3 >= 0; --n3){\n                            var c = t3.charCodeAt(n3);\n                            if (47 === c) {\n                                if (!s) {\n                                    i = n3 + 1;\n                                    break;\n                                }\n                            } else -1 === a && (s = false, a = n3 + 1), h >= 0 && (c === r3.charCodeAt(h) ? -1 == --h && (o = n3) : (h = -1, o = a));\n                        }\n                        return i === o ? o = a : -1 === o && (o = t3.length), t3.slice(i, o);\n                    }\n                    for(n3 = t3.length - 1; n3 >= 0; --n3)if (47 === t3.charCodeAt(n3)) {\n                        if (!s) {\n                            i = n3 + 1;\n                            break;\n                        }\n                    } else -1 === o && (s = false, o = n3 + 1);\n                    return -1 === o ? \"\" : t3.slice(i, o);\n                }, \"basename\"),\n                extname: /* @__PURE__ */ (0, $7xxrv.__name)(function(t3) {\n                    e2(t3);\n                    for(var r3 = -1, n3 = 0, i = -1, o = true, s = 0, h = t3.length - 1; h >= 0; --h){\n                        var a = t3.charCodeAt(h);\n                        if (47 !== a) -1 === i && (o = false, i = h + 1), 46 === a ? -1 === r3 ? r3 = h : 1 !== s && (s = 1) : -1 !== r3 && (s = -1);\n                        else if (!o) {\n                            n3 = h + 1;\n                            break;\n                        }\n                    }\n                    return -1 === r3 || -1 === i || 0 === s || 1 === s && r3 === i - 1 && r3 === n3 + 1 ? \"\" : t3.slice(r3, i);\n                }, \"extname\"),\n                format: /* @__PURE__ */ (0, $7xxrv.__name)(function(t3) {\n                    if (null === t3 || \"object\" != typeof t3) throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof t3);\n                    return function(t4, e3) {\n                        var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || \"\") + (e3.ext || \"\");\n                        return r3 ? r3 === e3.root ? r3 + n3 : r3 + \"/\" + n3 : n3;\n                    }(0, t3);\n                }, \"format\"),\n                parse: /* @__PURE__ */ (0, $7xxrv.__name)(function(t3) {\n                    e2(t3);\n                    var r3 = {\n                        root: \"\",\n                        dir: \"\",\n                        base: \"\",\n                        ext: \"\",\n                        name: \"\"\n                    };\n                    if (0 === t3.length) return r3;\n                    var n3, i = t3.charCodeAt(0), o = 47 === i;\n                    o ? (r3.root = \"/\", n3 = 1) : n3 = 0;\n                    for(var s = -1, h = 0, a = -1, c = true, f = t3.length - 1, u = 0; f >= n3; --f)if (47 !== (i = t3.charCodeAt(f))) -1 === a && (c = false, a = f + 1), 46 === i ? -1 === s ? s = f : 1 !== u && (u = 1) : -1 !== s && (u = -1);\n                    else if (!c) {\n                        h = f + 1;\n                        break;\n                    }\n                    return -1 === s || -1 === a || 0 === u || 1 === u && s === a - 1 && s === h + 1 ? -1 !== a && (r3.base = r3.name = 0 === h && o ? t3.slice(1, a) : t3.slice(h, a)) : (0 === h && o ? (r3.name = t3.slice(1, s), r3.base = t3.slice(1, a)) : (r3.name = t3.slice(h, s), r3.base = t3.slice(h, a)), r3.ext = t3.slice(s, a)), h > 0 ? r3.dir = t3.slice(0, h - 1) : o && (r3.dir = \"/\"), r3;\n                }, \"parse\"),\n                sep: \"/\",\n                delimiter: \":\",\n                win32: null,\n                posix: null\n            };\n            n2.posix = n2, t2.exports = n2;\n        }\n    }, e = {};\n    function r(n2) {\n        var i = e[n2];\n        if (void 0 !== i) return i.exports;\n        var o = e[n2] = {\n            exports: {}\n        };\n        return t[n2](o, o.exports, r), o.exports;\n    }\n    (0, $7xxrv.__name)(r, \"r\");\n    r.d = (t2, e2)=>{\n        for(var n2 in e2)r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, {\n            enumerable: true,\n            get: e2[n2]\n        });\n    }, r.o = (t2, e2)=>Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2)=>{\n        \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, {\n            value: \"Module\"\n        }), Object.defineProperty(t2, \"__esModule\", {\n            value: true\n        });\n    };\n    var n = {};\n    (()=>{\n        let t2;\n        if (r.r(n), r.d(n, {\n            URI: /* @__PURE__ */ (0, $7xxrv.__name)(()=>f, \"URI\"),\n            Utils: /* @__PURE__ */ (0, $7xxrv.__name)(()=>P, \"Utils\")\n        }), \"object\" == typeof $hPtJY) t2 = \"win32\" === $hPtJY.platform;\n        else if (\"object\" == typeof navigator) {\n            let e3 = navigator.userAgent;\n            t2 = e3.indexOf(\"Windows\") >= 0;\n        }\n        const e2 = /^\\w[\\w\\d+.-]*$/, i = /^\\//, o = /^\\/\\//;\n        function s(t3, r2) {\n            if (!t3.scheme && r2) throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${t3.authority}\", path: \"${t3.path}\", query: \"${t3.query}\", fragment: \"${t3.fragment}\"}`);\n            if (t3.scheme && !e2.test(t3.scheme)) throw new Error(\"[UriError]: Scheme contains illegal characters.\");\n            if (t3.path) {\n                if (t3.authority) {\n                    if (!i.test(t3.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n                } else if (o.test(t3.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n            }\n        }\n        (0, $7xxrv.__name)(s, \"s\");\n        const h = \"\", a = \"/\", c = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n        class f {\n            static{\n                (0, $7xxrv.__name)(this, \"f\");\n            }\n            static isUri(t3) {\n                return t3 instanceof f || !!t3 && \"string\" == typeof t3.authority && \"string\" == typeof t3.fragment && \"string\" == typeof t3.path && \"string\" == typeof t3.query && \"string\" == typeof t3.scheme && \"string\" == typeof t3.fsPath && \"function\" == typeof t3.with && \"function\" == typeof t3.toString;\n            }\n            scheme;\n            authority;\n            path;\n            query;\n            fragment;\n            constructor(t3, e3, r2, n2, i2, o2 = false){\n                \"object\" == typeof t3 ? (this.scheme = t3.scheme || h, this.authority = t3.authority || h, this.path = t3.path || h, this.query = t3.query || h, this.fragment = t3.fragment || h) : (this.scheme = /* @__PURE__ */ function(t4, e4) {\n                    return t4 || e4 ? t4 : \"file\";\n                }(t3, o2), this.authority = e3 || h, this.path = function(t4, e4) {\n                    switch(t4){\n                        case \"https\":\n                        case \"http\":\n                        case \"file\":\n                            e4 ? e4[0] !== a && (e4 = a + e4) : e4 = a;\n                    }\n                    return e4;\n                }(this.scheme, r2 || h), this.query = n2 || h, this.fragment = i2 || h, s(this, o2));\n            }\n            get fsPath() {\n                return m(this, false);\n            }\n            with(t3) {\n                if (!t3) return this;\n                let { scheme: e3, authority: r2, path: n2, query: i2, fragment: o2 } = t3;\n                return void 0 === e3 ? e3 = this.scheme : null === e3 && (e3 = h), void 0 === r2 ? r2 = this.authority : null === r2 && (r2 = h), void 0 === n2 ? n2 = this.path : null === n2 && (n2 = h), void 0 === i2 ? i2 = this.query : null === i2 && (i2 = h), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = h), e3 === this.scheme && r2 === this.authority && n2 === this.path && i2 === this.query && o2 === this.fragment ? this : new l(e3, r2, n2, i2, o2);\n            }\n            static parse(t3, e3 = false) {\n                const r2 = c.exec(t3);\n                return r2 ? new l(r2[2] || h, C(r2[4] || h), C(r2[5] || h), C(r2[7] || h), C(r2[9] || h), e3) : new l(h, h, h, h, h);\n            }\n            static file(e3) {\n                let r2 = h;\n                if (t2 && (e3 = e3.replace(/\\\\/g, a)), e3[0] === a && e3[1] === a) {\n                    const t3 = e3.indexOf(a, 2);\n                    -1 === t3 ? (r2 = e3.substring(2), e3 = a) : (r2 = e3.substring(2, t3), e3 = e3.substring(t3) || a);\n                }\n                return new l(\"file\", r2, e3, h, h);\n            }\n            static from(t3) {\n                const e3 = new l(t3.scheme, t3.authority, t3.path, t3.query, t3.fragment);\n                return s(e3, true), e3;\n            }\n            toString(t3 = false) {\n                return y(this, t3);\n            }\n            toJSON() {\n                return this;\n            }\n            static revive(t3) {\n                if (t3) {\n                    if (t3 instanceof f) return t3;\n                    {\n                        const e3 = new l(t3);\n                        return e3._formatted = t3.external, e3._fsPath = t3._sep === u ? t3.fsPath : null, e3;\n                    }\n                }\n                return t3;\n            }\n        }\n        const u = t2 ? 1 : void 0;\n        class l extends f {\n            static{\n                (0, $7xxrv.__name)(this, \"l\");\n            }\n            _formatted = null;\n            _fsPath = null;\n            get fsPath() {\n                return this._fsPath || (this._fsPath = m(this, false)), this._fsPath;\n            }\n            toString(t3 = false) {\n                return t3 ? y(this, true) : (this._formatted || (this._formatted = y(this, false)), this._formatted);\n            }\n            toJSON() {\n                const t3 = {\n                    $mid: 1\n                };\n                return this._fsPath && (t3.fsPath = this._fsPath, t3._sep = u), this._formatted && (t3.external = this._formatted), this.path && (t3.path = this.path), this.scheme && (t3.scheme = this.scheme), this.authority && (t3.authority = this.authority), this.query && (t3.query = this.query), this.fragment && (t3.fragment = this.fragment), t3;\n            }\n        }\n        const g = {\n            58: \"%3A\",\n            47: \"%2F\",\n            63: \"%3F\",\n            35: \"%23\",\n            91: \"%5B\",\n            93: \"%5D\",\n            64: \"%40\",\n            33: \"%21\",\n            36: \"%24\",\n            38: \"%26\",\n            39: \"%27\",\n            40: \"%28\",\n            41: \"%29\",\n            42: \"%2A\",\n            43: \"%2B\",\n            44: \"%2C\",\n            59: \"%3B\",\n            61: \"%3D\",\n            32: \"%20\"\n        };\n        function d(t3, e3, r2) {\n            let n2, i2 = -1;\n            for(let o2 = 0; o2 < t3.length; o2++){\n                const s2 = t3.charCodeAt(o2);\n                if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e3 && 47 === s2 || r2 && 91 === s2 || r2 && 93 === s2 || r2 && 58 === s2) -1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), void 0 !== n2 && (n2 += t3.charAt(o2));\n                else {\n                    void 0 === n2 && (n2 = t3.substr(0, o2));\n                    const e4 = g[s2];\n                    void 0 !== e4 ? (-1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), n2 += e4) : -1 === i2 && (i2 = o2);\n                }\n            }\n            return -1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2))), void 0 !== n2 ? n2 : t3;\n        }\n        (0, $7xxrv.__name)(d, \"d\");\n        function p(t3) {\n            let e3;\n            for(let r2 = 0; r2 < t3.length; r2++){\n                const n2 = t3.charCodeAt(r2);\n                35 === n2 || 63 === n2 ? (void 0 === e3 && (e3 = t3.substr(0, r2)), e3 += g[n2]) : void 0 !== e3 && (e3 += t3[r2]);\n            }\n            return void 0 !== e3 ? e3 : t3;\n        }\n        (0, $7xxrv.__name)(p, \"p\");\n        function m(e3, r2) {\n            let n2;\n            return n2 = e3.authority && e3.path.length > 1 && \"file\" === e3.scheme ? `//${e3.authority}${e3.path}` : 47 === e3.path.charCodeAt(0) && (e3.path.charCodeAt(1) >= 65 && e3.path.charCodeAt(1) <= 90 || e3.path.charCodeAt(1) >= 97 && e3.path.charCodeAt(1) <= 122) && 58 === e3.path.charCodeAt(2) ? r2 ? e3.path.substr(1) : e3.path[1].toLowerCase() + e3.path.substr(2) : e3.path, t2 && (n2 = n2.replace(/\\//g, \"\\\\\")), n2;\n        }\n        (0, $7xxrv.__name)(m, \"m\");\n        function y(t3, e3) {\n            const r2 = e3 ? p : d;\n            let n2 = \"\", { scheme: i2, authority: o2, path: s2, query: h2, fragment: c2 } = t3;\n            if (i2 && (n2 += i2, n2 += \":\"), (o2 || \"file\" === i2) && (n2 += a, n2 += a), o2) {\n                let t4 = o2.indexOf(\"@\");\n                if (-1 !== t4) {\n                    const e4 = o2.substr(0, t4);\n                    o2 = o2.substr(t4 + 1), t4 = e4.lastIndexOf(\":\"), -1 === t4 ? n2 += r2(e4, false, false) : (n2 += r2(e4.substr(0, t4), false, false), n2 += \":\", n2 += r2(e4.substr(t4 + 1), false, true)), n2 += \"@\";\n                }\n                o2 = o2.toLowerCase(), t4 = o2.lastIndexOf(\":\"), -1 === t4 ? n2 += r2(o2, false, true) : (n2 += r2(o2.substr(0, t4), false, true), n2 += o2.substr(t4));\n            }\n            if (s2) {\n                if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {\n                    const t4 = s2.charCodeAt(1);\n                    t4 >= 65 && t4 <= 90 && (s2 = `/${String.fromCharCode(t4 + 32)}:${s2.substr(3)}`);\n                } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {\n                    const t4 = s2.charCodeAt(0);\n                    t4 >= 65 && t4 <= 90 && (s2 = `${String.fromCharCode(t4 + 32)}:${s2.substr(2)}`);\n                }\n                n2 += r2(s2, true, false);\n            }\n            return h2 && (n2 += \"?\", n2 += r2(h2, false, false)), c2 && (n2 += \"#\", n2 += e3 ? c2 : d(c2, false, false)), n2;\n        }\n        (0, $7xxrv.__name)(y, \"y\");\n        function v(t3) {\n            try {\n                return decodeURIComponent(t3);\n            } catch  {\n                return t3.length > 3 ? t3.substr(0, 3) + v(t3.substr(3)) : t3;\n            }\n        }\n        (0, $7xxrv.__name)(v, \"v\");\n        const b = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n        function C(t3) {\n            return t3.match(b) ? t3.replace(b, (t4)=>v(t4)) : t3;\n        }\n        (0, $7xxrv.__name)(C, \"C\");\n        var A = r(470);\n        const w = A.posix || A, x = \"/\";\n        var P;\n        !function(t3) {\n            t3.joinPath = function(t4, ...e3) {\n                return t4.with({\n                    path: w.join(t4.path, ...e3)\n                });\n            }, t3.resolvePath = function(t4, ...e3) {\n                let r2 = t4.path, n2 = false;\n                r2[0] !== x && (r2 = x + r2, n2 = true);\n                let i2 = w.resolve(r2, ...e3);\n                return n2 && i2[0] === x && !t4.authority && (i2 = i2.substring(1)), t4.with({\n                    path: i2\n                });\n            }, t3.dirname = function(t4) {\n                if (0 === t4.path.length || t4.path === x) return t4;\n                let e3 = w.dirname(t4.path);\n                return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = \"\"), t4.with({\n                    path: e3\n                });\n            }, t3.basename = function(t4) {\n                return w.basename(t4.path);\n            }, t3.extname = function(t4) {\n                return w.extname(t4.path);\n            };\n        }(P || (P = {}));\n    })(), $1d44efb04eab6ceb$var$LIB = n;\n})();\nvar { URI: $1d44efb04eab6ceb$var$URI2, Utils: $1d44efb04eab6ceb$var$Utils } = $1d44efb04eab6ceb$var$LIB;\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/uri-utils.js\nvar $1d44efb04eab6ceb$var$UriUtils;\n(function(UriUtils2) {\n    UriUtils2.basename = $1d44efb04eab6ceb$var$Utils.basename;\n    UriUtils2.dirname = $1d44efb04eab6ceb$var$Utils.dirname;\n    UriUtils2.extname = $1d44efb04eab6ceb$var$Utils.extname;\n    UriUtils2.joinPath = $1d44efb04eab6ceb$var$Utils.joinPath;\n    UriUtils2.resolvePath = $1d44efb04eab6ceb$var$Utils.resolvePath;\n    function equals(a, b) {\n        return (a === null || a === void 0 ? void 0 : a.toString()) === (b === null || b === void 0 ? void 0 : b.toString());\n    }\n    (0, $7xxrv.__name)(equals, \"equals\");\n    UriUtils2.equals = equals;\n    function relative(from, to) {\n        const fromPath = typeof from === \"string\" ? from : from.path;\n        const toPath = typeof to === \"string\" ? to : to.path;\n        const fromParts = fromPath.split(\"/\").filter((e)=>e.length > 0);\n        const toParts = toPath.split(\"/\").filter((e)=>e.length > 0);\n        let i = 0;\n        for(; i < fromParts.length; i++){\n            if (fromParts[i] !== toParts[i]) break;\n        }\n        const backPart = \"../\".repeat(fromParts.length - i);\n        const toPart = toParts.slice(i).join(\"/\");\n        return backPart + toPart;\n    }\n    (0, $7xxrv.__name)(relative, \"relative\");\n    UriUtils2.relative = relative;\n})($1d44efb04eab6ceb$var$UriUtils || ($1d44efb04eab6ceb$var$UriUtils = {}));\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/workspace/documents.js\nvar $1d44efb04eab6ceb$var$DocumentState;\n(function(DocumentState2) {\n    DocumentState2[DocumentState2[\"Changed\"] = 0] = \"Changed\";\n    DocumentState2[DocumentState2[\"Parsed\"] = 1] = \"Parsed\";\n    DocumentState2[DocumentState2[\"IndexedContent\"] = 2] = \"IndexedContent\";\n    DocumentState2[DocumentState2[\"ComputedScopes\"] = 3] = \"ComputedScopes\";\n    DocumentState2[DocumentState2[\"Linked\"] = 4] = \"Linked\";\n    DocumentState2[DocumentState2[\"IndexedReferences\"] = 5] = \"IndexedReferences\";\n    DocumentState2[DocumentState2[\"Validated\"] = 6] = \"Validated\";\n})($1d44efb04eab6ceb$var$DocumentState || ($1d44efb04eab6ceb$var$DocumentState = {}));\nvar $1d44efb04eab6ceb$var$DefaultLangiumDocumentFactory = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultLangiumDocumentFactory\");\n    }\n    constructor(services){\n        this.serviceRegistry = services.ServiceRegistry;\n        this.textDocuments = services.workspace.TextDocuments;\n        this.fileSystemProvider = services.workspace.FileSystemProvider;\n    }\n    async fromUri(uri, cancellationToken = $1d44efb04eab6ceb$var$cancellation_exports.CancellationToken.None) {\n        const content = await this.fileSystemProvider.readFile(uri);\n        return this.createAsync(uri, content, cancellationToken);\n    }\n    fromTextDocument(textDocument, uri, cancellationToken) {\n        uri = uri !== null && uri !== void 0 ? uri : $1d44efb04eab6ceb$var$URI2.parse(textDocument.uri);\n        if (cancellationToken) return this.createAsync(uri, textDocument, cancellationToken);\n        else return this.create(uri, textDocument);\n    }\n    fromString(text, uri, cancellationToken) {\n        if (cancellationToken) return this.createAsync(uri, text, cancellationToken);\n        else return this.create(uri, text);\n    }\n    fromModel(model, uri) {\n        return this.create(uri, {\n            $model: model\n        });\n    }\n    create(uri, content) {\n        if (typeof content === \"string\") {\n            const parseResult = this.parse(uri, content);\n            return this.createLangiumDocument(parseResult, uri, void 0, content);\n        } else if (\"$model\" in content) {\n            const parseResult = {\n                value: content.$model,\n                parserErrors: [],\n                lexerErrors: []\n            };\n            return this.createLangiumDocument(parseResult, uri);\n        } else {\n            const parseResult = this.parse(uri, content.getText());\n            return this.createLangiumDocument(parseResult, uri, content);\n        }\n    }\n    async createAsync(uri, content, cancelToken) {\n        if (typeof content === \"string\") {\n            const parseResult = await this.parseAsync(uri, content, cancelToken);\n            return this.createLangiumDocument(parseResult, uri, void 0, content);\n        } else {\n            const parseResult = await this.parseAsync(uri, content.getText(), cancelToken);\n            return this.createLangiumDocument(parseResult, uri, content);\n        }\n    }\n    /**\n   * Create a LangiumDocument from a given parse result.\n   *\n   * A TextDocument is created on demand if it is not provided as argument here. Usually this\n   * should not be necessary because the main purpose of the TextDocument is to convert between\n   * text ranges and offsets, which is done solely in LSP request handling.\n   *\n   * With the introduction of {@link update} below this method is supposed to be mainly called\n   * during workspace initialization and on addition/recognition of new files, while changes in\n   * existing documents are processed via {@link update}.\n   */ createLangiumDocument(parseResult, uri, textDocument, text) {\n        let document;\n        if (textDocument) document = {\n            parseResult: parseResult,\n            uri: uri,\n            state: $1d44efb04eab6ceb$var$DocumentState.Parsed,\n            references: [],\n            textDocument: textDocument\n        };\n        else {\n            const textDocumentGetter = this.createTextDocumentGetter(uri, text);\n            document = {\n                parseResult: parseResult,\n                uri: uri,\n                state: $1d44efb04eab6ceb$var$DocumentState.Parsed,\n                references: [],\n                get textDocument () {\n                    return textDocumentGetter();\n                }\n            };\n        }\n        parseResult.value.$document = document;\n        return document;\n    }\n    async update(document, cancellationToken) {\n        var _a, _b;\n        const oldText = (_a = document.parseResult.value.$cstNode) === null || _a === void 0 ? void 0 : _a.root.fullText;\n        const textDocument = (_b = this.textDocuments) === null || _b === void 0 ? void 0 : _b.get(document.uri.toString());\n        const text = textDocument ? textDocument.getText() : await this.fileSystemProvider.readFile(document.uri);\n        if (textDocument) Object.defineProperty(document, \"textDocument\", {\n            value: textDocument\n        });\n        else {\n            const textDocumentGetter = this.createTextDocumentGetter(document.uri, text);\n            Object.defineProperty(document, \"textDocument\", {\n                get: textDocumentGetter\n            });\n        }\n        if (oldText !== text) {\n            document.parseResult = await this.parseAsync(document.uri, text, cancellationToken);\n            document.parseResult.value.$document = document;\n        }\n        document.state = $1d44efb04eab6ceb$var$DocumentState.Parsed;\n        return document;\n    }\n    parse(uri, text) {\n        const services = this.serviceRegistry.getServices(uri);\n        return services.parser.LangiumParser.parse(text);\n    }\n    parseAsync(uri, text, cancellationToken) {\n        const services = this.serviceRegistry.getServices(uri);\n        return services.parser.AsyncParser.parse(text, cancellationToken);\n    }\n    createTextDocumentGetter(uri, text) {\n        const serviceRegistry = this.serviceRegistry;\n        let textDoc = void 0;\n        return ()=>{\n            return textDoc !== null && textDoc !== void 0 ? textDoc : textDoc = $1d44efb04eab6ceb$var$TextDocument2.create(uri.toString(), serviceRegistry.getServices(uri).LanguageMetaData.languageId, 0, text !== null && text !== void 0 ? text : \"\");\n        };\n    }\n};\nvar $1d44efb04eab6ceb$var$DefaultLangiumDocuments = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultLangiumDocuments\");\n    }\n    constructor(services){\n        this.documentMap = /* @__PURE__ */ new Map();\n        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\n    }\n    get all() {\n        return $1d44efb04eab6ceb$var$stream(this.documentMap.values());\n    }\n    addDocument(document) {\n        const uriString = document.uri.toString();\n        if (this.documentMap.has(uriString)) throw new Error(`A document with the URI '${uriString}' is already present.`);\n        this.documentMap.set(uriString, document);\n    }\n    getDocument(uri) {\n        const uriString = uri.toString();\n        return this.documentMap.get(uriString);\n    }\n    async getOrCreateDocument(uri, cancellationToken) {\n        let document = this.getDocument(uri);\n        if (document) return document;\n        document = await this.langiumDocumentFactory.fromUri(uri, cancellationToken);\n        this.addDocument(document);\n        return document;\n    }\n    createDocument(uri, text, cancellationToken) {\n        if (cancellationToken) return this.langiumDocumentFactory.fromString(text, uri, cancellationToken).then((document)=>{\n            this.addDocument(document);\n            return document;\n        });\n        else {\n            const document = this.langiumDocumentFactory.fromString(text, uri);\n            this.addDocument(document);\n            return document;\n        }\n    }\n    hasDocument(uri) {\n        return this.documentMap.has(uri.toString());\n    }\n    invalidateDocument(uri) {\n        const uriString = uri.toString();\n        const langiumDoc = this.documentMap.get(uriString);\n        if (langiumDoc) {\n            langiumDoc.state = $1d44efb04eab6ceb$var$DocumentState.Changed;\n            langiumDoc.precomputedScopes = void 0;\n            langiumDoc.references = [];\n            langiumDoc.diagnostics = void 0;\n        }\n        return langiumDoc;\n    }\n    deleteDocument(uri) {\n        const uriString = uri.toString();\n        const langiumDoc = this.documentMap.get(uriString);\n        if (langiumDoc) {\n            langiumDoc.state = $1d44efb04eab6ceb$var$DocumentState.Changed;\n            this.documentMap.delete(uriString);\n        }\n        return langiumDoc;\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/references/linker.js\nvar $1d44efb04eab6ceb$var$DefaultLinker = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultLinker\");\n    }\n    constructor(services){\n        this.reflection = services.shared.AstReflection;\n        this.langiumDocuments = ()=>services.shared.workspace.LangiumDocuments;\n        this.scopeProvider = services.references.ScopeProvider;\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n    }\n    async link(document, cancelToken = $1d44efb04eab6ceb$var$cancellation_exports.CancellationToken.None) {\n        for (const node of $1d44efb04eab6ceb$var$streamAst(document.parseResult.value)){\n            await $1d44efb04eab6ceb$var$interruptAndCheck(cancelToken);\n            $1d44efb04eab6ceb$var$streamReferences(node).forEach((ref)=>this.doLink(ref, document));\n        }\n    }\n    doLink(refInfo, document) {\n        const ref = refInfo.reference;\n        if (ref._ref === void 0) try {\n            const description = this.getCandidate(refInfo);\n            if ($1d44efb04eab6ceb$var$isLinkingError(description)) ref._ref = description;\n            else {\n                ref._nodeDescription = description;\n                if (this.langiumDocuments().hasDocument(description.documentUri)) {\n                    const linkedNode = this.loadAstNode(description);\n                    ref._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : this.createLinkingError(refInfo, description);\n                }\n            }\n        } catch (err) {\n            ref._ref = Object.assign(Object.assign({}, refInfo), {\n                message: `An error occurred while resolving reference to '${ref.$refText}': ${err}`\n            });\n        }\n        document.references.push(ref);\n    }\n    unlink(document) {\n        for (const ref of document.references){\n            delete ref._ref;\n            delete ref._nodeDescription;\n        }\n        document.references = [];\n    }\n    getCandidate(refInfo) {\n        const scope = this.scopeProvider.getScope(refInfo);\n        const description = scope.getElement(refInfo.reference.$refText);\n        return description !== null && description !== void 0 ? description : this.createLinkingError(refInfo);\n    }\n    buildReference(node, property, refNode, refText) {\n        const linker = this;\n        const reference = {\n            $refNode: refNode,\n            $refText: refText,\n            get ref () {\n                var _a;\n                if ($1d44efb04eab6ceb$var$isAstNode(this._ref)) return this._ref;\n                else if ($1d44efb04eab6ceb$var$isAstNodeDescription(this._nodeDescription)) {\n                    const linkedNode = linker.loadAstNode(this._nodeDescription);\n                    this._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : linker.createLinkingError({\n                        reference: reference,\n                        container: node,\n                        property: property\n                    }, this._nodeDescription);\n                } else if (this._ref === void 0) {\n                    const refData = linker.getLinkedNode({\n                        reference: reference,\n                        container: node,\n                        property: property\n                    });\n                    if (refData.error && $1d44efb04eab6ceb$var$getDocument(node).state < $1d44efb04eab6ceb$var$DocumentState.ComputedScopes) return void 0;\n                    this._ref = (_a = refData.node) !== null && _a !== void 0 ? _a : refData.error;\n                    this._nodeDescription = refData.descr;\n                }\n                return $1d44efb04eab6ceb$var$isAstNode(this._ref) ? this._ref : void 0;\n            },\n            get $nodeDescription () {\n                return this._nodeDescription;\n            },\n            get error () {\n                return $1d44efb04eab6ceb$var$isLinkingError(this._ref) ? this._ref : void 0;\n            }\n        };\n        return reference;\n    }\n    getLinkedNode(refInfo) {\n        try {\n            const description = this.getCandidate(refInfo);\n            if ($1d44efb04eab6ceb$var$isLinkingError(description)) return {\n                error: description\n            };\n            const linkedNode = this.loadAstNode(description);\n            if (linkedNode) return {\n                node: linkedNode,\n                descr: description\n            };\n            else return {\n                descr: description,\n                error: this.createLinkingError(refInfo, description)\n            };\n        } catch (err) {\n            return {\n                error: Object.assign(Object.assign({}, refInfo), {\n                    message: `An error occurred while resolving reference to '${refInfo.reference.$refText}': ${err}`\n                })\n            };\n        }\n    }\n    loadAstNode(nodeDescription) {\n        if (nodeDescription.node) return nodeDescription.node;\n        const doc = this.langiumDocuments().getDocument(nodeDescription.documentUri);\n        if (!doc) return void 0;\n        return this.astNodeLocator.getAstNode(doc.parseResult.value, nodeDescription.path);\n    }\n    createLinkingError(refInfo, targetDescription) {\n        const document = $1d44efb04eab6ceb$var$getDocument(refInfo.container);\n        if (document.state < $1d44efb04eab6ceb$var$DocumentState.ComputedScopes) console.warn(`Attempted reference resolution before document reached ComputedScopes state (${document.uri}).`);\n        const referenceType = this.reflection.getReferenceType(refInfo);\n        return Object.assign(Object.assign({}, refInfo), {\n            message: `Could not resolve reference to ${referenceType} named '${refInfo.reference.$refText}'.`,\n            targetDescription: targetDescription\n        });\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/references/name-provider.js\nfunction $1d44efb04eab6ceb$var$isNamed(node) {\n    return typeof node.name === \"string\";\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isNamed, \"isNamed\");\nvar $1d44efb04eab6ceb$var$DefaultNameProvider = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultNameProvider\");\n    }\n    getName(node) {\n        if ($1d44efb04eab6ceb$var$isNamed(node)) return node.name;\n        return void 0;\n    }\n    getNameNode(node) {\n        return $1d44efb04eab6ceb$var$findNodeForProperty(node.$cstNode, \"name\");\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/references/references.js\nvar $1d44efb04eab6ceb$var$DefaultReferences = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultReferences\");\n    }\n    constructor(services){\n        this.nameProvider = services.references.NameProvider;\n        this.index = services.shared.workspace.IndexManager;\n        this.nodeLocator = services.workspace.AstNodeLocator;\n    }\n    findDeclaration(sourceCstNode) {\n        if (sourceCstNode) {\n            const assignment = $1d44efb04eab6ceb$var$findAssignment(sourceCstNode);\n            const nodeElem = sourceCstNode.astNode;\n            if (assignment && nodeElem) {\n                const reference = nodeElem[assignment.feature];\n                if ($1d44efb04eab6ceb$var$isReference(reference)) return reference.ref;\n                else if (Array.isArray(reference)) for (const ref of reference){\n                    if ($1d44efb04eab6ceb$var$isReference(ref) && ref.$refNode && ref.$refNode.offset <= sourceCstNode.offset && ref.$refNode.end >= sourceCstNode.end) return ref.ref;\n                }\n            }\n            if (nodeElem) {\n                const nameNode = this.nameProvider.getNameNode(nodeElem);\n                if (nameNode && (nameNode === sourceCstNode || $1d44efb04eab6ceb$var$isChildNode(sourceCstNode, nameNode))) return nodeElem;\n            }\n        }\n        return void 0;\n    }\n    findDeclarationNode(sourceCstNode) {\n        const astNode = this.findDeclaration(sourceCstNode);\n        if (astNode === null || astNode === void 0 ? void 0 : astNode.$cstNode) {\n            const targetNode = this.nameProvider.getNameNode(astNode);\n            return targetNode !== null && targetNode !== void 0 ? targetNode : astNode.$cstNode;\n        }\n        return void 0;\n    }\n    findReferences(targetNode, options) {\n        const refs = [];\n        if (options.includeDeclaration) {\n            const ref = this.getReferenceToSelf(targetNode);\n            if (ref) refs.push(ref);\n        }\n        let indexReferences = this.index.findAllReferences(targetNode, this.nodeLocator.getAstNodePath(targetNode));\n        if (options.documentUri) indexReferences = indexReferences.filter((ref)=>$1d44efb04eab6ceb$var$UriUtils.equals(ref.sourceUri, options.documentUri));\n        refs.push(...indexReferences);\n        return $1d44efb04eab6ceb$var$stream(refs);\n    }\n    getReferenceToSelf(targetNode) {\n        const nameNode = this.nameProvider.getNameNode(targetNode);\n        if (nameNode) {\n            const doc = $1d44efb04eab6ceb$var$getDocument(targetNode);\n            const path = this.nodeLocator.getAstNodePath(targetNode);\n            return {\n                sourceUri: doc.uri,\n                sourcePath: path,\n                targetUri: doc.uri,\n                targetPath: path,\n                segment: $1d44efb04eab6ceb$var$toDocumentSegment(nameNode),\n                local: true\n            };\n        }\n        return void 0;\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/collections.js\nvar $1d44efb04eab6ceb$var$MultiMap = class {\n    static{\n        (0, $7xxrv.__name)(this, \"MultiMap\");\n    }\n    constructor(elements){\n        this.map = /* @__PURE__ */ new Map();\n        if (elements) for (const [key, value] of elements)this.add(key, value);\n    }\n    /**\n   * The total number of values in the multimap.\n   */ get size() {\n        return $1d44efb04eab6ceb$var$Reduction.sum($1d44efb04eab6ceb$var$stream(this.map.values()).map((a)=>a.length));\n    }\n    /**\n   * Clear all entries in the multimap.\n   */ clear() {\n        this.map.clear();\n    }\n    /**\n   * Operates differently depending on whether a `value` is given:\n   *  * With a value, this method deletes the specific key / value pair from the multimap.\n   *  * Without a value, all values associated with the given key are deleted.\n   *\n   * @returns `true` if a value existed and has been removed, or `false` if the specified\n   *     key / value does not exist.\n   */ delete(key, value) {\n        if (value === void 0) return this.map.delete(key);\n        else {\n            const values = this.map.get(key);\n            if (values) {\n                const index = values.indexOf(value);\n                if (index >= 0) {\n                    if (values.length === 1) this.map.delete(key);\n                    else values.splice(index, 1);\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n    /**\n   * Returns an array of all values associated with the given key. If no value exists,\n   * an empty array is returned.\n   *\n   * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a\n   * value and `delete` to remove a value from the multimap.\n   */ get(key) {\n        var _a;\n        return (_a = this.map.get(key)) !== null && _a !== void 0 ? _a : [];\n    }\n    /**\n   * Operates differently depending on whether a `value` is given:\n   *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.\n   *  * Without a value, this method returns `true` if the given key is present in the multimap.\n   */ has(key, value) {\n        if (value === void 0) return this.map.has(key);\n        else {\n            const values = this.map.get(key);\n            if (values) return values.indexOf(value) >= 0;\n            return false;\n        }\n    }\n    /**\n   * Add the given key / value pair to the multimap.\n   */ add(key, value) {\n        if (this.map.has(key)) this.map.get(key).push(value);\n        else this.map.set(key, [\n            value\n        ]);\n        return this;\n    }\n    /**\n   * Add the given set of key / value pairs to the multimap.\n   */ addAll(key, values) {\n        if (this.map.has(key)) this.map.get(key).push(...values);\n        else this.map.set(key, Array.from(values));\n        return this;\n    }\n    /**\n   * Invokes the given callback function for every key / value pair in the multimap.\n   */ forEach(callbackfn) {\n        this.map.forEach((array, key)=>array.forEach((value)=>callbackfn(value, key, this)));\n    }\n    /**\n   * Returns an iterator of key, value pairs for every entry in the map.\n   */ [Symbol.iterator]() {\n        return this.entries().iterator();\n    }\n    /**\n   * Returns a stream of key, value pairs for every entry in the map.\n   */ entries() {\n        return $1d44efb04eab6ceb$var$stream(this.map.entries()).flatMap(([key, array])=>array.map((value)=>[\n                    key,\n                    value\n                ]));\n    }\n    /**\n   * Returns a stream of keys in the map.\n   */ keys() {\n        return $1d44efb04eab6ceb$var$stream(this.map.keys());\n    }\n    /**\n   * Returns a stream of values in the map.\n   */ values() {\n        return $1d44efb04eab6ceb$var$stream(this.map.values()).flat();\n    }\n    /**\n   * Returns a stream of key, value set pairs for every key in the map.\n   */ entriesGroupedByKey() {\n        return $1d44efb04eab6ceb$var$stream(this.map.entries());\n    }\n};\nvar $1d44efb04eab6ceb$var$BiMap = class {\n    static{\n        (0, $7xxrv.__name)(this, \"BiMap\");\n    }\n    get size() {\n        return this.map.size;\n    }\n    constructor(elements){\n        this.map = /* @__PURE__ */ new Map();\n        this.inverse = /* @__PURE__ */ new Map();\n        if (elements) for (const [key, value] of elements)this.set(key, value);\n    }\n    clear() {\n        this.map.clear();\n        this.inverse.clear();\n    }\n    set(key, value) {\n        this.map.set(key, value);\n        this.inverse.set(value, key);\n        return this;\n    }\n    get(key) {\n        return this.map.get(key);\n    }\n    getKey(value) {\n        return this.inverse.get(value);\n    }\n    delete(key) {\n        const value = this.map.get(key);\n        if (value !== void 0) {\n            this.map.delete(key);\n            this.inverse.delete(value);\n            return true;\n        }\n        return false;\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/references/scope-computation.js\nvar $1d44efb04eab6ceb$var$DefaultScopeComputation = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultScopeComputation\");\n    }\n    constructor(services){\n        this.nameProvider = services.references.NameProvider;\n        this.descriptions = services.workspace.AstNodeDescriptionProvider;\n    }\n    async computeExports(document, cancelToken = $1d44efb04eab6ceb$var$cancellation_exports.CancellationToken.None) {\n        return this.computeExportsForNode(document.parseResult.value, document, void 0, cancelToken);\n    }\n    /**\n   * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.\n   * The list of children to be considered is determined by the function parameter {@link children}.\n   * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.\n   *\n   * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.\n   * @param document The document containing the AST node to be exported.\n   * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.\n   * @param cancelToken Indicates when to cancel the current operation.\n   * @throws `OperationCanceled` if a user action occurs during execution.\n   * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.\n   */ async computeExportsForNode(parentNode, document, children = $1d44efb04eab6ceb$var$streamContents, cancelToken = $1d44efb04eab6ceb$var$cancellation_exports.CancellationToken.None) {\n        const exports = [];\n        this.exportNode(parentNode, exports, document);\n        for (const node of children(parentNode)){\n            await $1d44efb04eab6ceb$var$interruptAndCheck(cancelToken);\n            this.exportNode(node, exports, document);\n        }\n        return exports;\n    }\n    /**\n   * Add a single node to the list of exports if it has a name. Override this method to change how\n   * symbols are exported, e.g. by modifying their exported name.\n   */ exportNode(node, exports, document) {\n        const name = this.nameProvider.getName(node);\n        if (name) exports.push(this.descriptions.createDescription(node, name, document));\n    }\n    async computeLocalScopes(document, cancelToken = $1d44efb04eab6ceb$var$cancellation_exports.CancellationToken.None) {\n        const rootNode = document.parseResult.value;\n        const scopes = new $1d44efb04eab6ceb$var$MultiMap();\n        for (const node of $1d44efb04eab6ceb$var$streamAllContents(rootNode)){\n            await $1d44efb04eab6ceb$var$interruptAndCheck(cancelToken);\n            this.processNode(node, document, scopes);\n        }\n        return scopes;\n    }\n    /**\n   * Process a single node during scopes computation. The default implementation makes the node visible\n   * in the subtree of its container (if the node has a name). Override this method to change this,\n   * e.g. by increasing the visibility to a higher level in the AST.\n   */ processNode(node, document, scopes) {\n        const container = node.$container;\n        if (container) {\n            const name = this.nameProvider.getName(node);\n            if (name) scopes.add(container, this.descriptions.createDescription(node, name, document));\n        }\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/references/scope.js\nvar $1d44efb04eab6ceb$var$StreamScope = class {\n    static{\n        (0, $7xxrv.__name)(this, \"StreamScope\");\n    }\n    constructor(elements, outerScope, options){\n        var _a;\n        this.elements = elements;\n        this.outerScope = outerScope;\n        this.caseInsensitive = (_a = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null && _a !== void 0 ? _a : false;\n    }\n    getAllElements() {\n        if (this.outerScope) return this.elements.concat(this.outerScope.getAllElements());\n        else return this.elements;\n    }\n    getElement(name) {\n        const local = this.caseInsensitive ? this.elements.find((e)=>e.name.toLowerCase() === name.toLowerCase()) : this.elements.find((e)=>e.name === name);\n        if (local) return local;\n        if (this.outerScope) return this.outerScope.getElement(name);\n        return void 0;\n    }\n};\nvar $1d44efb04eab6ceb$var$MapScope = class {\n    static{\n        (0, $7xxrv.__name)(this, \"MapScope\");\n    }\n    constructor(elements, outerScope, options){\n        var _a;\n        this.elements = /* @__PURE__ */ new Map();\n        this.caseInsensitive = (_a = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null && _a !== void 0 ? _a : false;\n        for (const element of elements){\n            const name = this.caseInsensitive ? element.name.toLowerCase() : element.name;\n            this.elements.set(name, element);\n        }\n        this.outerScope = outerScope;\n    }\n    getElement(name) {\n        const localName = this.caseInsensitive ? name.toLowerCase() : name;\n        const local = this.elements.get(localName);\n        if (local) return local;\n        if (this.outerScope) return this.outerScope.getElement(name);\n        return void 0;\n    }\n    getAllElements() {\n        let elementStream = $1d44efb04eab6ceb$var$stream(this.elements.values());\n        if (this.outerScope) elementStream = elementStream.concat(this.outerScope.getAllElements());\n        return elementStream;\n    }\n};\nvar $1d44efb04eab6ceb$var$EMPTY_SCOPE = {\n    getElement () {\n        return void 0;\n    },\n    getAllElements () {\n        return $1d44efb04eab6ceb$var$EMPTY_STREAM;\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/caching.js\nvar $1d44efb04eab6ceb$var$DisposableCache = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DisposableCache\");\n    }\n    constructor(){\n        this.toDispose = [];\n        this.isDisposed = false;\n    }\n    onDispose(disposable) {\n        this.toDispose.push(disposable);\n    }\n    dispose() {\n        this.throwIfDisposed();\n        this.clear();\n        this.isDisposed = true;\n        this.toDispose.forEach((disposable)=>disposable.dispose());\n    }\n    throwIfDisposed() {\n        if (this.isDisposed) throw new Error(\"This cache has already been disposed\");\n    }\n};\nvar $1d44efb04eab6ceb$var$SimpleCache = class extends $1d44efb04eab6ceb$var$DisposableCache {\n    static{\n        (0, $7xxrv.__name)(this, \"SimpleCache\");\n    }\n    constructor(){\n        super(...arguments);\n        this.cache = /* @__PURE__ */ new Map();\n    }\n    has(key) {\n        this.throwIfDisposed();\n        return this.cache.has(key);\n    }\n    set(key, value) {\n        this.throwIfDisposed();\n        this.cache.set(key, value);\n    }\n    get(key, provider) {\n        this.throwIfDisposed();\n        if (this.cache.has(key)) return this.cache.get(key);\n        else if (provider) {\n            const value = provider();\n            this.cache.set(key, value);\n            return value;\n        } else return void 0;\n    }\n    delete(key) {\n        this.throwIfDisposed();\n        return this.cache.delete(key);\n    }\n    clear() {\n        this.throwIfDisposed();\n        this.cache.clear();\n    }\n};\nvar $1d44efb04eab6ceb$var$ContextCache = class extends $1d44efb04eab6ceb$var$DisposableCache {\n    static{\n        (0, $7xxrv.__name)(this, \"ContextCache\");\n    }\n    constructor(converter){\n        super();\n        this.cache = /* @__PURE__ */ new Map();\n        this.converter = converter !== null && converter !== void 0 ? converter : (value)=>value;\n    }\n    has(contextKey, key) {\n        this.throwIfDisposed();\n        return this.cacheForContext(contextKey).has(key);\n    }\n    set(contextKey, key, value) {\n        this.throwIfDisposed();\n        this.cacheForContext(contextKey).set(key, value);\n    }\n    get(contextKey, key, provider) {\n        this.throwIfDisposed();\n        const contextCache = this.cacheForContext(contextKey);\n        if (contextCache.has(key)) return contextCache.get(key);\n        else if (provider) {\n            const value = provider();\n            contextCache.set(key, value);\n            return value;\n        } else return void 0;\n    }\n    delete(contextKey, key) {\n        this.throwIfDisposed();\n        return this.cacheForContext(contextKey).delete(key);\n    }\n    clear(contextKey) {\n        this.throwIfDisposed();\n        if (contextKey) {\n            const mapKey = this.converter(contextKey);\n            this.cache.delete(mapKey);\n        } else this.cache.clear();\n    }\n    cacheForContext(contextKey) {\n        const mapKey = this.converter(contextKey);\n        let documentCache = this.cache.get(mapKey);\n        if (!documentCache) {\n            documentCache = /* @__PURE__ */ new Map();\n            this.cache.set(mapKey, documentCache);\n        }\n        return documentCache;\n    }\n};\nvar $1d44efb04eab6ceb$var$DocumentCache = class extends $1d44efb04eab6ceb$var$ContextCache {\n    static{\n        (0, $7xxrv.__name)(this, \"DocumentCache\");\n    }\n    constructor(sharedServices){\n        super((uri)=>uri.toString());\n        this.onDispose(sharedServices.workspace.DocumentBuilder.onUpdate((changed, deleted)=>{\n            const allUris = changed.concat(deleted);\n            for (const uri of allUris)this.clear(uri);\n        }));\n    }\n};\nvar $1d44efb04eab6ceb$var$WorkspaceCache = class extends $1d44efb04eab6ceb$var$SimpleCache {\n    static{\n        (0, $7xxrv.__name)(this, \"WorkspaceCache\");\n    }\n    constructor(sharedServices){\n        super();\n        this.onDispose(sharedServices.workspace.DocumentBuilder.onUpdate(()=>{\n            this.clear();\n        }));\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/references/scope-provider.js\nvar $1d44efb04eab6ceb$var$DefaultScopeProvider = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultScopeProvider\");\n    }\n    constructor(services){\n        this.reflection = services.shared.AstReflection;\n        this.nameProvider = services.references.NameProvider;\n        this.descriptions = services.workspace.AstNodeDescriptionProvider;\n        this.indexManager = services.shared.workspace.IndexManager;\n        this.globalScopeCache = new $1d44efb04eab6ceb$var$WorkspaceCache(services.shared);\n    }\n    getScope(context) {\n        const scopes = [];\n        const referenceType = this.reflection.getReferenceType(context);\n        const precomputed = $1d44efb04eab6ceb$var$getDocument(context.container).precomputedScopes;\n        if (precomputed) {\n            let currentNode = context.container;\n            do {\n                const allDescriptions = precomputed.get(currentNode);\n                if (allDescriptions.length > 0) scopes.push($1d44efb04eab6ceb$var$stream(allDescriptions).filter((desc)=>this.reflection.isSubtype(desc.type, referenceType)));\n                currentNode = currentNode.$container;\n            }while (currentNode);\n        }\n        let result = this.getGlobalScope(referenceType, context);\n        for(let i = scopes.length - 1; i >= 0; i--)result = this.createScope(scopes[i], result);\n        return result;\n    }\n    /**\n   * Create a scope for the given collection of AST node descriptions.\n   */ createScope(elements, outerScope, options) {\n        return new $1d44efb04eab6ceb$var$StreamScope($1d44efb04eab6ceb$var$stream(elements), outerScope, options);\n    }\n    /**\n   * Create a scope for the given collection of AST nodes, which need to be transformed into respective\n   * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.\n   */ createScopeForNodes(elements, outerScope, options) {\n        const s = $1d44efb04eab6ceb$var$stream(elements).map((e)=>{\n            const name = this.nameProvider.getName(e);\n            if (name) return this.descriptions.createDescription(e, name);\n            return void 0;\n        }).nonNullable();\n        return new $1d44efb04eab6ceb$var$StreamScope(s, outerScope, options);\n    }\n    /**\n   * Create a global scope filtered for the given reference type.\n   */ getGlobalScope(referenceType, _context) {\n        return this.globalScopeCache.get(referenceType, ()=>new $1d44efb04eab6ceb$var$MapScope(this.indexManager.allElements(referenceType)));\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/serializer/json-serializer.js\nfunction $1d44efb04eab6ceb$var$isAstNodeWithComment(node) {\n    return typeof node.$comment === \"string\";\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isAstNodeWithComment, \"isAstNodeWithComment\");\nfunction $1d44efb04eab6ceb$var$isIntermediateReference(obj) {\n    return typeof obj === \"object\" && !!obj && (\"$ref\" in obj || \"$error\" in obj);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isIntermediateReference, \"isIntermediateReference\");\nvar $1d44efb04eab6ceb$var$DefaultJsonSerializer = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultJsonSerializer\");\n    }\n    constructor(services){\n        this.ignoreProperties = /* @__PURE__ */ new Set([\n            \"$container\",\n            \"$containerProperty\",\n            \"$containerIndex\",\n            \"$document\",\n            \"$cstNode\"\n        ]);\n        this.langiumDocuments = services.shared.workspace.LangiumDocuments;\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n        this.nameProvider = services.references.NameProvider;\n        this.commentProvider = services.documentation.CommentProvider;\n    }\n    serialize(node, options = {}) {\n        const specificReplacer = options === null || options === void 0 ? void 0 : options.replacer;\n        const defaultReplacer = /* @__PURE__ */ (0, $7xxrv.__name)((key, value)=>this.replacer(key, value, options), \"defaultReplacer\");\n        const replacer = specificReplacer ? (key, value)=>specificReplacer(key, value, defaultReplacer) : defaultReplacer;\n        try {\n            this.currentDocument = $1d44efb04eab6ceb$var$getDocument(node);\n            return JSON.stringify(node, replacer, options === null || options === void 0 ? void 0 : options.space);\n        } finally{\n            this.currentDocument = void 0;\n        }\n    }\n    deserialize(content, options = {}) {\n        const root = JSON.parse(content);\n        this.linkNode(root, root, options);\n        return root;\n    }\n    replacer(key, value, { refText: refText, sourceText: sourceText, textRegions: textRegions, comments: comments, uriConverter: uriConverter }) {\n        var _a, _b, _c, _d;\n        if (this.ignoreProperties.has(key)) return void 0;\n        else if ($1d44efb04eab6ceb$var$isReference(value)) {\n            const refValue = value.ref;\n            const $refText = refText ? value.$refText : void 0;\n            if (refValue) {\n                const targetDocument = $1d44efb04eab6ceb$var$getDocument(refValue);\n                let targetUri = \"\";\n                if (this.currentDocument && this.currentDocument !== targetDocument) {\n                    if (uriConverter) targetUri = uriConverter(targetDocument.uri, value);\n                    else targetUri = targetDocument.uri.toString();\n                }\n                const targetPath = this.astNodeLocator.getAstNodePath(refValue);\n                return {\n                    $ref: `${targetUri}#${targetPath}`,\n                    $refText: $refText\n                };\n            } else return {\n                $error: (_b = (_a = value.error) === null || _a === void 0 ? void 0 : _a.message) !== null && _b !== void 0 ? _b : \"Could not resolve reference\",\n                $refText: $refText\n            };\n        } else if ($1d44efb04eab6ceb$var$isAstNode(value)) {\n            let astNode = void 0;\n            if (textRegions) {\n                astNode = this.addAstNodeRegionWithAssignmentsTo(Object.assign({}, value));\n                if ((!key || value.$document) && (astNode === null || astNode === void 0 ? void 0 : astNode.$textRegion)) astNode.$textRegion.documentURI = (_c = this.currentDocument) === null || _c === void 0 ? void 0 : _c.uri.toString();\n            }\n            if (sourceText && !key) {\n                astNode !== null && astNode !== void 0 ? astNode : astNode = Object.assign({}, value);\n                astNode.$sourceText = (_d = value.$cstNode) === null || _d === void 0 ? void 0 : _d.text;\n            }\n            if (comments) {\n                astNode !== null && astNode !== void 0 ? astNode : astNode = Object.assign({}, value);\n                const comment = this.commentProvider.getComment(value);\n                if (comment) astNode.$comment = comment.replace(/\\r/g, \"\");\n            }\n            return astNode !== null && astNode !== void 0 ? astNode : value;\n        } else return value;\n    }\n    addAstNodeRegionWithAssignmentsTo(node) {\n        const createDocumentSegment = /* @__PURE__ */ (0, $7xxrv.__name)((cstNode)=>({\n                offset: cstNode.offset,\n                end: cstNode.end,\n                length: cstNode.length,\n                range: cstNode.range\n            }), \"createDocumentSegment\");\n        if (node.$cstNode) {\n            const textRegion = node.$textRegion = createDocumentSegment(node.$cstNode);\n            const assignments = textRegion.assignments = {};\n            Object.keys(node).filter((key)=>!key.startsWith(\"$\")).forEach((key)=>{\n                const propertyAssignments = $1d44efb04eab6ceb$var$findNodesForProperty(node.$cstNode, key).map(createDocumentSegment);\n                if (propertyAssignments.length !== 0) assignments[key] = propertyAssignments;\n            });\n            return node;\n        }\n        return void 0;\n    }\n    linkNode(node, root, options, container, containerProperty, containerIndex) {\n        for (const [propertyName, item] of Object.entries(node)){\n            if (Array.isArray(item)) for(let index = 0; index < item.length; index++){\n                const element = item[index];\n                if ($1d44efb04eab6ceb$var$isIntermediateReference(element)) item[index] = this.reviveReference(node, propertyName, root, element, options);\n                else if ($1d44efb04eab6ceb$var$isAstNode(element)) this.linkNode(element, root, options, node, propertyName, index);\n            }\n            else if ($1d44efb04eab6ceb$var$isIntermediateReference(item)) node[propertyName] = this.reviveReference(node, propertyName, root, item, options);\n            else if ($1d44efb04eab6ceb$var$isAstNode(item)) this.linkNode(item, root, options, node, propertyName);\n        }\n        const mutable = node;\n        mutable.$container = container;\n        mutable.$containerProperty = containerProperty;\n        mutable.$containerIndex = containerIndex;\n    }\n    reviveReference(container, property, root, reference, options) {\n        let refText = reference.$refText;\n        let error = reference.$error;\n        if (reference.$ref) {\n            const ref = this.getRefNode(root, reference.$ref, options.uriConverter);\n            if ($1d44efb04eab6ceb$var$isAstNode(ref)) {\n                if (!refText) refText = this.nameProvider.getName(ref);\n                return {\n                    $refText: refText !== null && refText !== void 0 ? refText : \"\",\n                    ref: ref\n                };\n            } else error = ref;\n        }\n        if (error) {\n            const ref = {\n                $refText: refText !== null && refText !== void 0 ? refText : \"\"\n            };\n            ref.error = {\n                container: container,\n                property: property,\n                message: error,\n                reference: ref\n            };\n            return ref;\n        } else return void 0;\n    }\n    getRefNode(root, uri, uriConverter) {\n        try {\n            const fragmentIndex = uri.indexOf(\"#\");\n            if (fragmentIndex === 0) {\n                const node2 = this.astNodeLocator.getAstNode(root, uri.substring(1));\n                if (!node2) return \"Could not resolve path: \" + uri;\n                return node2;\n            }\n            if (fragmentIndex < 0) {\n                const documentUri2 = uriConverter ? uriConverter(uri) : $1d44efb04eab6ceb$var$URI2.parse(uri);\n                const document2 = this.langiumDocuments.getDocument(documentUri2);\n                if (!document2) return \"Could not find document for URI: \" + uri;\n                return document2.parseResult.value;\n            }\n            const documentUri = uriConverter ? uriConverter(uri.substring(0, fragmentIndex)) : $1d44efb04eab6ceb$var$URI2.parse(uri.substring(0, fragmentIndex));\n            const document = this.langiumDocuments.getDocument(documentUri);\n            if (!document) return \"Could not find document for URI: \" + uri;\n            if (fragmentIndex === uri.length - 1) return document.parseResult.value;\n            const node = this.astNodeLocator.getAstNode(document.parseResult.value, uri.substring(fragmentIndex + 1));\n            if (!node) return \"Could not resolve URI: \" + uri;\n            return node;\n        } catch (err) {\n            return String(err);\n        }\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/service-registry.js\nvar $1d44efb04eab6ceb$var$DefaultServiceRegistry = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultServiceRegistry\");\n    }\n    register(language) {\n        if (!this.singleton && !this.map) {\n            this.singleton = language;\n            return;\n        }\n        if (!this.map) {\n            this.map = {};\n            if (this.singleton) {\n                for (const ext of this.singleton.LanguageMetaData.fileExtensions)this.map[ext] = this.singleton;\n                this.singleton = void 0;\n            }\n        }\n        for (const ext of language.LanguageMetaData.fileExtensions){\n            if (this.map[ext] !== void 0 && this.map[ext] !== language) console.warn(`The file extension ${ext} is used by multiple languages. It is now assigned to '${language.LanguageMetaData.languageId}'.`);\n            this.map[ext] = language;\n        }\n    }\n    getServices(uri) {\n        if (this.singleton !== void 0) return this.singleton;\n        if (this.map === void 0) throw new Error(\"The service registry is empty. Use `register` to register the services of a language.\");\n        const ext = $1d44efb04eab6ceb$var$UriUtils.extname(uri);\n        const services = this.map[ext];\n        if (!services) throw new Error(`The service registry contains no services for the extension '${ext}'.`);\n        return services;\n    }\n    get all() {\n        if (this.singleton !== void 0) return [\n            this.singleton\n        ];\n        if (this.map !== void 0) return Object.values(this.map);\n        return [];\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/validation/validation-registry.js\nfunction $1d44efb04eab6ceb$var$diagnosticData(code) {\n    return {\n        code: code\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$diagnosticData, \"diagnosticData\");\nvar $1d44efb04eab6ceb$var$ValidationCategory;\n(function(ValidationCategory2) {\n    ValidationCategory2.all = [\n        \"fast\",\n        \"slow\",\n        \"built-in\"\n    ];\n})($1d44efb04eab6ceb$var$ValidationCategory || ($1d44efb04eab6ceb$var$ValidationCategory = {}));\nvar $1d44efb04eab6ceb$var$ValidationRegistry = class {\n    static{\n        (0, $7xxrv.__name)(this, \"ValidationRegistry\");\n    }\n    constructor(services){\n        this.entries = new $1d44efb04eab6ceb$var$MultiMap();\n        this.reflection = services.shared.AstReflection;\n    }\n    /**\n   * Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)\n   * or an array of validation checks.\n   *\n   * @param checksRecord Set of validation checks to register.\n   * @param category Optional category for the validation checks (defaults to `'fast'`).\n   * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n   */ register(checksRecord, thisObj = this, category = \"fast\") {\n        if (category === \"built-in\") throw new Error(\"The 'built-in' category is reserved for lexer, parser, and linker errors.\");\n        for (const [type, ch] of Object.entries(checksRecord)){\n            const callbacks = ch;\n            if (Array.isArray(callbacks)) for (const check of callbacks){\n                const entry = {\n                    check: this.wrapValidationException(check, thisObj),\n                    category: category\n                };\n                this.addEntry(type, entry);\n            }\n            else if (typeof callbacks === \"function\") {\n                const entry = {\n                    check: this.wrapValidationException(callbacks, thisObj),\n                    category: category\n                };\n                this.addEntry(type, entry);\n            }\n        }\n    }\n    wrapValidationException(check, thisObj) {\n        return async (node, accept, cancelToken)=>{\n            try {\n                await check.call(thisObj, node, accept, cancelToken);\n            } catch (err) {\n                if ($1d44efb04eab6ceb$var$isOperationCancelled(err)) throw err;\n                console.error(\"An error occurred during validation:\", err);\n                const message = err instanceof Error ? err.message : String(err);\n                if (err instanceof Error && err.stack) console.error(err.stack);\n                accept(\"error\", \"An error occurred during validation: \" + message, {\n                    node: node\n                });\n            }\n        };\n    }\n    addEntry(type, entry) {\n        if (type === \"AstNode\") {\n            this.entries.add(\"AstNode\", entry);\n            return;\n        }\n        for (const subtype of this.reflection.getAllSubTypes(type))this.entries.add(subtype, entry);\n    }\n    getChecks(type, categories) {\n        let checks = $1d44efb04eab6ceb$var$stream(this.entries.get(type)).concat(this.entries.get(\"AstNode\"));\n        if (categories) checks = checks.filter((entry)=>categories.includes(entry.category));\n        return checks.map((entry)=>entry.check);\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/validation/document-validator.js\nvar $1d44efb04eab6ceb$var$DefaultDocumentValidator = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultDocumentValidator\");\n    }\n    constructor(services){\n        this.validationRegistry = services.validation.ValidationRegistry;\n        this.metadata = services.LanguageMetaData;\n    }\n    async validateDocument(document, options = {}, cancelToken = $1d44efb04eab6ceb$var$cancellation_exports.CancellationToken.None) {\n        const parseResult = document.parseResult;\n        const diagnostics = [];\n        await $1d44efb04eab6ceb$var$interruptAndCheck(cancelToken);\n        if (!options.categories || options.categories.includes(\"built-in\")) {\n            this.processLexingErrors(parseResult, diagnostics, options);\n            if (options.stopAfterLexingErrors && diagnostics.some((d)=>{\n                var _a;\n                return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === $1d44efb04eab6ceb$var$DocumentValidator.LexingError;\n            })) return diagnostics;\n            this.processParsingErrors(parseResult, diagnostics, options);\n            if (options.stopAfterParsingErrors && diagnostics.some((d)=>{\n                var _a;\n                return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === $1d44efb04eab6ceb$var$DocumentValidator.ParsingError;\n            })) return diagnostics;\n            this.processLinkingErrors(document, diagnostics, options);\n            if (options.stopAfterLinkingErrors && diagnostics.some((d)=>{\n                var _a;\n                return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === $1d44efb04eab6ceb$var$DocumentValidator.LinkingError;\n            })) return diagnostics;\n        }\n        try {\n            diagnostics.push(...await this.validateAst(parseResult.value, options, cancelToken));\n        } catch (err) {\n            if ($1d44efb04eab6ceb$var$isOperationCancelled(err)) throw err;\n            console.error(\"An error occurred during validation:\", err);\n        }\n        await $1d44efb04eab6ceb$var$interruptAndCheck(cancelToken);\n        return diagnostics;\n    }\n    processLexingErrors(parseResult, diagnostics, _options) {\n        for (const lexerError of parseResult.lexerErrors){\n            const diagnostic = {\n                severity: $1d44efb04eab6ceb$var$toDiagnosticSeverity(\"error\"),\n                range: {\n                    start: {\n                        line: lexerError.line - 1,\n                        character: lexerError.column - 1\n                    },\n                    end: {\n                        line: lexerError.line - 1,\n                        character: lexerError.column + lexerError.length - 1\n                    }\n                },\n                message: lexerError.message,\n                data: $1d44efb04eab6ceb$var$diagnosticData($1d44efb04eab6ceb$var$DocumentValidator.LexingError),\n                source: this.getSource()\n            };\n            diagnostics.push(diagnostic);\n        }\n    }\n    processParsingErrors(parseResult, diagnostics, _options) {\n        for (const parserError of parseResult.parserErrors){\n            let range = void 0;\n            if (isNaN(parserError.token.startOffset)) {\n                if (\"previousToken\" in parserError) {\n                    const token = parserError.previousToken;\n                    if (!isNaN(token.startOffset)) {\n                        const position = {\n                            line: token.endLine - 1,\n                            character: token.endColumn\n                        };\n                        range = {\n                            start: position,\n                            end: position\n                        };\n                    } else {\n                        const position = {\n                            line: 0,\n                            character: 0\n                        };\n                        range = {\n                            start: position,\n                            end: position\n                        };\n                    }\n                }\n            } else range = $1d44efb04eab6ceb$var$tokenToRange(parserError.token);\n            if (range) {\n                const diagnostic = {\n                    severity: $1d44efb04eab6ceb$var$toDiagnosticSeverity(\"error\"),\n                    range: range,\n                    message: parserError.message,\n                    data: $1d44efb04eab6ceb$var$diagnosticData($1d44efb04eab6ceb$var$DocumentValidator.ParsingError),\n                    source: this.getSource()\n                };\n                diagnostics.push(diagnostic);\n            }\n        }\n    }\n    processLinkingErrors(document, diagnostics, _options) {\n        for (const reference of document.references){\n            const linkingError = reference.error;\n            if (linkingError) {\n                const info = {\n                    node: linkingError.container,\n                    property: linkingError.property,\n                    index: linkingError.index,\n                    data: {\n                        code: $1d44efb04eab6ceb$var$DocumentValidator.LinkingError,\n                        containerType: linkingError.container.$type,\n                        property: linkingError.property,\n                        refText: linkingError.reference.$refText\n                    }\n                };\n                diagnostics.push(this.toDiagnostic(\"error\", linkingError.message, info));\n            }\n        }\n    }\n    async validateAst(rootNode, options, cancelToken = $1d44efb04eab6ceb$var$cancellation_exports.CancellationToken.None) {\n        const validationItems = [];\n        const acceptor = /* @__PURE__ */ (0, $7xxrv.__name)((severity, message, info)=>{\n            validationItems.push(this.toDiagnostic(severity, message, info));\n        }, \"acceptor\");\n        await Promise.all($1d44efb04eab6ceb$var$streamAst(rootNode).map(async (node)=>{\n            await $1d44efb04eab6ceb$var$interruptAndCheck(cancelToken);\n            const checks = this.validationRegistry.getChecks(node.$type, options.categories);\n            for (const check of checks)await check(node, acceptor, cancelToken);\n        }));\n        return validationItems;\n    }\n    toDiagnostic(severity, message, info) {\n        return {\n            message: message,\n            range: $1d44efb04eab6ceb$var$getDiagnosticRange(info),\n            severity: $1d44efb04eab6ceb$var$toDiagnosticSeverity(severity),\n            code: info.code,\n            codeDescription: info.codeDescription,\n            tags: info.tags,\n            relatedInformation: info.relatedInformation,\n            data: info.data,\n            source: this.getSource()\n        };\n    }\n    getSource() {\n        return this.metadata.languageId;\n    }\n};\nfunction $1d44efb04eab6ceb$var$getDiagnosticRange(info) {\n    if (info.range) return info.range;\n    let cstNode;\n    if (typeof info.property === \"string\") cstNode = $1d44efb04eab6ceb$var$findNodeForProperty(info.node.$cstNode, info.property, info.index);\n    else if (typeof info.keyword === \"string\") cstNode = $1d44efb04eab6ceb$var$findNodeForKeyword(info.node.$cstNode, info.keyword, info.index);\n    cstNode !== null && cstNode !== void 0 ? cstNode : cstNode = info.node.$cstNode;\n    if (!cstNode) return {\n        start: {\n            line: 0,\n            character: 0\n        },\n        end: {\n            line: 0,\n            character: 0\n        }\n    };\n    return cstNode.range;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getDiagnosticRange, \"getDiagnosticRange\");\nfunction $1d44efb04eab6ceb$var$toDiagnosticSeverity(severity) {\n    switch(severity){\n        case \"error\":\n            return 1;\n        case \"warning\":\n            return 2;\n        case \"info\":\n            return 3;\n        case \"hint\":\n            return 4;\n        default:\n            throw new Error(\"Invalid diagnostic severity: \" + severity);\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$toDiagnosticSeverity, \"toDiagnosticSeverity\");\nvar $1d44efb04eab6ceb$var$DocumentValidator;\n(function(DocumentValidator2) {\n    DocumentValidator2.LexingError = \"lexing-error\";\n    DocumentValidator2.ParsingError = \"parsing-error\";\n    DocumentValidator2.LinkingError = \"linking-error\";\n})($1d44efb04eab6ceb$var$DocumentValidator || ($1d44efb04eab6ceb$var$DocumentValidator = {}));\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/workspace/ast-descriptions.js\nvar $1d44efb04eab6ceb$var$DefaultAstNodeDescriptionProvider = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultAstNodeDescriptionProvider\");\n    }\n    constructor(services){\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n        this.nameProvider = services.references.NameProvider;\n    }\n    createDescription(node, name, document = $1d44efb04eab6ceb$var$getDocument(node)) {\n        name !== null && name !== void 0 ? name : name = this.nameProvider.getName(node);\n        const path = this.astNodeLocator.getAstNodePath(node);\n        if (!name) throw new Error(`Node at path ${path} has no name.`);\n        let nameNodeSegment;\n        const nameSegmentGetter = /* @__PURE__ */ (0, $7xxrv.__name)(()=>{\n            var _a;\n            return nameNodeSegment !== null && nameNodeSegment !== void 0 ? nameNodeSegment : nameNodeSegment = $1d44efb04eab6ceb$var$toDocumentSegment((_a = this.nameProvider.getNameNode(node)) !== null && _a !== void 0 ? _a : node.$cstNode);\n        }, \"nameSegmentGetter\");\n        return {\n            node: node,\n            name: name,\n            get nameSegment () {\n                return nameSegmentGetter();\n            },\n            selectionSegment: $1d44efb04eab6ceb$var$toDocumentSegment(node.$cstNode),\n            type: node.$type,\n            documentUri: document.uri,\n            path: path\n        };\n    }\n};\nvar $1d44efb04eab6ceb$var$DefaultReferenceDescriptionProvider = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultReferenceDescriptionProvider\");\n    }\n    constructor(services){\n        this.nodeLocator = services.workspace.AstNodeLocator;\n    }\n    async createDescriptions(document, cancelToken = $1d44efb04eab6ceb$var$cancellation_exports.CancellationToken.None) {\n        const descr = [];\n        const rootNode = document.parseResult.value;\n        for (const astNode of $1d44efb04eab6ceb$var$streamAst(rootNode)){\n            await $1d44efb04eab6ceb$var$interruptAndCheck(cancelToken);\n            $1d44efb04eab6ceb$var$streamReferences(astNode).filter((refInfo)=>!$1d44efb04eab6ceb$var$isLinkingError(refInfo)).forEach((refInfo)=>{\n                const description = this.createDescription(refInfo);\n                if (description) descr.push(description);\n            });\n        }\n        return descr;\n    }\n    createDescription(refInfo) {\n        const targetNodeDescr = refInfo.reference.$nodeDescription;\n        const refCstNode = refInfo.reference.$refNode;\n        if (!targetNodeDescr || !refCstNode) return void 0;\n        const docUri = $1d44efb04eab6ceb$var$getDocument(refInfo.container).uri;\n        return {\n            sourceUri: docUri,\n            sourcePath: this.nodeLocator.getAstNodePath(refInfo.container),\n            targetUri: targetNodeDescr.documentUri,\n            targetPath: targetNodeDescr.path,\n            segment: $1d44efb04eab6ceb$var$toDocumentSegment(refCstNode),\n            local: $1d44efb04eab6ceb$var$UriUtils.equals(targetNodeDescr.documentUri, docUri)\n        };\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/workspace/ast-node-locator.js\nvar $1d44efb04eab6ceb$var$DefaultAstNodeLocator = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultAstNodeLocator\");\n    }\n    constructor(){\n        this.segmentSeparator = \"/\";\n        this.indexSeparator = \"@\";\n    }\n    getAstNodePath(node) {\n        if (node.$container) {\n            const containerPath = this.getAstNodePath(node.$container);\n            const newSegment = this.getPathSegment(node);\n            const nodePath = containerPath + this.segmentSeparator + newSegment;\n            return nodePath;\n        }\n        return \"\";\n    }\n    getPathSegment({ $containerProperty: $containerProperty, $containerIndex: $containerIndex }) {\n        if (!$containerProperty) throw new Error(\"Missing '$containerProperty' in AST node.\");\n        if ($containerIndex !== void 0) return $containerProperty + this.indexSeparator + $containerIndex;\n        return $containerProperty;\n    }\n    getAstNode(node, path) {\n        const segments = path.split(this.segmentSeparator);\n        return segments.reduce((previousValue, currentValue)=>{\n            if (!previousValue || currentValue.length === 0) return previousValue;\n            const propertyIndex = currentValue.indexOf(this.indexSeparator);\n            if (propertyIndex > 0) {\n                const property = currentValue.substring(0, propertyIndex);\n                const arrayIndex = parseInt(currentValue.substring(propertyIndex + 1));\n                const array = previousValue[property];\n                return array === null || array === void 0 ? void 0 : array[arrayIndex];\n            }\n            return previousValue[currentValue];\n        }, node);\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/workspace/configuration.js\nvar $1d44efb04eab6ceb$var$DefaultConfigurationProvider = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultConfigurationProvider\");\n    }\n    constructor(services){\n        this._ready = new $1d44efb04eab6ceb$var$Deferred();\n        this.settings = {};\n        this.workspaceConfig = false;\n        this.serviceRegistry = services.ServiceRegistry;\n    }\n    get ready() {\n        return this._ready.promise;\n    }\n    initialize(params) {\n        var _a, _b;\n        this.workspaceConfig = (_b = (_a = params.capabilities.workspace) === null || _a === void 0 ? void 0 : _a.configuration) !== null && _b !== void 0 ? _b : false;\n    }\n    async initialized(params) {\n        if (this.workspaceConfig) {\n            if (params.register) {\n                const languages = this.serviceRegistry.all;\n                params.register({\n                    // Listen to configuration changes for all languages\n                    section: languages.map((lang)=>this.toSectionName(lang.LanguageMetaData.languageId))\n                });\n            }\n            if (params.fetchConfiguration) {\n                const configToUpdate = this.serviceRegistry.all.map((lang)=>({\n                        // Fetch the configuration changes for all languages\n                        section: this.toSectionName(lang.LanguageMetaData.languageId)\n                    }));\n                const configs = await params.fetchConfiguration(configToUpdate);\n                configToUpdate.forEach((conf, idx)=>{\n                    this.updateSectionConfiguration(conf.section, configs[idx]);\n                });\n            }\n        }\n        this._ready.resolve();\n    }\n    /**\n   *  Updates the cached configurations using the `change` notification parameters.\n   *\n   * @param change The parameters of a change configuration notification.\n   * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`\n   */ updateConfiguration(change) {\n        if (!change.settings) return;\n        Object.keys(change.settings).forEach((section)=>{\n            this.updateSectionConfiguration(section, change.settings[section]);\n        });\n    }\n    updateSectionConfiguration(section, configuration) {\n        this.settings[section] = configuration;\n    }\n    /**\n  * Returns a configuration value stored for the given language.\n  *\n  * @param language The language id\n  * @param configuration Configuration name\n  */ async getConfiguration(language, configuration) {\n        await this.ready;\n        const sectionName = this.toSectionName(language);\n        if (this.settings[sectionName]) return this.settings[sectionName][configuration];\n    }\n    toSectionName(languageId) {\n        return `${languageId}`;\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/disposable.js\nvar $1d44efb04eab6ceb$var$Disposable;\n(function(Disposable2) {\n    function create(callback) {\n        return {\n            dispose: /* @__PURE__ */ (0, $7xxrv.__name)(async ()=>await callback(), \"dispose\")\n        };\n    }\n    (0, $7xxrv.__name)(create, \"create\");\n    Disposable2.create = create;\n})($1d44efb04eab6ceb$var$Disposable || ($1d44efb04eab6ceb$var$Disposable = {}));\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/workspace/document-builder.js\nvar $1d44efb04eab6ceb$var$DefaultDocumentBuilder = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultDocumentBuilder\");\n    }\n    constructor(services){\n        this.updateBuildOptions = {\n            // Default: run only the built-in validation checks and those in the _fast_ category (includes those without category)\n            validation: {\n                categories: [\n                    \"built-in\",\n                    \"fast\"\n                ]\n            }\n        };\n        this.updateListeners = [];\n        this.buildPhaseListeners = new $1d44efb04eab6ceb$var$MultiMap();\n        this.buildState = /* @__PURE__ */ new Map();\n        this.documentBuildWaiters = /* @__PURE__ */ new Map();\n        this.currentState = $1d44efb04eab6ceb$var$DocumentState.Changed;\n        this.langiumDocuments = services.workspace.LangiumDocuments;\n        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\n        this.indexManager = services.workspace.IndexManager;\n        this.serviceRegistry = services.ServiceRegistry;\n    }\n    async build(documents, options = {}, cancelToken = $1d44efb04eab6ceb$var$cancellation_exports.CancellationToken.None) {\n        var _a, _b;\n        for (const document of documents){\n            const key = document.uri.toString();\n            if (document.state === $1d44efb04eab6ceb$var$DocumentState.Validated) {\n                if (typeof options.validation === \"boolean\" && options.validation) {\n                    document.state = $1d44efb04eab6ceb$var$DocumentState.IndexedReferences;\n                    document.diagnostics = void 0;\n                    this.buildState.delete(key);\n                } else if (typeof options.validation === \"object\") {\n                    const buildState = this.buildState.get(key);\n                    const previousCategories = (_a = buildState === null || buildState === void 0 ? void 0 : buildState.result) === null || _a === void 0 ? void 0 : _a.validationChecks;\n                    if (previousCategories) {\n                        const newCategories = (_b = options.validation.categories) !== null && _b !== void 0 ? _b : $1d44efb04eab6ceb$var$ValidationCategory.all;\n                        const categories = newCategories.filter((c)=>!previousCategories.includes(c));\n                        if (categories.length > 0) {\n                            this.buildState.set(key, {\n                                completed: false,\n                                options: {\n                                    validation: Object.assign(Object.assign({}, options.validation), {\n                                        categories: categories\n                                    })\n                                },\n                                result: buildState.result\n                            });\n                            document.state = $1d44efb04eab6ceb$var$DocumentState.IndexedReferences;\n                        }\n                    }\n                }\n            } else this.buildState.delete(key);\n        }\n        this.currentState = $1d44efb04eab6ceb$var$DocumentState.Changed;\n        await this.emitUpdate(documents.map((e)=>e.uri), []);\n        await this.buildDocuments(documents, options, cancelToken);\n    }\n    async update(changed, deleted, cancelToken = $1d44efb04eab6ceb$var$cancellation_exports.CancellationToken.None) {\n        this.currentState = $1d44efb04eab6ceb$var$DocumentState.Changed;\n        for (const deletedUri of deleted){\n            this.langiumDocuments.deleteDocument(deletedUri);\n            this.buildState.delete(deletedUri.toString());\n            this.indexManager.remove(deletedUri);\n        }\n        for (const changedUri of changed){\n            const invalidated = this.langiumDocuments.invalidateDocument(changedUri);\n            if (!invalidated) {\n                const newDocument = this.langiumDocumentFactory.fromModel({\n                    $type: \"INVALID\"\n                }, changedUri);\n                newDocument.state = $1d44efb04eab6ceb$var$DocumentState.Changed;\n                this.langiumDocuments.addDocument(newDocument);\n            }\n            this.buildState.delete(changedUri.toString());\n        }\n        const allChangedUris = $1d44efb04eab6ceb$var$stream(changed).concat(deleted).map((uri)=>uri.toString()).toSet();\n        this.langiumDocuments.all.filter((doc)=>!allChangedUris.has(doc.uri.toString()) && this.shouldRelink(doc, allChangedUris)).forEach((doc)=>{\n            const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\n            linker.unlink(doc);\n            doc.state = Math.min(doc.state, $1d44efb04eab6ceb$var$DocumentState.ComputedScopes);\n            doc.diagnostics = void 0;\n        });\n        await this.emitUpdate(changed, deleted);\n        await $1d44efb04eab6ceb$var$interruptAndCheck(cancelToken);\n        const rebuildDocuments = this.langiumDocuments.all.filter((doc)=>{\n            var _a;\n            return doc.state < $1d44efb04eab6ceb$var$DocumentState.Linked || !((_a = this.buildState.get(doc.uri.toString())) === null || _a === void 0 ? void 0 : _a.completed);\n        }).toArray();\n        await this.buildDocuments(rebuildDocuments, this.updateBuildOptions, cancelToken);\n    }\n    async emitUpdate(changed, deleted) {\n        await Promise.all(this.updateListeners.map((listener)=>listener(changed, deleted)));\n    }\n    /**\n   * Check whether the given document should be relinked after changes were found in the given URIs.\n   */ shouldRelink(document, changedUris) {\n        if (document.references.some((ref)=>ref.error !== void 0)) return true;\n        return this.indexManager.isAffected(document, changedUris);\n    }\n    onUpdate(callback) {\n        this.updateListeners.push(callback);\n        return $1d44efb04eab6ceb$var$Disposable.create(()=>{\n            const index = this.updateListeners.indexOf(callback);\n            if (index >= 0) this.updateListeners.splice(index, 1);\n        });\n    }\n    /**\n   * Build the given documents by stepping through all build phases. If a document's state indicates\n   * that a certain build phase is already done, the phase is skipped for that document.\n   */ async buildDocuments(documents, options, cancelToken) {\n        this.prepareBuild(documents, options);\n        await this.runCancelable(documents, $1d44efb04eab6ceb$var$DocumentState.Parsed, cancelToken, (doc)=>this.langiumDocumentFactory.update(doc, cancelToken));\n        await this.runCancelable(documents, $1d44efb04eab6ceb$var$DocumentState.IndexedContent, cancelToken, (doc)=>this.indexManager.updateContent(doc, cancelToken));\n        await this.runCancelable(documents, $1d44efb04eab6ceb$var$DocumentState.ComputedScopes, cancelToken, async (doc)=>{\n            const scopeComputation = this.serviceRegistry.getServices(doc.uri).references.ScopeComputation;\n            doc.precomputedScopes = await scopeComputation.computeLocalScopes(doc, cancelToken);\n        });\n        await this.runCancelable(documents, $1d44efb04eab6ceb$var$DocumentState.Linked, cancelToken, (doc)=>{\n            const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\n            return linker.link(doc, cancelToken);\n        });\n        await this.runCancelable(documents, $1d44efb04eab6ceb$var$DocumentState.IndexedReferences, cancelToken, (doc)=>this.indexManager.updateReferences(doc, cancelToken));\n        const toBeValidated = documents.filter((doc)=>this.shouldValidate(doc));\n        await this.runCancelable(toBeValidated, $1d44efb04eab6ceb$var$DocumentState.Validated, cancelToken, (doc)=>this.validate(doc, cancelToken));\n        for (const doc of documents){\n            const state = this.buildState.get(doc.uri.toString());\n            if (state) state.completed = true;\n        }\n    }\n    prepareBuild(documents, options) {\n        for (const doc of documents){\n            const key = doc.uri.toString();\n            const state = this.buildState.get(key);\n            if (!state || state.completed) this.buildState.set(key, {\n                completed: false,\n                options: options,\n                result: state === null || state === void 0 ? void 0 : state.result\n            });\n        }\n    }\n    async runCancelable(documents, targetState, cancelToken, callback) {\n        const filtered = documents.filter((e)=>e.state < targetState);\n        for (const document of filtered){\n            await $1d44efb04eab6ceb$var$interruptAndCheck(cancelToken);\n            await callback(document);\n            document.state = targetState;\n        }\n        await this.notifyBuildPhase(filtered, targetState, cancelToken);\n        this.currentState = targetState;\n    }\n    onBuildPhase(targetState, callback) {\n        this.buildPhaseListeners.add(targetState, callback);\n        return $1d44efb04eab6ceb$var$Disposable.create(()=>{\n            this.buildPhaseListeners.delete(targetState, callback);\n        });\n    }\n    waitUntil(state, uriOrToken, cancelToken) {\n        let uri = void 0;\n        if (uriOrToken && \"path\" in uriOrToken) uri = uriOrToken;\n        else cancelToken = uriOrToken;\n        cancelToken !== null && cancelToken !== void 0 ? cancelToken : cancelToken = $1d44efb04eab6ceb$var$cancellation_exports.CancellationToken.None;\n        if (uri) {\n            const document = this.langiumDocuments.getDocument(uri);\n            if (document && document.state > state) return Promise.resolve(uri);\n        }\n        if (this.currentState >= state) return Promise.resolve(void 0);\n        else if (cancelToken.isCancellationRequested) return Promise.reject($1d44efb04eab6ceb$var$OperationCancelled);\n        return new Promise((resolve, reject)=>{\n            const buildDisposable = this.onBuildPhase(state, ()=>{\n                buildDisposable.dispose();\n                cancelDisposable.dispose();\n                if (uri) {\n                    const document = this.langiumDocuments.getDocument(uri);\n                    resolve(document === null || document === void 0 ? void 0 : document.uri);\n                } else resolve(void 0);\n            });\n            const cancelDisposable = cancelToken.onCancellationRequested(()=>{\n                buildDisposable.dispose();\n                cancelDisposable.dispose();\n                reject($1d44efb04eab6ceb$var$OperationCancelled);\n            });\n        });\n    }\n    async notifyBuildPhase(documents, state, cancelToken) {\n        if (documents.length === 0) return;\n        const listeners = this.buildPhaseListeners.get(state);\n        for (const listener of listeners){\n            await $1d44efb04eab6ceb$var$interruptAndCheck(cancelToken);\n            await listener(documents, cancelToken);\n        }\n    }\n    /**\n   * Determine whether the given document should be validated during a build. The default\n   * implementation checks the `validation` property of the build options. If it's set to `true`\n   * or a `ValidationOptions` object, the document is included in the validation phase.\n   */ shouldValidate(document) {\n        return Boolean(this.getBuildOptions(document).validation);\n    }\n    /**\n   * Run validation checks on the given document and store the resulting diagnostics in the document.\n   * If the document already contains diagnostics, the new ones are added to the list.\n   */ async validate(document, cancelToken) {\n        var _a, _b;\n        const validator = this.serviceRegistry.getServices(document.uri).validation.DocumentValidator;\n        const validationSetting = this.getBuildOptions(document).validation;\n        const options = typeof validationSetting === \"object\" ? validationSetting : void 0;\n        const diagnostics = await validator.validateDocument(document, options, cancelToken);\n        if (document.diagnostics) document.diagnostics.push(...diagnostics);\n        else document.diagnostics = diagnostics;\n        const state = this.buildState.get(document.uri.toString());\n        if (state) {\n            (_a = state.result) !== null && _a !== void 0 ? _a : state.result = {};\n            const newCategories = (_b = options === null || options === void 0 ? void 0 : options.categories) !== null && _b !== void 0 ? _b : $1d44efb04eab6ceb$var$ValidationCategory.all;\n            if (state.result.validationChecks) state.result.validationChecks.push(...newCategories);\n            else state.result.validationChecks = [\n                ...newCategories\n            ];\n        }\n    }\n    getBuildOptions(document) {\n        var _a, _b;\n        return (_b = (_a = this.buildState.get(document.uri.toString())) === null || _a === void 0 ? void 0 : _a.options) !== null && _b !== void 0 ? _b : {};\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/workspace/index-manager.js\nvar $1d44efb04eab6ceb$var$DefaultIndexManager = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultIndexManager\");\n    }\n    constructor(services){\n        this.symbolIndex = /* @__PURE__ */ new Map();\n        this.symbolByTypeIndex = new $1d44efb04eab6ceb$var$ContextCache();\n        this.referenceIndex = /* @__PURE__ */ new Map();\n        this.documents = services.workspace.LangiumDocuments;\n        this.serviceRegistry = services.ServiceRegistry;\n        this.astReflection = services.AstReflection;\n    }\n    findAllReferences(targetNode, astNodePath) {\n        const targetDocUri = $1d44efb04eab6ceb$var$getDocument(targetNode).uri;\n        const result = [];\n        this.referenceIndex.forEach((docRefs)=>{\n            docRefs.forEach((refDescr)=>{\n                if ($1d44efb04eab6ceb$var$UriUtils.equals(refDescr.targetUri, targetDocUri) && refDescr.targetPath === astNodePath) result.push(refDescr);\n            });\n        });\n        return $1d44efb04eab6ceb$var$stream(result);\n    }\n    allElements(nodeType, uris) {\n        let documentUris = $1d44efb04eab6ceb$var$stream(this.symbolIndex.keys());\n        if (uris) documentUris = documentUris.filter((uri)=>!uris || uris.has(uri));\n        return documentUris.map((uri)=>this.getFileDescriptions(uri, nodeType)).flat();\n    }\n    getFileDescriptions(uri, nodeType) {\n        var _a;\n        if (!nodeType) return (_a = this.symbolIndex.get(uri)) !== null && _a !== void 0 ? _a : [];\n        const descriptions = this.symbolByTypeIndex.get(uri, nodeType, ()=>{\n            var _a2;\n            const allFileDescriptions = (_a2 = this.symbolIndex.get(uri)) !== null && _a2 !== void 0 ? _a2 : [];\n            return allFileDescriptions.filter((e)=>this.astReflection.isSubtype(e.type, nodeType));\n        });\n        return descriptions;\n    }\n    remove(uri) {\n        const uriString = uri.toString();\n        this.symbolIndex.delete(uriString);\n        this.symbolByTypeIndex.clear(uriString);\n        this.referenceIndex.delete(uriString);\n    }\n    async updateContent(document, cancelToken = $1d44efb04eab6ceb$var$cancellation_exports.CancellationToken.None) {\n        const services = this.serviceRegistry.getServices(document.uri);\n        const exports = await services.references.ScopeComputation.computeExports(document, cancelToken);\n        const uri = document.uri.toString();\n        this.symbolIndex.set(uri, exports);\n        this.symbolByTypeIndex.clear(uri);\n    }\n    async updateReferences(document, cancelToken = $1d44efb04eab6ceb$var$cancellation_exports.CancellationToken.None) {\n        const services = this.serviceRegistry.getServices(document.uri);\n        const indexData = await services.workspace.ReferenceDescriptionProvider.createDescriptions(document, cancelToken);\n        this.referenceIndex.set(document.uri.toString(), indexData);\n    }\n    isAffected(document, changedUris) {\n        const references = this.referenceIndex.get(document.uri.toString());\n        if (!references) return false;\n        return references.some((ref)=>!ref.local && changedUris.has(ref.targetUri.toString()));\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/workspace/workspace-manager.js\nvar $1d44efb04eab6ceb$var$DefaultWorkspaceManager = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultWorkspaceManager\");\n    }\n    constructor(services){\n        this.initialBuildOptions = {};\n        this._ready = new $1d44efb04eab6ceb$var$Deferred();\n        this.serviceRegistry = services.ServiceRegistry;\n        this.langiumDocuments = services.workspace.LangiumDocuments;\n        this.documentBuilder = services.workspace.DocumentBuilder;\n        this.fileSystemProvider = services.workspace.FileSystemProvider;\n        this.mutex = services.workspace.WorkspaceLock;\n    }\n    get ready() {\n        return this._ready.promise;\n    }\n    initialize(params) {\n        var _a;\n        this.folders = (_a = params.workspaceFolders) !== null && _a !== void 0 ? _a : void 0;\n    }\n    initialized(_params) {\n        return this.mutex.write((token)=>{\n            var _a;\n            return this.initializeWorkspace((_a = this.folders) !== null && _a !== void 0 ? _a : [], token);\n        });\n    }\n    async initializeWorkspace(folders, cancelToken = $1d44efb04eab6ceb$var$cancellation_exports.CancellationToken.None) {\n        const documents = await this.performStartup(folders);\n        await $1d44efb04eab6ceb$var$interruptAndCheck(cancelToken);\n        await this.documentBuilder.build(documents, this.initialBuildOptions, cancelToken);\n    }\n    /**\n   * Performs the uninterruptable startup sequence of the workspace manager.\n   * This methods loads all documents in the workspace and other documents and returns them.\n   */ async performStartup(folders) {\n        const fileExtensions = this.serviceRegistry.all.flatMap((e)=>e.LanguageMetaData.fileExtensions);\n        const documents = [];\n        const collector = /* @__PURE__ */ (0, $7xxrv.__name)((document)=>{\n            documents.push(document);\n            if (!this.langiumDocuments.hasDocument(document.uri)) this.langiumDocuments.addDocument(document);\n        }, \"collector\");\n        await this.loadAdditionalDocuments(folders, collector);\n        await Promise.all(folders.map((wf)=>[\n                wf,\n                this.getRootFolder(wf)\n            ]).map(async (entry)=>this.traverseFolder(...entry, fileExtensions, collector)));\n        this._ready.resolve();\n        return documents;\n    }\n    /**\n   * Load all additional documents that shall be visible in the context of the given workspace\n   * folders and add them to the collector. This can be used to include built-in libraries of\n   * your language, which can be either loaded from provided files or constructed in memory.\n   */ loadAdditionalDocuments(_folders, _collector) {\n        return Promise.resolve();\n    }\n    /**\n   * Determine the root folder of the source documents in the given workspace folder.\n   * The default implementation returns the URI of the workspace folder, but you can override\n   * this to return a subfolder like `src` instead.\n   */ getRootFolder(workspaceFolder) {\n        return $1d44efb04eab6ceb$var$URI2.parse(workspaceFolder.uri);\n    }\n    /**\n   * Traverse the file system folder identified by the given URI and its subfolders. All\n   * contained files that match the file extensions are added to the collector.\n   */ async traverseFolder(workspaceFolder, folderPath, fileExtensions, collector) {\n        const content = await this.fileSystemProvider.readDirectory(folderPath);\n        await Promise.all(content.map(async (entry)=>{\n            if (this.includeEntry(workspaceFolder, entry, fileExtensions)) {\n                if (entry.isDirectory) await this.traverseFolder(workspaceFolder, entry.uri, fileExtensions, collector);\n                else if (entry.isFile) {\n                    const document = await this.langiumDocuments.getOrCreateDocument(entry.uri);\n                    collector(document);\n                }\n            }\n        }));\n    }\n    /**\n   * Determine whether the given folder entry shall be included while indexing the workspace.\n   */ includeEntry(_workspaceFolder, entry, fileExtensions) {\n        const name = $1d44efb04eab6ceb$var$UriUtils.basename(entry.uri);\n        if (name.startsWith(\".\")) return false;\n        if (entry.isDirectory) return name !== \"node_modules\" && name !== \"out\";\n        else if (entry.isFile) {\n            const extname = $1d44efb04eab6ceb$var$UriUtils.extname(entry.uri);\n            return fileExtensions.includes(extname);\n        }\n        return false;\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/parser/lexer.js\nvar $1d44efb04eab6ceb$var$DefaultLexer = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultLexer\");\n    }\n    constructor(services){\n        const tokens = services.parser.TokenBuilder.buildTokens(services.Grammar, {\n            caseInsensitive: services.LanguageMetaData.caseInsensitive\n        });\n        this.tokenTypes = this.toTokenTypeDictionary(tokens);\n        const lexerTokens = $1d44efb04eab6ceb$var$isTokenTypeDictionary(tokens) ? Object.values(tokens) : tokens;\n        this.chevrotainLexer = new $1d44efb04eab6ceb$var$Lexer(lexerTokens, {\n            positionTracking: \"full\"\n        });\n    }\n    get definition() {\n        return this.tokenTypes;\n    }\n    tokenize(text) {\n        var _a;\n        const chevrotainResult = this.chevrotainLexer.tokenize(text);\n        return {\n            tokens: chevrotainResult.tokens,\n            errors: chevrotainResult.errors,\n            hidden: (_a = chevrotainResult.groups.hidden) !== null && _a !== void 0 ? _a : []\n        };\n    }\n    toTokenTypeDictionary(buildTokens) {\n        if ($1d44efb04eab6ceb$var$isTokenTypeDictionary(buildTokens)) return buildTokens;\n        const tokens = $1d44efb04eab6ceb$var$isIMultiModeLexerDefinition(buildTokens) ? Object.values(buildTokens.modes).flat() : buildTokens;\n        const res = {};\n        tokens.forEach((token)=>res[token.name] = token);\n        return res;\n    }\n};\nfunction $1d44efb04eab6ceb$var$isTokenTypeArray(tokenVocabulary) {\n    return Array.isArray(tokenVocabulary) && (tokenVocabulary.length === 0 || \"name\" in tokenVocabulary[0]);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isTokenTypeArray, \"isTokenTypeArray\");\nfunction $1d44efb04eab6ceb$var$isIMultiModeLexerDefinition(tokenVocabulary) {\n    return tokenVocabulary && \"modes\" in tokenVocabulary && \"defaultMode\" in tokenVocabulary;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isIMultiModeLexerDefinition, \"isIMultiModeLexerDefinition\");\nfunction $1d44efb04eab6ceb$var$isTokenTypeDictionary(tokenVocabulary) {\n    return !$1d44efb04eab6ceb$var$isTokenTypeArray(tokenVocabulary) && !$1d44efb04eab6ceb$var$isIMultiModeLexerDefinition(tokenVocabulary);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isTokenTypeDictionary, \"isTokenTypeDictionary\");\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/documentation/jsdoc.js\nfunction $1d44efb04eab6ceb$var$parseJSDoc(node, start, options) {\n    let opts;\n    let position;\n    if (typeof node === \"string\") {\n        position = start;\n        opts = options;\n    } else {\n        position = node.range.start;\n        opts = start;\n    }\n    if (!position) position = $1d44efb04eab6ceb$var$Position.create(0, 0);\n    const lines = $1d44efb04eab6ceb$var$getLines(node);\n    const normalizedOptions = $1d44efb04eab6ceb$var$normalizeOptions(opts);\n    const tokens = $1d44efb04eab6ceb$var$tokenize({\n        lines: lines,\n        position: position,\n        options: normalizedOptions\n    });\n    return $1d44efb04eab6ceb$var$parseJSDocComment({\n        index: 0,\n        tokens: tokens,\n        position: position\n    });\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$parseJSDoc, \"parseJSDoc\");\nfunction $1d44efb04eab6ceb$var$isJSDoc(node, options) {\n    const normalizedOptions = $1d44efb04eab6ceb$var$normalizeOptions(options);\n    const lines = $1d44efb04eab6ceb$var$getLines(node);\n    if (lines.length === 0) return false;\n    const first2 = lines[0];\n    const last = lines[lines.length - 1];\n    const firstRegex = normalizedOptions.start;\n    const lastRegex = normalizedOptions.end;\n    return Boolean(firstRegex === null || firstRegex === void 0 ? void 0 : firstRegex.exec(first2)) && Boolean(lastRegex === null || lastRegex === void 0 ? void 0 : lastRegex.exec(last));\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isJSDoc, \"isJSDoc\");\nfunction $1d44efb04eab6ceb$var$getLines(node) {\n    let content = \"\";\n    if (typeof node === \"string\") content = node;\n    else content = node.text;\n    const lines = content.split($1d44efb04eab6ceb$var$NEWLINE_REGEXP);\n    return lines;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$getLines, \"getLines\");\nvar $1d44efb04eab6ceb$var$tagRegex = /\\s*(@([\\p{L}][\\p{L}\\p{N}]*)?)/uy;\nvar $1d44efb04eab6ceb$var$inlineTagRegex = /\\{(@[\\p{L}][\\p{L}\\p{N}]*)(\\s*)([^\\r\\n}]+)?\\}/gu;\nfunction $1d44efb04eab6ceb$var$tokenize(context) {\n    var _a, _b, _c;\n    const tokens = [];\n    let currentLine = context.position.line;\n    let currentCharacter = context.position.character;\n    for(let i = 0; i < context.lines.length; i++){\n        const first2 = i === 0;\n        const last = i === context.lines.length - 1;\n        let line = context.lines[i];\n        let index = 0;\n        if (first2 && context.options.start) {\n            const match = (_a = context.options.start) === null || _a === void 0 ? void 0 : _a.exec(line);\n            if (match) index = match.index + match[0].length;\n        } else {\n            const match = (_b = context.options.line) === null || _b === void 0 ? void 0 : _b.exec(line);\n            if (match) index = match.index + match[0].length;\n        }\n        if (last) {\n            const match = (_c = context.options.end) === null || _c === void 0 ? void 0 : _c.exec(line);\n            if (match) line = line.substring(0, match.index);\n        }\n        line = line.substring(0, $1d44efb04eab6ceb$var$lastCharacter(line));\n        const whitespaceEnd = $1d44efb04eab6ceb$var$skipWhitespace(line, index);\n        if (whitespaceEnd >= line.length) {\n            if (tokens.length > 0) {\n                const position = $1d44efb04eab6ceb$var$Position.create(currentLine, currentCharacter);\n                tokens.push({\n                    type: \"break\",\n                    content: \"\",\n                    range: $1d44efb04eab6ceb$var$Range.create(position, position)\n                });\n            }\n        } else {\n            $1d44efb04eab6ceb$var$tagRegex.lastIndex = index;\n            const tagMatch = $1d44efb04eab6ceb$var$tagRegex.exec(line);\n            if (tagMatch) {\n                const fullMatch = tagMatch[0];\n                const value = tagMatch[1];\n                const start = $1d44efb04eab6ceb$var$Position.create(currentLine, currentCharacter + index);\n                const end = $1d44efb04eab6ceb$var$Position.create(currentLine, currentCharacter + index + fullMatch.length);\n                tokens.push({\n                    type: \"tag\",\n                    content: value,\n                    range: $1d44efb04eab6ceb$var$Range.create(start, end)\n                });\n                index += fullMatch.length;\n                index = $1d44efb04eab6ceb$var$skipWhitespace(line, index);\n            }\n            if (index < line.length) {\n                const rest = line.substring(index);\n                const inlineTagMatches = Array.from(rest.matchAll($1d44efb04eab6ceb$var$inlineTagRegex));\n                tokens.push(...$1d44efb04eab6ceb$var$buildInlineTokens(inlineTagMatches, rest, currentLine, currentCharacter + index));\n            }\n        }\n        currentLine++;\n        currentCharacter = 0;\n    }\n    if (tokens.length > 0 && tokens[tokens.length - 1].type === \"break\") return tokens.slice(0, -1);\n    return tokens;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$tokenize, \"tokenize\");\nfunction $1d44efb04eab6ceb$var$buildInlineTokens(tags, line, lineIndex, characterIndex) {\n    const tokens = [];\n    if (tags.length === 0) {\n        const start = $1d44efb04eab6ceb$var$Position.create(lineIndex, characterIndex);\n        const end = $1d44efb04eab6ceb$var$Position.create(lineIndex, characterIndex + line.length);\n        tokens.push({\n            type: \"text\",\n            content: line,\n            range: $1d44efb04eab6ceb$var$Range.create(start, end)\n        });\n    } else {\n        let lastIndex = 0;\n        for (const match of tags){\n            const matchIndex = match.index;\n            const startContent = line.substring(lastIndex, matchIndex);\n            if (startContent.length > 0) tokens.push({\n                type: \"text\",\n                content: line.substring(lastIndex, matchIndex),\n                range: $1d44efb04eab6ceb$var$Range.create($1d44efb04eab6ceb$var$Position.create(lineIndex, lastIndex + characterIndex), $1d44efb04eab6ceb$var$Position.create(lineIndex, matchIndex + characterIndex))\n            });\n            let offset = startContent.length + 1;\n            const tagName = match[1];\n            tokens.push({\n                type: \"inline-tag\",\n                content: tagName,\n                range: $1d44efb04eab6ceb$var$Range.create($1d44efb04eab6ceb$var$Position.create(lineIndex, lastIndex + offset + characterIndex), $1d44efb04eab6ceb$var$Position.create(lineIndex, lastIndex + offset + tagName.length + characterIndex))\n            });\n            offset += tagName.length;\n            if (match.length === 4) {\n                offset += match[2].length;\n                const value = match[3];\n                tokens.push({\n                    type: \"text\",\n                    content: value,\n                    range: $1d44efb04eab6ceb$var$Range.create($1d44efb04eab6ceb$var$Position.create(lineIndex, lastIndex + offset + characterIndex), $1d44efb04eab6ceb$var$Position.create(lineIndex, lastIndex + offset + value.length + characterIndex))\n                });\n            } else tokens.push({\n                type: \"text\",\n                content: \"\",\n                range: $1d44efb04eab6ceb$var$Range.create($1d44efb04eab6ceb$var$Position.create(lineIndex, lastIndex + offset + characterIndex), $1d44efb04eab6ceb$var$Position.create(lineIndex, lastIndex + offset + characterIndex))\n            });\n            lastIndex = matchIndex + match[0].length;\n        }\n        const endContent = line.substring(lastIndex);\n        if (endContent.length > 0) tokens.push({\n            type: \"text\",\n            content: endContent,\n            range: $1d44efb04eab6ceb$var$Range.create($1d44efb04eab6ceb$var$Position.create(lineIndex, lastIndex + characterIndex), $1d44efb04eab6ceb$var$Position.create(lineIndex, lastIndex + characterIndex + endContent.length))\n        });\n    }\n    return tokens;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$buildInlineTokens, \"buildInlineTokens\");\nvar $1d44efb04eab6ceb$var$nonWhitespaceRegex = /\\S/;\nvar $1d44efb04eab6ceb$var$whitespaceEndRegex = /\\s*$/;\nfunction $1d44efb04eab6ceb$var$skipWhitespace(line, index) {\n    const match = line.substring(index).match($1d44efb04eab6ceb$var$nonWhitespaceRegex);\n    if (match) return index + match.index;\n    else return line.length;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$skipWhitespace, \"skipWhitespace\");\nfunction $1d44efb04eab6ceb$var$lastCharacter(line) {\n    const match = line.match($1d44efb04eab6ceb$var$whitespaceEndRegex);\n    if (match && typeof match.index === \"number\") return match.index;\n    return void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$lastCharacter, \"lastCharacter\");\nfunction $1d44efb04eab6ceb$var$parseJSDocComment(context) {\n    var _a, _b, _c, _d;\n    const startPosition = $1d44efb04eab6ceb$var$Position.create(context.position.line, context.position.character);\n    if (context.tokens.length === 0) return new $1d44efb04eab6ceb$var$JSDocCommentImpl([], $1d44efb04eab6ceb$var$Range.create(startPosition, startPosition));\n    const elements = [];\n    while(context.index < context.tokens.length){\n        const element = $1d44efb04eab6ceb$var$parseJSDocElement(context, elements[elements.length - 1]);\n        if (element) elements.push(element);\n    }\n    const start = (_b = (_a = elements[0]) === null || _a === void 0 ? void 0 : _a.range.start) !== null && _b !== void 0 ? _b : startPosition;\n    const end = (_d = (_c = elements[elements.length - 1]) === null || _c === void 0 ? void 0 : _c.range.end) !== null && _d !== void 0 ? _d : startPosition;\n    return new $1d44efb04eab6ceb$var$JSDocCommentImpl(elements, $1d44efb04eab6ceb$var$Range.create(start, end));\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$parseJSDocComment, \"parseJSDocComment\");\nfunction $1d44efb04eab6ceb$var$parseJSDocElement(context, last) {\n    const next = context.tokens[context.index];\n    if (next.type === \"tag\") return $1d44efb04eab6ceb$var$parseJSDocTag(context, false);\n    else if (next.type === \"text\" || next.type === \"inline-tag\") return $1d44efb04eab6ceb$var$parseJSDocText(context);\n    else {\n        $1d44efb04eab6ceb$var$appendEmptyLine(next, last);\n        context.index++;\n        return void 0;\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$parseJSDocElement, \"parseJSDocElement\");\nfunction $1d44efb04eab6ceb$var$appendEmptyLine(token, element) {\n    if (element) {\n        const line = new $1d44efb04eab6ceb$var$JSDocLineImpl(\"\", token.range);\n        if (\"inlines\" in element) element.inlines.push(line);\n        else element.content.inlines.push(line);\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$appendEmptyLine, \"appendEmptyLine\");\nfunction $1d44efb04eab6ceb$var$parseJSDocText(context) {\n    let token = context.tokens[context.index];\n    const firstToken = token;\n    let lastToken = token;\n    const lines = [];\n    while(token && token.type !== \"break\" && token.type !== \"tag\"){\n        lines.push($1d44efb04eab6ceb$var$parseJSDocInline(context));\n        lastToken = token;\n        token = context.tokens[context.index];\n    }\n    return new $1d44efb04eab6ceb$var$JSDocTextImpl(lines, $1d44efb04eab6ceb$var$Range.create(firstToken.range.start, lastToken.range.end));\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$parseJSDocText, \"parseJSDocText\");\nfunction $1d44efb04eab6ceb$var$parseJSDocInline(context) {\n    const token = context.tokens[context.index];\n    if (token.type === \"inline-tag\") return $1d44efb04eab6ceb$var$parseJSDocTag(context, true);\n    else return $1d44efb04eab6ceb$var$parseJSDocLine(context);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$parseJSDocInline, \"parseJSDocInline\");\nfunction $1d44efb04eab6ceb$var$parseJSDocTag(context, inline) {\n    const tagToken = context.tokens[context.index++];\n    const name = tagToken.content.substring(1);\n    const nextToken = context.tokens[context.index];\n    if ((nextToken === null || nextToken === void 0 ? void 0 : nextToken.type) === \"text\") {\n        if (inline) {\n            const docLine = $1d44efb04eab6ceb$var$parseJSDocLine(context);\n            return new $1d44efb04eab6ceb$var$JSDocTagImpl(name, new $1d44efb04eab6ceb$var$JSDocTextImpl([\n                docLine\n            ], docLine.range), inline, $1d44efb04eab6ceb$var$Range.create(tagToken.range.start, docLine.range.end));\n        } else {\n            const textDoc = $1d44efb04eab6ceb$var$parseJSDocText(context);\n            return new $1d44efb04eab6ceb$var$JSDocTagImpl(name, textDoc, inline, $1d44efb04eab6ceb$var$Range.create(tagToken.range.start, textDoc.range.end));\n        }\n    } else {\n        const range = tagToken.range;\n        return new $1d44efb04eab6ceb$var$JSDocTagImpl(name, new $1d44efb04eab6ceb$var$JSDocTextImpl([], range), inline, range);\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$parseJSDocTag, \"parseJSDocTag\");\nfunction $1d44efb04eab6ceb$var$parseJSDocLine(context) {\n    const token = context.tokens[context.index++];\n    return new $1d44efb04eab6ceb$var$JSDocLineImpl(token.content, token.range);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$parseJSDocLine, \"parseJSDocLine\");\nfunction $1d44efb04eab6ceb$var$normalizeOptions(options) {\n    if (!options) return $1d44efb04eab6ceb$var$normalizeOptions({\n        start: \"/**\",\n        end: \"*/\",\n        line: \"*\"\n    });\n    const { start: start, end: end, line: line } = options;\n    return {\n        start: $1d44efb04eab6ceb$var$normalizeOption(start, true),\n        end: $1d44efb04eab6ceb$var$normalizeOption(end, false),\n        line: $1d44efb04eab6ceb$var$normalizeOption(line, true)\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$normalizeOptions, \"normalizeOptions\");\nfunction $1d44efb04eab6ceb$var$normalizeOption(option2, start) {\n    if (typeof option2 === \"string\" || typeof option2 === \"object\") {\n        const escaped = typeof option2 === \"string\" ? $1d44efb04eab6ceb$var$escapeRegExp(option2) : option2.source;\n        if (start) return new RegExp(`^\\\\s*${escaped}`);\n        else return new RegExp(`\\\\s*${escaped}\\\\s*$`);\n    } else return option2;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$normalizeOption, \"normalizeOption\");\nvar $1d44efb04eab6ceb$var$JSDocCommentImpl = class {\n    static{\n        (0, $7xxrv.__name)(this, \"JSDocCommentImpl\");\n    }\n    constructor(elements, range){\n        this.elements = elements;\n        this.range = range;\n    }\n    getTag(name) {\n        return this.getAllTags().find((e)=>e.name === name);\n    }\n    getTags(name) {\n        return this.getAllTags().filter((e)=>e.name === name);\n    }\n    getAllTags() {\n        return this.elements.filter((e)=>\"name\" in e);\n    }\n    toString() {\n        let value = \"\";\n        for (const element of this.elements)if (value.length === 0) value = element.toString();\n        else {\n            const text = element.toString();\n            value += $1d44efb04eab6ceb$var$fillNewlines(value) + text;\n        }\n        return value.trim();\n    }\n    toMarkdown(options) {\n        let value = \"\";\n        for (const element of this.elements)if (value.length === 0) value = element.toMarkdown(options);\n        else {\n            const text = element.toMarkdown(options);\n            value += $1d44efb04eab6ceb$var$fillNewlines(value) + text;\n        }\n        return value.trim();\n    }\n};\nvar $1d44efb04eab6ceb$var$JSDocTagImpl = class {\n    static{\n        (0, $7xxrv.__name)(this, \"JSDocTagImpl\");\n    }\n    constructor(name, content, inline, range){\n        this.name = name;\n        this.content = content;\n        this.inline = inline;\n        this.range = range;\n    }\n    toString() {\n        let text = `@${this.name}`;\n        const content = this.content.toString();\n        if (this.content.inlines.length === 1) text = `${text} ${content}`;\n        else if (this.content.inlines.length > 1) text = `${text}\n${content}`;\n        if (this.inline) return `{${text}}`;\n        else return text;\n    }\n    toMarkdown(options) {\n        var _a, _b;\n        return (_b = (_a = options === null || options === void 0 ? void 0 : options.renderTag) === null || _a === void 0 ? void 0 : _a.call(options, this)) !== null && _b !== void 0 ? _b : this.toMarkdownDefault(options);\n    }\n    toMarkdownDefault(options) {\n        const content = this.content.toMarkdown(options);\n        if (this.inline) {\n            const rendered = $1d44efb04eab6ceb$var$renderInlineTag(this.name, content, options !== null && options !== void 0 ? options : {});\n            if (typeof rendered === \"string\") return rendered;\n        }\n        let marker = \"\";\n        if ((options === null || options === void 0 ? void 0 : options.tag) === \"italic\" || (options === null || options === void 0 ? void 0 : options.tag) === void 0) marker = \"*\";\n        else if ((options === null || options === void 0 ? void 0 : options.tag) === \"bold\") marker = \"**\";\n        else if ((options === null || options === void 0 ? void 0 : options.tag) === \"bold-italic\") marker = \"***\";\n        let text = `${marker}@${this.name}${marker}`;\n        if (this.content.inlines.length === 1) text = `${text} \\u2014 ${content}`;\n        else if (this.content.inlines.length > 1) text = `${text}\n${content}`;\n        if (this.inline) return `{${text}}`;\n        else return text;\n    }\n};\nfunction $1d44efb04eab6ceb$var$renderInlineTag(tag, content, options) {\n    var _a, _b;\n    if (tag === \"linkplain\" || tag === \"linkcode\" || tag === \"link\") {\n        const index = content.indexOf(\" \");\n        let display = content;\n        if (index > 0) {\n            const displayStart = $1d44efb04eab6ceb$var$skipWhitespace(content, index);\n            display = content.substring(displayStart);\n            content = content.substring(0, index);\n        }\n        if (tag === \"linkcode\" || tag === \"link\" && options.link === \"code\") display = `\\`${display}\\``;\n        const renderedLink = (_b = (_a = options.renderLink) === null || _a === void 0 ? void 0 : _a.call(options, content, display)) !== null && _b !== void 0 ? _b : $1d44efb04eab6ceb$var$renderLinkDefault(content, display);\n        return renderedLink;\n    }\n    return void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$renderInlineTag, \"renderInlineTag\");\nfunction $1d44efb04eab6ceb$var$renderLinkDefault(content, display) {\n    try {\n        $1d44efb04eab6ceb$var$URI2.parse(content, true);\n        return `[${display}](${content})`;\n    } catch (_a) {\n        return content;\n    }\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$renderLinkDefault, \"renderLinkDefault\");\nvar $1d44efb04eab6ceb$var$JSDocTextImpl = class {\n    static{\n        (0, $7xxrv.__name)(this, \"JSDocTextImpl\");\n    }\n    constructor(lines, range){\n        this.inlines = lines;\n        this.range = range;\n    }\n    toString() {\n        let text = \"\";\n        for(let i = 0; i < this.inlines.length; i++){\n            const inline = this.inlines[i];\n            const next = this.inlines[i + 1];\n            text += inline.toString();\n            if (next && next.range.start.line > inline.range.start.line) text += \"\\n\";\n        }\n        return text;\n    }\n    toMarkdown(options) {\n        let text = \"\";\n        for(let i = 0; i < this.inlines.length; i++){\n            const inline = this.inlines[i];\n            const next = this.inlines[i + 1];\n            text += inline.toMarkdown(options);\n            if (next && next.range.start.line > inline.range.start.line) text += \"\\n\";\n        }\n        return text;\n    }\n};\nvar $1d44efb04eab6ceb$var$JSDocLineImpl = class {\n    static{\n        (0, $7xxrv.__name)(this, \"JSDocLineImpl\");\n    }\n    constructor(text, range){\n        this.text = text;\n        this.range = range;\n    }\n    toString() {\n        return this.text;\n    }\n    toMarkdown() {\n        return this.text;\n    }\n};\nfunction $1d44efb04eab6ceb$var$fillNewlines(text) {\n    if (text.endsWith(\"\\n\")) return \"\\n\";\n    else return \"\\n\\n\";\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$fillNewlines, \"fillNewlines\");\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/documentation/documentation-provider.js\nvar $1d44efb04eab6ceb$var$JSDocDocumentationProvider = class {\n    static{\n        (0, $7xxrv.__name)(this, \"JSDocDocumentationProvider\");\n    }\n    constructor(services){\n        this.indexManager = services.shared.workspace.IndexManager;\n        this.commentProvider = services.documentation.CommentProvider;\n    }\n    getDocumentation(node) {\n        const comment = this.commentProvider.getComment(node);\n        if (comment && $1d44efb04eab6ceb$var$isJSDoc(comment)) {\n            const parsedJSDoc = $1d44efb04eab6ceb$var$parseJSDoc(comment);\n            return parsedJSDoc.toMarkdown({\n                renderLink: /* @__PURE__ */ (0, $7xxrv.__name)((link, display)=>{\n                    return this.documentationLinkRenderer(node, link, display);\n                }, \"renderLink\"),\n                renderTag: /* @__PURE__ */ (0, $7xxrv.__name)((tag)=>{\n                    return this.documentationTagRenderer(node, tag);\n                }, \"renderTag\")\n            });\n        }\n        return void 0;\n    }\n    documentationLinkRenderer(node, name, display) {\n        var _a;\n        const description = (_a = this.findNameInPrecomputedScopes(node, name)) !== null && _a !== void 0 ? _a : this.findNameInGlobalScope(node, name);\n        if (description && description.nameSegment) {\n            const line = description.nameSegment.range.start.line + 1;\n            const character = description.nameSegment.range.start.character + 1;\n            const uri = description.documentUri.with({\n                fragment: `L${line},${character}`\n            });\n            return `[${display}](${uri.toString()})`;\n        } else return void 0;\n    }\n    documentationTagRenderer(_node, _tag) {\n        return void 0;\n    }\n    findNameInPrecomputedScopes(node, name) {\n        const document = $1d44efb04eab6ceb$var$getDocument(node);\n        const precomputed = document.precomputedScopes;\n        if (!precomputed) return void 0;\n        let currentNode = node;\n        do {\n            const allDescriptions = precomputed.get(currentNode);\n            const description = allDescriptions.find((e)=>e.name === name);\n            if (description) return description;\n            currentNode = currentNode.$container;\n        }while (currentNode);\n        return void 0;\n    }\n    findNameInGlobalScope(node, name) {\n        const description = this.indexManager.allElements().find((e)=>e.name === name);\n        return description;\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/documentation/comment-provider.js\nvar $1d44efb04eab6ceb$var$DefaultCommentProvider = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultCommentProvider\");\n    }\n    constructor(services){\n        this.grammarConfig = ()=>services.parser.GrammarConfig;\n    }\n    getComment(node) {\n        var _a;\n        if ($1d44efb04eab6ceb$var$isAstNodeWithComment(node)) return node.$comment;\n        return (_a = $1d44efb04eab6ceb$var$findCommentNode(node.$cstNode, this.grammarConfig().multilineCommentRules)) === null || _a === void 0 ? void 0 : _a.text;\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/event.js\nvar $1d44efb04eab6ceb$var$event_exports = {};\n(0, $7xxrv.__reExport)($1d44efb04eab6ceb$var$event_exports, (0, $7xxrv.__toESM)($1d44efb04eab6ceb$var$require_events(), 1));\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/parser/async-parser.js\nvar $1d44efb04eab6ceb$var$DefaultAsyncParser = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultAsyncParser\");\n    }\n    constructor(services){\n        this.syncParser = services.parser.LangiumParser;\n    }\n    parse(text) {\n        return Promise.resolve(this.syncParser.parse(text));\n    }\n};\nvar $1d44efb04eab6ceb$var$AbstractThreadedAsyncParser = class {\n    static{\n        (0, $7xxrv.__name)(this, \"AbstractThreadedAsyncParser\");\n    }\n    constructor(services){\n        this.threadCount = 8;\n        this.terminationDelay = 200;\n        this.workerPool = [];\n        this.queue = [];\n        this.hydrator = services.serializer.Hydrator;\n    }\n    initializeWorkers() {\n        while(this.workerPool.length < this.threadCount){\n            const worker = this.createWorker();\n            worker.onReady(()=>{\n                if (this.queue.length > 0) {\n                    const deferred = this.queue.shift();\n                    if (deferred) {\n                        worker.lock();\n                        deferred.resolve(worker);\n                    }\n                }\n            });\n            this.workerPool.push(worker);\n        }\n    }\n    async parse(text, cancelToken) {\n        const worker = await this.acquireParserWorker(cancelToken);\n        const deferred = new $1d44efb04eab6ceb$var$Deferred();\n        let timeout;\n        const cancellation = cancelToken.onCancellationRequested(()=>{\n            timeout = setTimeout(()=>{\n                this.terminateWorker(worker);\n            }, this.terminationDelay);\n        });\n        worker.parse(text).then((result)=>{\n            const hydrated = this.hydrator.hydrate(result);\n            deferred.resolve(hydrated);\n        }).catch((err)=>{\n            deferred.reject(err);\n        }).finally(()=>{\n            cancellation.dispose();\n            clearTimeout(timeout);\n        });\n        return deferred.promise;\n    }\n    terminateWorker(worker) {\n        worker.terminate();\n        const index = this.workerPool.indexOf(worker);\n        if (index >= 0) this.workerPool.splice(index, 1);\n    }\n    async acquireParserWorker(cancelToken) {\n        this.initializeWorkers();\n        for (const worker of this.workerPool)if (worker.ready) {\n            worker.lock();\n            return worker;\n        }\n        const deferred = new $1d44efb04eab6ceb$var$Deferred();\n        cancelToken.onCancellationRequested(()=>{\n            const index = this.queue.indexOf(deferred);\n            if (index >= 0) this.queue.splice(index, 1);\n            deferred.reject($1d44efb04eab6ceb$var$OperationCancelled);\n        });\n        this.queue.push(deferred);\n        return deferred.promise;\n    }\n};\nvar $1d44efb04eab6ceb$var$ParserWorker = class {\n    static{\n        (0, $7xxrv.__name)(this, \"ParserWorker\");\n    }\n    get ready() {\n        return this._ready;\n    }\n    get onReady() {\n        return this.onReadyEmitter.event;\n    }\n    constructor(sendMessage, onMessage, onError, terminate){\n        this.onReadyEmitter = new $1d44efb04eab6ceb$var$event_exports.Emitter();\n        this.deferred = new $1d44efb04eab6ceb$var$Deferred();\n        this._ready = true;\n        this._parsing = false;\n        this.sendMessage = sendMessage;\n        this._terminate = terminate;\n        onMessage((result)=>{\n            const parseResult = result;\n            this.deferred.resolve(parseResult);\n            this.unlock();\n        });\n        onError((error)=>{\n            this.deferred.reject(error);\n            this.unlock();\n        });\n    }\n    terminate() {\n        this.deferred.reject($1d44efb04eab6ceb$var$OperationCancelled);\n        this._terminate();\n    }\n    lock() {\n        this._ready = false;\n    }\n    unlock() {\n        this._parsing = false;\n        this._ready = true;\n        this.onReadyEmitter.fire();\n    }\n    parse(text) {\n        if (this._parsing) throw new Error(\"Parser worker is busy\");\n        this._parsing = true;\n        this.deferred = new $1d44efb04eab6ceb$var$Deferred();\n        this.sendMessage(text);\n        return this.deferred.promise;\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/workspace/workspace-lock.js\nvar $1d44efb04eab6ceb$var$DefaultWorkspaceLock = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultWorkspaceLock\");\n    }\n    constructor(){\n        this.previousTokenSource = new $1d44efb04eab6ceb$var$cancellation_exports.CancellationTokenSource();\n        this.writeQueue = [];\n        this.readQueue = [];\n        this.done = true;\n    }\n    write(action) {\n        this.cancelWrite();\n        const tokenSource = new $1d44efb04eab6ceb$var$cancellation_exports.CancellationTokenSource();\n        this.previousTokenSource = tokenSource;\n        return this.enqueue(this.writeQueue, action, tokenSource.token);\n    }\n    read(action) {\n        return this.enqueue(this.readQueue, action);\n    }\n    enqueue(queue, action, cancellationToken) {\n        const deferred = new $1d44efb04eab6ceb$var$Deferred();\n        const entry = {\n            action: action,\n            deferred: deferred,\n            cancellationToken: cancellationToken !== null && cancellationToken !== void 0 ? cancellationToken : $1d44efb04eab6ceb$var$cancellation_exports.CancellationToken.None\n        };\n        queue.push(entry);\n        this.performNextOperation();\n        return deferred.promise;\n    }\n    async performNextOperation() {\n        if (!this.done) return;\n        const entries = [];\n        if (this.writeQueue.length > 0) entries.push(this.writeQueue.shift());\n        else if (this.readQueue.length > 0) entries.push(...this.readQueue.splice(0, this.readQueue.length));\n        else return;\n        this.done = false;\n        await Promise.all(entries.map(async ({ action: action, deferred: deferred, cancellationToken: cancellationToken })=>{\n            try {\n                const result = await Promise.resolve().then(()=>action(cancellationToken));\n                deferred.resolve(result);\n            } catch (err) {\n                if ($1d44efb04eab6ceb$var$isOperationCancelled(err)) deferred.resolve(void 0);\n                else deferred.reject(err);\n            }\n        }));\n        this.done = true;\n        this.performNextOperation();\n    }\n    cancelWrite() {\n        this.previousTokenSource.cancel();\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/serializer/hydrator.js\nvar $1d44efb04eab6ceb$var$DefaultHydrator = class {\n    static{\n        (0, $7xxrv.__name)(this, \"DefaultHydrator\");\n    }\n    constructor(services){\n        this.grammarElementIdMap = new $1d44efb04eab6ceb$var$BiMap();\n        this.tokenTypeIdMap = new $1d44efb04eab6ceb$var$BiMap();\n        this.grammar = services.Grammar;\n        this.lexer = services.parser.Lexer;\n        this.linker = services.references.Linker;\n    }\n    dehydrate(result) {\n        return {\n            // We need to create shallow copies of the errors\n            // The original errors inherit from the `Error` class, which is not transferable across worker threads\n            lexerErrors: result.lexerErrors.map((e)=>Object.assign({}, e)),\n            parserErrors: result.parserErrors.map((e)=>Object.assign({}, e)),\n            value: this.dehydrateAstNode(result.value, this.createDehyrationContext(result.value))\n        };\n    }\n    createDehyrationContext(node) {\n        const astNodes = /* @__PURE__ */ new Map();\n        const cstNodes = /* @__PURE__ */ new Map();\n        for (const astNode of $1d44efb04eab6ceb$var$streamAst(node))astNodes.set(astNode, {});\n        if (node.$cstNode) for (const cstNode of $1d44efb04eab6ceb$var$streamCst(node.$cstNode))cstNodes.set(cstNode, {});\n        return {\n            astNodes: astNodes,\n            cstNodes: cstNodes\n        };\n    }\n    dehydrateAstNode(node, context) {\n        const obj = context.astNodes.get(node);\n        obj.$type = node.$type;\n        obj.$containerIndex = node.$containerIndex;\n        obj.$containerProperty = node.$containerProperty;\n        if (node.$cstNode !== void 0) obj.$cstNode = this.dehydrateCstNode(node.$cstNode, context);\n        for (const [name, value] of Object.entries(node)){\n            if (name.startsWith(\"$\")) continue;\n            if (Array.isArray(value)) {\n                const arr = [];\n                obj[name] = arr;\n                for (const item of value){\n                    if ($1d44efb04eab6ceb$var$isAstNode(item)) arr.push(this.dehydrateAstNode(item, context));\n                    else if ($1d44efb04eab6ceb$var$isReference(item)) arr.push(this.dehydrateReference(item, context));\n                    else arr.push(item);\n                }\n            } else if ($1d44efb04eab6ceb$var$isAstNode(value)) obj[name] = this.dehydrateAstNode(value, context);\n            else if ($1d44efb04eab6ceb$var$isReference(value)) obj[name] = this.dehydrateReference(value, context);\n            else if (value !== void 0) obj[name] = value;\n        }\n        return obj;\n    }\n    dehydrateReference(reference, context) {\n        const obj = {};\n        obj.$refText = reference.$refText;\n        if (reference.$refNode) obj.$refNode = context.cstNodes.get(reference.$refNode);\n        return obj;\n    }\n    dehydrateCstNode(node, context) {\n        const cstNode = context.cstNodes.get(node);\n        if ($1d44efb04eab6ceb$var$isRootCstNode(node)) cstNode.fullText = node.fullText;\n        else cstNode.grammarSource = this.getGrammarElementId(node.grammarSource);\n        cstNode.hidden = node.hidden;\n        cstNode.astNode = context.astNodes.get(node.astNode);\n        if ($1d44efb04eab6ceb$var$isCompositeCstNode(node)) cstNode.content = node.content.map((child)=>this.dehydrateCstNode(child, context));\n        else if ($1d44efb04eab6ceb$var$isLeafCstNode(node)) {\n            cstNode.tokenType = node.tokenType.name;\n            cstNode.offset = node.offset;\n            cstNode.length = node.length;\n            cstNode.startLine = node.range.start.line;\n            cstNode.startColumn = node.range.start.character;\n            cstNode.endLine = node.range.end.line;\n            cstNode.endColumn = node.range.end.character;\n        }\n        return cstNode;\n    }\n    hydrate(result) {\n        const node = result.value;\n        const context = this.createHydrationContext(node);\n        if (\"$cstNode\" in node) this.hydrateCstNode(node.$cstNode, context);\n        return {\n            lexerErrors: result.lexerErrors,\n            parserErrors: result.parserErrors,\n            value: this.hydrateAstNode(node, context)\n        };\n    }\n    createHydrationContext(node) {\n        const astNodes = /* @__PURE__ */ new Map();\n        const cstNodes = /* @__PURE__ */ new Map();\n        for (const astNode of $1d44efb04eab6ceb$var$streamAst(node))astNodes.set(astNode, {});\n        let root;\n        if (node.$cstNode) for (const cstNode of $1d44efb04eab6ceb$var$streamCst(node.$cstNode)){\n            let cst;\n            if (\"fullText\" in cstNode) {\n                cst = new $1d44efb04eab6ceb$var$RootCstNodeImpl(cstNode.fullText);\n                root = cst;\n            } else if (\"content\" in cstNode) cst = new $1d44efb04eab6ceb$var$CompositeCstNodeImpl();\n            else if (\"tokenType\" in cstNode) cst = this.hydrateCstLeafNode(cstNode);\n            if (cst) {\n                cstNodes.set(cstNode, cst);\n                cst.root = root;\n            }\n        }\n        return {\n            astNodes: astNodes,\n            cstNodes: cstNodes\n        };\n    }\n    hydrateAstNode(node, context) {\n        const astNode = context.astNodes.get(node);\n        astNode.$type = node.$type;\n        astNode.$containerIndex = node.$containerIndex;\n        astNode.$containerProperty = node.$containerProperty;\n        if (node.$cstNode) astNode.$cstNode = context.cstNodes.get(node.$cstNode);\n        for (const [name, value] of Object.entries(node)){\n            if (name.startsWith(\"$\")) continue;\n            if (Array.isArray(value)) {\n                const arr = [];\n                astNode[name] = arr;\n                for (const item of value){\n                    if ($1d44efb04eab6ceb$var$isAstNode(item)) arr.push(this.setParent(this.hydrateAstNode(item, context), astNode));\n                    else if ($1d44efb04eab6ceb$var$isReference(item)) arr.push(this.hydrateReference(item, astNode, name, context));\n                    else arr.push(item);\n                }\n            } else if ($1d44efb04eab6ceb$var$isAstNode(value)) astNode[name] = this.setParent(this.hydrateAstNode(value, context), astNode);\n            else if ($1d44efb04eab6ceb$var$isReference(value)) astNode[name] = this.hydrateReference(value, astNode, name, context);\n            else if (value !== void 0) astNode[name] = value;\n        }\n        return astNode;\n    }\n    setParent(node, parent) {\n        node.$container = parent;\n        return node;\n    }\n    hydrateReference(reference, node, name, context) {\n        return this.linker.buildReference(node, name, context.cstNodes.get(reference.$refNode), reference.$refText);\n    }\n    hydrateCstNode(cstNode, context, num = 0) {\n        const cstNodeObj = context.cstNodes.get(cstNode);\n        if (typeof cstNode.grammarSource === \"number\") cstNodeObj.grammarSource = this.getGrammarElement(cstNode.grammarSource);\n        cstNodeObj.astNode = context.astNodes.get(cstNode.astNode);\n        if ($1d44efb04eab6ceb$var$isCompositeCstNode(cstNodeObj)) for (const child of cstNode.content){\n            const hydrated = this.hydrateCstNode(child, context, num++);\n            cstNodeObj.content.push(hydrated);\n        }\n        return cstNodeObj;\n    }\n    hydrateCstLeafNode(cstNode) {\n        const tokenType = this.getTokenType(cstNode.tokenType);\n        const offset = cstNode.offset;\n        const length = cstNode.length;\n        const startLine = cstNode.startLine;\n        const startColumn = cstNode.startColumn;\n        const endLine = cstNode.endLine;\n        const endColumn = cstNode.endColumn;\n        const hidden = cstNode.hidden;\n        const node = new $1d44efb04eab6ceb$var$LeafCstNodeImpl(offset, length, {\n            start: {\n                line: startLine,\n                character: startColumn\n            },\n            end: {\n                line: endLine,\n                character: endColumn\n            }\n        }, tokenType, hidden);\n        return node;\n    }\n    getTokenType(name) {\n        return this.lexer.definition[name];\n    }\n    getGrammarElementId(node) {\n        if (this.grammarElementIdMap.size === 0) this.createGrammarElementIdMap();\n        return this.grammarElementIdMap.get(node);\n    }\n    getGrammarElement(id) {\n        if (this.grammarElementIdMap.size === 0) this.createGrammarElementIdMap();\n        const element = this.grammarElementIdMap.getKey(id);\n        if (element) return element;\n        else throw new Error(\"Invalid grammar element id: \" + id);\n    }\n    createGrammarElementIdMap() {\n        let id = 0;\n        for (const element of $1d44efb04eab6ceb$var$streamAst(this.grammar))if ($1d44efb04eab6ceb$var$isAbstractElement(element)) this.grammarElementIdMap.set(element, id++);\n    }\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/default-module.js\nfunction $1d44efb04eab6ceb$export$eab5a4b5adef815d(context) {\n    return {\n        documentation: {\n            CommentProvider: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>new $1d44efb04eab6ceb$var$DefaultCommentProvider(services), \"CommentProvider\"),\n            DocumentationProvider: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>new $1d44efb04eab6ceb$var$JSDocDocumentationProvider(services), \"DocumentationProvider\")\n        },\n        parser: {\n            AsyncParser: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>new $1d44efb04eab6ceb$var$DefaultAsyncParser(services), \"AsyncParser\"),\n            GrammarConfig: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>$1d44efb04eab6ceb$var$createGrammarConfig(services), \"GrammarConfig\"),\n            LangiumParser: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>$1d44efb04eab6ceb$var$createLangiumParser(services), \"LangiumParser\"),\n            CompletionParser: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>$1d44efb04eab6ceb$var$createCompletionParser(services), \"CompletionParser\"),\n            ValueConverter: /* @__PURE__ */ (0, $7xxrv.__name)(()=>new $1d44efb04eab6ceb$var$DefaultValueConverter(), \"ValueConverter\"),\n            TokenBuilder: /* @__PURE__ */ (0, $7xxrv.__name)(()=>new $1d44efb04eab6ceb$var$DefaultTokenBuilder(), \"TokenBuilder\"),\n            Lexer: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>new $1d44efb04eab6ceb$var$DefaultLexer(services), \"Lexer\"),\n            ParserErrorMessageProvider: /* @__PURE__ */ (0, $7xxrv.__name)(()=>new $1d44efb04eab6ceb$var$LangiumParserErrorMessageProvider(), \"ParserErrorMessageProvider\")\n        },\n        workspace: {\n            AstNodeLocator: /* @__PURE__ */ (0, $7xxrv.__name)(()=>new $1d44efb04eab6ceb$var$DefaultAstNodeLocator(), \"AstNodeLocator\"),\n            AstNodeDescriptionProvider: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>new $1d44efb04eab6ceb$var$DefaultAstNodeDescriptionProvider(services), \"AstNodeDescriptionProvider\"),\n            ReferenceDescriptionProvider: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>new $1d44efb04eab6ceb$var$DefaultReferenceDescriptionProvider(services), \"ReferenceDescriptionProvider\")\n        },\n        references: {\n            Linker: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>new $1d44efb04eab6ceb$var$DefaultLinker(services), \"Linker\"),\n            NameProvider: /* @__PURE__ */ (0, $7xxrv.__name)(()=>new $1d44efb04eab6ceb$var$DefaultNameProvider(), \"NameProvider\"),\n            ScopeProvider: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>new $1d44efb04eab6ceb$var$DefaultScopeProvider(services), \"ScopeProvider\"),\n            ScopeComputation: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>new $1d44efb04eab6ceb$var$DefaultScopeComputation(services), \"ScopeComputation\"),\n            References: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>new $1d44efb04eab6ceb$var$DefaultReferences(services), \"References\")\n        },\n        serializer: {\n            Hydrator: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>new $1d44efb04eab6ceb$var$DefaultHydrator(services), \"Hydrator\"),\n            JsonSerializer: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>new $1d44efb04eab6ceb$var$DefaultJsonSerializer(services), \"JsonSerializer\")\n        },\n        validation: {\n            DocumentValidator: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>new $1d44efb04eab6ceb$var$DefaultDocumentValidator(services), \"DocumentValidator\"),\n            ValidationRegistry: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>new $1d44efb04eab6ceb$var$ValidationRegistry(services), \"ValidationRegistry\")\n        },\n        shared: /* @__PURE__ */ (0, $7xxrv.__name)(()=>context.shared, \"shared\")\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$export$eab5a4b5adef815d, \"createDefaultCoreModule\");\nfunction $1d44efb04eab6ceb$export$dbab074a2a0a86aa(context) {\n    return {\n        ServiceRegistry: /* @__PURE__ */ (0, $7xxrv.__name)(()=>new $1d44efb04eab6ceb$var$DefaultServiceRegistry(), \"ServiceRegistry\"),\n        workspace: {\n            LangiumDocuments: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>new $1d44efb04eab6ceb$var$DefaultLangiumDocuments(services), \"LangiumDocuments\"),\n            LangiumDocumentFactory: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>new $1d44efb04eab6ceb$var$DefaultLangiumDocumentFactory(services), \"LangiumDocumentFactory\"),\n            DocumentBuilder: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>new $1d44efb04eab6ceb$var$DefaultDocumentBuilder(services), \"DocumentBuilder\"),\n            IndexManager: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>new $1d44efb04eab6ceb$var$DefaultIndexManager(services), \"IndexManager\"),\n            WorkspaceManager: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>new $1d44efb04eab6ceb$var$DefaultWorkspaceManager(services), \"WorkspaceManager\"),\n            FileSystemProvider: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>context.fileSystemProvider(services), \"FileSystemProvider\"),\n            WorkspaceLock: /* @__PURE__ */ (0, $7xxrv.__name)(()=>new $1d44efb04eab6ceb$var$DefaultWorkspaceLock(), \"WorkspaceLock\"),\n            ConfigurationProvider: /* @__PURE__ */ (0, $7xxrv.__name)((services)=>new $1d44efb04eab6ceb$var$DefaultConfigurationProvider(services), \"ConfigurationProvider\")\n        }\n    };\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$export$dbab074a2a0a86aa, \"createDefaultSharedCoreModule\");\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/dependency-injection.js\nvar $1d44efb04eab6ceb$var$Module;\n(function(Module2) {\n    Module2.merge = (m1, m2)=>$1d44efb04eab6ceb$var$_merge($1d44efb04eab6ceb$var$_merge({}, m1), m2);\n})($1d44efb04eab6ceb$var$Module || ($1d44efb04eab6ceb$var$Module = {}));\nfunction $1d44efb04eab6ceb$export$a976684a0efeb93f(module1, module2, module3, module4, module5, module6, module7, module8, module9) {\n    const module = [\n        module1,\n        module2,\n        module3,\n        module4,\n        module5,\n        module6,\n        module7,\n        module8,\n        module9\n    ].reduce($1d44efb04eab6ceb$var$_merge, {});\n    return $1d44efb04eab6ceb$var$_inject(module);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$export$a976684a0efeb93f, \"inject\");\nvar $1d44efb04eab6ceb$var$isProxy = Symbol(\"isProxy\");\nfunction $1d44efb04eab6ceb$var$eagerLoad(item) {\n    if (item && item[$1d44efb04eab6ceb$var$isProxy]) for (const value of Object.values(item))$1d44efb04eab6ceb$var$eagerLoad(value);\n    return item;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$eagerLoad, \"eagerLoad\");\nfunction $1d44efb04eab6ceb$var$_inject(module, injector) {\n    const proxy = new Proxy({}, {\n        deleteProperty: /* @__PURE__ */ (0, $7xxrv.__name)(()=>false, \"deleteProperty\"),\n        get: /* @__PURE__ */ (0, $7xxrv.__name)((obj, prop)=>$1d44efb04eab6ceb$var$_resolve(obj, prop, module, injector || proxy), \"get\"),\n        getOwnPropertyDescriptor: /* @__PURE__ */ (0, $7xxrv.__name)((obj, prop)=>($1d44efb04eab6ceb$var$_resolve(obj, prop, module, injector || proxy), Object.getOwnPropertyDescriptor(obj, prop)), \"getOwnPropertyDescriptor\"),\n        has: /* @__PURE__ */ (0, $7xxrv.__name)((_, prop)=>prop in module, \"has\"),\n        ownKeys: /* @__PURE__ */ (0, $7xxrv.__name)(()=>[\n                ...Reflect.ownKeys(module),\n                $1d44efb04eab6ceb$var$isProxy\n            ], \"ownKeys\")\n    });\n    proxy[$1d44efb04eab6ceb$var$isProxy] = true;\n    return proxy;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$_inject, \"_inject\");\nvar $1d44efb04eab6ceb$var$__requested__ = Symbol();\nfunction $1d44efb04eab6ceb$var$_resolve(obj, prop, module, injector) {\n    if (prop in obj) {\n        if (obj[prop] instanceof Error) throw new Error(\"Construction failure. Please make sure that your dependencies are constructable.\", {\n            cause: obj[prop]\n        });\n        if (obj[prop] === $1d44efb04eab6ceb$var$__requested__) throw new Error('Cycle detected. Please make \"' + String(prop) + '\" lazy. See https://langium.org/docs/configuration-services/#resolving-cyclic-dependencies');\n        return obj[prop];\n    } else if (prop in module) {\n        const value = module[prop];\n        obj[prop] = $1d44efb04eab6ceb$var$__requested__;\n        try {\n            obj[prop] = typeof value === \"function\" ? value(injector) : $1d44efb04eab6ceb$var$_inject(value, injector);\n        } catch (error) {\n            obj[prop] = error instanceof Error ? error : void 0;\n            throw error;\n        }\n        return obj[prop];\n    } else return void 0;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$_resolve, \"_resolve\");\nfunction $1d44efb04eab6ceb$var$_merge(target, source) {\n    if (source) {\n        for (const [key, value2] of Object.entries(source))if (value2 !== void 0) {\n            const value1 = target[key];\n            if (value1 !== null && value2 !== null && typeof value1 === \"object\" && typeof value2 === \"object\") target[key] = $1d44efb04eab6ceb$var$_merge(value1, value2);\n            else target[key] = value2;\n        }\n    }\n    return target;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$_merge, \"_merge\");\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/index.js\nvar $1d44efb04eab6ceb$var$utils_exports = {};\n(0, $7xxrv.__export)($1d44efb04eab6ceb$var$utils_exports, {\n    AstUtils: ()=>$1d44efb04eab6ceb$var$ast_utils_exports,\n    BiMap: ()=>$1d44efb04eab6ceb$var$BiMap,\n    Cancellation: ()=>$1d44efb04eab6ceb$var$cancellation_exports,\n    ContextCache: ()=>$1d44efb04eab6ceb$var$ContextCache,\n    CstUtils: ()=>$1d44efb04eab6ceb$var$cst_utils_exports,\n    DONE_RESULT: ()=>$1d44efb04eab6ceb$var$DONE_RESULT,\n    Deferred: ()=>$1d44efb04eab6ceb$var$Deferred,\n    Disposable: ()=>$1d44efb04eab6ceb$var$Disposable,\n    DisposableCache: ()=>$1d44efb04eab6ceb$var$DisposableCache,\n    DocumentCache: ()=>$1d44efb04eab6ceb$var$DocumentCache,\n    EMPTY_STREAM: ()=>$1d44efb04eab6ceb$var$EMPTY_STREAM,\n    ErrorWithLocation: ()=>$1d44efb04eab6ceb$var$ErrorWithLocation,\n    GrammarUtils: ()=>$1d44efb04eab6ceb$var$grammar_utils_exports,\n    MultiMap: ()=>$1d44efb04eab6ceb$var$MultiMap,\n    OperationCancelled: ()=>$1d44efb04eab6ceb$var$OperationCancelled,\n    Reduction: ()=>$1d44efb04eab6ceb$var$Reduction,\n    RegExpUtils: ()=>$1d44efb04eab6ceb$var$regexp_utils_exports,\n    SimpleCache: ()=>$1d44efb04eab6ceb$var$SimpleCache,\n    StreamImpl: ()=>$1d44efb04eab6ceb$var$StreamImpl,\n    TreeStreamImpl: ()=>$1d44efb04eab6ceb$var$TreeStreamImpl,\n    URI: ()=>$1d44efb04eab6ceb$var$URI2,\n    UriUtils: ()=>$1d44efb04eab6ceb$var$UriUtils,\n    WorkspaceCache: ()=>$1d44efb04eab6ceb$var$WorkspaceCache,\n    assertUnreachable: ()=>$1d44efb04eab6ceb$var$assertUnreachable,\n    delayNextTick: ()=>$1d44efb04eab6ceb$var$delayNextTick,\n    interruptAndCheck: ()=>$1d44efb04eab6ceb$var$interruptAndCheck,\n    isOperationCancelled: ()=>$1d44efb04eab6ceb$var$isOperationCancelled,\n    loadGrammarFromJson: ()=>$1d44efb04eab6ceb$var$loadGrammarFromJson,\n    setInterruptionPeriod: ()=>$1d44efb04eab6ceb$var$setInterruptionPeriod,\n    startCancelableOperation: ()=>$1d44efb04eab6ceb$var$startCancelableOperation,\n    stream: ()=>$1d44efb04eab6ceb$var$stream\n});\n(0, $7xxrv.__reExport)($1d44efb04eab6ceb$var$utils_exports, $1d44efb04eab6ceb$var$event_exports);\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/workspace/file-system-provider.js\nvar $1d44efb04eab6ceb$var$EmptyFileSystemProvider = class {\n    static{\n        (0, $7xxrv.__name)(this, \"EmptyFileSystemProvider\");\n    }\n    readFile() {\n        throw new Error(\"No file system is available.\");\n    }\n    async readDirectory() {\n        return [];\n    }\n};\nvar $1d44efb04eab6ceb$export$9849fb42e1532cce = {\n    fileSystemProvider: /* @__PURE__ */ (0, $7xxrv.__name)(()=>new $1d44efb04eab6ceb$var$EmptyFileSystemProvider(), \"fileSystemProvider\")\n};\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/grammar-loader.js\nvar $1d44efb04eab6ceb$var$minimalGrammarModule = {\n    Grammar: /* @__PURE__ */ (0, $7xxrv.__name)(()=>void 0, \"Grammar\"),\n    LanguageMetaData: /* @__PURE__ */ (0, $7xxrv.__name)(()=>({\n            caseInsensitive: false,\n            fileExtensions: [\n                \".langium\"\n            ],\n            languageId: \"langium\"\n        }), \"LanguageMetaData\")\n};\nvar $1d44efb04eab6ceb$var$minimalSharedGrammarModule = {\n    AstReflection: /* @__PURE__ */ (0, $7xxrv.__name)(()=>new $1d44efb04eab6ceb$var$LangiumGrammarAstReflection(), \"AstReflection\")\n};\nfunction $1d44efb04eab6ceb$var$createMinimalGrammarServices() {\n    const shared = $1d44efb04eab6ceb$export$a976684a0efeb93f($1d44efb04eab6ceb$export$dbab074a2a0a86aa($1d44efb04eab6ceb$export$9849fb42e1532cce), $1d44efb04eab6ceb$var$minimalSharedGrammarModule);\n    const grammar = $1d44efb04eab6ceb$export$a976684a0efeb93f($1d44efb04eab6ceb$export$eab5a4b5adef815d({\n        shared: shared\n    }), $1d44efb04eab6ceb$var$minimalGrammarModule);\n    shared.ServiceRegistry.register(grammar);\n    return grammar;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$createMinimalGrammarServices, \"createMinimalGrammarServices\");\nfunction $1d44efb04eab6ceb$var$loadGrammarFromJson(json) {\n    var _a;\n    const services = $1d44efb04eab6ceb$var$createMinimalGrammarServices();\n    const astNode = services.serializer.JsonSerializer.deserialize(json);\n    services.shared.workspace.LangiumDocumentFactory.fromModel(astNode, $1d44efb04eab6ceb$var$URI2.parse(`memory://${(_a = astNode.name) !== null && _a !== void 0 ? _a : \"grammar\"}.langium`));\n    return astNode;\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$loadGrammarFromJson, \"loadGrammarFromJson\");\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/index.js\n(0, $7xxrv.__reExport)($1d44efb04eab6ceb$export$d254ce2913df4585, $1d44efb04eab6ceb$var$utils_exports);\n// ../parser/dist/chunks/mermaid-parser.core/chunk-Y27MQZ3U.mjs\nvar $1d44efb04eab6ceb$var$__defProp = Object.defineProperty;\nvar $1d44efb04eab6ceb$export$3777ff4d263eb622 = /* @__PURE__ */ (0, $7xxrv.__name)((target, value)=>$1d44efb04eab6ceb$var$__defProp(target, \"name\", {\n        value: value,\n        configurable: true\n    }), \"__name\");\nvar $1d44efb04eab6ceb$var$Statement = \"Statement\";\nvar $1d44efb04eab6ceb$var$Architecture = \"Architecture\";\nfunction $1d44efb04eab6ceb$var$isArchitecture(item) {\n    return $1d44efb04eab6ceb$var$reflection2.isInstance(item, $1d44efb04eab6ceb$var$Architecture);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isArchitecture, \"isArchitecture\");\n$1d44efb04eab6ceb$export$3777ff4d263eb622($1d44efb04eab6ceb$var$isArchitecture, \"isArchitecture\");\nvar $1d44efb04eab6ceb$var$Branch = \"Branch\";\nfunction $1d44efb04eab6ceb$var$isBranch(item) {\n    return $1d44efb04eab6ceb$var$reflection2.isInstance(item, $1d44efb04eab6ceb$var$Branch);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isBranch, \"isBranch\");\n$1d44efb04eab6ceb$export$3777ff4d263eb622($1d44efb04eab6ceb$var$isBranch, \"isBranch\");\nvar $1d44efb04eab6ceb$var$Checkout = \"Checkout\";\nvar $1d44efb04eab6ceb$var$CherryPicking = \"CherryPicking\";\nvar $1d44efb04eab6ceb$var$Commit = \"Commit\";\nfunction $1d44efb04eab6ceb$var$isCommit(item) {\n    return $1d44efb04eab6ceb$var$reflection2.isInstance(item, $1d44efb04eab6ceb$var$Commit);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isCommit, \"isCommit\");\n$1d44efb04eab6ceb$export$3777ff4d263eb622($1d44efb04eab6ceb$var$isCommit, \"isCommit\");\nvar $1d44efb04eab6ceb$var$Common = \"Common\";\nfunction $1d44efb04eab6ceb$var$isCommon(item) {\n    return $1d44efb04eab6ceb$var$reflection2.isInstance(item, $1d44efb04eab6ceb$var$Common);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isCommon, \"isCommon\");\n$1d44efb04eab6ceb$export$3777ff4d263eb622($1d44efb04eab6ceb$var$isCommon, \"isCommon\");\nvar $1d44efb04eab6ceb$var$GitGraph = \"GitGraph\";\nfunction $1d44efb04eab6ceb$var$isGitGraph(item) {\n    return $1d44efb04eab6ceb$var$reflection2.isInstance(item, $1d44efb04eab6ceb$var$GitGraph);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isGitGraph, \"isGitGraph\");\n$1d44efb04eab6ceb$export$3777ff4d263eb622($1d44efb04eab6ceb$var$isGitGraph, \"isGitGraph\");\nvar $1d44efb04eab6ceb$var$Info = \"Info\";\nfunction $1d44efb04eab6ceb$var$isInfo(item) {\n    return $1d44efb04eab6ceb$var$reflection2.isInstance(item, $1d44efb04eab6ceb$var$Info);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isInfo, \"isInfo\");\n$1d44efb04eab6ceb$export$3777ff4d263eb622($1d44efb04eab6ceb$var$isInfo, \"isInfo\");\nvar $1d44efb04eab6ceb$var$Merge = \"Merge\";\nfunction $1d44efb04eab6ceb$var$isMerge(item) {\n    return $1d44efb04eab6ceb$var$reflection2.isInstance(item, $1d44efb04eab6ceb$var$Merge);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isMerge, \"isMerge\");\n$1d44efb04eab6ceb$export$3777ff4d263eb622($1d44efb04eab6ceb$var$isMerge, \"isMerge\");\nvar $1d44efb04eab6ceb$var$Packet = \"Packet\";\nfunction $1d44efb04eab6ceb$var$isPacket(item) {\n    return $1d44efb04eab6ceb$var$reflection2.isInstance(item, $1d44efb04eab6ceb$var$Packet);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isPacket, \"isPacket\");\n$1d44efb04eab6ceb$export$3777ff4d263eb622($1d44efb04eab6ceb$var$isPacket, \"isPacket\");\nvar $1d44efb04eab6ceb$var$PacketBlock = \"PacketBlock\";\nfunction $1d44efb04eab6ceb$var$isPacketBlock(item) {\n    return $1d44efb04eab6ceb$var$reflection2.isInstance(item, $1d44efb04eab6ceb$var$PacketBlock);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isPacketBlock, \"isPacketBlock\");\n$1d44efb04eab6ceb$export$3777ff4d263eb622($1d44efb04eab6ceb$var$isPacketBlock, \"isPacketBlock\");\nvar $1d44efb04eab6ceb$var$Pie = \"Pie\";\nfunction $1d44efb04eab6ceb$var$isPie(item) {\n    return $1d44efb04eab6ceb$var$reflection2.isInstance(item, $1d44efb04eab6ceb$var$Pie);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isPie, \"isPie\");\n$1d44efb04eab6ceb$export$3777ff4d263eb622($1d44efb04eab6ceb$var$isPie, \"isPie\");\nvar $1d44efb04eab6ceb$var$PieSection = \"PieSection\";\nfunction $1d44efb04eab6ceb$var$isPieSection(item) {\n    return $1d44efb04eab6ceb$var$reflection2.isInstance(item, $1d44efb04eab6ceb$var$PieSection);\n}\n(0, $7xxrv.__name)($1d44efb04eab6ceb$var$isPieSection, \"isPieSection\");\n$1d44efb04eab6ceb$export$3777ff4d263eb622($1d44efb04eab6ceb$var$isPieSection, \"isPieSection\");\nvar $1d44efb04eab6ceb$var$Direction = \"Direction\";\nvar $1d44efb04eab6ceb$var$MermaidAstReflection = class extends $1d44efb04eab6ceb$var$AbstractAstReflection {\n    static{\n        (0, $7xxrv.__name)(this, \"MermaidAstReflection\");\n    }\n    static{\n        $1d44efb04eab6ceb$export$3777ff4d263eb622(this, \"MermaidAstReflection\");\n    }\n    getAllTypes() {\n        return [\n            \"Architecture\",\n            \"Branch\",\n            \"Checkout\",\n            \"CherryPicking\",\n            \"Commit\",\n            \"Common\",\n            \"Direction\",\n            \"Edge\",\n            \"GitGraph\",\n            \"Group\",\n            \"Info\",\n            \"Junction\",\n            \"Merge\",\n            \"Packet\",\n            \"PacketBlock\",\n            \"Pie\",\n            \"PieSection\",\n            \"Service\",\n            \"Statement\"\n        ];\n    }\n    computeIsSubtype(subtype, supertype) {\n        switch(subtype){\n            case $1d44efb04eab6ceb$var$Branch:\n            case $1d44efb04eab6ceb$var$Checkout:\n            case $1d44efb04eab6ceb$var$CherryPicking:\n            case $1d44efb04eab6ceb$var$Commit:\n            case $1d44efb04eab6ceb$var$Merge:\n                return this.isSubtype($1d44efb04eab6ceb$var$Statement, supertype);\n            case $1d44efb04eab6ceb$var$Direction:\n                return this.isSubtype($1d44efb04eab6ceb$var$GitGraph, supertype);\n            default:\n                return false;\n        }\n    }\n    getReferenceType(refInfo) {\n        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n        referenceId;\n        throw new Error(`${referenceId} is not a valid reference id.`);\n    }\n    getTypeMetaData(type) {\n        switch(type){\n            case \"Architecture\":\n                return {\n                    name: \"Architecture\",\n                    properties: [\n                        {\n                            name: \"accDescr\"\n                        },\n                        {\n                            name: \"accTitle\"\n                        },\n                        {\n                            name: \"edges\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"groups\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"junctions\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"services\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"title\"\n                        }\n                    ]\n                };\n            case \"Branch\":\n                return {\n                    name: \"Branch\",\n                    properties: [\n                        {\n                            name: \"name\"\n                        },\n                        {\n                            name: \"order\"\n                        }\n                    ]\n                };\n            case \"Checkout\":\n                return {\n                    name: \"Checkout\",\n                    properties: [\n                        {\n                            name: \"branch\"\n                        }\n                    ]\n                };\n            case \"CherryPicking\":\n                return {\n                    name: \"CherryPicking\",\n                    properties: [\n                        {\n                            name: \"id\"\n                        },\n                        {\n                            name: \"parent\"\n                        },\n                        {\n                            name: \"tags\",\n                            defaultValue: []\n                        }\n                    ]\n                };\n            case \"Commit\":\n                return {\n                    name: \"Commit\",\n                    properties: [\n                        {\n                            name: \"id\"\n                        },\n                        {\n                            name: \"message\"\n                        },\n                        {\n                            name: \"tags\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"type\"\n                        }\n                    ]\n                };\n            case \"Common\":\n                return {\n                    name: \"Common\",\n                    properties: [\n                        {\n                            name: \"accDescr\"\n                        },\n                        {\n                            name: \"accTitle\"\n                        },\n                        {\n                            name: \"title\"\n                        }\n                    ]\n                };\n            case \"Edge\":\n                return {\n                    name: \"Edge\",\n                    properties: [\n                        {\n                            name: \"lhsDir\"\n                        },\n                        {\n                            name: \"lhsGroup\",\n                            defaultValue: false\n                        },\n                        {\n                            name: \"lhsId\"\n                        },\n                        {\n                            name: \"lhsInto\",\n                            defaultValue: false\n                        },\n                        {\n                            name: \"rhsDir\"\n                        },\n                        {\n                            name: \"rhsGroup\",\n                            defaultValue: false\n                        },\n                        {\n                            name: \"rhsId\"\n                        },\n                        {\n                            name: \"rhsInto\",\n                            defaultValue: false\n                        },\n                        {\n                            name: \"title\"\n                        }\n                    ]\n                };\n            case \"GitGraph\":\n                return {\n                    name: \"GitGraph\",\n                    properties: [\n                        {\n                            name: \"accDescr\"\n                        },\n                        {\n                            name: \"accTitle\"\n                        },\n                        {\n                            name: \"statements\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"title\"\n                        }\n                    ]\n                };\n            case \"Group\":\n                return {\n                    name: \"Group\",\n                    properties: [\n                        {\n                            name: \"icon\"\n                        },\n                        {\n                            name: \"id\"\n                        },\n                        {\n                            name: \"in\"\n                        },\n                        {\n                            name: \"title\"\n                        }\n                    ]\n                };\n            case \"Info\":\n                return {\n                    name: \"Info\",\n                    properties: [\n                        {\n                            name: \"accDescr\"\n                        },\n                        {\n                            name: \"accTitle\"\n                        },\n                        {\n                            name: \"title\"\n                        }\n                    ]\n                };\n            case \"Junction\":\n                return {\n                    name: \"Junction\",\n                    properties: [\n                        {\n                            name: \"id\"\n                        },\n                        {\n                            name: \"in\"\n                        }\n                    ]\n                };\n            case \"Merge\":\n                return {\n                    name: \"Merge\",\n                    properties: [\n                        {\n                            name: \"branch\"\n                        },\n                        {\n                            name: \"id\"\n                        },\n                        {\n                            name: \"tags\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"type\"\n                        }\n                    ]\n                };\n            case \"Packet\":\n                return {\n                    name: \"Packet\",\n                    properties: [\n                        {\n                            name: \"accDescr\"\n                        },\n                        {\n                            name: \"accTitle\"\n                        },\n                        {\n                            name: \"blocks\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"title\"\n                        }\n                    ]\n                };\n            case \"PacketBlock\":\n                return {\n                    name: \"PacketBlock\",\n                    properties: [\n                        {\n                            name: \"end\"\n                        },\n                        {\n                            name: \"label\"\n                        },\n                        {\n                            name: \"start\"\n                        }\n                    ]\n                };\n            case \"Pie\":\n                return {\n                    name: \"Pie\",\n                    properties: [\n                        {\n                            name: \"accDescr\"\n                        },\n                        {\n                            name: \"accTitle\"\n                        },\n                        {\n                            name: \"sections\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"showData\",\n                            defaultValue: false\n                        },\n                        {\n                            name: \"title\"\n                        }\n                    ]\n                };\n            case \"PieSection\":\n                return {\n                    name: \"PieSection\",\n                    properties: [\n                        {\n                            name: \"label\"\n                        },\n                        {\n                            name: \"value\"\n                        }\n                    ]\n                };\n            case \"Service\":\n                return {\n                    name: \"Service\",\n                    properties: [\n                        {\n                            name: \"icon\"\n                        },\n                        {\n                            name: \"iconText\"\n                        },\n                        {\n                            name: \"id\"\n                        },\n                        {\n                            name: \"in\"\n                        },\n                        {\n                            name: \"title\"\n                        }\n                    ]\n                };\n            case \"Direction\":\n                return {\n                    name: \"Direction\",\n                    properties: [\n                        {\n                            name: \"accDescr\"\n                        },\n                        {\n                            name: \"accTitle\"\n                        },\n                        {\n                            name: \"dir\"\n                        },\n                        {\n                            name: \"statements\",\n                            defaultValue: []\n                        },\n                        {\n                            name: \"title\"\n                        }\n                    ]\n                };\n            default:\n                return {\n                    name: type,\n                    properties: []\n                };\n        }\n    }\n};\nvar $1d44efb04eab6ceb$var$reflection2 = new $1d44efb04eab6ceb$var$MermaidAstReflection();\nvar $1d44efb04eab6ceb$var$loadedInfoGrammar;\nvar $1d44efb04eab6ceb$var$InfoGrammar = /* @__PURE__ */ $1d44efb04eab6ceb$export$3777ff4d263eb622(()=>$1d44efb04eab6ceb$var$loadedInfoGrammar ?? ($1d44efb04eab6ceb$var$loadedInfoGrammar = $1d44efb04eab6ceb$var$loadGrammarFromJson('{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Info\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"name\":\"Info\",\"entry\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"info\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"showInfo\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"*\"}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"TitleAndAccessibilities\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"EOL\",\"fragment\":true,\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}')), \"InfoGrammar\");\nvar $1d44efb04eab6ceb$var$loadedPacketGrammar;\nvar $1d44efb04eab6ceb$var$PacketGrammar = /* @__PURE__ */ $1d44efb04eab6ceb$export$3777ff4d263eb622(()=>$1d44efb04eab6ceb$var$loadedPacketGrammar ?? ($1d44efb04eab6ceb$var$loadedPacketGrammar = $1d44efb04eab6ceb$var$loadGrammarFromJson(`{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Packet\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"name\":\"Packet\",\"entry\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"packet-beta\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"blocks\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"Assignment\",\"feature\":\"blocks\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"+\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"PacketBlock\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"start\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"-\"},{\"$type\":\"Assignment\",\"feature\":\"end\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"label\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"INT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/0|[1-9][0-9]*/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]*\\\\\"|'[^']*'/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"name\":\"TitleAndAccessibilities\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"EOL\",\"fragment\":true,\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}`)), \"PacketGrammar\");\nvar $1d44efb04eab6ceb$var$loadedPieGrammar;\nvar $1d44efb04eab6ceb$var$PieGrammar = /* @__PURE__ */ $1d44efb04eab6ceb$export$3777ff4d263eb622(()=>$1d44efb04eab6ceb$var$loadedPieGrammar ?? ($1d44efb04eab6ceb$var$loadedPieGrammar = $1d44efb04eab6ceb$var$loadGrammarFromJson('{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Pie\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"name\":\"Pie\",\"entry\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"pie\"},{\"$type\":\"Assignment\",\"feature\":\"showData\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"showData\"},\"cardinality\":\"?\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"sections\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"Assignment\",\"feature\":\"sections\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"+\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"PieSection\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"label\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"PIE_SECTION_LABEL\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]+\\\\\"/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"PIE_SECTION_VALUE\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/(0|[1-9][0-9]*)(\\\\\\\\.[0-9]+)?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"name\":\"TitleAndAccessibilities\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"EOL\",\"fragment\":true,\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}')), \"PieGrammar\");\nvar $1d44efb04eab6ceb$var$loadedArchitectureGrammar;\nvar $1d44efb04eab6ceb$var$ArchitectureGrammar = /* @__PURE__ */ $1d44efb04eab6ceb$export$3777ff4d263eb622(()=>$1d44efb04eab6ceb$var$loadedArchitectureGrammar ?? ($1d44efb04eab6ceb$var$loadedArchitectureGrammar = $1d44efb04eab6ceb$var$loadGrammarFromJson('{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Architecture\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"name\":\"Architecture\",\"entry\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"architecture-beta\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[],\"cardinality\":\"*\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Statement\",\"fragment\":true,\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"groups\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"services\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"junctions\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"edges\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"LeftPort\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"lhsDir\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"RightPort\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"rhsDir\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\":\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Arrow\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"lhsInto\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"--\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"-\"},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\"-\"}]}]},{\"$type\":\"Assignment\",\"feature\":\"rhsInto\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Group\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"group\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"icon\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"in\"},{\"$type\":\"Assignment\",\"feature\":\"in\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Service\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"service\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"iconText\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"icon\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"in\"},{\"$type\":\"Assignment\",\"feature\":\"in\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Junction\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"junction\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"in\"},{\"$type\":\"Assignment\",\"feature\":\"in\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Edge\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"lhsId\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"lhsGroup\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"rhsId\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"rhsGroup\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARROW_DIRECTION\",\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"L\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"R\"}}]},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"T\"}}]},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"B\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_ID\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\w]+/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_TEXT_ICON\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\(\\\\\"[^\\\\\"]+\\\\\"\\\\\\\\)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_ICON\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\([\\\\\\\\w-:]+\\\\\\\\)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\[[\\\\\\\\w ]+\\\\\\\\]/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARROW_GROUP\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\{group\\\\\\\\}/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARROW_INTO\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/<|>/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"name\":\"TitleAndAccessibilities\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@21\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"EOL\",\"fragment\":true,\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}')), \"ArchitectureGrammar\");\nvar $1d44efb04eab6ceb$var$loadedGitGraphGrammar;\nvar $1d44efb04eab6ceb$var$GitGraphGrammar = /* @__PURE__ */ $1d44efb04eab6ceb$export$3777ff4d263eb622(()=>$1d44efb04eab6ceb$var$loadedGitGraphGrammar ?? ($1d44efb04eab6ceb$var$loadedGitGraphGrammar = $1d44efb04eab6ceb$var$loadGrammarFromJson(`{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"GitGraph\",\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"rules\":[{\"$type\":\"ParserRule\",\"name\":\"TitleAndAccessibilities\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"EOL\",\"fragment\":true,\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false},{\"$type\":\"ParserRule\",\"name\":\"GitGraph\",\"entry\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"gitGraph\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"gitGraph\"},{\"$type\":\"Keyword\",\"value\":\":\"}]},{\"$type\":\"Keyword\",\"value\":\"gitGraph:\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"gitGraph\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]},{\"$type\":\"Keyword\",\"value\":\":\"}]}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@0\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"statements\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Statement\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Direction\",\"definition\":{\"$type\":\"Assignment\",\"feature\":\"dir\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"LR\"},{\"$type\":\"Keyword\",\"value\":\"TB\"},{\"$type\":\"Keyword\",\"value\":\"BT\"}]}},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Commit\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"commit\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"id:\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"msg:\",\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"message\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"tag:\"},{\"$type\":\"Assignment\",\"feature\":\"tags\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"type:\"},{\"$type\":\"Assignment\",\"feature\":\"type\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"NORMAL\"},{\"$type\":\"Keyword\",\"value\":\"REVERSE\"},{\"$type\":\"Keyword\",\"value\":\"HIGHLIGHT\"}]}}]}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Branch\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"branch\"},{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"order:\"},{\"$type\":\"Assignment\",\"feature\":\"order\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Merge\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"merge\"},{\"$type\":\"Assignment\",\"feature\":\"branch\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}]}},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"id:\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"tag:\"},{\"$type\":\"Assignment\",\"feature\":\"tags\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"type:\"},{\"$type\":\"Assignment\",\"feature\":\"type\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"NORMAL\"},{\"$type\":\"Keyword\",\"value\":\"REVERSE\"},{\"$type\":\"Keyword\",\"value\":\"HIGHLIGHT\"}]}}]}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Checkout\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"checkout\"},{\"$type\":\"Keyword\",\"value\":\"switch\"}]},{\"$type\":\"Assignment\",\"feature\":\"branch\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"CherryPicking\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"cherry-pick\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"id:\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"tag:\"},{\"$type\":\"Assignment\",\"feature\":\"tags\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"parent:\"},{\"$type\":\"Assignment\",\"feature\":\"parent\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"INT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[0-9]+(?=\\\\\\\\s)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ID\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\w([-\\\\\\\\./\\\\\\\\w]*[-\\\\\\\\w])?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]*\\\\\"|'[^']*'/\"},\"fragment\":false,\"hidden\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"imports\":[],\"types\":[],\"usedGrammars\":[]}`)), \"GitGraphGrammar\");\nvar $1d44efb04eab6ceb$var$InfoLanguageMetaData = {\n    languageId: \"info\",\n    fileExtensions: [\n        \".mmd\",\n        \".mermaid\"\n    ],\n    caseInsensitive: false\n};\nvar $1d44efb04eab6ceb$var$PacketLanguageMetaData = {\n    languageId: \"packet\",\n    fileExtensions: [\n        \".mmd\",\n        \".mermaid\"\n    ],\n    caseInsensitive: false\n};\nvar $1d44efb04eab6ceb$var$PieLanguageMetaData = {\n    languageId: \"pie\",\n    fileExtensions: [\n        \".mmd\",\n        \".mermaid\"\n    ],\n    caseInsensitive: false\n};\nvar $1d44efb04eab6ceb$var$ArchitectureLanguageMetaData = {\n    languageId: \"architecture\",\n    fileExtensions: [\n        \".mmd\",\n        \".mermaid\"\n    ],\n    caseInsensitive: false\n};\nvar $1d44efb04eab6ceb$var$GitGraphLanguageMetaData = {\n    languageId: \"gitGraph\",\n    fileExtensions: [\n        \".mmd\",\n        \".mermaid\"\n    ],\n    caseInsensitive: false\n};\nvar $1d44efb04eab6ceb$export$7b9033c24b3bcb4e = {\n    AstReflection: /* @__PURE__ */ $1d44efb04eab6ceb$export$3777ff4d263eb622(()=>new $1d44efb04eab6ceb$var$MermaidAstReflection(), \"AstReflection\")\n};\nvar $1d44efb04eab6ceb$export$e4b0bc98a20a633a = {\n    Grammar: /* @__PURE__ */ $1d44efb04eab6ceb$export$3777ff4d263eb622(()=>$1d44efb04eab6ceb$var$InfoGrammar(), \"Grammar\"),\n    LanguageMetaData: /* @__PURE__ */ $1d44efb04eab6ceb$export$3777ff4d263eb622(()=>$1d44efb04eab6ceb$var$InfoLanguageMetaData, \"LanguageMetaData\"),\n    parser: {}\n};\nvar $1d44efb04eab6ceb$export$d28586600dc40d43 = {\n    Grammar: /* @__PURE__ */ $1d44efb04eab6ceb$export$3777ff4d263eb622(()=>$1d44efb04eab6ceb$var$PacketGrammar(), \"Grammar\"),\n    LanguageMetaData: /* @__PURE__ */ $1d44efb04eab6ceb$export$3777ff4d263eb622(()=>$1d44efb04eab6ceb$var$PacketLanguageMetaData, \"LanguageMetaData\"),\n    parser: {}\n};\nvar $1d44efb04eab6ceb$export$9a9f13da65008281 = {\n    Grammar: /* @__PURE__ */ $1d44efb04eab6ceb$export$3777ff4d263eb622(()=>$1d44efb04eab6ceb$var$PieGrammar(), \"Grammar\"),\n    LanguageMetaData: /* @__PURE__ */ $1d44efb04eab6ceb$export$3777ff4d263eb622(()=>$1d44efb04eab6ceb$var$PieLanguageMetaData, \"LanguageMetaData\"),\n    parser: {}\n};\nvar $1d44efb04eab6ceb$export$28acc4e42f5f4855 = {\n    Grammar: /* @__PURE__ */ $1d44efb04eab6ceb$export$3777ff4d263eb622(()=>$1d44efb04eab6ceb$var$ArchitectureGrammar(), \"Grammar\"),\n    LanguageMetaData: /* @__PURE__ */ $1d44efb04eab6ceb$export$3777ff4d263eb622(()=>$1d44efb04eab6ceb$var$ArchitectureLanguageMetaData, \"LanguageMetaData\"),\n    parser: {}\n};\nvar $1d44efb04eab6ceb$export$3805a3057b70f628 = {\n    Grammar: /* @__PURE__ */ $1d44efb04eab6ceb$export$3777ff4d263eb622(()=>$1d44efb04eab6ceb$var$GitGraphGrammar(), \"Grammar\"),\n    LanguageMetaData: /* @__PURE__ */ $1d44efb04eab6ceb$export$3777ff4d263eb622(()=>$1d44efb04eab6ceb$var$GitGraphLanguageMetaData, \"LanguageMetaData\"),\n    parser: {}\n};\nvar $1d44efb04eab6ceb$var$accessibilityDescrRegex = /accDescr(?:[\\t ]*:([^\\n\\r]*)|\\s*{([^}]*)})/;\nvar $1d44efb04eab6ceb$var$accessibilityTitleRegex = /accTitle[\\t ]*:([^\\n\\r]*)/;\nvar $1d44efb04eab6ceb$var$titleRegex = /title([\\t ][^\\n\\r]*|)/;\nvar $1d44efb04eab6ceb$var$rulesRegexes = {\n    ACC_DESCR: $1d44efb04eab6ceb$var$accessibilityDescrRegex,\n    ACC_TITLE: $1d44efb04eab6ceb$var$accessibilityTitleRegex,\n    TITLE: $1d44efb04eab6ceb$var$titleRegex\n};\nvar $1d44efb04eab6ceb$export$6024982db2edb064 = class extends $1d44efb04eab6ceb$var$DefaultValueConverter {\n    static{\n        (0, $7xxrv.__name)(this, \"AbstractMermaidValueConverter\");\n    }\n    static{\n        $1d44efb04eab6ceb$export$3777ff4d263eb622(this, \"AbstractMermaidValueConverter\");\n    }\n    runConverter(rule, input, cstNode) {\n        let value = this.runCommonConverter(rule, input, cstNode);\n        if (value === void 0) value = this.runCustomConverter(rule, input, cstNode);\n        if (value === void 0) return super.runConverter(rule, input, cstNode);\n        return value;\n    }\n    runCommonConverter(rule, input, _cstNode) {\n        const regex = $1d44efb04eab6ceb$var$rulesRegexes[rule.name];\n        if (regex === void 0) return void 0;\n        const match = regex.exec(input);\n        if (match === null) return void 0;\n        if (match[1] !== void 0) return match[1].trim().replace(/[\\t ]{2,}/gm, \" \");\n        if (match[2] !== void 0) return match[2].replace(/^\\s*/gm, \"\").replace(/\\s+$/gm, \"\").replace(/[\\t ]{2,}/gm, \" \").replace(/[\\n\\r]{2,}/gm, \"\\n\");\n        return void 0;\n    }\n};\nvar $1d44efb04eab6ceb$export$5814ff0710a44fb8 = class extends $1d44efb04eab6ceb$export$6024982db2edb064 {\n    static{\n        (0, $7xxrv.__name)(this, \"CommonValueConverter\");\n    }\n    static{\n        $1d44efb04eab6ceb$export$3777ff4d263eb622(this, \"CommonValueConverter\");\n    }\n    runCustomConverter(_rule, _input, _cstNode) {\n        return void 0;\n    }\n};\nvar $1d44efb04eab6ceb$export$a487a80f9ea1e74e = class extends $1d44efb04eab6ceb$var$DefaultTokenBuilder {\n    static{\n        (0, $7xxrv.__name)(this, \"AbstractMermaidTokenBuilder\");\n    }\n    static{\n        $1d44efb04eab6ceb$export$3777ff4d263eb622(this, \"AbstractMermaidTokenBuilder\");\n    }\n    constructor(keywords){\n        super();\n        this.keywords = new Set(keywords);\n    }\n    buildKeywordTokens(rules, terminalTokens, options) {\n        const tokenTypes = super.buildKeywordTokens(rules, terminalTokens, options);\n        tokenTypes.forEach((tokenType)=>{\n            if (this.keywords.has(tokenType.name) && tokenType.PATTERN !== void 0) tokenType.PATTERN = new RegExp(tokenType.PATTERN.toString() + \"(?:(?=%%)|(?!\\\\S))\");\n        });\n        return tokenTypes;\n    }\n};\nvar $1d44efb04eab6ceb$var$CommonTokenBuilder = class extends $1d44efb04eab6ceb$export$a487a80f9ea1e74e {\n    static{\n        (0, $7xxrv.__name)(this, \"CommonTokenBuilder\");\n    }\n    static{\n        $1d44efb04eab6ceb$export$3777ff4d263eb622(this, \"CommonTokenBuilder\");\n    }\n};\n\n});\n\nparcelRegister(\"3nMuO\", function(module, exports) {\n\nvar $Gr8vk = parcelRequire(\"Gr8vk\");\nmodule.exports = $Gr8vk(\"8keGE\").then(()=>parcelRequire('djlbY'));\n\n});\nparcelRegister(\"Gr8vk\", function(module, exports) {\n\"use strict\";\n\nfunction $07f8f9093a769793$var$load(id) {\n    // eslint-disable-next-line no-undef\n    return import((parcelRequire(\"27Lyk\")).resolve(id));\n}\nmodule.exports = $07f8f9093a769793$var$load;\n\n});\nparcelRegister(\"27Lyk\", function(module, exports) {\n\n$parcel$export(module.exports, \"register\", () => $18c11f3350a906ea$export$6503ec6e8aabbaf, (v) => $18c11f3350a906ea$export$6503ec6e8aabbaf = v);\n$parcel$export(module.exports, \"resolve\", () => $18c11f3350a906ea$export$f7ad0328861e2f03, (v) => $18c11f3350a906ea$export$f7ad0328861e2f03 = v);\nvar $18c11f3350a906ea$export$6503ec6e8aabbaf;\nvar $18c11f3350a906ea$export$f7ad0328861e2f03;\n\"use strict\";\nvar $18c11f3350a906ea$var$mapping = new Map();\nfunction $18c11f3350a906ea$var$register(baseUrl, manifest) {\n    for(var i = 0; i < manifest.length - 1; i += 2)$18c11f3350a906ea$var$mapping.set(manifest[i], {\n        baseUrl: baseUrl,\n        path: manifest[i + 1]\n    });\n}\nfunction $18c11f3350a906ea$var$resolve(id) {\n    var resolved = $18c11f3350a906ea$var$mapping.get(id);\n    if (resolved == null) throw new Error('Could not resolve bundle with id ' + id);\n    return new URL(resolved.path, resolved.baseUrl).toString();\n}\n$18c11f3350a906ea$export$6503ec6e8aabbaf = $18c11f3350a906ea$var$register;\n$18c11f3350a906ea$export$f7ad0328861e2f03 = $18c11f3350a906ea$var$resolve;\n\n});\n\n\n\nparcelRegister(\"8j2w0\", function(module, exports) {\n\nvar $Gr8vk = parcelRequire(\"Gr8vk\");\nmodule.exports = $Gr8vk(\"d6WIZ\").then(()=>parcelRequire('fLfFj'));\n\n});\n\nparcelRegister(\"6zM4s\", function(module, exports) {\n\nvar $Gr8vk = parcelRequire(\"Gr8vk\");\nmodule.exports = $Gr8vk(\"8xVaV\").then(()=>parcelRequire('f8ywF'));\n\n});\n\nparcelRegister(\"it5sz\", function(module, exports) {\n\nvar $Gr8vk = parcelRequire(\"Gr8vk\");\nmodule.exports = $Gr8vk(\"8nmL9\").then(()=>parcelRequire('934lS'));\n\n});\n\nparcelRegister(\"bNRfS\", function(module, exports) {\n\nvar $Gr8vk = parcelRequire(\"Gr8vk\");\nmodule.exports = $Gr8vk(\"hyTfq\").then(()=>parcelRequire('h7uU7'));\n\n});\n\n\nparcelRegister(\"5aabO\", function(module, exports) {\n\n$parcel$export(module.exports, \"createInfoServices\", () => $d10833e8570ddaee$export$df8d68917b0b9773);\n\nvar $bYG2S = parcelRequire(\"bYG2S\");\n\nvar $7xxrv = parcelRequire(\"7xxrv\");\n// ../parser/dist/chunks/mermaid-parser.core/chunk-4YFB5VUC.mjs\nvar $d10833e8570ddaee$var$InfoTokenBuilder = class extends (0, $bYG2S.AbstractMermaidTokenBuilder) {\n    static{\n        (0, $7xxrv.__name)(this, \"InfoTokenBuilder\");\n    }\n    static{\n        (0, $bYG2S.__name)(this, \"InfoTokenBuilder\");\n    }\n    constructor(){\n        super([\n            \"info\",\n            \"showInfo\"\n        ]);\n    }\n};\nvar $d10833e8570ddaee$export$ff9bd92f44cc7907 = {\n    parser: {\n        TokenBuilder: /* @__PURE__ */ (0, $bYG2S.__name)(()=>new $d10833e8570ddaee$var$InfoTokenBuilder(), \"TokenBuilder\"),\n        ValueConverter: /* @__PURE__ */ (0, $bYG2S.__name)(()=>new (0, $bYG2S.CommonValueConverter)(), \"ValueConverter\")\n    }\n};\nfunction $d10833e8570ddaee$export$df8d68917b0b9773(context = (0, $bYG2S.EmptyFileSystem)) {\n    const shared = (0, $bYG2S.inject)((0, $bYG2S.createDefaultSharedCoreModule)(context), (0, $bYG2S.MermaidGeneratedSharedModule));\n    const Info = (0, $bYG2S.inject)((0, $bYG2S.createDefaultCoreModule)({\n        shared: shared\n    }), (0, $bYG2S.InfoGeneratedModule), $d10833e8570ddaee$export$ff9bd92f44cc7907);\n    shared.ServiceRegistry.register(Info);\n    return {\n        shared: shared,\n        Info: Info\n    };\n}\n(0, $7xxrv.__name)($d10833e8570ddaee$export$df8d68917b0b9773, \"createInfoServices\");\n(0, $bYG2S.__name)($d10833e8570ddaee$export$df8d68917b0b9773, \"createInfoServices\");\n\n});\n\nparcelRegister(\"bqRip\", function(module, exports) {\n\n$parcel$export(module.exports, \"createPacketServices\", () => $d4fad4bc643f38e9$export$7e4e23c01014549b);\n\nvar $bYG2S = parcelRequire(\"bYG2S\");\n\nvar $7xxrv = parcelRequire(\"7xxrv\");\n// ../parser/dist/chunks/mermaid-parser.core/chunk-EQFLFMNE.mjs\nvar $d4fad4bc643f38e9$var$PacketTokenBuilder = class extends (0, $bYG2S.AbstractMermaidTokenBuilder) {\n    static{\n        (0, $7xxrv.__name)(this, \"PacketTokenBuilder\");\n    }\n    static{\n        (0, $bYG2S.__name)(this, \"PacketTokenBuilder\");\n    }\n    constructor(){\n        super([\n            \"packet-beta\"\n        ]);\n    }\n};\nvar $d4fad4bc643f38e9$export$696749b8bb714ad2 = {\n    parser: {\n        TokenBuilder: /* @__PURE__ */ (0, $bYG2S.__name)(()=>new $d4fad4bc643f38e9$var$PacketTokenBuilder(), \"TokenBuilder\"),\n        ValueConverter: /* @__PURE__ */ (0, $bYG2S.__name)(()=>new (0, $bYG2S.CommonValueConverter)(), \"ValueConverter\")\n    }\n};\nfunction $d4fad4bc643f38e9$export$7e4e23c01014549b(context = (0, $bYG2S.EmptyFileSystem)) {\n    const shared = (0, $bYG2S.inject)((0, $bYG2S.createDefaultSharedCoreModule)(context), (0, $bYG2S.MermaidGeneratedSharedModule));\n    const Packet = (0, $bYG2S.inject)((0, $bYG2S.createDefaultCoreModule)({\n        shared: shared\n    }), (0, $bYG2S.PacketGeneratedModule), $d4fad4bc643f38e9$export$696749b8bb714ad2);\n    shared.ServiceRegistry.register(Packet);\n    return {\n        shared: shared,\n        Packet: Packet\n    };\n}\n(0, $7xxrv.__name)($d4fad4bc643f38e9$export$7e4e23c01014549b, \"createPacketServices\");\n(0, $bYG2S.__name)($d4fad4bc643f38e9$export$7e4e23c01014549b, \"createPacketServices\");\n\n});\n\nparcelRegister(\"2P6uP\", function(module, exports) {\n\n$parcel$export(module.exports, \"createPieServices\", () => $296a600e4286884f$export$8c8c36c453ebad36);\n\nvar $bYG2S = parcelRequire(\"bYG2S\");\n\nvar $7xxrv = parcelRequire(\"7xxrv\");\n// ../parser/dist/chunks/mermaid-parser.core/chunk-BI6EQKOQ.mjs\nvar $296a600e4286884f$var$PieTokenBuilder = class extends (0, $bYG2S.AbstractMermaidTokenBuilder) {\n    static{\n        (0, $7xxrv.__name)(this, \"PieTokenBuilder\");\n    }\n    static{\n        (0, $bYG2S.__name)(this, \"PieTokenBuilder\");\n    }\n    constructor(){\n        super([\n            \"pie\",\n            \"showData\"\n        ]);\n    }\n};\nvar $296a600e4286884f$var$PieValueConverter = class extends (0, $bYG2S.AbstractMermaidValueConverter) {\n    static{\n        (0, $7xxrv.__name)(this, \"PieValueConverter\");\n    }\n    static{\n        (0, $bYG2S.__name)(this, \"PieValueConverter\");\n    }\n    runCustomConverter(rule, input, _cstNode) {\n        if (rule.name !== \"PIE_SECTION_LABEL\") return void 0;\n        return input.replace(/\"/g, \"\").trim();\n    }\n};\nvar $296a600e4286884f$export$82c0f447a0f95de = {\n    parser: {\n        TokenBuilder: /* @__PURE__ */ (0, $bYG2S.__name)(()=>new $296a600e4286884f$var$PieTokenBuilder(), \"TokenBuilder\"),\n        ValueConverter: /* @__PURE__ */ (0, $bYG2S.__name)(()=>new $296a600e4286884f$var$PieValueConverter(), \"ValueConverter\")\n    }\n};\nfunction $296a600e4286884f$export$8c8c36c453ebad36(context = (0, $bYG2S.EmptyFileSystem)) {\n    const shared = (0, $bYG2S.inject)((0, $bYG2S.createDefaultSharedCoreModule)(context), (0, $bYG2S.MermaidGeneratedSharedModule));\n    const Pie = (0, $bYG2S.inject)((0, $bYG2S.createDefaultCoreModule)({\n        shared: shared\n    }), (0, $bYG2S.PieGeneratedModule), $296a600e4286884f$export$82c0f447a0f95de);\n    shared.ServiceRegistry.register(Pie);\n    return {\n        shared: shared,\n        Pie: Pie\n    };\n}\n(0, $7xxrv.__name)($296a600e4286884f$export$8c8c36c453ebad36, \"createPieServices\");\n(0, $bYG2S.__name)($296a600e4286884f$export$8c8c36c453ebad36, \"createPieServices\");\n\n});\n\nparcelRegister(\"58fUp\", function(module, exports) {\n\n$parcel$export(module.exports, \"createArchitectureServices\", () => $d50b8c1bbf3383d4$export$6bf19b4a269deaf6);\n\nvar $bYG2S = parcelRequire(\"bYG2S\");\n\nvar $7xxrv = parcelRequire(\"7xxrv\");\n// ../parser/dist/chunks/mermaid-parser.core/chunk-FF7BQXOH.mjs\nvar $d50b8c1bbf3383d4$var$ArchitectureTokenBuilder = class extends (0, $bYG2S.AbstractMermaidTokenBuilder) {\n    static{\n        (0, $7xxrv.__name)(this, \"ArchitectureTokenBuilder\");\n    }\n    static{\n        (0, $bYG2S.__name)(this, \"ArchitectureTokenBuilder\");\n    }\n    constructor(){\n        super([\n            \"architecture\"\n        ]);\n    }\n};\nvar $d50b8c1bbf3383d4$var$ArchitectureValueConverter = class extends (0, $bYG2S.AbstractMermaidValueConverter) {\n    static{\n        (0, $7xxrv.__name)(this, \"ArchitectureValueConverter\");\n    }\n    static{\n        (0, $bYG2S.__name)(this, \"ArchitectureValueConverter\");\n    }\n    runCustomConverter(rule, input, _cstNode) {\n        if (rule.name === \"ARCH_ICON\") return input.replace(/[()]/g, \"\").trim();\n        else if (rule.name === \"ARCH_TEXT_ICON\") return input.replace(/[\"()]/g, \"\");\n        else if (rule.name === \"ARCH_TITLE\") return input.replace(/[[\\]]/g, \"\").trim();\n        return void 0;\n    }\n};\nvar $d50b8c1bbf3383d4$export$b6995d23b3452254 = {\n    parser: {\n        TokenBuilder: /* @__PURE__ */ (0, $bYG2S.__name)(()=>new $d50b8c1bbf3383d4$var$ArchitectureTokenBuilder(), \"TokenBuilder\"),\n        ValueConverter: /* @__PURE__ */ (0, $bYG2S.__name)(()=>new $d50b8c1bbf3383d4$var$ArchitectureValueConverter(), \"ValueConverter\")\n    }\n};\nfunction $d50b8c1bbf3383d4$export$6bf19b4a269deaf6(context = (0, $bYG2S.EmptyFileSystem)) {\n    const shared = (0, $bYG2S.inject)((0, $bYG2S.createDefaultSharedCoreModule)(context), (0, $bYG2S.MermaidGeneratedSharedModule));\n    const Architecture = (0, $bYG2S.inject)((0, $bYG2S.createDefaultCoreModule)({\n        shared: shared\n    }), (0, $bYG2S.ArchitectureGeneratedModule), $d50b8c1bbf3383d4$export$b6995d23b3452254);\n    shared.ServiceRegistry.register(Architecture);\n    return {\n        shared: shared,\n        Architecture: Architecture\n    };\n}\n(0, $7xxrv.__name)($d50b8c1bbf3383d4$export$6bf19b4a269deaf6, \"createArchitectureServices\");\n(0, $bYG2S.__name)($d50b8c1bbf3383d4$export$6bf19b4a269deaf6, \"createArchitectureServices\");\n\n});\n\nparcelRegister(\"6JCZZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"createGitGraphServices\", () => $51e7999b1e5f3296$export$ef9a00b13c3f874c);\n\nvar $bYG2S = parcelRequire(\"bYG2S\");\n\nvar $7xxrv = parcelRequire(\"7xxrv\");\n// ../parser/dist/chunks/mermaid-parser.core/chunk-NCMFTTUW.mjs\nvar $51e7999b1e5f3296$var$GitGraphTokenBuilder = class extends (0, $bYG2S.AbstractMermaidTokenBuilder) {\n    static{\n        (0, $7xxrv.__name)(this, \"GitGraphTokenBuilder\");\n    }\n    static{\n        (0, $bYG2S.__name)(this, \"GitGraphTokenBuilder\");\n    }\n    constructor(){\n        super([\n            \"gitGraph\"\n        ]);\n    }\n};\nvar $51e7999b1e5f3296$export$499b7d9a23e4443d = {\n    parser: {\n        TokenBuilder: /* @__PURE__ */ (0, $bYG2S.__name)(()=>new $51e7999b1e5f3296$var$GitGraphTokenBuilder(), \"TokenBuilder\"),\n        ValueConverter: /* @__PURE__ */ (0, $bYG2S.__name)(()=>new (0, $bYG2S.CommonValueConverter)(), \"ValueConverter\")\n    }\n};\nfunction $51e7999b1e5f3296$export$ef9a00b13c3f874c(context = (0, $bYG2S.EmptyFileSystem)) {\n    const shared = (0, $bYG2S.inject)((0, $bYG2S.createDefaultSharedCoreModule)(context), (0, $bYG2S.MermaidGeneratedSharedModule));\n    const GitGraph = (0, $bYG2S.inject)((0, $bYG2S.createDefaultCoreModule)({\n        shared: shared\n    }), (0, $bYG2S.GitGraphGeneratedModule), $51e7999b1e5f3296$export$499b7d9a23e4443d);\n    shared.ServiceRegistry.register(GitGraph);\n    return {\n        shared: shared,\n        GitGraph: GitGraph\n    };\n}\n(0, $7xxrv.__name)($51e7999b1e5f3296$export$ef9a00b13c3f874c, \"createGitGraphServices\");\n(0, $bYG2S.__name)($51e7999b1e5f3296$export$ef9a00b13c3f874c, \"createGitGraphServices\");\n\n});\n\n\n//# sourceMappingURL=gitGraphDiagram-GAN24H3L.eaff6536.js.map\n","import {\n  __name as __name2\n} from \"./chunk-46UCTVYF.mjs\";\nimport {\n  __name\n} from \"./chunk-DLQEHMXD.mjs\";\n\n// ../parser/dist/mermaid-parser.core.mjs\nvar parsers = {};\nvar initializers = {\n  info: /* @__PURE__ */ __name2(async () => {\n    const { createInfoServices: createInfoServices2 } = await import(\"./info-46DW6VJ7-DWL5YA7S.mjs\");\n    const parser = createInfoServices2().Info.parser.LangiumParser;\n    parsers.info = parser;\n  }, \"info\"),\n  packet: /* @__PURE__ */ __name2(async () => {\n    const { createPacketServices: createPacketServices2 } = await import(\"./packet-W2GHVCYJ-BYDCIJGQ.mjs\");\n    const parser = createPacketServices2().Packet.parser.LangiumParser;\n    parsers.packet = parser;\n  }, \"packet\"),\n  pie: /* @__PURE__ */ __name2(async () => {\n    const { createPieServices: createPieServices2 } = await import(\"./pie-BEWT4RHE-7NZKCH6N.mjs\");\n    const parser = createPieServices2().Pie.parser.LangiumParser;\n    parsers.pie = parser;\n  }, \"pie\"),\n  architecture: /* @__PURE__ */ __name2(async () => {\n    const { createArchitectureServices: createArchitectureServices2 } = await import(\"./architecture-I3QFYML2-BYLGXPH6.mjs\");\n    const parser = createArchitectureServices2().Architecture.parser.LangiumParser;\n    parsers.architecture = parser;\n  }, \"architecture\"),\n  gitGraph: /* @__PURE__ */ __name2(async () => {\n    const { createGitGraphServices: createGitGraphServices2 } = await import(\"./gitGraph-YCYPL57B-5MQDGNWY.mjs\");\n    const parser = createGitGraphServices2().GitGraph.parser.LangiumParser;\n    parsers.gitGraph = parser;\n  }, \"gitGraph\")\n};\nasync function parse(diagramType, text) {\n  const initializer = initializers[diagramType];\n  if (!initializer) {\n    throw new Error(`Unknown diagram type: ${diagramType}`);\n  }\n  if (!parsers[diagramType]) {\n    await initializer();\n  }\n  const parser = parsers[diagramType];\n  const result = parser.parse(text);\n  if (result.lexerErrors.length > 0 || result.parserErrors.length > 0) {\n    throw new MermaidParseError(result);\n  }\n  return result.value;\n}\n__name(parse, \"parse\");\n__name2(parse, \"parse\");\nvar MermaidParseError = class extends Error {\n  static {\n    __name(this, \"MermaidParseError\");\n  }\n  constructor(result) {\n    const lexerErrors = result.lexerErrors.map((err) => err.message).join(\"\\n\");\n    const parserErrors = result.parserErrors.map((err) => err.message).join(\"\\n\");\n    super(`Parsing failed: ${lexerErrors} ${parserErrors}`);\n    this.result = result;\n  }\n  static {\n    __name2(this, \"MermaidParseError\");\n  }\n};\n\nexport {\n  parse\n};\n","import {\n  assign_default,\n  clone_default,\n  compact_default,\n  defaults_default,\n  difference_default,\n  dropRight_default,\n  drop_default,\n  every_default,\n  filter_default,\n  find_default,\n  flatMap_default,\n  flatten_default,\n  forEach_default,\n  groupBy_default,\n  has_default,\n  head_default,\n  includes_default,\n  indexOf_default,\n  isRegExp_default,\n  isString_default,\n  isUndefined_default,\n  keys_default,\n  last_default,\n  map_default,\n  min_default,\n  noop_default,\n  pickBy_default,\n  reduce_default,\n  reject_default,\n  some_default,\n  uniqBy_default,\n  uniq_default,\n  values_default\n} from \"./chunk-TGZYFRKZ.mjs\";\nimport {\n  isEmpty_default\n} from \"./chunk-GRZAG2UZ.mjs\";\nimport {\n  identity_default,\n  isArray_default,\n  isFunction_default,\n  isObject_default\n} from \"./chunk-HD3LK5B5.mjs\";\nimport {\n  __commonJS,\n  __export,\n  __name,\n  __reExport,\n  __toESM\n} from \"./chunk-DLQEHMXD.mjs\";\n\n// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/ral.js\nvar require_ral = __commonJS({\n  \"../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/ral.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var _ral;\n    function RAL() {\n      if (_ral === void 0) {\n        throw new Error(`No runtime abstraction layer installed`);\n      }\n      return _ral;\n    }\n    __name(RAL, \"RAL\");\n    (function(RAL2) {\n      function install(ral) {\n        if (ral === void 0) {\n          throw new Error(`No runtime abstraction layer provided`);\n        }\n        _ral = ral;\n      }\n      __name(install, \"install\");\n      RAL2.install = install;\n    })(RAL || (RAL = {}));\n    exports.default = RAL;\n  }\n});\n\n// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/is.js\nvar require_is = __commonJS({\n  \"../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/is.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;\n    function boolean(value) {\n      return value === true || value === false;\n    }\n    __name(boolean, \"boolean\");\n    exports.boolean = boolean;\n    function string(value) {\n      return typeof value === \"string\" || value instanceof String;\n    }\n    __name(string, \"string\");\n    exports.string = string;\n    function number(value) {\n      return typeof value === \"number\" || value instanceof Number;\n    }\n    __name(number, \"number\");\n    exports.number = number;\n    function error(value) {\n      return value instanceof Error;\n    }\n    __name(error, \"error\");\n    exports.error = error;\n    function func(value) {\n      return typeof value === \"function\";\n    }\n    __name(func, \"func\");\n    exports.func = func;\n    function array(value) {\n      return Array.isArray(value);\n    }\n    __name(array, \"array\");\n    exports.array = array;\n    function stringArray(value) {\n      return array(value) && value.every((elem) => string(elem));\n    }\n    __name(stringArray, \"stringArray\");\n    exports.stringArray = stringArray;\n  }\n});\n\n// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/events.js\nvar require_events = __commonJS({\n  \"../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/events.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.Emitter = exports.Event = void 0;\n    var ral_1 = require_ral();\n    var Event;\n    (function(Event2) {\n      const _disposable = { dispose() {\n      } };\n      Event2.None = function() {\n        return _disposable;\n      };\n    })(Event || (exports.Event = Event = {}));\n    var CallbackList = class {\n      static {\n        __name(this, \"CallbackList\");\n      }\n      add(callback, context = null, bucket) {\n        if (!this._callbacks) {\n          this._callbacks = [];\n          this._contexts = [];\n        }\n        this._callbacks.push(callback);\n        this._contexts.push(context);\n        if (Array.isArray(bucket)) {\n          bucket.push({ dispose: /* @__PURE__ */ __name(() => this.remove(callback, context), \"dispose\") });\n        }\n      }\n      remove(callback, context = null) {\n        if (!this._callbacks) {\n          return;\n        }\n        let foundCallbackWithDifferentContext = false;\n        for (let i = 0, len = this._callbacks.length; i < len; i++) {\n          if (this._callbacks[i] === callback) {\n            if (this._contexts[i] === context) {\n              this._callbacks.splice(i, 1);\n              this._contexts.splice(i, 1);\n              return;\n            } else {\n              foundCallbackWithDifferentContext = true;\n            }\n          }\n        }\n        if (foundCallbackWithDifferentContext) {\n          throw new Error(\"When adding a listener with a context, you should remove it with the same context\");\n        }\n      }\n      invoke(...args) {\n        if (!this._callbacks) {\n          return [];\n        }\n        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);\n        for (let i = 0, len = callbacks.length; i < len; i++) {\n          try {\n            ret.push(callbacks[i].apply(contexts[i], args));\n          } catch (e) {\n            (0, ral_1.default)().console.error(e);\n          }\n        }\n        return ret;\n      }\n      isEmpty() {\n        return !this._callbacks || this._callbacks.length === 0;\n      }\n      dispose() {\n        this._callbacks = void 0;\n        this._contexts = void 0;\n      }\n    };\n    var Emitter2 = class _Emitter {\n      static {\n        __name(this, \"Emitter\");\n      }\n      constructor(_options) {\n        this._options = _options;\n      }\n      /**\n       * For the public to allow to subscribe\n       * to events from this Emitter\n       */\n      get event() {\n        if (!this._event) {\n          this._event = (listener, thisArgs, disposables) => {\n            if (!this._callbacks) {\n              this._callbacks = new CallbackList();\n            }\n            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {\n              this._options.onFirstListenerAdd(this);\n            }\n            this._callbacks.add(listener, thisArgs);\n            const result = {\n              dispose: /* @__PURE__ */ __name(() => {\n                if (!this._callbacks) {\n                  return;\n                }\n                this._callbacks.remove(listener, thisArgs);\n                result.dispose = _Emitter._noop;\n                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {\n                  this._options.onLastListenerRemove(this);\n                }\n              }, \"dispose\")\n            };\n            if (Array.isArray(disposables)) {\n              disposables.push(result);\n            }\n            return result;\n          };\n        }\n        return this._event;\n      }\n      /**\n       * To be kept private to fire an event to\n       * subscribers\n       */\n      fire(event) {\n        if (this._callbacks) {\n          this._callbacks.invoke.call(this._callbacks, event);\n        }\n      }\n      dispose() {\n        if (this._callbacks) {\n          this._callbacks.dispose();\n          this._callbacks = void 0;\n        }\n      }\n    };\n    exports.Emitter = Emitter2;\n    Emitter2._noop = function() {\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/cancellation.js\nvar require_cancellation = __commonJS({\n  \"../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/cancellation.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.CancellationTokenSource = exports.CancellationToken = void 0;\n    var ral_1 = require_ral();\n    var Is2 = require_is();\n    var events_1 = require_events();\n    var CancellationToken11;\n    (function(CancellationToken12) {\n      CancellationToken12.None = Object.freeze({\n        isCancellationRequested: false,\n        onCancellationRequested: events_1.Event.None\n      });\n      CancellationToken12.Cancelled = Object.freeze({\n        isCancellationRequested: true,\n        onCancellationRequested: events_1.Event.None\n      });\n      function is(value) {\n        const candidate = value;\n        return candidate && (candidate === CancellationToken12.None || candidate === CancellationToken12.Cancelled || Is2.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);\n      }\n      __name(is, \"is\");\n      CancellationToken12.is = is;\n    })(CancellationToken11 || (exports.CancellationToken = CancellationToken11 = {}));\n    var shortcutEvent = Object.freeze(function(callback, context) {\n      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);\n      return { dispose() {\n        handle.dispose();\n      } };\n    });\n    var MutableToken = class {\n      static {\n        __name(this, \"MutableToken\");\n      }\n      constructor() {\n        this._isCancelled = false;\n      }\n      cancel() {\n        if (!this._isCancelled) {\n          this._isCancelled = true;\n          if (this._emitter) {\n            this._emitter.fire(void 0);\n            this.dispose();\n          }\n        }\n      }\n      get isCancellationRequested() {\n        return this._isCancelled;\n      }\n      get onCancellationRequested() {\n        if (this._isCancelled) {\n          return shortcutEvent;\n        }\n        if (!this._emitter) {\n          this._emitter = new events_1.Emitter();\n        }\n        return this._emitter.event;\n      }\n      dispose() {\n        if (this._emitter) {\n          this._emitter.dispose();\n          this._emitter = void 0;\n        }\n      }\n    };\n    var CancellationTokenSource3 = class {\n      static {\n        __name(this, \"CancellationTokenSource\");\n      }\n      get token() {\n        if (!this._token) {\n          this._token = new MutableToken();\n        }\n        return this._token;\n      }\n      cancel() {\n        if (!this._token) {\n          this._token = CancellationToken11.Cancelled;\n        } else {\n          this._token.cancel();\n        }\n      }\n      dispose() {\n        if (!this._token) {\n          this._token = CancellationToken11.None;\n        } else if (this._token instanceof MutableToken) {\n          this._token.dispose();\n        }\n      }\n    };\n    exports.CancellationTokenSource = CancellationTokenSource3;\n  }\n});\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/index.js\nvar lib_exports = {};\n__export(lib_exports, {\n  AbstractAstReflection: () => AbstractAstReflection,\n  AbstractCstNode: () => AbstractCstNode,\n  AbstractLangiumParser: () => AbstractLangiumParser,\n  AbstractParserErrorMessageProvider: () => AbstractParserErrorMessageProvider,\n  AbstractThreadedAsyncParser: () => AbstractThreadedAsyncParser,\n  AstUtils: () => ast_utils_exports,\n  BiMap: () => BiMap,\n  Cancellation: () => cancellation_exports,\n  CompositeCstNodeImpl: () => CompositeCstNodeImpl,\n  ContextCache: () => ContextCache,\n  CstNodeBuilder: () => CstNodeBuilder,\n  CstUtils: () => cst_utils_exports,\n  DONE_RESULT: () => DONE_RESULT,\n  DatatypeSymbol: () => DatatypeSymbol,\n  DefaultAstNodeDescriptionProvider: () => DefaultAstNodeDescriptionProvider,\n  DefaultAstNodeLocator: () => DefaultAstNodeLocator,\n  DefaultAsyncParser: () => DefaultAsyncParser,\n  DefaultCommentProvider: () => DefaultCommentProvider,\n  DefaultConfigurationProvider: () => DefaultConfigurationProvider,\n  DefaultDocumentBuilder: () => DefaultDocumentBuilder,\n  DefaultDocumentValidator: () => DefaultDocumentValidator,\n  DefaultHydrator: () => DefaultHydrator,\n  DefaultIndexManager: () => DefaultIndexManager,\n  DefaultJsonSerializer: () => DefaultJsonSerializer,\n  DefaultLangiumDocumentFactory: () => DefaultLangiumDocumentFactory,\n  DefaultLangiumDocuments: () => DefaultLangiumDocuments,\n  DefaultLexer: () => DefaultLexer,\n  DefaultLinker: () => DefaultLinker,\n  DefaultNameProvider: () => DefaultNameProvider,\n  DefaultReferenceDescriptionProvider: () => DefaultReferenceDescriptionProvider,\n  DefaultReferences: () => DefaultReferences,\n  DefaultScopeComputation: () => DefaultScopeComputation,\n  DefaultScopeProvider: () => DefaultScopeProvider,\n  DefaultServiceRegistry: () => DefaultServiceRegistry,\n  DefaultTokenBuilder: () => DefaultTokenBuilder,\n  DefaultValueConverter: () => DefaultValueConverter,\n  DefaultWorkspaceLock: () => DefaultWorkspaceLock,\n  DefaultWorkspaceManager: () => DefaultWorkspaceManager,\n  Deferred: () => Deferred,\n  Disposable: () => Disposable,\n  DisposableCache: () => DisposableCache,\n  DocumentCache: () => DocumentCache,\n  DocumentState: () => DocumentState,\n  DocumentValidator: () => DocumentValidator,\n  EMPTY_SCOPE: () => EMPTY_SCOPE,\n  EMPTY_STREAM: () => EMPTY_STREAM,\n  EmptyFileSystem: () => EmptyFileSystem,\n  EmptyFileSystemProvider: () => EmptyFileSystemProvider,\n  ErrorWithLocation: () => ErrorWithLocation,\n  GrammarAST: () => ast_exports,\n  GrammarUtils: () => grammar_utils_exports,\n  JSDocDocumentationProvider: () => JSDocDocumentationProvider,\n  LangiumCompletionParser: () => LangiumCompletionParser,\n  LangiumParser: () => LangiumParser,\n  LangiumParserErrorMessageProvider: () => LangiumParserErrorMessageProvider,\n  LeafCstNodeImpl: () => LeafCstNodeImpl,\n  MapScope: () => MapScope,\n  Module: () => Module,\n  MultiMap: () => MultiMap,\n  OperationCancelled: () => OperationCancelled,\n  ParserWorker: () => ParserWorker,\n  Reduction: () => Reduction,\n  RegExpUtils: () => regexp_utils_exports,\n  RootCstNodeImpl: () => RootCstNodeImpl,\n  SimpleCache: () => SimpleCache,\n  StreamImpl: () => StreamImpl,\n  StreamScope: () => StreamScope,\n  TextDocument: () => TextDocument2,\n  TreeStreamImpl: () => TreeStreamImpl,\n  URI: () => URI2,\n  UriUtils: () => UriUtils,\n  ValidationCategory: () => ValidationCategory,\n  ValidationRegistry: () => ValidationRegistry,\n  ValueConverter: () => ValueConverter,\n  WorkspaceCache: () => WorkspaceCache,\n  assertUnreachable: () => assertUnreachable,\n  createCompletionParser: () => createCompletionParser,\n  createDefaultCoreModule: () => createDefaultCoreModule,\n  createDefaultSharedCoreModule: () => createDefaultSharedCoreModule,\n  createGrammarConfig: () => createGrammarConfig,\n  createLangiumParser: () => createLangiumParser,\n  delayNextTick: () => delayNextTick,\n  diagnosticData: () => diagnosticData,\n  eagerLoad: () => eagerLoad,\n  getDiagnosticRange: () => getDiagnosticRange,\n  inject: () => inject,\n  interruptAndCheck: () => interruptAndCheck,\n  isAstNode: () => isAstNode,\n  isAstNodeDescription: () => isAstNodeDescription,\n  isAstNodeWithComment: () => isAstNodeWithComment,\n  isCompositeCstNode: () => isCompositeCstNode,\n  isIMultiModeLexerDefinition: () => isIMultiModeLexerDefinition,\n  isJSDoc: () => isJSDoc,\n  isLeafCstNode: () => isLeafCstNode,\n  isLinkingError: () => isLinkingError,\n  isNamed: () => isNamed,\n  isOperationCancelled: () => isOperationCancelled,\n  isReference: () => isReference,\n  isRootCstNode: () => isRootCstNode,\n  isTokenTypeArray: () => isTokenTypeArray,\n  isTokenTypeDictionary: () => isTokenTypeDictionary,\n  loadGrammarFromJson: () => loadGrammarFromJson,\n  parseJSDoc: () => parseJSDoc,\n  prepareLangiumParser: () => prepareLangiumParser,\n  setInterruptionPeriod: () => setInterruptionPeriod,\n  startCancelableOperation: () => startCancelableOperation,\n  stream: () => stream,\n  toDiagnosticSeverity: () => toDiagnosticSeverity\n});\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/cst-utils.js\nvar cst_utils_exports = {};\n__export(cst_utils_exports, {\n  DefaultNameRegexp: () => DefaultNameRegexp,\n  RangeComparison: () => RangeComparison,\n  compareRange: () => compareRange,\n  findCommentNode: () => findCommentNode,\n  findDeclarationNodeAtOffset: () => findDeclarationNodeAtOffset,\n  findLeafNodeAtOffset: () => findLeafNodeAtOffset,\n  findLeafNodeBeforeOffset: () => findLeafNodeBeforeOffset,\n  flattenCst: () => flattenCst,\n  getInteriorNodes: () => getInteriorNodes,\n  getNextNode: () => getNextNode,\n  getPreviousNode: () => getPreviousNode,\n  getStartlineNode: () => getStartlineNode,\n  inRange: () => inRange,\n  isChildNode: () => isChildNode,\n  isCommentNode: () => isCommentNode,\n  streamCst: () => streamCst,\n  toDocumentSegment: () => toDocumentSegment,\n  tokenToRange: () => tokenToRange\n});\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/syntax-tree.js\nfunction isAstNode(obj) {\n  return typeof obj === \"object\" && obj !== null && typeof obj.$type === \"string\";\n}\n__name(isAstNode, \"isAstNode\");\nfunction isReference(obj) {\n  return typeof obj === \"object\" && obj !== null && typeof obj.$refText === \"string\";\n}\n__name(isReference, \"isReference\");\nfunction isAstNodeDescription(obj) {\n  return typeof obj === \"object\" && obj !== null && typeof obj.name === \"string\" && typeof obj.type === \"string\" && typeof obj.path === \"string\";\n}\n__name(isAstNodeDescription, \"isAstNodeDescription\");\nfunction isLinkingError(obj) {\n  return typeof obj === \"object\" && obj !== null && isAstNode(obj.container) && isReference(obj.reference) && typeof obj.message === \"string\";\n}\n__name(isLinkingError, \"isLinkingError\");\nvar AbstractAstReflection = class {\n  static {\n    __name(this, \"AbstractAstReflection\");\n  }\n  constructor() {\n    this.subtypes = {};\n    this.allSubtypes = {};\n  }\n  isInstance(node, type) {\n    return isAstNode(node) && this.isSubtype(node.$type, type);\n  }\n  isSubtype(subtype, supertype) {\n    if (subtype === supertype) {\n      return true;\n    }\n    let nested = this.subtypes[subtype];\n    if (!nested) {\n      nested = this.subtypes[subtype] = {};\n    }\n    const existing = nested[supertype];\n    if (existing !== void 0) {\n      return existing;\n    } else {\n      const result = this.computeIsSubtype(subtype, supertype);\n      nested[supertype] = result;\n      return result;\n    }\n  }\n  getAllSubTypes(type) {\n    const existing = this.allSubtypes[type];\n    if (existing) {\n      return existing;\n    } else {\n      const allTypes = this.getAllTypes();\n      const types = [];\n      for (const possibleSubType of allTypes) {\n        if (this.isSubtype(possibleSubType, type)) {\n          types.push(possibleSubType);\n        }\n      }\n      this.allSubtypes[type] = types;\n      return types;\n    }\n  }\n};\nfunction isCompositeCstNode(node) {\n  return typeof node === \"object\" && node !== null && Array.isArray(node.content);\n}\n__name(isCompositeCstNode, \"isCompositeCstNode\");\nfunction isLeafCstNode(node) {\n  return typeof node === \"object\" && node !== null && typeof node.tokenType === \"object\";\n}\n__name(isLeafCstNode, \"isLeafCstNode\");\nfunction isRootCstNode(node) {\n  return isCompositeCstNode(node) && typeof node.fullText === \"string\";\n}\n__name(isRootCstNode, \"isRootCstNode\");\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/stream.js\nvar StreamImpl = class _StreamImpl {\n  static {\n    __name(this, \"StreamImpl\");\n  }\n  constructor(startFn, nextFn) {\n    this.startFn = startFn;\n    this.nextFn = nextFn;\n  }\n  iterator() {\n    const iterator = {\n      state: this.startFn(),\n      next: /* @__PURE__ */ __name(() => this.nextFn(iterator.state), \"next\"),\n      [Symbol.iterator]: () => iterator\n    };\n    return iterator;\n  }\n  [Symbol.iterator]() {\n    return this.iterator();\n  }\n  isEmpty() {\n    const iterator = this.iterator();\n    return Boolean(iterator.next().done);\n  }\n  count() {\n    const iterator = this.iterator();\n    let count = 0;\n    let next = iterator.next();\n    while (!next.done) {\n      count++;\n      next = iterator.next();\n    }\n    return count;\n  }\n  toArray() {\n    const result = [];\n    const iterator = this.iterator();\n    let next;\n    do {\n      next = iterator.next();\n      if (next.value !== void 0) {\n        result.push(next.value);\n      }\n    } while (!next.done);\n    return result;\n  }\n  toSet() {\n    return new Set(this);\n  }\n  toMap(keyFn, valueFn) {\n    const entryStream = this.map((element) => [\n      keyFn ? keyFn(element) : element,\n      valueFn ? valueFn(element) : element\n    ]);\n    return new Map(entryStream);\n  }\n  toString() {\n    return this.join();\n  }\n  concat(other) {\n    const iterator = other[Symbol.iterator]();\n    return new _StreamImpl(() => ({ first: this.startFn(), firstDone: false }), (state) => {\n      let result;\n      if (!state.firstDone) {\n        do {\n          result = this.nextFn(state.first);\n          if (!result.done) {\n            return result;\n          }\n        } while (!result.done);\n        state.firstDone = true;\n      }\n      do {\n        result = iterator.next();\n        if (!result.done) {\n          return result;\n        }\n      } while (!result.done);\n      return DONE_RESULT;\n    });\n  }\n  join(separator = \",\") {\n    const iterator = this.iterator();\n    let value = \"\";\n    let result;\n    let addSeparator = false;\n    do {\n      result = iterator.next();\n      if (!result.done) {\n        if (addSeparator) {\n          value += separator;\n        }\n        value += toString(result.value);\n      }\n      addSeparator = true;\n    } while (!result.done);\n    return value;\n  }\n  indexOf(searchElement, fromIndex = 0) {\n    const iterator = this.iterator();\n    let index = 0;\n    let next = iterator.next();\n    while (!next.done) {\n      if (index >= fromIndex && next.value === searchElement) {\n        return index;\n      }\n      next = iterator.next();\n      index++;\n    }\n    return -1;\n  }\n  every(predicate) {\n    const iterator = this.iterator();\n    let next = iterator.next();\n    while (!next.done) {\n      if (!predicate(next.value)) {\n        return false;\n      }\n      next = iterator.next();\n    }\n    return true;\n  }\n  some(predicate) {\n    const iterator = this.iterator();\n    let next = iterator.next();\n    while (!next.done) {\n      if (predicate(next.value)) {\n        return true;\n      }\n      next = iterator.next();\n    }\n    return false;\n  }\n  forEach(callbackfn) {\n    const iterator = this.iterator();\n    let index = 0;\n    let next = iterator.next();\n    while (!next.done) {\n      callbackfn(next.value, index);\n      next = iterator.next();\n      index++;\n    }\n  }\n  map(callbackfn) {\n    return new _StreamImpl(this.startFn, (state) => {\n      const { done, value } = this.nextFn(state);\n      if (done) {\n        return DONE_RESULT;\n      } else {\n        return { done: false, value: callbackfn(value) };\n      }\n    });\n  }\n  filter(predicate) {\n    return new _StreamImpl(this.startFn, (state) => {\n      let result;\n      do {\n        result = this.nextFn(state);\n        if (!result.done && predicate(result.value)) {\n          return result;\n        }\n      } while (!result.done);\n      return DONE_RESULT;\n    });\n  }\n  nonNullable() {\n    return this.filter((e) => e !== void 0 && e !== null);\n  }\n  reduce(callbackfn, initialValue) {\n    const iterator = this.iterator();\n    let previousValue = initialValue;\n    let next = iterator.next();\n    while (!next.done) {\n      if (previousValue === void 0) {\n        previousValue = next.value;\n      } else {\n        previousValue = callbackfn(previousValue, next.value);\n      }\n      next = iterator.next();\n    }\n    return previousValue;\n  }\n  reduceRight(callbackfn, initialValue) {\n    return this.recursiveReduce(this.iterator(), callbackfn, initialValue);\n  }\n  recursiveReduce(iterator, callbackfn, initialValue) {\n    const next = iterator.next();\n    if (next.done) {\n      return initialValue;\n    }\n    const previousValue = this.recursiveReduce(iterator, callbackfn, initialValue);\n    if (previousValue === void 0) {\n      return next.value;\n    }\n    return callbackfn(previousValue, next.value);\n  }\n  find(predicate) {\n    const iterator = this.iterator();\n    let next = iterator.next();\n    while (!next.done) {\n      if (predicate(next.value)) {\n        return next.value;\n      }\n      next = iterator.next();\n    }\n    return void 0;\n  }\n  findIndex(predicate) {\n    const iterator = this.iterator();\n    let index = 0;\n    let next = iterator.next();\n    while (!next.done) {\n      if (predicate(next.value)) {\n        return index;\n      }\n      next = iterator.next();\n      index++;\n    }\n    return -1;\n  }\n  includes(searchElement) {\n    const iterator = this.iterator();\n    let next = iterator.next();\n    while (!next.done) {\n      if (next.value === searchElement) {\n        return true;\n      }\n      next = iterator.next();\n    }\n    return false;\n  }\n  flatMap(callbackfn) {\n    return new _StreamImpl(() => ({ this: this.startFn() }), (state) => {\n      do {\n        if (state.iterator) {\n          const next = state.iterator.next();\n          if (next.done) {\n            state.iterator = void 0;\n          } else {\n            return next;\n          }\n        }\n        const { done, value } = this.nextFn(state.this);\n        if (!done) {\n          const mapped = callbackfn(value);\n          if (isIterable(mapped)) {\n            state.iterator = mapped[Symbol.iterator]();\n          } else {\n            return { done: false, value: mapped };\n          }\n        }\n      } while (state.iterator);\n      return DONE_RESULT;\n    });\n  }\n  flat(depth) {\n    if (depth === void 0) {\n      depth = 1;\n    }\n    if (depth <= 0) {\n      return this;\n    }\n    const stream2 = depth > 1 ? this.flat(depth - 1) : this;\n    return new _StreamImpl(() => ({ this: stream2.startFn() }), (state) => {\n      do {\n        if (state.iterator) {\n          const next = state.iterator.next();\n          if (next.done) {\n            state.iterator = void 0;\n          } else {\n            return next;\n          }\n        }\n        const { done, value } = stream2.nextFn(state.this);\n        if (!done) {\n          if (isIterable(value)) {\n            state.iterator = value[Symbol.iterator]();\n          } else {\n            return { done: false, value };\n          }\n        }\n      } while (state.iterator);\n      return DONE_RESULT;\n    });\n  }\n  head() {\n    const iterator = this.iterator();\n    const result = iterator.next();\n    if (result.done) {\n      return void 0;\n    }\n    return result.value;\n  }\n  tail(skipCount = 1) {\n    return new _StreamImpl(() => {\n      const state = this.startFn();\n      for (let i = 0; i < skipCount; i++) {\n        const next = this.nextFn(state);\n        if (next.done) {\n          return state;\n        }\n      }\n      return state;\n    }, this.nextFn);\n  }\n  limit(maxSize) {\n    return new _StreamImpl(() => ({ size: 0, state: this.startFn() }), (state) => {\n      state.size++;\n      if (state.size > maxSize) {\n        return DONE_RESULT;\n      }\n      return this.nextFn(state.state);\n    });\n  }\n  distinct(by) {\n    const set = /* @__PURE__ */ new Set();\n    return this.filter((e) => {\n      const value = by ? by(e) : e;\n      if (set.has(value)) {\n        return false;\n      } else {\n        set.add(value);\n        return true;\n      }\n    });\n  }\n  exclude(other, key) {\n    const otherKeySet = /* @__PURE__ */ new Set();\n    for (const item of other) {\n      const value = key ? key(item) : item;\n      otherKeySet.add(value);\n    }\n    return this.filter((e) => {\n      const ownKey = key ? key(e) : e;\n      return !otherKeySet.has(ownKey);\n    });\n  }\n};\nfunction toString(item) {\n  if (typeof item === \"string\") {\n    return item;\n  }\n  if (typeof item === \"undefined\") {\n    return \"undefined\";\n  }\n  if (typeof item.toString === \"function\") {\n    return item.toString();\n  }\n  return Object.prototype.toString.call(item);\n}\n__name(toString, \"toString\");\nfunction isIterable(obj) {\n  return !!obj && typeof obj[Symbol.iterator] === \"function\";\n}\n__name(isIterable, \"isIterable\");\nvar EMPTY_STREAM = new StreamImpl(() => void 0, () => DONE_RESULT);\nvar DONE_RESULT = Object.freeze({ done: true, value: void 0 });\nfunction stream(...collections) {\n  if (collections.length === 1) {\n    const collection = collections[0];\n    if (collection instanceof StreamImpl) {\n      return collection;\n    }\n    if (isIterable(collection)) {\n      return new StreamImpl(() => collection[Symbol.iterator](), (iterator) => iterator.next());\n    }\n    if (typeof collection.length === \"number\") {\n      return new StreamImpl(() => ({ index: 0 }), (state) => {\n        if (state.index < collection.length) {\n          return { done: false, value: collection[state.index++] };\n        } else {\n          return DONE_RESULT;\n        }\n      });\n    }\n  }\n  if (collections.length > 1) {\n    return new StreamImpl(() => ({ collIndex: 0, arrIndex: 0 }), (state) => {\n      do {\n        if (state.iterator) {\n          const next = state.iterator.next();\n          if (!next.done) {\n            return next;\n          }\n          state.iterator = void 0;\n        }\n        if (state.array) {\n          if (state.arrIndex < state.array.length) {\n            return { done: false, value: state.array[state.arrIndex++] };\n          }\n          state.array = void 0;\n          state.arrIndex = 0;\n        }\n        if (state.collIndex < collections.length) {\n          const collection = collections[state.collIndex++];\n          if (isIterable(collection)) {\n            state.iterator = collection[Symbol.iterator]();\n          } else if (collection && typeof collection.length === \"number\") {\n            state.array = collection;\n          }\n        }\n      } while (state.iterator || state.array || state.collIndex < collections.length);\n      return DONE_RESULT;\n    });\n  }\n  return EMPTY_STREAM;\n}\n__name(stream, \"stream\");\nvar TreeStreamImpl = class extends StreamImpl {\n  static {\n    __name(this, \"TreeStreamImpl\");\n  }\n  constructor(root, children, options) {\n    super(() => ({\n      iterators: (options === null || options === void 0 ? void 0 : options.includeRoot) ? [[root][Symbol.iterator]()] : [children(root)[Symbol.iterator]()],\n      pruned: false\n    }), (state) => {\n      if (state.pruned) {\n        state.iterators.pop();\n        state.pruned = false;\n      }\n      while (state.iterators.length > 0) {\n        const iterator = state.iterators[state.iterators.length - 1];\n        const next = iterator.next();\n        if (next.done) {\n          state.iterators.pop();\n        } else {\n          state.iterators.push(children(next.value)[Symbol.iterator]());\n          return next;\n        }\n      }\n      return DONE_RESULT;\n    });\n  }\n  iterator() {\n    const iterator = {\n      state: this.startFn(),\n      next: /* @__PURE__ */ __name(() => this.nextFn(iterator.state), \"next\"),\n      prune: /* @__PURE__ */ __name(() => {\n        iterator.state.pruned = true;\n      }, \"prune\"),\n      [Symbol.iterator]: () => iterator\n    };\n    return iterator;\n  }\n};\nvar Reduction;\n(function(Reduction2) {\n  function sum(stream2) {\n    return stream2.reduce((a, b) => a + b, 0);\n  }\n  __name(sum, \"sum\");\n  Reduction2.sum = sum;\n  function product(stream2) {\n    return stream2.reduce((a, b) => a * b, 0);\n  }\n  __name(product, \"product\");\n  Reduction2.product = product;\n  function min(stream2) {\n    return stream2.reduce((a, b) => Math.min(a, b));\n  }\n  __name(min, \"min\");\n  Reduction2.min = min;\n  function max(stream2) {\n    return stream2.reduce((a, b) => Math.max(a, b));\n  }\n  __name(max, \"max\");\n  Reduction2.max = max;\n})(Reduction || (Reduction = {}));\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/cst-utils.js\nfunction streamCst(node) {\n  return new TreeStreamImpl(node, (element) => {\n    if (isCompositeCstNode(element)) {\n      return element.content;\n    } else {\n      return [];\n    }\n  }, { includeRoot: true });\n}\n__name(streamCst, \"streamCst\");\nfunction flattenCst(node) {\n  return streamCst(node).filter(isLeafCstNode);\n}\n__name(flattenCst, \"flattenCst\");\nfunction isChildNode(child, parent) {\n  while (child.container) {\n    child = child.container;\n    if (child === parent) {\n      return true;\n    }\n  }\n  return false;\n}\n__name(isChildNode, \"isChildNode\");\nfunction tokenToRange(token) {\n  return {\n    start: {\n      character: token.startColumn - 1,\n      line: token.startLine - 1\n    },\n    end: {\n      character: token.endColumn,\n      line: token.endLine - 1\n    }\n  };\n}\n__name(tokenToRange, \"tokenToRange\");\nfunction toDocumentSegment(node) {\n  if (!node) {\n    return void 0;\n  }\n  const { offset, end, range } = node;\n  return {\n    range,\n    offset,\n    end,\n    length: end - offset\n  };\n}\n__name(toDocumentSegment, \"toDocumentSegment\");\nvar RangeComparison;\n(function(RangeComparison2) {\n  RangeComparison2[RangeComparison2[\"Before\"] = 0] = \"Before\";\n  RangeComparison2[RangeComparison2[\"After\"] = 1] = \"After\";\n  RangeComparison2[RangeComparison2[\"OverlapFront\"] = 2] = \"OverlapFront\";\n  RangeComparison2[RangeComparison2[\"OverlapBack\"] = 3] = \"OverlapBack\";\n  RangeComparison2[RangeComparison2[\"Inside\"] = 4] = \"Inside\";\n})(RangeComparison || (RangeComparison = {}));\nfunction compareRange(range, to) {\n  if (range.end.line < to.start.line || range.end.line === to.start.line && range.end.character < range.start.character) {\n    return RangeComparison.Before;\n  } else if (range.start.line > to.end.line || range.start.line === to.end.line && range.start.character > to.end.character) {\n    return RangeComparison.After;\n  }\n  const startInside = range.start.line > to.start.line || range.start.line === to.start.line && range.start.character >= to.start.character;\n  const endInside = range.end.line < to.end.line || range.end.line === to.end.line && range.end.character <= to.end.character;\n  if (startInside && endInside) {\n    return RangeComparison.Inside;\n  } else if (startInside) {\n    return RangeComparison.OverlapBack;\n  } else {\n    return RangeComparison.OverlapFront;\n  }\n}\n__name(compareRange, \"compareRange\");\nfunction inRange(range, to) {\n  const comparison = compareRange(range, to);\n  return comparison > RangeComparison.After;\n}\n__name(inRange, \"inRange\");\nvar DefaultNameRegexp = /^[\\w\\p{L}]$/u;\nfunction findDeclarationNodeAtOffset(cstNode, offset, nameRegexp = DefaultNameRegexp) {\n  if (cstNode) {\n    if (offset > 0) {\n      const localOffset = offset - cstNode.offset;\n      const textAtOffset = cstNode.text.charAt(localOffset);\n      if (!nameRegexp.test(textAtOffset)) {\n        offset--;\n      }\n    }\n    return findLeafNodeAtOffset(cstNode, offset);\n  }\n  return void 0;\n}\n__name(findDeclarationNodeAtOffset, \"findDeclarationNodeAtOffset\");\nfunction findCommentNode(cstNode, commentNames) {\n  if (cstNode) {\n    const previous = getPreviousNode(cstNode, true);\n    if (previous && isCommentNode(previous, commentNames)) {\n      return previous;\n    }\n    if (isRootCstNode(cstNode)) {\n      const endIndex = cstNode.content.findIndex((e) => !e.hidden);\n      for (let i = endIndex - 1; i >= 0; i--) {\n        const child = cstNode.content[i];\n        if (isCommentNode(child, commentNames)) {\n          return child;\n        }\n      }\n    }\n  }\n  return void 0;\n}\n__name(findCommentNode, \"findCommentNode\");\nfunction isCommentNode(cstNode, commentNames) {\n  return isLeafCstNode(cstNode) && commentNames.includes(cstNode.tokenType.name);\n}\n__name(isCommentNode, \"isCommentNode\");\nfunction findLeafNodeAtOffset(node, offset) {\n  if (isLeafCstNode(node)) {\n    return node;\n  } else if (isCompositeCstNode(node)) {\n    const searchResult = binarySearch(node, offset, false);\n    if (searchResult) {\n      return findLeafNodeAtOffset(searchResult, offset);\n    }\n  }\n  return void 0;\n}\n__name(findLeafNodeAtOffset, \"findLeafNodeAtOffset\");\nfunction findLeafNodeBeforeOffset(node, offset) {\n  if (isLeafCstNode(node)) {\n    return node;\n  } else if (isCompositeCstNode(node)) {\n    const searchResult = binarySearch(node, offset, true);\n    if (searchResult) {\n      return findLeafNodeBeforeOffset(searchResult, offset);\n    }\n  }\n  return void 0;\n}\n__name(findLeafNodeBeforeOffset, \"findLeafNodeBeforeOffset\");\nfunction binarySearch(node, offset, closest) {\n  let left = 0;\n  let right = node.content.length - 1;\n  let closestNode = void 0;\n  while (left <= right) {\n    const middle = Math.floor((left + right) / 2);\n    const middleNode = node.content[middle];\n    if (middleNode.offset <= offset && middleNode.end > offset) {\n      return middleNode;\n    }\n    if (middleNode.end <= offset) {\n      closestNode = closest ? middleNode : void 0;\n      left = middle + 1;\n    } else {\n      right = middle - 1;\n    }\n  }\n  return closestNode;\n}\n__name(binarySearch, \"binarySearch\");\nfunction getPreviousNode(node, hidden = true) {\n  while (node.container) {\n    const parent = node.container;\n    let index = parent.content.indexOf(node);\n    while (index > 0) {\n      index--;\n      const previous = parent.content[index];\n      if (hidden || !previous.hidden) {\n        return previous;\n      }\n    }\n    node = parent;\n  }\n  return void 0;\n}\n__name(getPreviousNode, \"getPreviousNode\");\nfunction getNextNode(node, hidden = true) {\n  while (node.container) {\n    const parent = node.container;\n    let index = parent.content.indexOf(node);\n    const last = parent.content.length - 1;\n    while (index < last) {\n      index++;\n      const next = parent.content[index];\n      if (hidden || !next.hidden) {\n        return next;\n      }\n    }\n    node = parent;\n  }\n  return void 0;\n}\n__name(getNextNode, \"getNextNode\");\nfunction getStartlineNode(node) {\n  if (node.range.start.character === 0) {\n    return node;\n  }\n  const line = node.range.start.line;\n  let last = node;\n  let index;\n  while (node.container) {\n    const parent = node.container;\n    const selfIndex = index !== null && index !== void 0 ? index : parent.content.indexOf(node);\n    if (selfIndex === 0) {\n      node = parent;\n      index = void 0;\n    } else {\n      index = selfIndex - 1;\n      node = parent.content[index];\n    }\n    if (node.range.start.line !== line) {\n      break;\n    }\n    last = node;\n  }\n  return last;\n}\n__name(getStartlineNode, \"getStartlineNode\");\nfunction getInteriorNodes(start, end) {\n  const commonParent = getCommonParent(start, end);\n  if (!commonParent) {\n    return [];\n  }\n  return commonParent.parent.content.slice(commonParent.a + 1, commonParent.b);\n}\n__name(getInteriorNodes, \"getInteriorNodes\");\nfunction getCommonParent(a, b) {\n  const aParents = getParentChain(a);\n  const bParents = getParentChain(b);\n  let current;\n  for (let i = 0; i < aParents.length && i < bParents.length; i++) {\n    const aParent = aParents[i];\n    const bParent = bParents[i];\n    if (aParent.parent === bParent.parent) {\n      current = {\n        parent: aParent.parent,\n        a: aParent.index,\n        b: bParent.index\n      };\n    } else {\n      break;\n    }\n  }\n  return current;\n}\n__name(getCommonParent, \"getCommonParent\");\nfunction getParentChain(node) {\n  const chain = [];\n  while (node.container) {\n    const parent = node.container;\n    const index = parent.content.indexOf(node);\n    chain.push({\n      parent,\n      index\n    });\n    node = parent;\n  }\n  return chain.reverse();\n}\n__name(getParentChain, \"getParentChain\");\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/grammar-utils.js\nvar grammar_utils_exports = {};\n__export(grammar_utils_exports, {\n  findAssignment: () => findAssignment,\n  findNameAssignment: () => findNameAssignment,\n  findNodeForKeyword: () => findNodeForKeyword,\n  findNodeForProperty: () => findNodeForProperty,\n  findNodesForKeyword: () => findNodesForKeyword,\n  findNodesForKeywordInternal: () => findNodesForKeywordInternal,\n  findNodesForProperty: () => findNodesForProperty,\n  getActionAtElement: () => getActionAtElement,\n  getActionType: () => getActionType,\n  getAllReachableRules: () => getAllReachableRules,\n  getCrossReferenceTerminal: () => getCrossReferenceTerminal,\n  getEntryRule: () => getEntryRule,\n  getExplicitRuleType: () => getExplicitRuleType,\n  getHiddenRules: () => getHiddenRules,\n  getRuleType: () => getRuleType,\n  getTypeName: () => getTypeName,\n  isArrayCardinality: () => isArrayCardinality,\n  isArrayOperator: () => isArrayOperator,\n  isCommentTerminal: () => isCommentTerminal,\n  isDataType: () => isDataType,\n  isDataTypeRule: () => isDataTypeRule,\n  isOptionalCardinality: () => isOptionalCardinality,\n  terminalRegex: () => terminalRegex\n});\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/errors.js\nvar ErrorWithLocation = class extends Error {\n  static {\n    __name(this, \"ErrorWithLocation\");\n  }\n  constructor(node, message) {\n    super(node ? `${message} at ${node.range.start.line}:${node.range.start.character}` : message);\n  }\n};\nfunction assertUnreachable(_) {\n  throw new Error(\"Error! The input value was not handled.\");\n}\n__name(assertUnreachable, \"assertUnreachable\");\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/languages/generated/ast.js\nvar ast_exports = {};\n__export(ast_exports, {\n  AbstractElement: () => AbstractElement,\n  AbstractRule: () => AbstractRule,\n  AbstractType: () => AbstractType,\n  Action: () => Action,\n  Alternatives: () => Alternatives,\n  ArrayLiteral: () => ArrayLiteral,\n  ArrayType: () => ArrayType,\n  Assignment: () => Assignment,\n  BooleanLiteral: () => BooleanLiteral,\n  CharacterRange: () => CharacterRange,\n  Condition: () => Condition,\n  Conjunction: () => Conjunction,\n  CrossReference: () => CrossReference,\n  Disjunction: () => Disjunction,\n  EndOfFile: () => EndOfFile,\n  Grammar: () => Grammar,\n  GrammarImport: () => GrammarImport,\n  Group: () => Group,\n  InferredType: () => InferredType,\n  Interface: () => Interface,\n  Keyword: () => Keyword,\n  LangiumGrammarAstReflection: () => LangiumGrammarAstReflection,\n  LangiumGrammarTerminals: () => LangiumGrammarTerminals,\n  NamedArgument: () => NamedArgument,\n  NegatedToken: () => NegatedToken,\n  Negation: () => Negation,\n  NumberLiteral: () => NumberLiteral,\n  Parameter: () => Parameter,\n  ParameterReference: () => ParameterReference,\n  ParserRule: () => ParserRule,\n  ReferenceType: () => ReferenceType,\n  RegexToken: () => RegexToken,\n  ReturnType: () => ReturnType,\n  RuleCall: () => RuleCall,\n  SimpleType: () => SimpleType,\n  StringLiteral: () => StringLiteral,\n  TerminalAlternatives: () => TerminalAlternatives,\n  TerminalGroup: () => TerminalGroup,\n  TerminalRule: () => TerminalRule,\n  TerminalRuleCall: () => TerminalRuleCall,\n  Type: () => Type,\n  TypeAttribute: () => TypeAttribute,\n  TypeDefinition: () => TypeDefinition,\n  UnionType: () => UnionType,\n  UnorderedGroup: () => UnorderedGroup,\n  UntilToken: () => UntilToken,\n  ValueLiteral: () => ValueLiteral,\n  Wildcard: () => Wildcard,\n  isAbstractElement: () => isAbstractElement,\n  isAbstractRule: () => isAbstractRule,\n  isAbstractType: () => isAbstractType,\n  isAction: () => isAction,\n  isAlternatives: () => isAlternatives,\n  isArrayLiteral: () => isArrayLiteral,\n  isArrayType: () => isArrayType,\n  isAssignment: () => isAssignment,\n  isBooleanLiteral: () => isBooleanLiteral,\n  isCharacterRange: () => isCharacterRange,\n  isCondition: () => isCondition,\n  isConjunction: () => isConjunction,\n  isCrossReference: () => isCrossReference,\n  isDisjunction: () => isDisjunction,\n  isEndOfFile: () => isEndOfFile,\n  isFeatureName: () => isFeatureName,\n  isGrammar: () => isGrammar,\n  isGrammarImport: () => isGrammarImport,\n  isGroup: () => isGroup,\n  isInferredType: () => isInferredType,\n  isInterface: () => isInterface,\n  isKeyword: () => isKeyword,\n  isNamedArgument: () => isNamedArgument,\n  isNegatedToken: () => isNegatedToken,\n  isNegation: () => isNegation,\n  isNumberLiteral: () => isNumberLiteral,\n  isParameter: () => isParameter,\n  isParameterReference: () => isParameterReference,\n  isParserRule: () => isParserRule,\n  isPrimitiveType: () => isPrimitiveType,\n  isReferenceType: () => isReferenceType,\n  isRegexToken: () => isRegexToken,\n  isReturnType: () => isReturnType,\n  isRuleCall: () => isRuleCall,\n  isSimpleType: () => isSimpleType,\n  isStringLiteral: () => isStringLiteral,\n  isTerminalAlternatives: () => isTerminalAlternatives,\n  isTerminalGroup: () => isTerminalGroup,\n  isTerminalRule: () => isTerminalRule,\n  isTerminalRuleCall: () => isTerminalRuleCall,\n  isType: () => isType,\n  isTypeAttribute: () => isTypeAttribute,\n  isTypeDefinition: () => isTypeDefinition,\n  isUnionType: () => isUnionType,\n  isUnorderedGroup: () => isUnorderedGroup,\n  isUntilToken: () => isUntilToken,\n  isValueLiteral: () => isValueLiteral,\n  isWildcard: () => isWildcard,\n  reflection: () => reflection\n});\nvar LangiumGrammarTerminals = {\n  ID: /\\^?[_a-zA-Z][\\w_]*/,\n  STRING: /\"(\\\\.|[^\"\\\\])*\"|'(\\\\.|[^'\\\\])*'/,\n  NUMBER: /NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity)/,\n  RegexLiteral: /\\/(?![*+?])(?:[^\\r\\n\\[/\\\\]|\\\\.|\\[(?:[^\\r\\n\\]\\\\]|\\\\.)*\\])+\\/[a-z]*/,\n  WS: /\\s+/,\n  ML_COMMENT: /\\/\\*[\\s\\S]*?\\*\\//,\n  SL_COMMENT: /\\/\\/[^\\n\\r]*/\n};\nvar AbstractRule = \"AbstractRule\";\nfunction isAbstractRule(item) {\n  return reflection.isInstance(item, AbstractRule);\n}\n__name(isAbstractRule, \"isAbstractRule\");\nvar AbstractType = \"AbstractType\";\nfunction isAbstractType(item) {\n  return reflection.isInstance(item, AbstractType);\n}\n__name(isAbstractType, \"isAbstractType\");\nvar Condition = \"Condition\";\nfunction isCondition(item) {\n  return reflection.isInstance(item, Condition);\n}\n__name(isCondition, \"isCondition\");\nfunction isFeatureName(item) {\n  return isPrimitiveType(item) || item === \"current\" || item === \"entry\" || item === \"extends\" || item === \"false\" || item === \"fragment\" || item === \"grammar\" || item === \"hidden\" || item === \"import\" || item === \"interface\" || item === \"returns\" || item === \"terminal\" || item === \"true\" || item === \"type\" || item === \"infer\" || item === \"infers\" || item === \"with\" || typeof item === \"string\" && /\\^?[_a-zA-Z][\\w_]*/.test(item);\n}\n__name(isFeatureName, \"isFeatureName\");\nfunction isPrimitiveType(item) {\n  return item === \"string\" || item === \"number\" || item === \"boolean\" || item === \"Date\" || item === \"bigint\";\n}\n__name(isPrimitiveType, \"isPrimitiveType\");\nvar TypeDefinition = \"TypeDefinition\";\nfunction isTypeDefinition(item) {\n  return reflection.isInstance(item, TypeDefinition);\n}\n__name(isTypeDefinition, \"isTypeDefinition\");\nvar ValueLiteral = \"ValueLiteral\";\nfunction isValueLiteral(item) {\n  return reflection.isInstance(item, ValueLiteral);\n}\n__name(isValueLiteral, \"isValueLiteral\");\nvar AbstractElement = \"AbstractElement\";\nfunction isAbstractElement(item) {\n  return reflection.isInstance(item, AbstractElement);\n}\n__name(isAbstractElement, \"isAbstractElement\");\nvar ArrayLiteral = \"ArrayLiteral\";\nfunction isArrayLiteral(item) {\n  return reflection.isInstance(item, ArrayLiteral);\n}\n__name(isArrayLiteral, \"isArrayLiteral\");\nvar ArrayType = \"ArrayType\";\nfunction isArrayType(item) {\n  return reflection.isInstance(item, ArrayType);\n}\n__name(isArrayType, \"isArrayType\");\nvar BooleanLiteral = \"BooleanLiteral\";\nfunction isBooleanLiteral(item) {\n  return reflection.isInstance(item, BooleanLiteral);\n}\n__name(isBooleanLiteral, \"isBooleanLiteral\");\nvar Conjunction = \"Conjunction\";\nfunction isConjunction(item) {\n  return reflection.isInstance(item, Conjunction);\n}\n__name(isConjunction, \"isConjunction\");\nvar Disjunction = \"Disjunction\";\nfunction isDisjunction(item) {\n  return reflection.isInstance(item, Disjunction);\n}\n__name(isDisjunction, \"isDisjunction\");\nvar Grammar = \"Grammar\";\nfunction isGrammar(item) {\n  return reflection.isInstance(item, Grammar);\n}\n__name(isGrammar, \"isGrammar\");\nvar GrammarImport = \"GrammarImport\";\nfunction isGrammarImport(item) {\n  return reflection.isInstance(item, GrammarImport);\n}\n__name(isGrammarImport, \"isGrammarImport\");\nvar InferredType = \"InferredType\";\nfunction isInferredType(item) {\n  return reflection.isInstance(item, InferredType);\n}\n__name(isInferredType, \"isInferredType\");\nvar Interface = \"Interface\";\nfunction isInterface(item) {\n  return reflection.isInstance(item, Interface);\n}\n__name(isInterface, \"isInterface\");\nvar NamedArgument = \"NamedArgument\";\nfunction isNamedArgument(item) {\n  return reflection.isInstance(item, NamedArgument);\n}\n__name(isNamedArgument, \"isNamedArgument\");\nvar Negation = \"Negation\";\nfunction isNegation(item) {\n  return reflection.isInstance(item, Negation);\n}\n__name(isNegation, \"isNegation\");\nvar NumberLiteral = \"NumberLiteral\";\nfunction isNumberLiteral(item) {\n  return reflection.isInstance(item, NumberLiteral);\n}\n__name(isNumberLiteral, \"isNumberLiteral\");\nvar Parameter = \"Parameter\";\nfunction isParameter(item) {\n  return reflection.isInstance(item, Parameter);\n}\n__name(isParameter, \"isParameter\");\nvar ParameterReference = \"ParameterReference\";\nfunction isParameterReference(item) {\n  return reflection.isInstance(item, ParameterReference);\n}\n__name(isParameterReference, \"isParameterReference\");\nvar ParserRule = \"ParserRule\";\nfunction isParserRule(item) {\n  return reflection.isInstance(item, ParserRule);\n}\n__name(isParserRule, \"isParserRule\");\nvar ReferenceType = \"ReferenceType\";\nfunction isReferenceType(item) {\n  return reflection.isInstance(item, ReferenceType);\n}\n__name(isReferenceType, \"isReferenceType\");\nvar ReturnType = \"ReturnType\";\nfunction isReturnType(item) {\n  return reflection.isInstance(item, ReturnType);\n}\n__name(isReturnType, \"isReturnType\");\nvar SimpleType = \"SimpleType\";\nfunction isSimpleType(item) {\n  return reflection.isInstance(item, SimpleType);\n}\n__name(isSimpleType, \"isSimpleType\");\nvar StringLiteral = \"StringLiteral\";\nfunction isStringLiteral(item) {\n  return reflection.isInstance(item, StringLiteral);\n}\n__name(isStringLiteral, \"isStringLiteral\");\nvar TerminalRule = \"TerminalRule\";\nfunction isTerminalRule(item) {\n  return reflection.isInstance(item, TerminalRule);\n}\n__name(isTerminalRule, \"isTerminalRule\");\nvar Type = \"Type\";\nfunction isType(item) {\n  return reflection.isInstance(item, Type);\n}\n__name(isType, \"isType\");\nvar TypeAttribute = \"TypeAttribute\";\nfunction isTypeAttribute(item) {\n  return reflection.isInstance(item, TypeAttribute);\n}\n__name(isTypeAttribute, \"isTypeAttribute\");\nvar UnionType = \"UnionType\";\nfunction isUnionType(item) {\n  return reflection.isInstance(item, UnionType);\n}\n__name(isUnionType, \"isUnionType\");\nvar Action = \"Action\";\nfunction isAction(item) {\n  return reflection.isInstance(item, Action);\n}\n__name(isAction, \"isAction\");\nvar Alternatives = \"Alternatives\";\nfunction isAlternatives(item) {\n  return reflection.isInstance(item, Alternatives);\n}\n__name(isAlternatives, \"isAlternatives\");\nvar Assignment = \"Assignment\";\nfunction isAssignment(item) {\n  return reflection.isInstance(item, Assignment);\n}\n__name(isAssignment, \"isAssignment\");\nvar CharacterRange = \"CharacterRange\";\nfunction isCharacterRange(item) {\n  return reflection.isInstance(item, CharacterRange);\n}\n__name(isCharacterRange, \"isCharacterRange\");\nvar CrossReference = \"CrossReference\";\nfunction isCrossReference(item) {\n  return reflection.isInstance(item, CrossReference);\n}\n__name(isCrossReference, \"isCrossReference\");\nvar EndOfFile = \"EndOfFile\";\nfunction isEndOfFile(item) {\n  return reflection.isInstance(item, EndOfFile);\n}\n__name(isEndOfFile, \"isEndOfFile\");\nvar Group = \"Group\";\nfunction isGroup(item) {\n  return reflection.isInstance(item, Group);\n}\n__name(isGroup, \"isGroup\");\nvar Keyword = \"Keyword\";\nfunction isKeyword(item) {\n  return reflection.isInstance(item, Keyword);\n}\n__name(isKeyword, \"isKeyword\");\nvar NegatedToken = \"NegatedToken\";\nfunction isNegatedToken(item) {\n  return reflection.isInstance(item, NegatedToken);\n}\n__name(isNegatedToken, \"isNegatedToken\");\nvar RegexToken = \"RegexToken\";\nfunction isRegexToken(item) {\n  return reflection.isInstance(item, RegexToken);\n}\n__name(isRegexToken, \"isRegexToken\");\nvar RuleCall = \"RuleCall\";\nfunction isRuleCall(item) {\n  return reflection.isInstance(item, RuleCall);\n}\n__name(isRuleCall, \"isRuleCall\");\nvar TerminalAlternatives = \"TerminalAlternatives\";\nfunction isTerminalAlternatives(item) {\n  return reflection.isInstance(item, TerminalAlternatives);\n}\n__name(isTerminalAlternatives, \"isTerminalAlternatives\");\nvar TerminalGroup = \"TerminalGroup\";\nfunction isTerminalGroup(item) {\n  return reflection.isInstance(item, TerminalGroup);\n}\n__name(isTerminalGroup, \"isTerminalGroup\");\nvar TerminalRuleCall = \"TerminalRuleCall\";\nfunction isTerminalRuleCall(item) {\n  return reflection.isInstance(item, TerminalRuleCall);\n}\n__name(isTerminalRuleCall, \"isTerminalRuleCall\");\nvar UnorderedGroup = \"UnorderedGroup\";\nfunction isUnorderedGroup(item) {\n  return reflection.isInstance(item, UnorderedGroup);\n}\n__name(isUnorderedGroup, \"isUnorderedGroup\");\nvar UntilToken = \"UntilToken\";\nfunction isUntilToken(item) {\n  return reflection.isInstance(item, UntilToken);\n}\n__name(isUntilToken, \"isUntilToken\");\nvar Wildcard = \"Wildcard\";\nfunction isWildcard(item) {\n  return reflection.isInstance(item, Wildcard);\n}\n__name(isWildcard, \"isWildcard\");\nvar LangiumGrammarAstReflection = class extends AbstractAstReflection {\n  static {\n    __name(this, \"LangiumGrammarAstReflection\");\n  }\n  getAllTypes() {\n    return [\"AbstractElement\", \"AbstractRule\", \"AbstractType\", \"Action\", \"Alternatives\", \"ArrayLiteral\", \"ArrayType\", \"Assignment\", \"BooleanLiteral\", \"CharacterRange\", \"Condition\", \"Conjunction\", \"CrossReference\", \"Disjunction\", \"EndOfFile\", \"Grammar\", \"GrammarImport\", \"Group\", \"InferredType\", \"Interface\", \"Keyword\", \"NamedArgument\", \"NegatedToken\", \"Negation\", \"NumberLiteral\", \"Parameter\", \"ParameterReference\", \"ParserRule\", \"ReferenceType\", \"RegexToken\", \"ReturnType\", \"RuleCall\", \"SimpleType\", \"StringLiteral\", \"TerminalAlternatives\", \"TerminalGroup\", \"TerminalRule\", \"TerminalRuleCall\", \"Type\", \"TypeAttribute\", \"TypeDefinition\", \"UnionType\", \"UnorderedGroup\", \"UntilToken\", \"ValueLiteral\", \"Wildcard\"];\n  }\n  computeIsSubtype(subtype, supertype) {\n    switch (subtype) {\n      case Action:\n      case Alternatives:\n      case Assignment:\n      case CharacterRange:\n      case CrossReference:\n      case EndOfFile:\n      case Group:\n      case Keyword:\n      case NegatedToken:\n      case RegexToken:\n      case RuleCall:\n      case TerminalAlternatives:\n      case TerminalGroup:\n      case TerminalRuleCall:\n      case UnorderedGroup:\n      case UntilToken:\n      case Wildcard: {\n        return this.isSubtype(AbstractElement, supertype);\n      }\n      case ArrayLiteral:\n      case NumberLiteral:\n      case StringLiteral: {\n        return this.isSubtype(ValueLiteral, supertype);\n      }\n      case ArrayType:\n      case ReferenceType:\n      case SimpleType:\n      case UnionType: {\n        return this.isSubtype(TypeDefinition, supertype);\n      }\n      case BooleanLiteral: {\n        return this.isSubtype(Condition, supertype) || this.isSubtype(ValueLiteral, supertype);\n      }\n      case Conjunction:\n      case Disjunction:\n      case Negation:\n      case ParameterReference: {\n        return this.isSubtype(Condition, supertype);\n      }\n      case InferredType:\n      case Interface:\n      case Type: {\n        return this.isSubtype(AbstractType, supertype);\n      }\n      case ParserRule: {\n        return this.isSubtype(AbstractRule, supertype) || this.isSubtype(AbstractType, supertype);\n      }\n      case TerminalRule: {\n        return this.isSubtype(AbstractRule, supertype);\n      }\n      default: {\n        return false;\n      }\n    }\n  }\n  getReferenceType(refInfo) {\n    const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n    switch (referenceId) {\n      case \"Action:type\":\n      case \"CrossReference:type\":\n      case \"Interface:superTypes\":\n      case \"ParserRule:returnType\":\n      case \"SimpleType:typeRef\": {\n        return AbstractType;\n      }\n      case \"Grammar:hiddenTokens\":\n      case \"ParserRule:hiddenTokens\":\n      case \"RuleCall:rule\": {\n        return AbstractRule;\n      }\n      case \"Grammar:usedGrammars\": {\n        return Grammar;\n      }\n      case \"NamedArgument:parameter\":\n      case \"ParameterReference:parameter\": {\n        return Parameter;\n      }\n      case \"TerminalRuleCall:rule\": {\n        return TerminalRule;\n      }\n      default: {\n        throw new Error(`${referenceId} is not a valid reference id.`);\n      }\n    }\n  }\n  getTypeMetaData(type) {\n    switch (type) {\n      case \"AbstractElement\": {\n        return {\n          name: \"AbstractElement\",\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"lookahead\" }\n          ]\n        };\n      }\n      case \"ArrayLiteral\": {\n        return {\n          name: \"ArrayLiteral\",\n          properties: [\n            { name: \"elements\", defaultValue: [] }\n          ]\n        };\n      }\n      case \"ArrayType\": {\n        return {\n          name: \"ArrayType\",\n          properties: [\n            { name: \"elementType\" }\n          ]\n        };\n      }\n      case \"BooleanLiteral\": {\n        return {\n          name: \"BooleanLiteral\",\n          properties: [\n            { name: \"true\", defaultValue: false }\n          ]\n        };\n      }\n      case \"Conjunction\": {\n        return {\n          name: \"Conjunction\",\n          properties: [\n            { name: \"left\" },\n            { name: \"right\" }\n          ]\n        };\n      }\n      case \"Disjunction\": {\n        return {\n          name: \"Disjunction\",\n          properties: [\n            { name: \"left\" },\n            { name: \"right\" }\n          ]\n        };\n      }\n      case \"Grammar\": {\n        return {\n          name: \"Grammar\",\n          properties: [\n            { name: \"definesHiddenTokens\", defaultValue: false },\n            { name: \"hiddenTokens\", defaultValue: [] },\n            { name: \"imports\", defaultValue: [] },\n            { name: \"interfaces\", defaultValue: [] },\n            { name: \"isDeclared\", defaultValue: false },\n            { name: \"name\" },\n            { name: \"rules\", defaultValue: [] },\n            { name: \"types\", defaultValue: [] },\n            { name: \"usedGrammars\", defaultValue: [] }\n          ]\n        };\n      }\n      case \"GrammarImport\": {\n        return {\n          name: \"GrammarImport\",\n          properties: [\n            { name: \"path\" }\n          ]\n        };\n      }\n      case \"InferredType\": {\n        return {\n          name: \"InferredType\",\n          properties: [\n            { name: \"name\" }\n          ]\n        };\n      }\n      case \"Interface\": {\n        return {\n          name: \"Interface\",\n          properties: [\n            { name: \"attributes\", defaultValue: [] },\n            { name: \"name\" },\n            { name: \"superTypes\", defaultValue: [] }\n          ]\n        };\n      }\n      case \"NamedArgument\": {\n        return {\n          name: \"NamedArgument\",\n          properties: [\n            { name: \"calledByName\", defaultValue: false },\n            { name: \"parameter\" },\n            { name: \"value\" }\n          ]\n        };\n      }\n      case \"Negation\": {\n        return {\n          name: \"Negation\",\n          properties: [\n            { name: \"value\" }\n          ]\n        };\n      }\n      case \"NumberLiteral\": {\n        return {\n          name: \"NumberLiteral\",\n          properties: [\n            { name: \"value\" }\n          ]\n        };\n      }\n      case \"Parameter\": {\n        return {\n          name: \"Parameter\",\n          properties: [\n            { name: \"name\" }\n          ]\n        };\n      }\n      case \"ParameterReference\": {\n        return {\n          name: \"ParameterReference\",\n          properties: [\n            { name: \"parameter\" }\n          ]\n        };\n      }\n      case \"ParserRule\": {\n        return {\n          name: \"ParserRule\",\n          properties: [\n            { name: \"dataType\" },\n            { name: \"definesHiddenTokens\", defaultValue: false },\n            { name: \"definition\" },\n            { name: \"entry\", defaultValue: false },\n            { name: \"fragment\", defaultValue: false },\n            { name: \"hiddenTokens\", defaultValue: [] },\n            { name: \"inferredType\" },\n            { name: \"name\" },\n            { name: \"parameters\", defaultValue: [] },\n            { name: \"returnType\" },\n            { name: \"wildcard\", defaultValue: false }\n          ]\n        };\n      }\n      case \"ReferenceType\": {\n        return {\n          name: \"ReferenceType\",\n          properties: [\n            { name: \"referenceType\" }\n          ]\n        };\n      }\n      case \"ReturnType\": {\n        return {\n          name: \"ReturnType\",\n          properties: [\n            { name: \"name\" }\n          ]\n        };\n      }\n      case \"SimpleType\": {\n        return {\n          name: \"SimpleType\",\n          properties: [\n            { name: \"primitiveType\" },\n            { name: \"stringType\" },\n            { name: \"typeRef\" }\n          ]\n        };\n      }\n      case \"StringLiteral\": {\n        return {\n          name: \"StringLiteral\",\n          properties: [\n            { name: \"value\" }\n          ]\n        };\n      }\n      case \"TerminalRule\": {\n        return {\n          name: \"TerminalRule\",\n          properties: [\n            { name: \"definition\" },\n            { name: \"fragment\", defaultValue: false },\n            { name: \"hidden\", defaultValue: false },\n            { name: \"name\" },\n            { name: \"type\" }\n          ]\n        };\n      }\n      case \"Type\": {\n        return {\n          name: \"Type\",\n          properties: [\n            { name: \"name\" },\n            { name: \"type\" }\n          ]\n        };\n      }\n      case \"TypeAttribute\": {\n        return {\n          name: \"TypeAttribute\",\n          properties: [\n            { name: \"defaultValue\" },\n            { name: \"isOptional\", defaultValue: false },\n            { name: \"name\" },\n            { name: \"type\" }\n          ]\n        };\n      }\n      case \"UnionType\": {\n        return {\n          name: \"UnionType\",\n          properties: [\n            { name: \"types\", defaultValue: [] }\n          ]\n        };\n      }\n      case \"Action\": {\n        return {\n          name: \"Action\",\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"feature\" },\n            { name: \"inferredType\" },\n            { name: \"lookahead\" },\n            { name: \"operator\" },\n            { name: \"type\" }\n          ]\n        };\n      }\n      case \"Alternatives\": {\n        return {\n          name: \"Alternatives\",\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"elements\", defaultValue: [] },\n            { name: \"lookahead\" }\n          ]\n        };\n      }\n      case \"Assignment\": {\n        return {\n          name: \"Assignment\",\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"feature\" },\n            { name: \"lookahead\" },\n            { name: \"operator\" },\n            { name: \"terminal\" }\n          ]\n        };\n      }\n      case \"CharacterRange\": {\n        return {\n          name: \"CharacterRange\",\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"left\" },\n            { name: \"lookahead\" },\n            { name: \"right\" }\n          ]\n        };\n      }\n      case \"CrossReference\": {\n        return {\n          name: \"CrossReference\",\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"deprecatedSyntax\", defaultValue: false },\n            { name: \"lookahead\" },\n            { name: \"terminal\" },\n            { name: \"type\" }\n          ]\n        };\n      }\n      case \"EndOfFile\": {\n        return {\n          name: \"EndOfFile\",\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"lookahead\" }\n          ]\n        };\n      }\n      case \"Group\": {\n        return {\n          name: \"Group\",\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"elements\", defaultValue: [] },\n            { name: \"guardCondition\" },\n            { name: \"lookahead\" }\n          ]\n        };\n      }\n      case \"Keyword\": {\n        return {\n          name: \"Keyword\",\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"lookahead\" },\n            { name: \"value\" }\n          ]\n        };\n      }\n      case \"NegatedToken\": {\n        return {\n          name: \"NegatedToken\",\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"lookahead\" },\n            { name: \"terminal\" }\n          ]\n        };\n      }\n      case \"RegexToken\": {\n        return {\n          name: \"RegexToken\",\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"lookahead\" },\n            { name: \"regex\" }\n          ]\n        };\n      }\n      case \"RuleCall\": {\n        return {\n          name: \"RuleCall\",\n          properties: [\n            { name: \"arguments\", defaultValue: [] },\n            { name: \"cardinality\" },\n            { name: \"lookahead\" },\n            { name: \"rule\" }\n          ]\n        };\n      }\n      case \"TerminalAlternatives\": {\n        return {\n          name: \"TerminalAlternatives\",\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"elements\", defaultValue: [] },\n            { name: \"lookahead\" }\n          ]\n        };\n      }\n      case \"TerminalGroup\": {\n        return {\n          name: \"TerminalGroup\",\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"elements\", defaultValue: [] },\n            { name: \"lookahead\" }\n          ]\n        };\n      }\n      case \"TerminalRuleCall\": {\n        return {\n          name: \"TerminalRuleCall\",\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"lookahead\" },\n            { name: \"rule\" }\n          ]\n        };\n      }\n      case \"UnorderedGroup\": {\n        return {\n          name: \"UnorderedGroup\",\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"elements\", defaultValue: [] },\n            { name: \"lookahead\" }\n          ]\n        };\n      }\n      case \"UntilToken\": {\n        return {\n          name: \"UntilToken\",\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"lookahead\" },\n            { name: \"terminal\" }\n          ]\n        };\n      }\n      case \"Wildcard\": {\n        return {\n          name: \"Wildcard\",\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"lookahead\" }\n          ]\n        };\n      }\n      default: {\n        return {\n          name: type,\n          properties: []\n        };\n      }\n    }\n  }\n};\nvar reflection = new LangiumGrammarAstReflection();\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/ast-utils.js\nvar ast_utils_exports = {};\n__export(ast_utils_exports, {\n  assignMandatoryProperties: () => assignMandatoryProperties,\n  copyAstNode: () => copyAstNode,\n  findLocalReferences: () => findLocalReferences,\n  findRootNode: () => findRootNode,\n  getContainerOfType: () => getContainerOfType,\n  getDocument: () => getDocument,\n  hasContainerOfType: () => hasContainerOfType,\n  linkContentToContainer: () => linkContentToContainer,\n  streamAllContents: () => streamAllContents,\n  streamAst: () => streamAst,\n  streamContents: () => streamContents,\n  streamReferences: () => streamReferences\n});\nfunction linkContentToContainer(node) {\n  for (const [name, value] of Object.entries(node)) {\n    if (!name.startsWith(\"$\")) {\n      if (Array.isArray(value)) {\n        value.forEach((item, index) => {\n          if (isAstNode(item)) {\n            item.$container = node;\n            item.$containerProperty = name;\n            item.$containerIndex = index;\n          }\n        });\n      } else if (isAstNode(value)) {\n        value.$container = node;\n        value.$containerProperty = name;\n      }\n    }\n  }\n}\n__name(linkContentToContainer, \"linkContentToContainer\");\nfunction getContainerOfType(node, typePredicate) {\n  let item = node;\n  while (item) {\n    if (typePredicate(item)) {\n      return item;\n    }\n    item = item.$container;\n  }\n  return void 0;\n}\n__name(getContainerOfType, \"getContainerOfType\");\nfunction hasContainerOfType(node, predicate) {\n  let item = node;\n  while (item) {\n    if (predicate(item)) {\n      return true;\n    }\n    item = item.$container;\n  }\n  return false;\n}\n__name(hasContainerOfType, \"hasContainerOfType\");\nfunction getDocument(node) {\n  const rootNode = findRootNode(node);\n  const result = rootNode.$document;\n  if (!result) {\n    throw new Error(\"AST node has no document.\");\n  }\n  return result;\n}\n__name(getDocument, \"getDocument\");\nfunction findRootNode(node) {\n  while (node.$container) {\n    node = node.$container;\n  }\n  return node;\n}\n__name(findRootNode, \"findRootNode\");\nfunction streamContents(node, options) {\n  if (!node) {\n    throw new Error(\"Node must be an AstNode.\");\n  }\n  const range = options === null || options === void 0 ? void 0 : options.range;\n  return new StreamImpl(() => ({\n    keys: Object.keys(node),\n    keyIndex: 0,\n    arrayIndex: 0\n  }), (state) => {\n    while (state.keyIndex < state.keys.length) {\n      const property = state.keys[state.keyIndex];\n      if (!property.startsWith(\"$\")) {\n        const value = node[property];\n        if (isAstNode(value)) {\n          state.keyIndex++;\n          if (isAstNodeInRange(value, range)) {\n            return { done: false, value };\n          }\n        } else if (Array.isArray(value)) {\n          while (state.arrayIndex < value.length) {\n            const index = state.arrayIndex++;\n            const element = value[index];\n            if (isAstNode(element) && isAstNodeInRange(element, range)) {\n              return { done: false, value: element };\n            }\n          }\n          state.arrayIndex = 0;\n        }\n      }\n      state.keyIndex++;\n    }\n    return DONE_RESULT;\n  });\n}\n__name(streamContents, \"streamContents\");\nfunction streamAllContents(root, options) {\n  if (!root) {\n    throw new Error(\"Root node must be an AstNode.\");\n  }\n  return new TreeStreamImpl(root, (node) => streamContents(node, options));\n}\n__name(streamAllContents, \"streamAllContents\");\nfunction streamAst(root, options) {\n  if (!root) {\n    throw new Error(\"Root node must be an AstNode.\");\n  } else if ((options === null || options === void 0 ? void 0 : options.range) && !isAstNodeInRange(root, options.range)) {\n    return new TreeStreamImpl(root, () => []);\n  }\n  return new TreeStreamImpl(root, (node) => streamContents(node, options), { includeRoot: true });\n}\n__name(streamAst, \"streamAst\");\nfunction isAstNodeInRange(astNode, range) {\n  var _a;\n  if (!range) {\n    return true;\n  }\n  const nodeRange = (_a = astNode.$cstNode) === null || _a === void 0 ? void 0 : _a.range;\n  if (!nodeRange) {\n    return false;\n  }\n  return inRange(nodeRange, range);\n}\n__name(isAstNodeInRange, \"isAstNodeInRange\");\nfunction streamReferences(node) {\n  return new StreamImpl(() => ({\n    keys: Object.keys(node),\n    keyIndex: 0,\n    arrayIndex: 0\n  }), (state) => {\n    while (state.keyIndex < state.keys.length) {\n      const property = state.keys[state.keyIndex];\n      if (!property.startsWith(\"$\")) {\n        const value = node[property];\n        if (isReference(value)) {\n          state.keyIndex++;\n          return { done: false, value: { reference: value, container: node, property } };\n        } else if (Array.isArray(value)) {\n          while (state.arrayIndex < value.length) {\n            const index = state.arrayIndex++;\n            const element = value[index];\n            if (isReference(element)) {\n              return { done: false, value: { reference: element, container: node, property, index } };\n            }\n          }\n          state.arrayIndex = 0;\n        }\n      }\n      state.keyIndex++;\n    }\n    return DONE_RESULT;\n  });\n}\n__name(streamReferences, \"streamReferences\");\nfunction findLocalReferences(targetNode, lookup = getDocument(targetNode).parseResult.value) {\n  const refs = [];\n  streamAst(lookup).forEach((node) => {\n    streamReferences(node).forEach((refInfo) => {\n      if (refInfo.reference.ref === targetNode) {\n        refs.push(refInfo.reference);\n      }\n    });\n  });\n  return stream(refs);\n}\n__name(findLocalReferences, \"findLocalReferences\");\nfunction assignMandatoryProperties(reflection3, node) {\n  const typeMetaData = reflection3.getTypeMetaData(node.$type);\n  const genericNode = node;\n  for (const property of typeMetaData.properties) {\n    if (property.defaultValue !== void 0 && genericNode[property.name] === void 0) {\n      genericNode[property.name] = copyDefaultValue(property.defaultValue);\n    }\n  }\n}\n__name(assignMandatoryProperties, \"assignMandatoryProperties\");\nfunction copyDefaultValue(propertyType) {\n  if (Array.isArray(propertyType)) {\n    return [...propertyType.map(copyDefaultValue)];\n  } else {\n    return propertyType;\n  }\n}\n__name(copyDefaultValue, \"copyDefaultValue\");\nfunction copyAstNode(node, buildReference) {\n  const copy = { $type: node.$type };\n  for (const [name, value] of Object.entries(node)) {\n    if (!name.startsWith(\"$\")) {\n      if (isAstNode(value)) {\n        copy[name] = copyAstNode(value, buildReference);\n      } else if (isReference(value)) {\n        copy[name] = buildReference(copy, name, value.$refNode, value.$refText);\n      } else if (Array.isArray(value)) {\n        const copiedArray = [];\n        for (const element of value) {\n          if (isAstNode(element)) {\n            copiedArray.push(copyAstNode(element, buildReference));\n          } else if (isReference(element)) {\n            copiedArray.push(buildReference(copy, name, element.$refNode, element.$refText));\n          } else {\n            copiedArray.push(element);\n          }\n        }\n        copy[name] = copiedArray;\n      } else {\n        copy[name] = value;\n      }\n    }\n  }\n  linkContentToContainer(copy);\n  return copy;\n}\n__name(copyAstNode, \"copyAstNode\");\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/regexp-utils.js\nvar regexp_utils_exports = {};\n__export(regexp_utils_exports, {\n  NEWLINE_REGEXP: () => NEWLINE_REGEXP,\n  escapeRegExp: () => escapeRegExp,\n  getCaseInsensitivePattern: () => getCaseInsensitivePattern,\n  getTerminalParts: () => getTerminalParts,\n  isMultilineComment: () => isMultilineComment,\n  isWhitespace: () => isWhitespace,\n  partialMatches: () => partialMatches,\n  partialRegExp: () => partialRegExp\n});\n\n// ../../node_modules/.pnpm/@chevrotain+regexp-to-ast@11.0.3/node_modules/@chevrotain/regexp-to-ast/lib/src/utils.js\nfunction cc(char) {\n  return char.charCodeAt(0);\n}\n__name(cc, \"cc\");\nfunction insertToSet(item, set) {\n  if (Array.isArray(item)) {\n    item.forEach(function(subItem) {\n      set.push(subItem);\n    });\n  } else {\n    set.push(item);\n  }\n}\n__name(insertToSet, \"insertToSet\");\nfunction addFlag(flagObj, flagKey) {\n  if (flagObj[flagKey] === true) {\n    throw \"duplicate flag \" + flagKey;\n  }\n  const x = flagObj[flagKey];\n  flagObj[flagKey] = true;\n}\n__name(addFlag, \"addFlag\");\nfunction ASSERT_EXISTS(obj) {\n  if (obj === void 0) {\n    throw Error(\"Internal Error - Should never get here!\");\n  }\n  return true;\n}\n__name(ASSERT_EXISTS, \"ASSERT_EXISTS\");\nfunction ASSERT_NEVER_REACH_HERE() {\n  throw Error(\"Internal Error - Should never get here!\");\n}\n__name(ASSERT_NEVER_REACH_HERE, \"ASSERT_NEVER_REACH_HERE\");\nfunction isCharacter(obj) {\n  return obj[\"type\"] === \"Character\";\n}\n__name(isCharacter, \"isCharacter\");\n\n// ../../node_modules/.pnpm/@chevrotain+regexp-to-ast@11.0.3/node_modules/@chevrotain/regexp-to-ast/lib/src/character-classes.js\nvar digitsCharCodes = [];\nfor (let i = cc(\"0\"); i <= cc(\"9\"); i++) {\n  digitsCharCodes.push(i);\n}\nvar wordCharCodes = [cc(\"_\")].concat(digitsCharCodes);\nfor (let i = cc(\"a\"); i <= cc(\"z\"); i++) {\n  wordCharCodes.push(i);\n}\nfor (let i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n  wordCharCodes.push(i);\n}\nvar whitespaceCodes = [\n  cc(\" \"),\n  cc(\"\\f\"),\n  cc(\"\\n\"),\n  cc(\"\\r\"),\n  cc(\"\t\"),\n  cc(\"\\v\"),\n  cc(\"\t\"),\n  cc(\"\\xA0\"),\n  cc(\"\\u1680\"),\n  cc(\"\\u2000\"),\n  cc(\"\\u2001\"),\n  cc(\"\\u2002\"),\n  cc(\"\\u2003\"),\n  cc(\"\\u2004\"),\n  cc(\"\\u2005\"),\n  cc(\"\\u2006\"),\n  cc(\"\\u2007\"),\n  cc(\"\\u2008\"),\n  cc(\"\\u2009\"),\n  cc(\"\\u200A\"),\n  cc(\"\\u2028\"),\n  cc(\"\\u2029\"),\n  cc(\"\\u202F\"),\n  cc(\"\\u205F\"),\n  cc(\"\\u3000\"),\n  cc(\"\\uFEFF\")\n];\n\n// ../../node_modules/.pnpm/@chevrotain+regexp-to-ast@11.0.3/node_modules/@chevrotain/regexp-to-ast/lib/src/regexp-parser.js\nvar hexDigitPattern = /[0-9a-fA-F]/;\nvar decimalPattern = /[0-9]/;\nvar decimalPatternNoZero = /[1-9]/;\nvar RegExpParser = class {\n  static {\n    __name(this, \"RegExpParser\");\n  }\n  constructor() {\n    this.idx = 0;\n    this.input = \"\";\n    this.groupIdx = 0;\n  }\n  saveState() {\n    return {\n      idx: this.idx,\n      input: this.input,\n      groupIdx: this.groupIdx\n    };\n  }\n  restoreState(newState2) {\n    this.idx = newState2.idx;\n    this.input = newState2.input;\n    this.groupIdx = newState2.groupIdx;\n  }\n  pattern(input) {\n    this.idx = 0;\n    this.input = input;\n    this.groupIdx = 0;\n    this.consumeChar(\"/\");\n    const value = this.disjunction();\n    this.consumeChar(\"/\");\n    const flags = {\n      type: \"Flags\",\n      loc: { begin: this.idx, end: input.length },\n      global: false,\n      ignoreCase: false,\n      multiLine: false,\n      unicode: false,\n      sticky: false\n    };\n    while (this.isRegExpFlag()) {\n      switch (this.popChar()) {\n        case \"g\":\n          addFlag(flags, \"global\");\n          break;\n        case \"i\":\n          addFlag(flags, \"ignoreCase\");\n          break;\n        case \"m\":\n          addFlag(flags, \"multiLine\");\n          break;\n        case \"u\":\n          addFlag(flags, \"unicode\");\n          break;\n        case \"y\":\n          addFlag(flags, \"sticky\");\n          break;\n      }\n    }\n    if (this.idx !== this.input.length) {\n      throw Error(\"Redundant input: \" + this.input.substring(this.idx));\n    }\n    return {\n      type: \"Pattern\",\n      flags,\n      value,\n      loc: this.loc(0)\n    };\n  }\n  disjunction() {\n    const alts = [];\n    const begin = this.idx;\n    alts.push(this.alternative());\n    while (this.peekChar() === \"|\") {\n      this.consumeChar(\"|\");\n      alts.push(this.alternative());\n    }\n    return { type: \"Disjunction\", value: alts, loc: this.loc(begin) };\n  }\n  alternative() {\n    const terms = [];\n    const begin = this.idx;\n    while (this.isTerm()) {\n      terms.push(this.term());\n    }\n    return { type: \"Alternative\", value: terms, loc: this.loc(begin) };\n  }\n  term() {\n    if (this.isAssertion()) {\n      return this.assertion();\n    } else {\n      return this.atom();\n    }\n  }\n  assertion() {\n    const begin = this.idx;\n    switch (this.popChar()) {\n      case \"^\":\n        return {\n          type: \"StartAnchor\",\n          loc: this.loc(begin)\n        };\n      case \"$\":\n        return { type: \"EndAnchor\", loc: this.loc(begin) };\n      case \"\\\\\":\n        switch (this.popChar()) {\n          case \"b\":\n            return {\n              type: \"WordBoundary\",\n              loc: this.loc(begin)\n            };\n          case \"B\":\n            return {\n              type: \"NonWordBoundary\",\n              loc: this.loc(begin)\n            };\n        }\n        throw Error(\"Invalid Assertion Escape\");\n      case \"(\":\n        this.consumeChar(\"?\");\n        let type;\n        switch (this.popChar()) {\n          case \"=\":\n            type = \"Lookahead\";\n            break;\n          case \"!\":\n            type = \"NegativeLookahead\";\n            break;\n        }\n        ASSERT_EXISTS(type);\n        const disjunction = this.disjunction();\n        this.consumeChar(\")\");\n        return {\n          type,\n          value: disjunction,\n          loc: this.loc(begin)\n        };\n    }\n    return ASSERT_NEVER_REACH_HERE();\n  }\n  quantifier(isBacktracking = false) {\n    let range = void 0;\n    const begin = this.idx;\n    switch (this.popChar()) {\n      case \"*\":\n        range = {\n          atLeast: 0,\n          atMost: Infinity\n        };\n        break;\n      case \"+\":\n        range = {\n          atLeast: 1,\n          atMost: Infinity\n        };\n        break;\n      case \"?\":\n        range = {\n          atLeast: 0,\n          atMost: 1\n        };\n        break;\n      case \"{\":\n        const atLeast = this.integerIncludingZero();\n        switch (this.popChar()) {\n          case \"}\":\n            range = {\n              atLeast,\n              atMost: atLeast\n            };\n            break;\n          case \",\":\n            let atMost;\n            if (this.isDigit()) {\n              atMost = this.integerIncludingZero();\n              range = {\n                atLeast,\n                atMost\n              };\n            } else {\n              range = {\n                atLeast,\n                atMost: Infinity\n              };\n            }\n            this.consumeChar(\"}\");\n            break;\n        }\n        if (isBacktracking === true && range === void 0) {\n          return void 0;\n        }\n        ASSERT_EXISTS(range);\n        break;\n    }\n    if (isBacktracking === true && range === void 0) {\n      return void 0;\n    }\n    if (ASSERT_EXISTS(range)) {\n      if (this.peekChar(0) === \"?\") {\n        this.consumeChar(\"?\");\n        range.greedy = false;\n      } else {\n        range.greedy = true;\n      }\n      range.type = \"Quantifier\";\n      range.loc = this.loc(begin);\n      return range;\n    }\n  }\n  atom() {\n    let atom2;\n    const begin = this.idx;\n    switch (this.peekChar()) {\n      case \".\":\n        atom2 = this.dotAll();\n        break;\n      case \"\\\\\":\n        atom2 = this.atomEscape();\n        break;\n      case \"[\":\n        atom2 = this.characterClass();\n        break;\n      case \"(\":\n        atom2 = this.group();\n        break;\n    }\n    if (atom2 === void 0 && this.isPatternCharacter()) {\n      atom2 = this.patternCharacter();\n    }\n    if (ASSERT_EXISTS(atom2)) {\n      atom2.loc = this.loc(begin);\n      if (this.isQuantifier()) {\n        atom2.quantifier = this.quantifier();\n      }\n      return atom2;\n    }\n    return ASSERT_NEVER_REACH_HERE();\n  }\n  dotAll() {\n    this.consumeChar(\".\");\n    return {\n      type: \"Set\",\n      complement: true,\n      value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")]\n    };\n  }\n  atomEscape() {\n    this.consumeChar(\"\\\\\");\n    switch (this.peekChar()) {\n      case \"1\":\n      case \"2\":\n      case \"3\":\n      case \"4\":\n      case \"5\":\n      case \"6\":\n      case \"7\":\n      case \"8\":\n      case \"9\":\n        return this.decimalEscapeAtom();\n      case \"d\":\n      case \"D\":\n      case \"s\":\n      case \"S\":\n      case \"w\":\n      case \"W\":\n        return this.characterClassEscape();\n      case \"f\":\n      case \"n\":\n      case \"r\":\n      case \"t\":\n      case \"v\":\n        return this.controlEscapeAtom();\n      case \"c\":\n        return this.controlLetterEscapeAtom();\n      case \"0\":\n        return this.nulCharacterAtom();\n      case \"x\":\n        return this.hexEscapeSequenceAtom();\n      case \"u\":\n        return this.regExpUnicodeEscapeSequenceAtom();\n      default:\n        return this.identityEscapeAtom();\n    }\n  }\n  decimalEscapeAtom() {\n    const value = this.positiveInteger();\n    return { type: \"GroupBackReference\", value };\n  }\n  characterClassEscape() {\n    let set;\n    let complement = false;\n    switch (this.popChar()) {\n      case \"d\":\n        set = digitsCharCodes;\n        break;\n      case \"D\":\n        set = digitsCharCodes;\n        complement = true;\n        break;\n      case \"s\":\n        set = whitespaceCodes;\n        break;\n      case \"S\":\n        set = whitespaceCodes;\n        complement = true;\n        break;\n      case \"w\":\n        set = wordCharCodes;\n        break;\n      case \"W\":\n        set = wordCharCodes;\n        complement = true;\n        break;\n    }\n    if (ASSERT_EXISTS(set)) {\n      return { type: \"Set\", value: set, complement };\n    }\n    return ASSERT_NEVER_REACH_HERE();\n  }\n  controlEscapeAtom() {\n    let escapeCode;\n    switch (this.popChar()) {\n      case \"f\":\n        escapeCode = cc(\"\\f\");\n        break;\n      case \"n\":\n        escapeCode = cc(\"\\n\");\n        break;\n      case \"r\":\n        escapeCode = cc(\"\\r\");\n        break;\n      case \"t\":\n        escapeCode = cc(\"\t\");\n        break;\n      case \"v\":\n        escapeCode = cc(\"\\v\");\n        break;\n    }\n    if (ASSERT_EXISTS(escapeCode)) {\n      return { type: \"Character\", value: escapeCode };\n    }\n    return ASSERT_NEVER_REACH_HERE();\n  }\n  controlLetterEscapeAtom() {\n    this.consumeChar(\"c\");\n    const letter = this.popChar();\n    if (/[a-zA-Z]/.test(letter) === false) {\n      throw Error(\"Invalid \");\n    }\n    const letterCode = letter.toUpperCase().charCodeAt(0) - 64;\n    return { type: \"Character\", value: letterCode };\n  }\n  nulCharacterAtom() {\n    this.consumeChar(\"0\");\n    return { type: \"Character\", value: cc(\"\\0\") };\n  }\n  hexEscapeSequenceAtom() {\n    this.consumeChar(\"x\");\n    return this.parseHexDigits(2);\n  }\n  regExpUnicodeEscapeSequenceAtom() {\n    this.consumeChar(\"u\");\n    return this.parseHexDigits(4);\n  }\n  identityEscapeAtom() {\n    const escapedChar = this.popChar();\n    return { type: \"Character\", value: cc(escapedChar) };\n  }\n  classPatternCharacterAtom() {\n    switch (this.peekChar()) {\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n      case \"\\\\\":\n      case \"]\":\n        throw Error(\"TBD\");\n      default:\n        const nextChar = this.popChar();\n        return { type: \"Character\", value: cc(nextChar) };\n    }\n  }\n  characterClass() {\n    const set = [];\n    let complement = false;\n    this.consumeChar(\"[\");\n    if (this.peekChar(0) === \"^\") {\n      this.consumeChar(\"^\");\n      complement = true;\n    }\n    while (this.isClassAtom()) {\n      const from = this.classAtom();\n      const isFromSingleChar = from.type === \"Character\";\n      if (isCharacter(from) && this.isRangeDash()) {\n        this.consumeChar(\"-\");\n        const to = this.classAtom();\n        const isToSingleChar = to.type === \"Character\";\n        if (isCharacter(to)) {\n          if (to.value < from.value) {\n            throw Error(\"Range out of order in character class\");\n          }\n          set.push({ from: from.value, to: to.value });\n        } else {\n          insertToSet(from.value, set);\n          set.push(cc(\"-\"));\n          insertToSet(to.value, set);\n        }\n      } else {\n        insertToSet(from.value, set);\n      }\n    }\n    this.consumeChar(\"]\");\n    return { type: \"Set\", complement, value: set };\n  }\n  classAtom() {\n    switch (this.peekChar()) {\n      case \"]\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        throw Error(\"TBD\");\n      case \"\\\\\":\n        return this.classEscape();\n      default:\n        return this.classPatternCharacterAtom();\n    }\n  }\n  classEscape() {\n    this.consumeChar(\"\\\\\");\n    switch (this.peekChar()) {\n      case \"b\":\n        this.consumeChar(\"b\");\n        return { type: \"Character\", value: cc(\"\\b\") };\n      case \"d\":\n      case \"D\":\n      case \"s\":\n      case \"S\":\n      case \"w\":\n      case \"W\":\n        return this.characterClassEscape();\n      case \"f\":\n      case \"n\":\n      case \"r\":\n      case \"t\":\n      case \"v\":\n        return this.controlEscapeAtom();\n      case \"c\":\n        return this.controlLetterEscapeAtom();\n      case \"0\":\n        return this.nulCharacterAtom();\n      case \"x\":\n        return this.hexEscapeSequenceAtom();\n      case \"u\":\n        return this.regExpUnicodeEscapeSequenceAtom();\n      default:\n        return this.identityEscapeAtom();\n    }\n  }\n  group() {\n    let capturing = true;\n    this.consumeChar(\"(\");\n    switch (this.peekChar(0)) {\n      case \"?\":\n        this.consumeChar(\"?\");\n        this.consumeChar(\":\");\n        capturing = false;\n        break;\n      default:\n        this.groupIdx++;\n        break;\n    }\n    const value = this.disjunction();\n    this.consumeChar(\")\");\n    const groupAst = {\n      type: \"Group\",\n      capturing,\n      value\n    };\n    if (capturing) {\n      groupAst[\"idx\"] = this.groupIdx;\n    }\n    return groupAst;\n  }\n  positiveInteger() {\n    let number = this.popChar();\n    if (decimalPatternNoZero.test(number) === false) {\n      throw Error(\"Expecting a positive integer\");\n    }\n    while (decimalPattern.test(this.peekChar(0))) {\n      number += this.popChar();\n    }\n    return parseInt(number, 10);\n  }\n  integerIncludingZero() {\n    let number = this.popChar();\n    if (decimalPattern.test(number) === false) {\n      throw Error(\"Expecting an integer\");\n    }\n    while (decimalPattern.test(this.peekChar(0))) {\n      number += this.popChar();\n    }\n    return parseInt(number, 10);\n  }\n  patternCharacter() {\n    const nextChar = this.popChar();\n    switch (nextChar) {\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n      case \"^\":\n      case \"$\":\n      case \"\\\\\":\n      case \".\":\n      case \"*\":\n      case \"+\":\n      case \"?\":\n      case \"(\":\n      case \")\":\n      case \"[\":\n      case \"|\":\n        throw Error(\"TBD\");\n      default:\n        return { type: \"Character\", value: cc(nextChar) };\n    }\n  }\n  isRegExpFlag() {\n    switch (this.peekChar(0)) {\n      case \"g\":\n      case \"i\":\n      case \"m\":\n      case \"u\":\n      case \"y\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  isRangeDash() {\n    return this.peekChar() === \"-\" && this.isClassAtom(1);\n  }\n  isDigit() {\n    return decimalPattern.test(this.peekChar(0));\n  }\n  isClassAtom(howMuch = 0) {\n    switch (this.peekChar(howMuch)) {\n      case \"]\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        return false;\n      default:\n        return true;\n    }\n  }\n  isTerm() {\n    return this.isAtom() || this.isAssertion();\n  }\n  isAtom() {\n    if (this.isPatternCharacter()) {\n      return true;\n    }\n    switch (this.peekChar(0)) {\n      case \".\":\n      case \"\\\\\":\n      case \"[\":\n      case \"(\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  isAssertion() {\n    switch (this.peekChar(0)) {\n      case \"^\":\n      case \"$\":\n        return true;\n      case \"\\\\\":\n        switch (this.peekChar(1)) {\n          case \"b\":\n          case \"B\":\n            return true;\n          default:\n            return false;\n        }\n      case \"(\":\n        return this.peekChar(1) === \"?\" && (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\");\n      default:\n        return false;\n    }\n  }\n  isQuantifier() {\n    const prevState = this.saveState();\n    try {\n      return this.quantifier(true) !== void 0;\n    } catch (e) {\n      return false;\n    } finally {\n      this.restoreState(prevState);\n    }\n  }\n  isPatternCharacter() {\n    switch (this.peekChar()) {\n      case \"^\":\n      case \"$\":\n      case \"\\\\\":\n      case \".\":\n      case \"*\":\n      case \"+\":\n      case \"?\":\n      case \"(\":\n      case \")\":\n      case \"[\":\n      case \"|\":\n      case \"/\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        return false;\n      default:\n        return true;\n    }\n  }\n  parseHexDigits(howMany) {\n    let hexString = \"\";\n    for (let i = 0; i < howMany; i++) {\n      const hexChar = this.popChar();\n      if (hexDigitPattern.test(hexChar) === false) {\n        throw Error(\"Expecting a HexDecimal digits\");\n      }\n      hexString += hexChar;\n    }\n    const charCode = parseInt(hexString, 16);\n    return { type: \"Character\", value: charCode };\n  }\n  peekChar(howMuch = 0) {\n    return this.input[this.idx + howMuch];\n  }\n  popChar() {\n    const nextChar = this.peekChar(0);\n    this.consumeChar(void 0);\n    return nextChar;\n  }\n  consumeChar(char) {\n    if (char !== void 0 && this.input[this.idx] !== char) {\n      throw Error(\"Expected: '\" + char + \"' but found: '\" + this.input[this.idx] + \"' at offset: \" + this.idx);\n    }\n    if (this.idx >= this.input.length) {\n      throw Error(\"Unexpected end of input\");\n    }\n    this.idx++;\n  }\n  loc(begin) {\n    return { begin, end: this.idx };\n  }\n};\n\n// ../../node_modules/.pnpm/@chevrotain+regexp-to-ast@11.0.3/node_modules/@chevrotain/regexp-to-ast/lib/src/base-regexp-visitor.js\nvar BaseRegExpVisitor = class {\n  static {\n    __name(this, \"BaseRegExpVisitor\");\n  }\n  visitChildren(node) {\n    for (const key in node) {\n      const child = node[key];\n      if (node.hasOwnProperty(key)) {\n        if (child.type !== void 0) {\n          this.visit(child);\n        } else if (Array.isArray(child)) {\n          child.forEach((subChild) => {\n            this.visit(subChild);\n          }, this);\n        }\n      }\n    }\n  }\n  visit(node) {\n    switch (node.type) {\n      case \"Pattern\":\n        this.visitPattern(node);\n        break;\n      case \"Flags\":\n        this.visitFlags(node);\n        break;\n      case \"Disjunction\":\n        this.visitDisjunction(node);\n        break;\n      case \"Alternative\":\n        this.visitAlternative(node);\n        break;\n      case \"StartAnchor\":\n        this.visitStartAnchor(node);\n        break;\n      case \"EndAnchor\":\n        this.visitEndAnchor(node);\n        break;\n      case \"WordBoundary\":\n        this.visitWordBoundary(node);\n        break;\n      case \"NonWordBoundary\":\n        this.visitNonWordBoundary(node);\n        break;\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        break;\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        break;\n      case \"Character\":\n        this.visitCharacter(node);\n        break;\n      case \"Set\":\n        this.visitSet(node);\n        break;\n      case \"Group\":\n        this.visitGroup(node);\n        break;\n      case \"GroupBackReference\":\n        this.visitGroupBackReference(node);\n        break;\n      case \"Quantifier\":\n        this.visitQuantifier(node);\n        break;\n    }\n    this.visitChildren(node);\n  }\n  visitPattern(node) {\n  }\n  visitFlags(node) {\n  }\n  visitDisjunction(node) {\n  }\n  visitAlternative(node) {\n  }\n  // Assertion\n  visitStartAnchor(node) {\n  }\n  visitEndAnchor(node) {\n  }\n  visitWordBoundary(node) {\n  }\n  visitNonWordBoundary(node) {\n  }\n  visitLookahead(node) {\n  }\n  visitNegativeLookahead(node) {\n  }\n  // atoms\n  visitCharacter(node) {\n  }\n  visitSet(node) {\n  }\n  visitGroup(node) {\n  }\n  visitGroupBackReference(node) {\n  }\n  visitQuantifier(node) {\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/regexp-utils.js\nvar NEWLINE_REGEXP = /\\r?\\n/gm;\nvar regexpParser = new RegExpParser();\nvar TerminalRegExpVisitor = class extends BaseRegExpVisitor {\n  static {\n    __name(this, \"TerminalRegExpVisitor\");\n  }\n  constructor() {\n    super(...arguments);\n    this.isStarting = true;\n    this.endRegexpStack = [];\n    this.multiline = false;\n  }\n  get endRegex() {\n    return this.endRegexpStack.join(\"\");\n  }\n  reset(regex) {\n    this.multiline = false;\n    this.regex = regex;\n    this.startRegexp = \"\";\n    this.isStarting = true;\n    this.endRegexpStack = [];\n  }\n  visitGroup(node) {\n    if (node.quantifier) {\n      this.isStarting = false;\n      this.endRegexpStack = [];\n    }\n  }\n  visitCharacter(node) {\n    const char = String.fromCharCode(node.value);\n    if (!this.multiline && char === \"\\n\") {\n      this.multiline = true;\n    }\n    if (node.quantifier) {\n      this.isStarting = false;\n      this.endRegexpStack = [];\n    } else {\n      const escapedChar = escapeRegExp(char);\n      this.endRegexpStack.push(escapedChar);\n      if (this.isStarting) {\n        this.startRegexp += escapedChar;\n      }\n    }\n  }\n  visitSet(node) {\n    if (!this.multiline) {\n      const set = this.regex.substring(node.loc.begin, node.loc.end);\n      const regex = new RegExp(set);\n      this.multiline = Boolean(\"\\n\".match(regex));\n    }\n    if (node.quantifier) {\n      this.isStarting = false;\n      this.endRegexpStack = [];\n    } else {\n      const set = this.regex.substring(node.loc.begin, node.loc.end);\n      this.endRegexpStack.push(set);\n      if (this.isStarting) {\n        this.startRegexp += set;\n      }\n    }\n  }\n  visitChildren(node) {\n    if (node.type === \"Group\") {\n      const group = node;\n      if (group.quantifier) {\n        return;\n      }\n    }\n    super.visitChildren(node);\n  }\n};\nvar visitor = new TerminalRegExpVisitor();\nfunction getTerminalParts(regexp) {\n  try {\n    if (typeof regexp !== \"string\") {\n      regexp = regexp.source;\n    }\n    regexp = `/${regexp}/`;\n    const pattern = regexpParser.pattern(regexp);\n    const parts = [];\n    for (const alternative of pattern.value.value) {\n      visitor.reset(regexp);\n      visitor.visit(alternative);\n      parts.push({\n        start: visitor.startRegexp,\n        end: visitor.endRegex\n      });\n    }\n    return parts;\n  } catch (_a) {\n    return [];\n  }\n}\n__name(getTerminalParts, \"getTerminalParts\");\nfunction isMultilineComment(regexp) {\n  try {\n    if (typeof regexp === \"string\") {\n      regexp = new RegExp(regexp);\n    }\n    regexp = regexp.toString();\n    visitor.reset(regexp);\n    visitor.visit(regexpParser.pattern(regexp));\n    return visitor.multiline;\n  } catch (_a) {\n    return false;\n  }\n}\n__name(isMultilineComment, \"isMultilineComment\");\nfunction isWhitespace(value) {\n  const regexp = typeof value === \"string\" ? new RegExp(value) : value;\n  return regexp.test(\" \");\n}\n__name(isWhitespace, \"isWhitespace\");\nfunction escapeRegExp(value) {\n  return value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n__name(escapeRegExp, \"escapeRegExp\");\nfunction getCaseInsensitivePattern(keyword) {\n  return Array.prototype.map.call(keyword, (letter) => /\\w/.test(letter) ? `[${letter.toLowerCase()}${letter.toUpperCase()}]` : escapeRegExp(letter)).join(\"\");\n}\n__name(getCaseInsensitivePattern, \"getCaseInsensitivePattern\");\nfunction partialMatches(regex, input) {\n  const partial = partialRegExp(regex);\n  const match = input.match(partial);\n  return !!match && match[0].length > 0;\n}\n__name(partialMatches, \"partialMatches\");\nfunction partialRegExp(regex) {\n  if (typeof regex === \"string\") {\n    regex = new RegExp(regex);\n  }\n  const re = regex, source = regex.source;\n  let i = 0;\n  function process2() {\n    let result = \"\", tmp;\n    function appendRaw(nbChars) {\n      result += source.substr(i, nbChars);\n      i += nbChars;\n    }\n    __name(appendRaw, \"appendRaw\");\n    function appendOptional(nbChars) {\n      result += \"(?:\" + source.substr(i, nbChars) + \"|$)\";\n      i += nbChars;\n    }\n    __name(appendOptional, \"appendOptional\");\n    while (i < source.length) {\n      switch (source[i]) {\n        case \"\\\\\":\n          switch (source[i + 1]) {\n            case \"c\":\n              appendOptional(3);\n              break;\n            case \"x\":\n              appendOptional(4);\n              break;\n            case \"u\":\n              if (re.unicode) {\n                if (source[i + 2] === \"{\") {\n                  appendOptional(source.indexOf(\"}\", i) - i + 1);\n                } else {\n                  appendOptional(6);\n                }\n              } else {\n                appendOptional(2);\n              }\n              break;\n            case \"p\":\n            case \"P\":\n              if (re.unicode) {\n                appendOptional(source.indexOf(\"}\", i) - i + 1);\n              } else {\n                appendOptional(2);\n              }\n              break;\n            case \"k\":\n              appendOptional(source.indexOf(\">\", i) - i + 1);\n              break;\n            default:\n              appendOptional(2);\n              break;\n          }\n          break;\n        case \"[\":\n          tmp = /\\[(?:\\\\.|.)*?\\]/g;\n          tmp.lastIndex = i;\n          tmp = tmp.exec(source) || [];\n          appendOptional(tmp[0].length);\n          break;\n        case \"|\":\n        case \"^\":\n        case \"$\":\n        case \"*\":\n        case \"+\":\n        case \"?\":\n          appendRaw(1);\n          break;\n        case \"{\":\n          tmp = /\\{\\d+,?\\d*\\}/g;\n          tmp.lastIndex = i;\n          tmp = tmp.exec(source);\n          if (tmp) {\n            appendRaw(tmp[0].length);\n          } else {\n            appendOptional(1);\n          }\n          break;\n        case \"(\":\n          if (source[i + 1] === \"?\") {\n            switch (source[i + 2]) {\n              case \":\":\n                result += \"(?:\";\n                i += 3;\n                result += process2() + \"|$)\";\n                break;\n              case \"=\":\n                result += \"(?=\";\n                i += 3;\n                result += process2() + \")\";\n                break;\n              case \"!\":\n                tmp = i;\n                i += 3;\n                process2();\n                result += source.substr(tmp, i - tmp);\n                break;\n              case \"<\":\n                switch (source[i + 3]) {\n                  case \"=\":\n                  case \"!\":\n                    tmp = i;\n                    i += 4;\n                    process2();\n                    result += source.substr(tmp, i - tmp);\n                    break;\n                  default:\n                    appendRaw(source.indexOf(\">\", i) - i + 1);\n                    result += process2() + \"|$)\";\n                    break;\n                }\n                break;\n            }\n          } else {\n            appendRaw(1);\n            result += process2() + \"|$)\";\n          }\n          break;\n        case \")\":\n          ++i;\n          return result;\n        default:\n          appendOptional(1);\n          break;\n      }\n    }\n    return result;\n  }\n  __name(process2, \"process\");\n  return new RegExp(process2(), regex.flags);\n}\n__name(partialRegExp, \"partialRegExp\");\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/grammar-utils.js\nfunction getEntryRule(grammar) {\n  return grammar.rules.find((e) => isParserRule(e) && e.entry);\n}\n__name(getEntryRule, \"getEntryRule\");\nfunction getHiddenRules(grammar) {\n  return grammar.rules.filter((e) => isTerminalRule(e) && e.hidden);\n}\n__name(getHiddenRules, \"getHiddenRules\");\nfunction getAllReachableRules(grammar, allTerminals) {\n  const ruleNames = /* @__PURE__ */ new Set();\n  const entryRule = getEntryRule(grammar);\n  if (!entryRule) {\n    return new Set(grammar.rules);\n  }\n  const topMostRules = [entryRule].concat(getHiddenRules(grammar));\n  for (const rule of topMostRules) {\n    ruleDfs(rule, ruleNames, allTerminals);\n  }\n  const rules = /* @__PURE__ */ new Set();\n  for (const rule of grammar.rules) {\n    if (ruleNames.has(rule.name) || isTerminalRule(rule) && rule.hidden) {\n      rules.add(rule);\n    }\n  }\n  return rules;\n}\n__name(getAllReachableRules, \"getAllReachableRules\");\nfunction ruleDfs(rule, visitedSet, allTerminals) {\n  visitedSet.add(rule.name);\n  streamAllContents(rule).forEach((node) => {\n    if (isRuleCall(node) || allTerminals && isTerminalRuleCall(node)) {\n      const refRule = node.rule.ref;\n      if (refRule && !visitedSet.has(refRule.name)) {\n        ruleDfs(refRule, visitedSet, allTerminals);\n      }\n    }\n  });\n}\n__name(ruleDfs, \"ruleDfs\");\nfunction getCrossReferenceTerminal(crossRef) {\n  if (crossRef.terminal) {\n    return crossRef.terminal;\n  } else if (crossRef.type.ref) {\n    const nameAssigment = findNameAssignment(crossRef.type.ref);\n    return nameAssigment === null || nameAssigment === void 0 ? void 0 : nameAssigment.terminal;\n  }\n  return void 0;\n}\n__name(getCrossReferenceTerminal, \"getCrossReferenceTerminal\");\nfunction isCommentTerminal(terminalRule) {\n  return terminalRule.hidden && !terminalRegex(terminalRule).test(\" \");\n}\n__name(isCommentTerminal, \"isCommentTerminal\");\nfunction findNodesForProperty(node, property) {\n  if (!node || !property) {\n    return [];\n  }\n  return findNodesForPropertyInternal(node, property, node.astNode, true);\n}\n__name(findNodesForProperty, \"findNodesForProperty\");\nfunction findNodeForProperty(node, property, index) {\n  if (!node || !property) {\n    return void 0;\n  }\n  const nodes = findNodesForPropertyInternal(node, property, node.astNode, true);\n  if (nodes.length === 0) {\n    return void 0;\n  }\n  if (index !== void 0) {\n    index = Math.max(0, Math.min(index, nodes.length - 1));\n  } else {\n    index = 0;\n  }\n  return nodes[index];\n}\n__name(findNodeForProperty, \"findNodeForProperty\");\nfunction findNodesForPropertyInternal(node, property, element, first2) {\n  if (!first2) {\n    const nodeFeature = getContainerOfType(node.grammarSource, isAssignment);\n    if (nodeFeature && nodeFeature.feature === property) {\n      return [node];\n    }\n  }\n  if (isCompositeCstNode(node) && node.astNode === element) {\n    return node.content.flatMap((e) => findNodesForPropertyInternal(e, property, element, false));\n  }\n  return [];\n}\n__name(findNodesForPropertyInternal, \"findNodesForPropertyInternal\");\nfunction findNodesForKeyword(node, keyword) {\n  if (!node) {\n    return [];\n  }\n  return findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);\n}\n__name(findNodesForKeyword, \"findNodesForKeyword\");\nfunction findNodeForKeyword(node, keyword, index) {\n  if (!node) {\n    return void 0;\n  }\n  const nodes = findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);\n  if (nodes.length === 0) {\n    return void 0;\n  }\n  if (index !== void 0) {\n    index = Math.max(0, Math.min(index, nodes.length - 1));\n  } else {\n    index = 0;\n  }\n  return nodes[index];\n}\n__name(findNodeForKeyword, \"findNodeForKeyword\");\nfunction findNodesForKeywordInternal(node, keyword, element) {\n  if (node.astNode !== element) {\n    return [];\n  }\n  if (isKeyword(node.grammarSource) && node.grammarSource.value === keyword) {\n    return [node];\n  }\n  const treeIterator = streamCst(node).iterator();\n  let result;\n  const keywordNodes = [];\n  do {\n    result = treeIterator.next();\n    if (!result.done) {\n      const childNode = result.value;\n      if (childNode.astNode === element) {\n        if (isKeyword(childNode.grammarSource) && childNode.grammarSource.value === keyword) {\n          keywordNodes.push(childNode);\n        }\n      } else {\n        treeIterator.prune();\n      }\n    }\n  } while (!result.done);\n  return keywordNodes;\n}\n__name(findNodesForKeywordInternal, \"findNodesForKeywordInternal\");\nfunction findAssignment(cstNode) {\n  var _a;\n  const astNode = cstNode.astNode;\n  while (astNode === ((_a = cstNode.container) === null || _a === void 0 ? void 0 : _a.astNode)) {\n    const assignment = getContainerOfType(cstNode.grammarSource, isAssignment);\n    if (assignment) {\n      return assignment;\n    }\n    cstNode = cstNode.container;\n  }\n  return void 0;\n}\n__name(findAssignment, \"findAssignment\");\nfunction findNameAssignment(type) {\n  let startNode = type;\n  if (isInferredType(startNode)) {\n    if (isAction(startNode.$container)) {\n      startNode = startNode.$container.$container;\n    } else if (isParserRule(startNode.$container)) {\n      startNode = startNode.$container;\n    } else {\n      assertUnreachable(startNode.$container);\n    }\n  }\n  return findNameAssignmentInternal(type, startNode, /* @__PURE__ */ new Map());\n}\n__name(findNameAssignment, \"findNameAssignment\");\nfunction findNameAssignmentInternal(type, startNode, cache) {\n  var _a;\n  function go(node, refType) {\n    let childAssignment = void 0;\n    const parentAssignment = getContainerOfType(node, isAssignment);\n    if (!parentAssignment) {\n      childAssignment = findNameAssignmentInternal(refType, refType, cache);\n    }\n    cache.set(type, childAssignment);\n    return childAssignment;\n  }\n  __name(go, \"go\");\n  if (cache.has(type)) {\n    return cache.get(type);\n  }\n  cache.set(type, void 0);\n  for (const node of streamAllContents(startNode)) {\n    if (isAssignment(node) && node.feature.toLowerCase() === \"name\") {\n      cache.set(type, node);\n      return node;\n    } else if (isRuleCall(node) && isParserRule(node.rule.ref)) {\n      return go(node, node.rule.ref);\n    } else if (isSimpleType(node) && ((_a = node.typeRef) === null || _a === void 0 ? void 0 : _a.ref)) {\n      return go(node, node.typeRef.ref);\n    }\n  }\n  return void 0;\n}\n__name(findNameAssignmentInternal, \"findNameAssignmentInternal\");\nfunction getActionAtElement(element) {\n  const parent = element.$container;\n  if (isGroup(parent)) {\n    const elements = parent.elements;\n    const index = elements.indexOf(element);\n    for (let i = index - 1; i >= 0; i--) {\n      const item = elements[i];\n      if (isAction(item)) {\n        return item;\n      } else {\n        const action = streamAllContents(elements[i]).find(isAction);\n        if (action) {\n          return action;\n        }\n      }\n    }\n  }\n  if (isAbstractElement(parent)) {\n    return getActionAtElement(parent);\n  } else {\n    return void 0;\n  }\n}\n__name(getActionAtElement, \"getActionAtElement\");\nfunction isOptionalCardinality(cardinality, element) {\n  return cardinality === \"?\" || cardinality === \"*\" || isGroup(element) && Boolean(element.guardCondition);\n}\n__name(isOptionalCardinality, \"isOptionalCardinality\");\nfunction isArrayCardinality(cardinality) {\n  return cardinality === \"*\" || cardinality === \"+\";\n}\n__name(isArrayCardinality, \"isArrayCardinality\");\nfunction isArrayOperator(operator) {\n  return operator === \"+=\";\n}\n__name(isArrayOperator, \"isArrayOperator\");\nfunction isDataTypeRule(rule) {\n  return isDataTypeRuleInternal(rule, /* @__PURE__ */ new Set());\n}\n__name(isDataTypeRule, \"isDataTypeRule\");\nfunction isDataTypeRuleInternal(rule, visited) {\n  if (visited.has(rule)) {\n    return true;\n  } else {\n    visited.add(rule);\n  }\n  for (const node of streamAllContents(rule)) {\n    if (isRuleCall(node)) {\n      if (!node.rule.ref) {\n        return false;\n      }\n      if (isParserRule(node.rule.ref) && !isDataTypeRuleInternal(node.rule.ref, visited)) {\n        return false;\n      }\n    } else if (isAssignment(node)) {\n      return false;\n    } else if (isAction(node)) {\n      return false;\n    }\n  }\n  return Boolean(rule.definition);\n}\n__name(isDataTypeRuleInternal, \"isDataTypeRuleInternal\");\nfunction isDataType(type) {\n  return isDataTypeInternal(type.type, /* @__PURE__ */ new Set());\n}\n__name(isDataType, \"isDataType\");\nfunction isDataTypeInternal(type, visited) {\n  if (visited.has(type)) {\n    return true;\n  } else {\n    visited.add(type);\n  }\n  if (isArrayType(type)) {\n    return false;\n  } else if (isReferenceType(type)) {\n    return false;\n  } else if (isUnionType(type)) {\n    return type.types.every((e) => isDataTypeInternal(e, visited));\n  } else if (isSimpleType(type)) {\n    if (type.primitiveType !== void 0) {\n      return true;\n    } else if (type.stringType !== void 0) {\n      return true;\n    } else if (type.typeRef !== void 0) {\n      const ref = type.typeRef.ref;\n      if (isType(ref)) {\n        return isDataTypeInternal(ref.type, visited);\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n__name(isDataTypeInternal, \"isDataTypeInternal\");\nfunction getExplicitRuleType(rule) {\n  if (rule.inferredType) {\n    return rule.inferredType.name;\n  } else if (rule.dataType) {\n    return rule.dataType;\n  } else if (rule.returnType) {\n    const refType = rule.returnType.ref;\n    if (refType) {\n      if (isParserRule(refType)) {\n        return refType.name;\n      } else if (isInterface(refType) || isType(refType)) {\n        return refType.name;\n      }\n    }\n  }\n  return void 0;\n}\n__name(getExplicitRuleType, \"getExplicitRuleType\");\nfunction getTypeName(type) {\n  var _a;\n  if (isParserRule(type)) {\n    return isDataTypeRule(type) ? type.name : (_a = getExplicitRuleType(type)) !== null && _a !== void 0 ? _a : type.name;\n  } else if (isInterface(type) || isType(type) || isReturnType(type)) {\n    return type.name;\n  } else if (isAction(type)) {\n    const actionType = getActionType(type);\n    if (actionType) {\n      return actionType;\n    }\n  } else if (isInferredType(type)) {\n    return type.name;\n  }\n  throw new Error(\"Cannot get name of Unknown Type\");\n}\n__name(getTypeName, \"getTypeName\");\nfunction getActionType(action) {\n  var _a;\n  if (action.inferredType) {\n    return action.inferredType.name;\n  } else if ((_a = action.type) === null || _a === void 0 ? void 0 : _a.ref) {\n    return getTypeName(action.type.ref);\n  }\n  return void 0;\n}\n__name(getActionType, \"getActionType\");\nfunction getRuleType(rule) {\n  var _a, _b, _c;\n  if (isTerminalRule(rule)) {\n    return (_b = (_a = rule.type) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : \"string\";\n  } else {\n    return isDataTypeRule(rule) ? rule.name : (_c = getExplicitRuleType(rule)) !== null && _c !== void 0 ? _c : rule.name;\n  }\n}\n__name(getRuleType, \"getRuleType\");\nfunction terminalRegex(terminalRule) {\n  const flags = {\n    s: false,\n    i: false,\n    u: false\n  };\n  const source = abstractElementToRegex(terminalRule.definition, flags);\n  const flagText = Object.entries(flags).filter(([, value]) => value).map(([name]) => name).join(\"\");\n  return new RegExp(source, flagText);\n}\n__name(terminalRegex, \"terminalRegex\");\nvar WILDCARD = /[\\s\\S]/.source;\nfunction abstractElementToRegex(element, flags) {\n  if (isTerminalAlternatives(element)) {\n    return terminalAlternativesToRegex(element);\n  } else if (isTerminalGroup(element)) {\n    return terminalGroupToRegex(element);\n  } else if (isCharacterRange(element)) {\n    return characterRangeToRegex(element);\n  } else if (isTerminalRuleCall(element)) {\n    const rule = element.rule.ref;\n    if (!rule) {\n      throw new Error(\"Missing rule reference.\");\n    }\n    return withCardinality(abstractElementToRegex(rule.definition), {\n      cardinality: element.cardinality,\n      lookahead: element.lookahead\n    });\n  } else if (isNegatedToken(element)) {\n    return negateTokenToRegex(element);\n  } else if (isUntilToken(element)) {\n    return untilTokenToRegex(element);\n  } else if (isRegexToken(element)) {\n    const lastSlash = element.regex.lastIndexOf(\"/\");\n    const source = element.regex.substring(1, lastSlash);\n    const regexFlags = element.regex.substring(lastSlash + 1);\n    if (flags) {\n      flags.i = regexFlags.includes(\"i\");\n      flags.s = regexFlags.includes(\"s\");\n      flags.u = regexFlags.includes(\"u\");\n    }\n    return withCardinality(source, {\n      cardinality: element.cardinality,\n      lookahead: element.lookahead,\n      wrap: false\n    });\n  } else if (isWildcard(element)) {\n    return withCardinality(WILDCARD, {\n      cardinality: element.cardinality,\n      lookahead: element.lookahead\n    });\n  } else {\n    throw new Error(`Invalid terminal element: ${element === null || element === void 0 ? void 0 : element.$type}`);\n  }\n}\n__name(abstractElementToRegex, \"abstractElementToRegex\");\nfunction terminalAlternativesToRegex(alternatives) {\n  return withCardinality(alternatives.elements.map((e) => abstractElementToRegex(e)).join(\"|\"), {\n    cardinality: alternatives.cardinality,\n    lookahead: alternatives.lookahead\n  });\n}\n__name(terminalAlternativesToRegex, \"terminalAlternativesToRegex\");\nfunction terminalGroupToRegex(group) {\n  return withCardinality(group.elements.map((e) => abstractElementToRegex(e)).join(\"\"), {\n    cardinality: group.cardinality,\n    lookahead: group.lookahead\n  });\n}\n__name(terminalGroupToRegex, \"terminalGroupToRegex\");\nfunction untilTokenToRegex(until) {\n  return withCardinality(`${WILDCARD}*?${abstractElementToRegex(until.terminal)}`, {\n    cardinality: until.cardinality,\n    lookahead: until.lookahead\n  });\n}\n__name(untilTokenToRegex, \"untilTokenToRegex\");\nfunction negateTokenToRegex(negate) {\n  return withCardinality(`(?!${abstractElementToRegex(negate.terminal)})${WILDCARD}*?`, {\n    cardinality: negate.cardinality,\n    lookahead: negate.lookahead\n  });\n}\n__name(negateTokenToRegex, \"negateTokenToRegex\");\nfunction characterRangeToRegex(range) {\n  if (range.right) {\n    return withCardinality(`[${keywordToRegex(range.left)}-${keywordToRegex(range.right)}]`, {\n      cardinality: range.cardinality,\n      lookahead: range.lookahead,\n      wrap: false\n    });\n  }\n  return withCardinality(keywordToRegex(range.left), {\n    cardinality: range.cardinality,\n    lookahead: range.lookahead,\n    wrap: false\n  });\n}\n__name(characterRangeToRegex, \"characterRangeToRegex\");\nfunction keywordToRegex(keyword) {\n  return escapeRegExp(keyword.value);\n}\n__name(keywordToRegex, \"keywordToRegex\");\nfunction withCardinality(regex, options) {\n  var _a;\n  if (options.wrap !== false || options.lookahead) {\n    regex = `(${(_a = options.lookahead) !== null && _a !== void 0 ? _a : \"\"}${regex})`;\n  }\n  if (options.cardinality) {\n    return `${regex}${options.cardinality}`;\n  }\n  return regex;\n}\n__name(withCardinality, \"withCardinality\");\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/languages/grammar-config.js\nfunction createGrammarConfig(services) {\n  const rules = [];\n  const grammar = services.Grammar;\n  for (const rule of grammar.rules) {\n    if (isTerminalRule(rule) && isCommentTerminal(rule) && isMultilineComment(terminalRegex(rule))) {\n      rules.push(rule.name);\n    }\n  }\n  return {\n    multilineCommentRules: rules,\n    nameRegexp: DefaultNameRegexp\n  };\n}\n__name(createGrammarConfig, \"createGrammarConfig\");\n\n// ../../node_modules/.pnpm/@chevrotain+utils@11.0.3/node_modules/@chevrotain/utils/lib/src/print.js\nfunction PRINT_ERROR(msg) {\n  if (console && console.error) {\n    console.error(`Error: ${msg}`);\n  }\n}\n__name(PRINT_ERROR, \"PRINT_ERROR\");\nfunction PRINT_WARNING(msg) {\n  if (console && console.warn) {\n    console.warn(`Warning: ${msg}`);\n  }\n}\n__name(PRINT_WARNING, \"PRINT_WARNING\");\n\n// ../../node_modules/.pnpm/@chevrotain+utils@11.0.3/node_modules/@chevrotain/utils/lib/src/timer.js\nfunction timer(func) {\n  const start = (/* @__PURE__ */ new Date()).getTime();\n  const val = func();\n  const end = (/* @__PURE__ */ new Date()).getTime();\n  const total = end - start;\n  return { time: total, value: val };\n}\n__name(timer, \"timer\");\n\n// ../../node_modules/.pnpm/@chevrotain+utils@11.0.3/node_modules/@chevrotain/utils/lib/src/to-fast-properties.js\nfunction toFastProperties(toBecomeFast) {\n  function FakeConstructor() {\n  }\n  __name(FakeConstructor, \"FakeConstructor\");\n  FakeConstructor.prototype = toBecomeFast;\n  const fakeInstance = new FakeConstructor();\n  function fakeAccess() {\n    return typeof fakeInstance.bar;\n  }\n  __name(fakeAccess, \"fakeAccess\");\n  fakeAccess();\n  fakeAccess();\n  if (1)\n    return toBecomeFast;\n  (0, eval)(toBecomeFast);\n}\n__name(toFastProperties, \"toFastProperties\");\n\n// ../../node_modules/.pnpm/@chevrotain+gast@11.0.3/node_modules/@chevrotain/gast/lib/src/model.js\nfunction tokenLabel(tokType) {\n  if (hasTokenLabel(tokType)) {\n    return tokType.LABEL;\n  } else {\n    return tokType.name;\n  }\n}\n__name(tokenLabel, \"tokenLabel\");\nfunction hasTokenLabel(obj) {\n  return isString_default(obj.LABEL) && obj.LABEL !== \"\";\n}\n__name(hasTokenLabel, \"hasTokenLabel\");\nvar AbstractProduction = class {\n  static {\n    __name(this, \"AbstractProduction\");\n  }\n  get definition() {\n    return this._definition;\n  }\n  set definition(value) {\n    this._definition = value;\n  }\n  constructor(_definition) {\n    this._definition = _definition;\n  }\n  accept(visitor2) {\n    visitor2.visit(this);\n    forEach_default(this.definition, (prod) => {\n      prod.accept(visitor2);\n    });\n  }\n};\nvar NonTerminal = class extends AbstractProduction {\n  static {\n    __name(this, \"NonTerminal\");\n  }\n  constructor(options) {\n    super([]);\n    this.idx = 1;\n    assign_default(this, pickBy_default(options, (v) => v !== void 0));\n  }\n  set definition(definition) {\n  }\n  get definition() {\n    if (this.referencedRule !== void 0) {\n      return this.referencedRule.definition;\n    }\n    return [];\n  }\n  accept(visitor2) {\n    visitor2.visit(this);\n  }\n};\nvar Rule = class extends AbstractProduction {\n  static {\n    __name(this, \"Rule\");\n  }\n  constructor(options) {\n    super(options.definition);\n    this.orgText = \"\";\n    assign_default(this, pickBy_default(options, (v) => v !== void 0));\n  }\n};\nvar Alternative = class extends AbstractProduction {\n  static {\n    __name(this, \"Alternative\");\n  }\n  constructor(options) {\n    super(options.definition);\n    this.ignoreAmbiguities = false;\n    assign_default(this, pickBy_default(options, (v) => v !== void 0));\n  }\n};\nvar Option = class extends AbstractProduction {\n  static {\n    __name(this, \"Option\");\n  }\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    assign_default(this, pickBy_default(options, (v) => v !== void 0));\n  }\n};\nvar RepetitionMandatory = class extends AbstractProduction {\n  static {\n    __name(this, \"RepetitionMandatory\");\n  }\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    assign_default(this, pickBy_default(options, (v) => v !== void 0));\n  }\n};\nvar RepetitionMandatoryWithSeparator = class extends AbstractProduction {\n  static {\n    __name(this, \"RepetitionMandatoryWithSeparator\");\n  }\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    assign_default(this, pickBy_default(options, (v) => v !== void 0));\n  }\n};\nvar Repetition = class extends AbstractProduction {\n  static {\n    __name(this, \"Repetition\");\n  }\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    assign_default(this, pickBy_default(options, (v) => v !== void 0));\n  }\n};\nvar RepetitionWithSeparator = class extends AbstractProduction {\n  static {\n    __name(this, \"RepetitionWithSeparator\");\n  }\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    assign_default(this, pickBy_default(options, (v) => v !== void 0));\n  }\n};\nvar Alternation = class extends AbstractProduction {\n  static {\n    __name(this, \"Alternation\");\n  }\n  get definition() {\n    return this._definition;\n  }\n  set definition(value) {\n    this._definition = value;\n  }\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    this.ignoreAmbiguities = false;\n    this.hasPredicates = false;\n    assign_default(this, pickBy_default(options, (v) => v !== void 0));\n  }\n};\nvar Terminal = class {\n  static {\n    __name(this, \"Terminal\");\n  }\n  constructor(options) {\n    this.idx = 1;\n    assign_default(this, pickBy_default(options, (v) => v !== void 0));\n  }\n  accept(visitor2) {\n    visitor2.visit(this);\n  }\n};\nfunction serializeGrammar(topRules) {\n  return map_default(topRules, serializeProduction);\n}\n__name(serializeGrammar, \"serializeGrammar\");\nfunction serializeProduction(node) {\n  function convertDefinition(definition) {\n    return map_default(definition, serializeProduction);\n  }\n  __name(convertDefinition, \"convertDefinition\");\n  if (node instanceof NonTerminal) {\n    const serializedNonTerminal = {\n      type: \"NonTerminal\",\n      name: node.nonTerminalName,\n      idx: node.idx\n    };\n    if (isString_default(node.label)) {\n      serializedNonTerminal.label = node.label;\n    }\n    return serializedNonTerminal;\n  } else if (node instanceof Alternative) {\n    return {\n      type: \"Alternative\",\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Option) {\n    return {\n      type: \"Option\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionMandatory) {\n    return {\n      type: \"RepetitionMandatory\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionMandatoryWithSeparator) {\n    return {\n      type: \"RepetitionMandatoryWithSeparator\",\n      idx: node.idx,\n      separator: serializeProduction(new Terminal({ terminalType: node.separator })),\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionWithSeparator) {\n    return {\n      type: \"RepetitionWithSeparator\",\n      idx: node.idx,\n      separator: serializeProduction(new Terminal({ terminalType: node.separator })),\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Repetition) {\n    return {\n      type: \"Repetition\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Alternation) {\n    return {\n      type: \"Alternation\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Terminal) {\n    const serializedTerminal = {\n      type: \"Terminal\",\n      name: node.terminalType.name,\n      label: tokenLabel(node.terminalType),\n      idx: node.idx\n    };\n    if (isString_default(node.label)) {\n      serializedTerminal.terminalLabel = node.label;\n    }\n    const pattern = node.terminalType.PATTERN;\n    if (node.terminalType.PATTERN) {\n      serializedTerminal.pattern = isRegExp_default(pattern) ? pattern.source : pattern;\n    }\n    return serializedTerminal;\n  } else if (node instanceof Rule) {\n    return {\n      type: \"Rule\",\n      name: node.name,\n      orgText: node.orgText,\n      definition: convertDefinition(node.definition)\n    };\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n__name(serializeProduction, \"serializeProduction\");\n\n// ../../node_modules/.pnpm/@chevrotain+gast@11.0.3/node_modules/@chevrotain/gast/lib/src/visitor.js\nvar GAstVisitor = class {\n  static {\n    __name(this, \"GAstVisitor\");\n  }\n  visit(node) {\n    const nodeAny = node;\n    switch (nodeAny.constructor) {\n      case NonTerminal:\n        return this.visitNonTerminal(nodeAny);\n      case Alternative:\n        return this.visitAlternative(nodeAny);\n      case Option:\n        return this.visitOption(nodeAny);\n      case RepetitionMandatory:\n        return this.visitRepetitionMandatory(nodeAny);\n      case RepetitionMandatoryWithSeparator:\n        return this.visitRepetitionMandatoryWithSeparator(nodeAny);\n      case RepetitionWithSeparator:\n        return this.visitRepetitionWithSeparator(nodeAny);\n      case Repetition:\n        return this.visitRepetition(nodeAny);\n      case Alternation:\n        return this.visitAlternation(nodeAny);\n      case Terminal:\n        return this.visitTerminal(nodeAny);\n      case Rule:\n        return this.visitRule(nodeAny);\n      default:\n        throw Error(\"non exhaustive match\");\n    }\n  }\n  /* c8 ignore next */\n  visitNonTerminal(node) {\n  }\n  /* c8 ignore next */\n  visitAlternative(node) {\n  }\n  /* c8 ignore next */\n  visitOption(node) {\n  }\n  /* c8 ignore next */\n  visitRepetition(node) {\n  }\n  /* c8 ignore next */\n  visitRepetitionMandatory(node) {\n  }\n  /* c8 ignore next 3 */\n  visitRepetitionMandatoryWithSeparator(node) {\n  }\n  /* c8 ignore next */\n  visitRepetitionWithSeparator(node) {\n  }\n  /* c8 ignore next */\n  visitAlternation(node) {\n  }\n  /* c8 ignore next */\n  visitTerminal(node) {\n  }\n  /* c8 ignore next */\n  visitRule(node) {\n  }\n};\n\n// ../../node_modules/.pnpm/@chevrotain+gast@11.0.3/node_modules/@chevrotain/gast/lib/src/helpers.js\nfunction isSequenceProd(prod) {\n  return prod instanceof Alternative || prod instanceof Option || prod instanceof Repetition || prod instanceof RepetitionMandatory || prod instanceof RepetitionMandatoryWithSeparator || prod instanceof RepetitionWithSeparator || prod instanceof Terminal || prod instanceof Rule;\n}\n__name(isSequenceProd, \"isSequenceProd\");\nfunction isOptionalProd(prod, alreadyVisited = []) {\n  const isDirectlyOptional = prod instanceof Option || prod instanceof Repetition || prod instanceof RepetitionWithSeparator;\n  if (isDirectlyOptional) {\n    return true;\n  }\n  if (prod instanceof Alternation) {\n    return some_default(prod.definition, (subProd) => {\n      return isOptionalProd(subProd, alreadyVisited);\n    });\n  } else if (prod instanceof NonTerminal && includes_default(alreadyVisited, prod)) {\n    return false;\n  } else if (prod instanceof AbstractProduction) {\n    if (prod instanceof NonTerminal) {\n      alreadyVisited.push(prod);\n    }\n    return every_default(prod.definition, (subProd) => {\n      return isOptionalProd(subProd, alreadyVisited);\n    });\n  } else {\n    return false;\n  }\n}\n__name(isOptionalProd, \"isOptionalProd\");\nfunction isBranchingProd(prod) {\n  return prod instanceof Alternation;\n}\n__name(isBranchingProd, \"isBranchingProd\");\nfunction getProductionDslName(prod) {\n  if (prod instanceof NonTerminal) {\n    return \"SUBRULE\";\n  } else if (prod instanceof Option) {\n    return \"OPTION\";\n  } else if (prod instanceof Alternation) {\n    return \"OR\";\n  } else if (prod instanceof RepetitionMandatory) {\n    return \"AT_LEAST_ONE\";\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n    return \"AT_LEAST_ONE_SEP\";\n  } else if (prod instanceof RepetitionWithSeparator) {\n    return \"MANY_SEP\";\n  } else if (prod instanceof Repetition) {\n    return \"MANY\";\n  } else if (prod instanceof Terminal) {\n    return \"CONSUME\";\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n__name(getProductionDslName, \"getProductionDslName\");\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/grammar/rest.js\nvar RestWalker = class {\n  static {\n    __name(this, \"RestWalker\");\n  }\n  walk(prod, prevRest = []) {\n    forEach_default(prod.definition, (subProd, index) => {\n      const currRest = drop_default(prod.definition, index + 1);\n      if (subProd instanceof NonTerminal) {\n        this.walkProdRef(subProd, currRest, prevRest);\n      } else if (subProd instanceof Terminal) {\n        this.walkTerminal(subProd, currRest, prevRest);\n      } else if (subProd instanceof Alternative) {\n        this.walkFlat(subProd, currRest, prevRest);\n      } else if (subProd instanceof Option) {\n        this.walkOption(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionMandatory) {\n        this.walkAtLeastOne(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n        this.walkAtLeastOneSep(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionWithSeparator) {\n        this.walkManySep(subProd, currRest, prevRest);\n      } else if (subProd instanceof Repetition) {\n        this.walkMany(subProd, currRest, prevRest);\n      } else if (subProd instanceof Alternation) {\n        this.walkOr(subProd, currRest, prevRest);\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  }\n  walkTerminal(terminal, currRest, prevRest) {\n  }\n  walkProdRef(refProd, currRest, prevRest) {\n  }\n  walkFlat(flatProd, currRest, prevRest) {\n    const fullOrRest = currRest.concat(prevRest);\n    this.walk(flatProd, fullOrRest);\n  }\n  walkOption(optionProd, currRest, prevRest) {\n    const fullOrRest = currRest.concat(prevRest);\n    this.walk(optionProd, fullOrRest);\n  }\n  walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n    const fullAtLeastOneRest = [\n      new Option({ definition: atLeastOneProd.definition })\n    ].concat(currRest, prevRest);\n    this.walk(atLeastOneProd, fullAtLeastOneRest);\n  }\n  walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n    const fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n    this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n  }\n  walkMany(manyProd, currRest, prevRest) {\n    const fullManyRest = [\n      new Option({ definition: manyProd.definition })\n    ].concat(currRest, prevRest);\n    this.walk(manyProd, fullManyRest);\n  }\n  walkManySep(manySepProd, currRest, prevRest) {\n    const fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n    this.walk(manySepProd, fullManySepRest);\n  }\n  walkOr(orProd, currRest, prevRest) {\n    const fullOrRest = currRest.concat(prevRest);\n    forEach_default(orProd.definition, (alt) => {\n      const prodWrapper = new Alternative({ definition: [alt] });\n      this.walk(prodWrapper, fullOrRest);\n    });\n  }\n};\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n  const repSepRest = [\n    new Option({\n      definition: [\n        new Terminal({ terminalType: repSepProd.separator })\n      ].concat(repSepProd.definition)\n    })\n  ];\n  const fullRepSepRest = repSepRest.concat(currRest, prevRest);\n  return fullRepSepRest;\n}\n__name(restForRepetitionWithSeparator, \"restForRepetitionWithSeparator\");\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/grammar/first.js\nfunction first(prod) {\n  if (prod instanceof NonTerminal) {\n    return first(prod.referencedRule);\n  } else if (prod instanceof Terminal) {\n    return firstForTerminal(prod);\n  } else if (isSequenceProd(prod)) {\n    return firstForSequence(prod);\n  } else if (isBranchingProd(prod)) {\n    return firstForBranching(prod);\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n__name(first, \"first\");\nfunction firstForSequence(prod) {\n  let firstSet = [];\n  const seq = prod.definition;\n  let nextSubProdIdx = 0;\n  let hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  let currSubProd;\n  let isLastInnerProdOptional = true;\n  while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n    currSubProd = seq[nextSubProdIdx];\n    isLastInnerProdOptional = isOptionalProd(currSubProd);\n    firstSet = firstSet.concat(first(currSubProd));\n    nextSubProdIdx = nextSubProdIdx + 1;\n    hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  }\n  return uniq_default(firstSet);\n}\n__name(firstForSequence, \"firstForSequence\");\nfunction firstForBranching(prod) {\n  const allAlternativesFirsts = map_default(prod.definition, (innerProd) => {\n    return first(innerProd);\n  });\n  return uniq_default(flatten_default(allAlternativesFirsts));\n}\n__name(firstForBranching, \"firstForBranching\");\nfunction firstForTerminal(terminal) {\n  return [terminal.terminalType];\n}\n__name(firstForTerminal, \"firstForTerminal\");\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/constants.js\nvar IN = \"_~IN~_\";\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/grammar/follow.js\nvar ResyncFollowsWalker = class extends RestWalker {\n  static {\n    __name(this, \"ResyncFollowsWalker\");\n  }\n  constructor(topProd) {\n    super();\n    this.topProd = topProd;\n    this.follows = {};\n  }\n  startWalking() {\n    this.walk(this.topProd);\n    return this.follows;\n  }\n  walkTerminal(terminal, currRest, prevRest) {\n  }\n  walkProdRef(refProd, currRest, prevRest) {\n    const followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name;\n    const fullRest = currRest.concat(prevRest);\n    const restProd = new Alternative({ definition: fullRest });\n    const t_in_topProd_follows = first(restProd);\n    this.follows[followName] = t_in_topProd_follows;\n  }\n};\nfunction computeAllProdsFollows(topProductions) {\n  const reSyncFollows = {};\n  forEach_default(topProductions, (topProd) => {\n    const currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();\n    assign_default(reSyncFollows, currRefsFollow);\n  });\n  return reSyncFollows;\n}\n__name(computeAllProdsFollows, \"computeAllProdsFollows\");\nfunction buildBetweenProdsFollowPrefix(inner, occurenceInParent) {\n  return inner.name + occurenceInParent + IN;\n}\n__name(buildBetweenProdsFollowPrefix, \"buildBetweenProdsFollowPrefix\");\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/scan/reg_exp_parser.js\nvar regExpAstCache = {};\nvar regExpParser = new RegExpParser();\nfunction getRegExpAst(regExp) {\n  const regExpStr = regExp.toString();\n  if (regExpAstCache.hasOwnProperty(regExpStr)) {\n    return regExpAstCache[regExpStr];\n  } else {\n    const regExpAst = regExpParser.pattern(regExpStr);\n    regExpAstCache[regExpStr] = regExpAst;\n    return regExpAst;\n  }\n}\n__name(getRegExpAst, \"getRegExpAst\");\nfunction clearRegExpParserCache() {\n  regExpAstCache = {};\n}\n__name(clearRegExpParserCache, \"clearRegExpParserCache\");\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/scan/reg_exp.js\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nvar failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nfunction getOptimizedStartCodesIndices(regExp, ensureOptimizations = false) {\n  try {\n    const ast = getRegExpAst(regExp);\n    const firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n    return firstChars;\n  } catch (e) {\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        PRINT_WARNING(`${failedOptimizationPrefixMsg}\tUnable to optimize: < ${regExp.toString()} >\n\tComplement Sets cannot be automatically optimized.\n\tThis will disable the lexer's first char optimizations.\n\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);\n      }\n    } else {\n      let msgSuffix = \"\";\n      if (ensureOptimizations) {\n        msgSuffix = \"\\n\tThis will disable the lexer's first char optimizations.\\n\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n      }\n      PRINT_ERROR(`${failedOptimizationPrefixMsg}\n\tFailed parsing: < ${regExp.toString()} >\n\tUsing the @chevrotain/regexp-to-ast library\n\tPlease open an issue at: https://github.com/chevrotain/chevrotain/issues` + msgSuffix);\n    }\n  }\n  return [];\n}\n__name(getOptimizedStartCodesIndices, \"getOptimizedStartCodesIndices\");\nfunction firstCharOptimizedIndices(ast, result, ignoreCase) {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (let i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n      }\n      break;\n    case \"Alternative\":\n      const terms = ast.value;\n      for (let i = 0; i < terms.length; i++) {\n        const term = terms[i];\n        switch (term.type) {\n          case \"EndAnchor\":\n          case \"GroupBackReference\":\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue;\n        }\n        const atom2 = term;\n        switch (atom2.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom2.value, result, ignoreCase);\n            break;\n          case \"Set\":\n            if (atom2.complement === true) {\n              throw Error(complementErrorMessage);\n            }\n            forEach_default(atom2.value, (code) => {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase);\n              } else {\n                const range = code;\n                if (ignoreCase === true) {\n                  for (let rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                } else {\n                  for (let rangeCode = range.from; rangeCode <= range.to && rangeCode < minOptimizationVal; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                  if (range.to >= minOptimizationVal) {\n                    const minUnOptVal = range.from >= minOptimizationVal ? range.from : minOptimizationVal;\n                    const maxUnOptVal = range.to;\n                    const minOptIdx = charCodeToOptimizedIndex(minUnOptVal);\n                    const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);\n                    for (let currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                      result[currOptIdx] = currOptIdx;\n                    }\n                  }\n                }\n              }\n            });\n            break;\n          case \"Group\":\n            firstCharOptimizedIndices(atom2.value, result, ignoreCase);\n            break;\n          default:\n            throw Error(\"Non Exhaustive Match\");\n        }\n        const isOptionalQuantifier = atom2.quantifier !== void 0 && atom2.quantifier.atLeast === 0;\n        if (\n          // A group may be optional due to empty contents /(?:)/\n          // or if everything inside it is optional /((a)?)/\n          atom2.type === \"Group\" && isWholeOptional(atom2) === false || // If this term is not a group it may only be optional if it has an optional quantifier\n          atom2.type !== \"Group\" && isOptionalQuantifier === false\n        ) {\n          break;\n        }\n      }\n      break;\n    default:\n      throw Error(\"non exhaustive match!\");\n  }\n  return values_default(result);\n}\n__name(firstCharOptimizedIndices, \"firstCharOptimizedIndices\");\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n  const optimizedCharIdx = charCodeToOptimizedIndex(code);\n  result[optimizedCharIdx] = optimizedCharIdx;\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result);\n  }\n}\n__name(addOptimizedIdxToResult, \"addOptimizedIdxToResult\");\nfunction handleIgnoreCase(code, result) {\n  const char = String.fromCharCode(code);\n  const upperChar = char.toUpperCase();\n  if (upperChar !== char) {\n    const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n    result[optimizedCharIdx] = optimizedCharIdx;\n  } else {\n    const lowerChar = char.toLowerCase();\n    if (lowerChar !== char) {\n      const optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\n      result[optimizedCharIdx] = optimizedCharIdx;\n    }\n  }\n}\n__name(handleIgnoreCase, \"handleIgnoreCase\");\nfunction findCode(setNode, targetCharCodes) {\n  return find_default(setNode.value, (codeOrRange) => {\n    if (typeof codeOrRange === \"number\") {\n      return includes_default(targetCharCodes, codeOrRange);\n    } else {\n      const range = codeOrRange;\n      return find_default(targetCharCodes, (targetCode) => range.from <= targetCode && targetCode <= range.to) !== void 0;\n    }\n  });\n}\n__name(findCode, \"findCode\");\nfunction isWholeOptional(ast) {\n  const quantifier = ast.quantifier;\n  if (quantifier && quantifier.atLeast === 0) {\n    return true;\n  }\n  if (!ast.value) {\n    return false;\n  }\n  return isArray_default(ast.value) ? every_default(ast.value, isWholeOptional) : isWholeOptional(ast.value);\n}\n__name(isWholeOptional, \"isWholeOptional\");\nvar CharCodeFinder = class extends BaseRegExpVisitor {\n  static {\n    __name(this, \"CharCodeFinder\");\n  }\n  constructor(targetCharCodes) {\n    super();\n    this.targetCharCodes = targetCharCodes;\n    this.found = false;\n  }\n  visitChildren(node) {\n    if (this.found === true) {\n      return;\n    }\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        return;\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        return;\n    }\n    super.visitChildren(node);\n  }\n  visitCharacter(node) {\n    if (includes_default(this.targetCharCodes, node.value)) {\n      this.found = true;\n    }\n  }\n  visitSet(node) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === void 0) {\n        this.found = true;\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== void 0) {\n        this.found = true;\n      }\n    }\n  }\n};\nfunction canMatchCharCode(charCodes, pattern) {\n  if (pattern instanceof RegExp) {\n    const ast = getRegExpAst(pattern);\n    const charCodeFinder = new CharCodeFinder(charCodes);\n    charCodeFinder.visit(ast);\n    return charCodeFinder.found;\n  } else {\n    return find_default(pattern, (char) => {\n      return includes_default(charCodes, char.charCodeAt(0));\n    }) !== void 0;\n  }\n}\n__name(canMatchCharCode, \"canMatchCharCode\");\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/scan/lexer.js\nvar PATTERN = \"PATTERN\";\nvar DEFAULT_MODE = \"defaultMode\";\nvar MODES = \"modes\";\nvar SUPPORT_STICKY = typeof new RegExp(\"(?:)\").sticky === \"boolean\";\nfunction analyzeTokenTypes(tokenTypes, options) {\n  options = defaults_default(options, {\n    useSticky: SUPPORT_STICKY,\n    debug: false,\n    safeMode: false,\n    positionTracking: \"full\",\n    lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n    tracer: /* @__PURE__ */ __name((msg, action) => action(), \"tracer\")\n  });\n  const tracer = options.tracer;\n  tracer(\"initCharCodeToOptimizedIndexMap\", () => {\n    initCharCodeToOptimizedIndexMap();\n  });\n  let onlyRelevantTypes;\n  tracer(\"Reject Lexer.NA\", () => {\n    onlyRelevantTypes = reject_default(tokenTypes, (currType) => {\n      return currType[PATTERN] === Lexer.NA;\n    });\n  });\n  let hasCustom = false;\n  let allTransformedPatterns;\n  tracer(\"Transform Patterns\", () => {\n    hasCustom = false;\n    allTransformedPatterns = map_default(onlyRelevantTypes, (currType) => {\n      const currPattern = currType[PATTERN];\n      if (isRegExp_default(currPattern)) {\n        const regExpSource = currPattern.source;\n        if (regExpSource.length === 1 && // only these regExp meta characters which can appear in a length one regExp\n        regExpSource !== \"^\" && regExpSource !== \"$\" && regExpSource !== \".\" && !currPattern.ignoreCase) {\n          return regExpSource;\n        } else if (regExpSource.length === 2 && regExpSource[0] === \"\\\\\" && // not a meta character\n        !includes_default([\n          \"d\",\n          \"D\",\n          \"s\",\n          \"S\",\n          \"t\",\n          \"r\",\n          \"n\",\n          \"t\",\n          \"0\",\n          \"c\",\n          \"b\",\n          \"B\",\n          \"f\",\n          \"v\",\n          \"w\",\n          \"W\"\n        ], regExpSource[1])) {\n          return regExpSource[1];\n        } else {\n          return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);\n        }\n      } else if (isFunction_default(currPattern)) {\n        hasCustom = true;\n        return { exec: currPattern };\n      } else if (typeof currPattern === \"object\") {\n        hasCustom = true;\n        return currPattern;\n      } else if (typeof currPattern === \"string\") {\n        if (currPattern.length === 1) {\n          return currPattern;\n        } else {\n          const escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n          const wrappedRegExp = new RegExp(escapedRegExpString);\n          return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);\n        }\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  });\n  let patternIdxToType;\n  let patternIdxToGroup;\n  let patternIdxToLongerAltIdxArr;\n  let patternIdxToPushMode;\n  let patternIdxToPopMode;\n  tracer(\"misc mapping\", () => {\n    patternIdxToType = map_default(onlyRelevantTypes, (currType) => currType.tokenTypeIdx);\n    patternIdxToGroup = map_default(onlyRelevantTypes, (clazz) => {\n      const groupName = clazz.GROUP;\n      if (groupName === Lexer.SKIPPED) {\n        return void 0;\n      } else if (isString_default(groupName)) {\n        return groupName;\n      } else if (isUndefined_default(groupName)) {\n        return false;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n    patternIdxToLongerAltIdxArr = map_default(onlyRelevantTypes, (clazz) => {\n      const longerAltType = clazz.LONGER_ALT;\n      if (longerAltType) {\n        const longerAltIdxArr = isArray_default(longerAltType) ? map_default(longerAltType, (type) => indexOf_default(onlyRelevantTypes, type)) : [indexOf_default(onlyRelevantTypes, longerAltType)];\n        return longerAltIdxArr;\n      }\n    });\n    patternIdxToPushMode = map_default(onlyRelevantTypes, (clazz) => clazz.PUSH_MODE);\n    patternIdxToPopMode = map_default(onlyRelevantTypes, (clazz) => has_default(clazz, \"POP_MODE\"));\n  });\n  let patternIdxToCanLineTerminator;\n  tracer(\"Line Terminator Handling\", () => {\n    const lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);\n    patternIdxToCanLineTerminator = map_default(onlyRelevantTypes, (tokType) => false);\n    if (options.positionTracking !== \"onlyOffset\") {\n      patternIdxToCanLineTerminator = map_default(onlyRelevantTypes, (tokType) => {\n        if (has_default(tokType, \"LINE_BREAKS\")) {\n          return !!tokType.LINE_BREAKS;\n        } else {\n          return checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false && canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n        }\n      });\n    }\n  });\n  let patternIdxToIsCustom;\n  let patternIdxToShort;\n  let emptyGroups;\n  let patternIdxToConfig;\n  tracer(\"Misc Mapping #2\", () => {\n    patternIdxToIsCustom = map_default(onlyRelevantTypes, isCustomPattern);\n    patternIdxToShort = map_default(allTransformedPatterns, isShortPattern);\n    emptyGroups = reduce_default(onlyRelevantTypes, (acc, clazz) => {\n      const groupName = clazz.GROUP;\n      if (isString_default(groupName) && !(groupName === Lexer.SKIPPED)) {\n        acc[groupName] = [];\n      }\n      return acc;\n    }, {});\n    patternIdxToConfig = map_default(allTransformedPatterns, (x, idx) => {\n      return {\n        pattern: allTransformedPatterns[idx],\n        longerAlt: patternIdxToLongerAltIdxArr[idx],\n        canLineTerminator: patternIdxToCanLineTerminator[idx],\n        isCustom: patternIdxToIsCustom[idx],\n        short: patternIdxToShort[idx],\n        group: patternIdxToGroup[idx],\n        push: patternIdxToPushMode[idx],\n        pop: patternIdxToPopMode[idx],\n        tokenTypeIdx: patternIdxToType[idx],\n        tokenType: onlyRelevantTypes[idx]\n      };\n    });\n  });\n  let canBeOptimized = true;\n  let charCodeToPatternIdxToConfig = [];\n  if (!options.safeMode) {\n    tracer(\"First Char Optimization\", () => {\n      charCodeToPatternIdxToConfig = reduce_default(onlyRelevantTypes, (result, currTokType, idx) => {\n        if (typeof currTokType.PATTERN === \"string\") {\n          const charCode = currTokType.PATTERN.charCodeAt(0);\n          const optimizedIdx = charCodeToOptimizedIndex(charCode);\n          addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n        } else if (isArray_default(currTokType.START_CHARS_HINT)) {\n          let lastOptimizedIdx;\n          forEach_default(currTokType.START_CHARS_HINT, (charOrInt) => {\n            const charCode = typeof charOrInt === \"string\" ? charOrInt.charCodeAt(0) : charOrInt;\n            const currOptimizedIdx = charCodeToOptimizedIndex(charCode);\n            if (lastOptimizedIdx !== currOptimizedIdx) {\n              lastOptimizedIdx = currOptimizedIdx;\n              addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n            }\n          });\n        } else if (isRegExp_default(currTokType.PATTERN)) {\n          if (currTokType.PATTERN.unicode) {\n            canBeOptimized = false;\n            if (options.ensureOptimizations) {\n              PRINT_ERROR(`${failedOptimizationPrefixMsg}\tUnable to analyze < ${currTokType.PATTERN.toString()} > pattern.\n\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`);\n            }\n          } else {\n            const optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);\n            if (isEmpty_default(optimizedCodes)) {\n              canBeOptimized = false;\n            }\n            forEach_default(optimizedCodes, (code) => {\n              addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n            });\n          }\n        } else {\n          if (options.ensureOptimizations) {\n            PRINT_ERROR(`${failedOptimizationPrefixMsg}\tTokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`);\n          }\n          canBeOptimized = false;\n        }\n        return result;\n      }, []);\n    });\n  }\n  return {\n    emptyGroups,\n    patternIdxToConfig,\n    charCodeToPatternIdxToConfig,\n    hasCustom,\n    canBeOptimized\n  };\n}\n__name(analyzeTokenTypes, \"analyzeTokenTypes\");\nfunction validatePatterns(tokenTypes, validModesNames) {\n  let errors = [];\n  const missingResult = findMissingPatterns(tokenTypes);\n  errors = errors.concat(missingResult.errors);\n  const invalidResult = findInvalidPatterns(missingResult.valid);\n  const validTokenTypes = invalidResult.valid;\n  errors = errors.concat(invalidResult.errors);\n  errors = errors.concat(validateRegExpPattern(validTokenTypes));\n  errors = errors.concat(findInvalidGroupType(validTokenTypes));\n  errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));\n  errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n  return errors;\n}\n__name(validatePatterns, \"validatePatterns\");\nfunction validateRegExpPattern(tokenTypes) {\n  let errors = [];\n  const withRegExpPatterns = filter_default(tokenTypes, (currTokType) => isRegExp_default(currTokType[PATTERN]));\n  errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n  errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n  errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n  errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n  errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n  return errors;\n}\n__name(validateRegExpPattern, \"validateRegExpPattern\");\nfunction findMissingPatterns(tokenTypes) {\n  const tokenTypesWithMissingPattern = filter_default(tokenTypes, (currType) => {\n    return !has_default(currType, PATTERN);\n  });\n  const errors = map_default(tokenTypesWithMissingPattern, (currType) => {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- missing static 'PATTERN' property\",\n      type: LexerDefinitionErrorType.MISSING_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  const valid = difference_default(tokenTypes, tokenTypesWithMissingPattern);\n  return { errors, valid };\n}\n__name(findMissingPatterns, \"findMissingPatterns\");\nfunction findInvalidPatterns(tokenTypes) {\n  const tokenTypesWithInvalidPattern = filter_default(tokenTypes, (currType) => {\n    const pattern = currType[PATTERN];\n    return !isRegExp_default(pattern) && !isFunction_default(pattern) && !has_default(pattern, \"exec\") && !isString_default(pattern);\n  });\n  const errors = map_default(tokenTypesWithInvalidPattern, (currType) => {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n      type: LexerDefinitionErrorType.INVALID_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  const valid = difference_default(tokenTypes, tokenTypesWithInvalidPattern);\n  return { errors, valid };\n}\n__name(findInvalidPatterns, \"findInvalidPatterns\");\nvar end_of_input = /[^\\\\][$]/;\nfunction findEndOfInputAnchor(tokenTypes) {\n  class EndAnchorFinder extends BaseRegExpVisitor {\n    static {\n      __name(this, \"EndAnchorFinder\");\n    }\n    constructor() {\n      super(...arguments);\n      this.found = false;\n    }\n    visitEndAnchor(node) {\n      this.found = true;\n    }\n  }\n  const invalidRegex = filter_default(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN;\n    try {\n      const regexpAst = getRegExpAst(pattern);\n      const endAnchorVisitor = new EndAnchorFinder();\n      endAnchorVisitor.visit(regexpAst);\n      return endAnchorVisitor.found;\n    } catch (e) {\n      return end_of_input.test(pattern.source);\n    }\n  });\n  const errors = map_default(invalidRegex, (currType) => {\n    return {\n      message: \"Unexpected RegExp Anchor Error:\\n\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.\",\n      type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\n__name(findEndOfInputAnchor, \"findEndOfInputAnchor\");\nfunction findEmptyMatchRegExps(tokenTypes) {\n  const matchesEmptyString = filter_default(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN;\n    return pattern.test(\"\");\n  });\n  const errors = map_default(matchesEmptyString, (currType) => {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' must not match an empty string\",\n      type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\n__name(findEmptyMatchRegExps, \"findEmptyMatchRegExps\");\nvar start_of_input = /[^\\\\[][\\^]|^\\^/;\nfunction findStartOfInputAnchor(tokenTypes) {\n  class StartAnchorFinder extends BaseRegExpVisitor {\n    static {\n      __name(this, \"StartAnchorFinder\");\n    }\n    constructor() {\n      super(...arguments);\n      this.found = false;\n    }\n    visitStartAnchor(node) {\n      this.found = true;\n    }\n  }\n  const invalidRegex = filter_default(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN;\n    try {\n      const regexpAst = getRegExpAst(pattern);\n      const startAnchorVisitor = new StartAnchorFinder();\n      startAnchorVisitor.visit(regexpAst);\n      return startAnchorVisitor.found;\n    } catch (e) {\n      return start_of_input.test(pattern.source);\n    }\n  });\n  const errors = map_default(invalidRegex, (currType) => {\n    return {\n      message: \"Unexpected RegExp Anchor Error:\\n\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.\",\n      type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\n__name(findStartOfInputAnchor, \"findStartOfInputAnchor\");\nfunction findUnsupportedFlags(tokenTypes) {\n  const invalidFlags = filter_default(tokenTypes, (currType) => {\n    const pattern = currType[PATTERN];\n    return pattern instanceof RegExp && (pattern.multiline || pattern.global);\n  });\n  const errors = map_default(invalidFlags, (currType) => {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n      type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\n__name(findUnsupportedFlags, \"findUnsupportedFlags\");\nfunction findDuplicatePatterns(tokenTypes) {\n  const found = [];\n  let identicalPatterns = map_default(tokenTypes, (outerType) => {\n    return reduce_default(tokenTypes, (result, innerType) => {\n      if (outerType.PATTERN.source === innerType.PATTERN.source && !includes_default(found, innerType) && innerType.PATTERN !== Lexer.NA) {\n        found.push(innerType);\n        result.push(innerType);\n        return result;\n      }\n      return result;\n    }, []);\n  });\n  identicalPatterns = compact_default(identicalPatterns);\n  const duplicatePatterns = filter_default(identicalPatterns, (currIdenticalSet) => {\n    return currIdenticalSet.length > 1;\n  });\n  const errors = map_default(duplicatePatterns, (setOfIdentical) => {\n    const tokenTypeNames = map_default(setOfIdentical, (currType) => {\n      return currType.name;\n    });\n    const dupPatternSrc = head_default(setOfIdentical).PATTERN;\n    return {\n      message: `The same RegExp pattern ->${dupPatternSrc}<-has been used in all of the following Token Types: ${tokenTypeNames.join(\", \")} <-`,\n      type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n      tokenTypes: setOfIdentical\n    };\n  });\n  return errors;\n}\n__name(findDuplicatePatterns, \"findDuplicatePatterns\");\nfunction findInvalidGroupType(tokenTypes) {\n  const invalidTypes = filter_default(tokenTypes, (clazz) => {\n    if (!has_default(clazz, \"GROUP\")) {\n      return false;\n    }\n    const group = clazz.GROUP;\n    return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString_default(group);\n  });\n  const errors = map_default(invalidTypes, (currType) => {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n      type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\n__name(findInvalidGroupType, \"findInvalidGroupType\");\nfunction findModesThatDoNotExist(tokenTypes, validModes) {\n  const invalidModes = filter_default(tokenTypes, (clazz) => {\n    return clazz.PUSH_MODE !== void 0 && !includes_default(validModes, clazz.PUSH_MODE);\n  });\n  const errors = map_default(invalidModes, (tokType) => {\n    const msg = `Token Type: ->${tokType.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-which does not exist`;\n    return {\n      message: msg,\n      type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n      tokenTypes: [tokType]\n    };\n  });\n  return errors;\n}\n__name(findModesThatDoNotExist, \"findModesThatDoNotExist\");\nfunction findUnreachablePatterns(tokenTypes) {\n  const errors = [];\n  const canBeTested = reduce_default(tokenTypes, (result, tokType, idx) => {\n    const pattern = tokType.PATTERN;\n    if (pattern === Lexer.NA) {\n      return result;\n    }\n    if (isString_default(pattern)) {\n      result.push({ str: pattern, idx, tokenType: tokType });\n    } else if (isRegExp_default(pattern) && noMetaChar(pattern)) {\n      result.push({ str: pattern.source, idx, tokenType: tokType });\n    }\n    return result;\n  }, []);\n  forEach_default(tokenTypes, (tokType, testIdx) => {\n    forEach_default(canBeTested, ({ str, idx, tokenType }) => {\n      if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n        const msg = `Token: ->${tokenType.name}<- can never be matched.\nBecause it appears AFTER the Token Type ->${tokType.name}<-in the lexer's definition.\nSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;\n        errors.push({\n          message: msg,\n          type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n          tokenTypes: [tokType, tokenType]\n        });\n      }\n    });\n  });\n  return errors;\n}\n__name(findUnreachablePatterns, \"findUnreachablePatterns\");\nfunction testTokenType(str, pattern) {\n  if (isRegExp_default(pattern)) {\n    const regExpArray = pattern.exec(str);\n    return regExpArray !== null && regExpArray.index === 0;\n  } else if (isFunction_default(pattern)) {\n    return pattern(str, 0, [], {});\n  } else if (has_default(pattern, \"exec\")) {\n    return pattern.exec(str, 0, [], {});\n  } else if (typeof pattern === \"string\") {\n    return pattern === str;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n__name(testTokenType, \"testTokenType\");\nfunction noMetaChar(regExp) {\n  const metaChars = [\n    \".\",\n    \"\\\\\",\n    \"[\",\n    \"]\",\n    \"|\",\n    \"^\",\n    \"$\",\n    \"(\",\n    \")\",\n    \"?\",\n    \"*\",\n    \"+\",\n    \"{\"\n  ];\n  return find_default(metaChars, (char) => regExp.source.indexOf(char) !== -1) === void 0;\n}\n__name(noMetaChar, \"noMetaChar\");\nfunction addStartOfInput(pattern) {\n  const flags = pattern.ignoreCase ? \"i\" : \"\";\n  return new RegExp(`^(?:${pattern.source})`, flags);\n}\n__name(addStartOfInput, \"addStartOfInput\");\nfunction addStickyFlag(pattern) {\n  const flags = pattern.ignoreCase ? \"iy\" : \"y\";\n  return new RegExp(`${pattern.source}`, flags);\n}\n__name(addStickyFlag, \"addStickyFlag\");\nfunction performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n  const errors = [];\n  if (!has_default(lexerDefinition, DEFAULT_MODE)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized without a <\" + DEFAULT_MODE + \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n    });\n  }\n  if (!has_default(lexerDefinition, MODES)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized without a <\" + MODES + \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n    });\n  }\n  if (has_default(lexerDefinition, MODES) && has_default(lexerDefinition, DEFAULT_MODE) && !has_default(lexerDefinition.modes, lexerDefinition.defaultMode)) {\n    errors.push({\n      message: `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: <${lexerDefinition.defaultMode}>which does not exist\n`,\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n    });\n  }\n  if (has_default(lexerDefinition, MODES)) {\n    forEach_default(lexerDefinition.modes, (currModeValue, currModeName) => {\n      forEach_default(currModeValue, (currTokType, currIdx) => {\n        if (isUndefined_default(currTokType)) {\n          errors.push({\n            message: `A Lexer cannot be initialized using an undefined Token Type. Mode:<${currModeName}> at index: <${currIdx}>\n`,\n            type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n          });\n        } else if (has_default(currTokType, \"LONGER_ALT\")) {\n          const longerAlt = isArray_default(currTokType.LONGER_ALT) ? currTokType.LONGER_ALT : [currTokType.LONGER_ALT];\n          forEach_default(longerAlt, (currLongerAlt) => {\n            if (!isUndefined_default(currLongerAlt) && !includes_default(currModeValue, currLongerAlt)) {\n              errors.push({\n                message: `A MultiMode Lexer cannot be initialized with a longer_alt <${currLongerAlt.name}> on token <${currTokType.name}> outside of mode <${currModeName}>\n`,\n                type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\n              });\n            }\n          });\n        }\n      });\n    });\n  }\n  return errors;\n}\n__name(performRuntimeChecks, \"performRuntimeChecks\");\nfunction performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n  const warnings = [];\n  let hasAnyLineBreak = false;\n  const allTokenTypes = compact_default(flatten_default(values_default(lexerDefinition.modes)));\n  const concreteTokenTypes = reject_default(allTokenTypes, (currType) => currType[PATTERN] === Lexer.NA);\n  const terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n  if (trackLines) {\n    forEach_default(concreteTokenTypes, (tokType) => {\n      const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n      if (currIssue !== false) {\n        const message = buildLineBreakIssueMessage(tokType, currIssue);\n        const warningDescriptor = {\n          message,\n          type: currIssue.issue,\n          tokenType: tokType\n        };\n        warnings.push(warningDescriptor);\n      } else {\n        if (has_default(tokType, \"LINE_BREAKS\")) {\n          if (tokType.LINE_BREAKS === true) {\n            hasAnyLineBreak = true;\n          }\n        } else {\n          if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {\n            hasAnyLineBreak = true;\n          }\n        }\n      }\n    });\n  }\n  if (trackLines && !hasAnyLineBreak) {\n    warnings.push({\n      message: \"Warning: No LINE_BREAKS Found.\\n\tThis Lexer has been defined to track line and column information,\\n\tBut none of the Token Types can be identified as matching a line terminator.\\n\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\tfor details.\",\n      type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS\n    });\n  }\n  return warnings;\n}\n__name(performWarningRuntimeChecks, \"performWarningRuntimeChecks\");\nfunction cloneEmptyGroups(emptyGroups) {\n  const clonedResult = {};\n  const groupKeys = keys_default(emptyGroups);\n  forEach_default(groupKeys, (currKey) => {\n    const currGroupValue = emptyGroups[currKey];\n    if (isArray_default(currGroupValue)) {\n      clonedResult[currKey] = [];\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  });\n  return clonedResult;\n}\n__name(cloneEmptyGroups, \"cloneEmptyGroups\");\nfunction isCustomPattern(tokenType) {\n  const pattern = tokenType.PATTERN;\n  if (isRegExp_default(pattern)) {\n    return false;\n  } else if (isFunction_default(pattern)) {\n    return true;\n  } else if (has_default(pattern, \"exec\")) {\n    return true;\n  } else if (isString_default(pattern)) {\n    return false;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n__name(isCustomPattern, \"isCustomPattern\");\nfunction isShortPattern(pattern) {\n  if (isString_default(pattern) && pattern.length === 1) {\n    return pattern.charCodeAt(0);\n  } else {\n    return false;\n  }\n}\n__name(isShortPattern, \"isShortPattern\");\nvar LineTerminatorOptimizedTester = {\n  // implements /\\n|\\r\\n?/g.test\n  test: /* @__PURE__ */ __name(function(text) {\n    const len = text.length;\n    for (let i = this.lastIndex; i < len; i++) {\n      const c = text.charCodeAt(i);\n      if (c === 10) {\n        this.lastIndex = i + 1;\n        return true;\n      } else if (c === 13) {\n        if (text.charCodeAt(i + 1) === 10) {\n          this.lastIndex = i + 2;\n        } else {\n          this.lastIndex = i + 1;\n        }\n        return true;\n      }\n    }\n    return false;\n  }, \"test\"),\n  lastIndex: 0\n};\nfunction checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n  if (has_default(tokType, \"LINE_BREAKS\")) {\n    return false;\n  } else {\n    if (isRegExp_default(tokType.PATTERN)) {\n      try {\n        canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n      } catch (e) {\n        return {\n          issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n          errMsg: e.message\n        };\n      }\n      return false;\n    } else if (isString_default(tokType.PATTERN)) {\n      return false;\n    } else if (isCustomPattern(tokType)) {\n      return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK };\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n}\n__name(checkLineBreaksIssues, \"checkLineBreaksIssues\");\nfunction buildLineBreakIssueMessage(tokType, details) {\n  if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n    return `Warning: unable to identify line terminator usage in pattern.\n\tThe problem is in the <${tokType.name}> Token Type\n\t Root cause: ${details.errMsg}.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR`;\n  } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n    return `Warning: A Custom Token Pattern should specify the <line_breaks> option.\n\tThe problem is in the <${tokType.name}> Token Type\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK`;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n__name(buildLineBreakIssueMessage, \"buildLineBreakIssueMessage\");\nfunction getCharCodes(charsOrCodes) {\n  const charCodes = map_default(charsOrCodes, (numOrString) => {\n    if (isString_default(numOrString)) {\n      return numOrString.charCodeAt(0);\n    } else {\n      return numOrString;\n    }\n  });\n  return charCodes;\n}\n__name(getCharCodes, \"getCharCodes\");\nfunction addToMapOfArrays(map, key, value) {\n  if (map[key] === void 0) {\n    map[key] = [value];\n  } else {\n    map[key].push(value);\n  }\n}\n__name(addToMapOfArrays, \"addToMapOfArrays\");\nvar minOptimizationVal = 256;\nvar charCodeToOptimizedIdxMap = [];\nfunction charCodeToOptimizedIndex(charCode) {\n  return charCode < minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];\n}\n__name(charCodeToOptimizedIndex, \"charCodeToOptimizedIndex\");\nfunction initCharCodeToOptimizedIndexMap() {\n  if (isEmpty_default(charCodeToOptimizedIdxMap)) {\n    charCodeToOptimizedIdxMap = new Array(65536);\n    for (let i = 0; i < 65536; i++) {\n      charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n    }\n  }\n}\n__name(initCharCodeToOptimizedIndexMap, \"initCharCodeToOptimizedIndexMap\");\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/scan/tokens.js\nfunction tokenStructuredMatcher(tokInstance, tokConstructor) {\n  const instanceType = tokInstance.tokenTypeIdx;\n  if (instanceType === tokConstructor.tokenTypeIdx) {\n    return true;\n  } else {\n    return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;\n  }\n}\n__name(tokenStructuredMatcher, \"tokenStructuredMatcher\");\nfunction tokenStructuredMatcherNoCategories(token, tokType) {\n  return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\n__name(tokenStructuredMatcherNoCategories, \"tokenStructuredMatcherNoCategories\");\nvar tokenShortNameIdx = 1;\nvar tokenIdxToClass = {};\nfunction augmentTokenTypes(tokenTypes) {\n  const tokenTypesAndParents = expandCategories(tokenTypes);\n  assignTokenDefaultProps(tokenTypesAndParents);\n  assignCategoriesMapProp(tokenTypesAndParents);\n  assignCategoriesTokensProp(tokenTypesAndParents);\n  forEach_default(tokenTypesAndParents, (tokType) => {\n    tokType.isParent = tokType.categoryMatches.length > 0;\n  });\n}\n__name(augmentTokenTypes, \"augmentTokenTypes\");\nfunction expandCategories(tokenTypes) {\n  let result = clone_default(tokenTypes);\n  let categories = tokenTypes;\n  let searching = true;\n  while (searching) {\n    categories = compact_default(flatten_default(map_default(categories, (currTokType) => currTokType.CATEGORIES)));\n    const newCategories = difference_default(categories, result);\n    result = result.concat(newCategories);\n    if (isEmpty_default(newCategories)) {\n      searching = false;\n    } else {\n      categories = newCategories;\n    }\n  }\n  return result;\n}\n__name(expandCategories, \"expandCategories\");\nfunction assignTokenDefaultProps(tokenTypes) {\n  forEach_default(tokenTypes, (currTokType) => {\n    if (!hasShortKeyProperty(currTokType)) {\n      tokenIdxToClass[tokenShortNameIdx] = currTokType;\n      currTokType.tokenTypeIdx = tokenShortNameIdx++;\n    }\n    if (hasCategoriesProperty(currTokType) && !isArray_default(currTokType.CATEGORIES)) {\n      currTokType.CATEGORIES = [currTokType.CATEGORIES];\n    }\n    if (!hasCategoriesProperty(currTokType)) {\n      currTokType.CATEGORIES = [];\n    }\n    if (!hasExtendingTokensTypesProperty(currTokType)) {\n      currTokType.categoryMatches = [];\n    }\n    if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n      currTokType.categoryMatchesMap = {};\n    }\n  });\n}\n__name(assignTokenDefaultProps, \"assignTokenDefaultProps\");\nfunction assignCategoriesTokensProp(tokenTypes) {\n  forEach_default(tokenTypes, (currTokType) => {\n    currTokType.categoryMatches = [];\n    forEach_default(currTokType.categoryMatchesMap, (val, key) => {\n      currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);\n    });\n  });\n}\n__name(assignCategoriesTokensProp, \"assignCategoriesTokensProp\");\nfunction assignCategoriesMapProp(tokenTypes) {\n  forEach_default(tokenTypes, (currTokType) => {\n    singleAssignCategoriesToksMap([], currTokType);\n  });\n}\n__name(assignCategoriesMapProp, \"assignCategoriesMapProp\");\nfunction singleAssignCategoriesToksMap(path, nextNode) {\n  forEach_default(path, (pathNode) => {\n    nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n  });\n  forEach_default(nextNode.CATEGORIES, (nextCategory) => {\n    const newPath = path.concat(nextNode);\n    if (!includes_default(newPath, nextCategory)) {\n      singleAssignCategoriesToksMap(newPath, nextCategory);\n    }\n  });\n}\n__name(singleAssignCategoriesToksMap, \"singleAssignCategoriesToksMap\");\nfunction hasShortKeyProperty(tokType) {\n  return has_default(tokType, \"tokenTypeIdx\");\n}\n__name(hasShortKeyProperty, \"hasShortKeyProperty\");\nfunction hasCategoriesProperty(tokType) {\n  return has_default(tokType, \"CATEGORIES\");\n}\n__name(hasCategoriesProperty, \"hasCategoriesProperty\");\nfunction hasExtendingTokensTypesProperty(tokType) {\n  return has_default(tokType, \"categoryMatches\");\n}\n__name(hasExtendingTokensTypesProperty, \"hasExtendingTokensTypesProperty\");\nfunction hasExtendingTokensTypesMapProperty(tokType) {\n  return has_default(tokType, \"categoryMatchesMap\");\n}\n__name(hasExtendingTokensTypesMapProperty, \"hasExtendingTokensTypesMapProperty\");\nfunction isTokenType(tokType) {\n  return has_default(tokType, \"tokenTypeIdx\");\n}\n__name(isTokenType, \"isTokenType\");\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/scan/lexer_errors_public.js\nvar defaultLexerErrorProvider = {\n  buildUnableToPopLexerModeMessage(token) {\n    return `Unable to pop Lexer Mode after encountering Token ->${token.image}<- The Mode Stack is empty`;\n  },\n  buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {\n    return `unexpected character: ->${fullText.charAt(startOffset)}<- at offset: ${startOffset}, skipped ${length} characters.`;\n  }\n};\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/scan/lexer_public.js\nvar LexerDefinitionErrorType;\n(function(LexerDefinitionErrorType2) {\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\"] = 17] = \"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\";\n})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));\nvar DEFAULT_LEXER_CONFIG = {\n  deferDefinitionErrorsHandling: false,\n  positionTracking: \"full\",\n  lineTerminatorsPattern: /\\n|\\r\\n?/g,\n  lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n  ensureOptimizations: false,\n  safeMode: false,\n  errorMessageProvider: defaultLexerErrorProvider,\n  traceInitPerf: false,\n  skipValidations: false,\n  recoveryEnabled: true\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\nvar Lexer = class {\n  static {\n    __name(this, \"Lexer\");\n  }\n  constructor(lexerDefinition, config = DEFAULT_LEXER_CONFIG) {\n    this.lexerDefinition = lexerDefinition;\n    this.lexerDefinitionErrors = [];\n    this.lexerDefinitionWarning = [];\n    this.patternIdxToConfig = {};\n    this.charCodeToPatternIdxToConfig = {};\n    this.modes = [];\n    this.emptyGroups = {};\n    this.trackStartLines = true;\n    this.trackEndLines = true;\n    this.hasCustom = false;\n    this.canModeBeOptimized = {};\n    this.TRACE_INIT = (phaseDesc, phaseImpl) => {\n      if (this.traceInitPerf === true) {\n        this.traceInitIndent++;\n        const indent = new Array(this.traceInitIndent + 1).join(\"\t\");\n        if (this.traceInitIndent < this.traceInitMaxIdent) {\n          console.log(`${indent}--> <${phaseDesc}>`);\n        }\n        const { time, value } = timer(phaseImpl);\n        const traceMethod = time > 10 ? console.warn : console.log;\n        if (this.traceInitIndent < this.traceInitMaxIdent) {\n          traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n        }\n        this.traceInitIndent--;\n        return value;\n      } else {\n        return phaseImpl();\n      }\n    };\n    if (typeof config === \"boolean\") {\n      throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\na boolean 2nd argument is no longer supported\");\n    }\n    this.config = assign_default({}, DEFAULT_LEXER_CONFIG, config);\n    const traceInitVal = this.config.traceInitPerf;\n    if (traceInitVal === true) {\n      this.traceInitMaxIdent = Infinity;\n      this.traceInitPerf = true;\n    } else if (typeof traceInitVal === \"number\") {\n      this.traceInitMaxIdent = traceInitVal;\n      this.traceInitPerf = true;\n    }\n    this.traceInitIndent = -1;\n    this.TRACE_INIT(\"Lexer Constructor\", () => {\n      let actualDefinition;\n      let hasOnlySingleMode = true;\n      this.TRACE_INIT(\"Lexer Config handling\", () => {\n        if (this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n          this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;\n        } else {\n          if (this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n            throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n          }\n        }\n        if (config.safeMode && config.ensureOptimizations) {\n          throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n        }\n        this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking);\n        this.trackEndLines = /full/i.test(this.config.positionTracking);\n        if (isArray_default(lexerDefinition)) {\n          actualDefinition = {\n            modes: { defaultMode: clone_default(lexerDefinition) },\n            defaultMode: DEFAULT_MODE\n          };\n        } else {\n          hasOnlySingleMode = false;\n          actualDefinition = clone_default(lexerDefinition);\n        }\n      });\n      if (this.config.skipValidations === false) {\n        this.TRACE_INIT(\"performRuntimeChecks\", () => {\n          this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(performRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));\n        });\n        this.TRACE_INIT(\"performWarningRuntimeChecks\", () => {\n          this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(performWarningRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));\n        });\n      }\n      actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};\n      forEach_default(actualDefinition.modes, (currModeValue, currModeName) => {\n        actualDefinition.modes[currModeName] = reject_default(currModeValue, (currTokType) => isUndefined_default(currTokType));\n      });\n      const allModeNames = keys_default(actualDefinition.modes);\n      forEach_default(actualDefinition.modes, (currModDef, currModName) => {\n        this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {\n          this.modes.push(currModName);\n          if (this.config.skipValidations === false) {\n            this.TRACE_INIT(`validatePatterns`, () => {\n              this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(validatePatterns(currModDef, allModeNames));\n            });\n          }\n          if (isEmpty_default(this.lexerDefinitionErrors)) {\n            augmentTokenTypes(currModDef);\n            let currAnalyzeResult;\n            this.TRACE_INIT(`analyzeTokenTypes`, () => {\n              currAnalyzeResult = analyzeTokenTypes(currModDef, {\n                lineTerminatorCharacters: this.config.lineTerminatorCharacters,\n                positionTracking: config.positionTracking,\n                ensureOptimizations: config.ensureOptimizations,\n                safeMode: config.safeMode,\n                tracer: this.TRACE_INIT\n              });\n            });\n            this.patternIdxToConfig[currModName] = currAnalyzeResult.patternIdxToConfig;\n            this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult.charCodeToPatternIdxToConfig;\n            this.emptyGroups = assign_default({}, this.emptyGroups, currAnalyzeResult.emptyGroups);\n            this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom;\n            this.canModeBeOptimized[currModName] = currAnalyzeResult.canBeOptimized;\n          }\n        });\n      });\n      this.defaultMode = actualDefinition.defaultMode;\n      if (!isEmpty_default(this.lexerDefinitionErrors) && !this.config.deferDefinitionErrorsHandling) {\n        const allErrMessages = map_default(this.lexerDefinitionErrors, (error) => {\n          return error.message;\n        });\n        const allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n        throw new Error(\"Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n      }\n      forEach_default(this.lexerDefinitionWarning, (warningDescriptor) => {\n        PRINT_WARNING(warningDescriptor.message);\n      });\n      this.TRACE_INIT(\"Choosing sub-methods implementations\", () => {\n        if (SUPPORT_STICKY) {\n          this.chopInput = identity_default;\n          this.match = this.matchWithTest;\n        } else {\n          this.updateLastIndex = noop_default;\n          this.match = this.matchWithExec;\n        }\n        if (hasOnlySingleMode) {\n          this.handleModes = noop_default;\n        }\n        if (this.trackStartLines === false) {\n          this.computeNewColumn = identity_default;\n        }\n        if (this.trackEndLines === false) {\n          this.updateTokenEndLineColumnLocation = noop_default;\n        }\n        if (/full/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createFullToken;\n        } else if (/onlyStart/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createStartOnlyToken;\n        } else if (/onlyOffset/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createOffsetOnlyToken;\n        } else {\n          throw Error(`Invalid <positionTracking> config option: \"${this.config.positionTracking}\"`);\n        }\n        if (this.hasCustom) {\n          this.addToken = this.addTokenUsingPush;\n          this.handlePayload = this.handlePayloadWithCustom;\n        } else {\n          this.addToken = this.addTokenUsingMemberAccess;\n          this.handlePayload = this.handlePayloadNoCustom;\n        }\n      });\n      this.TRACE_INIT(\"Failed Optimization Warnings\", () => {\n        const unOptimizedModes = reduce_default(this.canModeBeOptimized, (cannotBeOptimized, canBeOptimized, modeName) => {\n          if (canBeOptimized === false) {\n            cannotBeOptimized.push(modeName);\n          }\n          return cannotBeOptimized;\n        }, []);\n        if (config.ensureOptimizations && !isEmpty_default(unOptimizedModes)) {\n          throw Error(`Lexer Modes: < ${unOptimizedModes.join(\", \")} > cannot be optimized.\n\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n\t Or inspect the console log for details on how to resolve these issues.`);\n        }\n      });\n      this.TRACE_INIT(\"clearRegExpParserCache\", () => {\n        clearRegExpParserCache();\n      });\n      this.TRACE_INIT(\"toFastProperties\", () => {\n        toFastProperties(this);\n      });\n    });\n  }\n  tokenize(text, initialMode = this.defaultMode) {\n    if (!isEmpty_default(this.lexerDefinitionErrors)) {\n      const allErrMessages = map_default(this.lexerDefinitionErrors, (error) => {\n        return error.message;\n      });\n      const allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n      throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n    }\n    return this.tokenizeInternal(text, initialMode);\n  }\n  // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n  // This is intentional due to performance considerations.\n  // this method also used quite a bit of `!` none null assertions because it is too optimized\n  // for `tsc` to always understand it is \"safe\"\n  tokenizeInternal(text, initialMode) {\n    let i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n    const orgText = text;\n    const orgLength = orgText.length;\n    let offset = 0;\n    let matchedTokensIndex = 0;\n    const guessedNumberOfTokens = this.hasCustom ? 0 : Math.floor(text.length / 10);\n    const matchedTokens = new Array(guessedNumberOfTokens);\n    const errors = [];\n    let line = this.trackStartLines ? 1 : void 0;\n    let column = this.trackStartLines ? 1 : void 0;\n    const groups = cloneEmptyGroups(this.emptyGroups);\n    const trackLines = this.trackStartLines;\n    const lineTerminatorPattern = this.config.lineTerminatorsPattern;\n    let currModePatternsLength = 0;\n    let patternIdxToConfig = [];\n    let currCharCodeToPatternIdxToConfig = [];\n    const modeStack = [];\n    const emptyArray = [];\n    Object.freeze(emptyArray);\n    let getPossiblePatterns;\n    function getPossiblePatternsSlow() {\n      return patternIdxToConfig;\n    }\n    __name(getPossiblePatternsSlow, \"getPossiblePatternsSlow\");\n    function getPossiblePatternsOptimized(charCode) {\n      const optimizedCharIdx = charCodeToOptimizedIndex(charCode);\n      const possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n      if (possiblePatterns === void 0) {\n        return emptyArray;\n      } else {\n        return possiblePatterns;\n      }\n    }\n    __name(getPossiblePatternsOptimized, \"getPossiblePatternsOptimized\");\n    const pop_mode = /* @__PURE__ */ __name((popToken) => {\n      if (modeStack.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n      // So no error should occur.\n      popToken.tokenType.PUSH_MODE === void 0) {\n        const msg2 = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n        errors.push({\n          offset: popToken.startOffset,\n          line: popToken.startLine,\n          column: popToken.startColumn,\n          length: popToken.image.length,\n          message: msg2\n        });\n      } else {\n        modeStack.pop();\n        const newMode = last_default(modeStack);\n        patternIdxToConfig = this.patternIdxToConfig[newMode];\n        currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];\n        currModePatternsLength = patternIdxToConfig.length;\n        const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n          getPossiblePatterns = getPossiblePatternsOptimized;\n        } else {\n          getPossiblePatterns = getPossiblePatternsSlow;\n        }\n      }\n    }, \"pop_mode\");\n    function push_mode(newMode) {\n      modeStack.push(newMode);\n      currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];\n      patternIdxToConfig = this.patternIdxToConfig[newMode];\n      currModePatternsLength = patternIdxToConfig.length;\n      currModePatternsLength = patternIdxToConfig.length;\n      const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n      if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n        getPossiblePatterns = getPossiblePatternsOptimized;\n      } else {\n        getPossiblePatterns = getPossiblePatternsSlow;\n      }\n    }\n    __name(push_mode, \"push_mode\");\n    push_mode.call(this, initialMode);\n    let currConfig;\n    const recoveryEnabled = this.config.recoveryEnabled;\n    while (offset < orgLength) {\n      matchedImage = null;\n      const nextCharCode = orgText.charCodeAt(offset);\n      const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n      const chosenPatternsLength = chosenPatternIdxToConfig.length;\n      for (i = 0; i < chosenPatternsLength; i++) {\n        currConfig = chosenPatternIdxToConfig[i];\n        const currPattern = currConfig.pattern;\n        payload = null;\n        const singleCharCode = currConfig.short;\n        if (singleCharCode !== false) {\n          if (nextCharCode === singleCharCode) {\n            matchedImage = currPattern;\n          }\n        } else if (currConfig.isCustom === true) {\n          match = currPattern.exec(orgText, offset, matchedTokens, groups);\n          if (match !== null) {\n            matchedImage = match[0];\n            if (match.payload !== void 0) {\n              payload = match.payload;\n            }\n          } else {\n            matchedImage = null;\n          }\n        } else {\n          this.updateLastIndex(currPattern, offset);\n          matchedImage = this.match(currPattern, text, offset);\n        }\n        if (matchedImage !== null) {\n          longerAlt = currConfig.longerAlt;\n          if (longerAlt !== void 0) {\n            const longerAltLength = longerAlt.length;\n            for (k = 0; k < longerAltLength; k++) {\n              const longerAltConfig = patternIdxToConfig[longerAlt[k]];\n              const longerAltPattern = longerAltConfig.pattern;\n              altPayload = null;\n              if (longerAltConfig.isCustom === true) {\n                match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n                if (match !== null) {\n                  matchAltImage = match[0];\n                  if (match.payload !== void 0) {\n                    altPayload = match.payload;\n                  }\n                } else {\n                  matchAltImage = null;\n                }\n              } else {\n                this.updateLastIndex(longerAltPattern, offset);\n                matchAltImage = this.match(longerAltPattern, text, offset);\n              }\n              if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                matchedImage = matchAltImage;\n                payload = altPayload;\n                currConfig = longerAltConfig;\n                break;\n              }\n            }\n          }\n          break;\n        }\n      }\n      if (matchedImage !== null) {\n        imageLength = matchedImage.length;\n        group = currConfig.group;\n        if (group !== void 0) {\n          tokType = currConfig.tokenTypeIdx;\n          newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n          this.handlePayload(newToken, payload);\n          if (group === false) {\n            matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n          } else {\n            groups[group].push(newToken);\n          }\n        }\n        text = this.chopInput(text, imageLength);\n        offset = offset + imageLength;\n        column = this.computeNewColumn(column, imageLength);\n        if (trackLines === true && currConfig.canLineTerminator === true) {\n          let numOfLTsInMatch = 0;\n          let foundTerminator;\n          let lastLTEndOffset;\n          lineTerminatorPattern.lastIndex = 0;\n          do {\n            foundTerminator = lineTerminatorPattern.test(matchedImage);\n            if (foundTerminator === true) {\n              lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n              numOfLTsInMatch++;\n            }\n          } while (foundTerminator === true);\n          if (numOfLTsInMatch !== 0) {\n            line = line + numOfLTsInMatch;\n            column = imageLength - lastLTEndOffset;\n            this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n          }\n        }\n        this.handleModes(currConfig, pop_mode, push_mode, newToken);\n      } else {\n        const errorStartOffset = offset;\n        const errorLine = line;\n        const errorColumn = column;\n        let foundResyncPoint = recoveryEnabled === false;\n        while (foundResyncPoint === false && offset < orgLength) {\n          text = this.chopInput(text, 1);\n          offset++;\n          for (j = 0; j < currModePatternsLength; j++) {\n            const currConfig2 = patternIdxToConfig[j];\n            const currPattern = currConfig2.pattern;\n            const singleCharCode = currConfig2.short;\n            if (singleCharCode !== false) {\n              if (orgText.charCodeAt(offset) === singleCharCode) {\n                foundResyncPoint = true;\n              }\n            } else if (currConfig2.isCustom === true) {\n              foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n            } else {\n              this.updateLastIndex(currPattern, offset);\n              foundResyncPoint = currPattern.exec(text) !== null;\n            }\n            if (foundResyncPoint === true) {\n              break;\n            }\n          }\n        }\n        errLength = offset - errorStartOffset;\n        column = this.computeNewColumn(column, errLength);\n        msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n        errors.push({\n          offset: errorStartOffset,\n          line: errorLine,\n          column: errorColumn,\n          length: errLength,\n          message: msg\n        });\n        if (recoveryEnabled === false) {\n          break;\n        }\n      }\n    }\n    if (!this.hasCustom) {\n      matchedTokens.length = matchedTokensIndex;\n    }\n    return {\n      tokens: matchedTokens,\n      groups,\n      errors\n    };\n  }\n  handleModes(config, pop_mode, push_mode, newToken) {\n    if (config.pop === true) {\n      const pushMode = config.push;\n      pop_mode(newToken);\n      if (pushMode !== void 0) {\n        push_mode.call(this, pushMode);\n      }\n    } else if (config.push !== void 0) {\n      push_mode.call(this, config.push);\n    }\n  }\n  chopInput(text, length) {\n    return text.substring(length);\n  }\n  updateLastIndex(regExp, newLastIndex) {\n    regExp.lastIndex = newLastIndex;\n  }\n  // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n  updateTokenEndLineColumnLocation(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n    let lastCharIsLT, fixForEndingInLT;\n    if (group !== void 0) {\n      lastCharIsLT = lastLTIdx === imageLength - 1;\n      fixForEndingInLT = lastCharIsLT ? -1 : 0;\n      if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n        newToken.endLine = line + fixForEndingInLT;\n        newToken.endColumn = column - 1 + -fixForEndingInLT;\n      }\n    }\n  }\n  computeNewColumn(oldColumn, imageLength) {\n    return oldColumn + imageLength;\n  }\n  createOffsetOnlyToken(image, startOffset, tokenTypeIdx, tokenType) {\n    return {\n      image,\n      startOffset,\n      tokenTypeIdx,\n      tokenType\n    };\n  }\n  createStartOnlyToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n    return {\n      image,\n      startOffset,\n      startLine,\n      startColumn,\n      tokenTypeIdx,\n      tokenType\n    };\n  }\n  createFullToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n    return {\n      image,\n      startOffset,\n      endOffset: startOffset + imageLength - 1,\n      startLine,\n      endLine: startLine,\n      startColumn,\n      endColumn: startColumn + imageLength - 1,\n      tokenTypeIdx,\n      tokenType\n    };\n  }\n  addTokenUsingPush(tokenVector, index, tokenToAdd) {\n    tokenVector.push(tokenToAdd);\n    return index;\n  }\n  addTokenUsingMemberAccess(tokenVector, index, tokenToAdd) {\n    tokenVector[index] = tokenToAdd;\n    index++;\n    return index;\n  }\n  handlePayloadNoCustom(token, payload) {\n  }\n  handlePayloadWithCustom(token, payload) {\n    if (payload !== null) {\n      token.payload = payload;\n    }\n  }\n  matchWithTest(pattern, text, offset) {\n    const found = pattern.test(text);\n    if (found === true) {\n      return text.substring(offset, pattern.lastIndex);\n    }\n    return null;\n  }\n  matchWithExec(pattern, text) {\n    const regExpArray = pattern.exec(text);\n    return regExpArray !== null ? regExpArray[0] : null;\n  }\n};\nLexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\nLexer.NA = /NOT_APPLICABLE/;\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/scan/tokens_public.js\nfunction tokenLabel2(tokType) {\n  if (hasTokenLabel2(tokType)) {\n    return tokType.LABEL;\n  } else {\n    return tokType.name;\n  }\n}\n__name(tokenLabel2, \"tokenLabel\");\nfunction hasTokenLabel2(obj) {\n  return isString_default(obj.LABEL) && obj.LABEL !== \"\";\n}\n__name(hasTokenLabel2, \"hasTokenLabel\");\nvar PARENT = \"parent\";\nvar CATEGORIES = \"categories\";\nvar LABEL = \"label\";\nvar GROUP = \"group\";\nvar PUSH_MODE = \"push_mode\";\nvar POP_MODE = \"pop_mode\";\nvar LONGER_ALT = \"longer_alt\";\nvar LINE_BREAKS = \"line_breaks\";\nvar START_CHARS_HINT = \"start_chars_hint\";\nfunction createToken(config) {\n  return createTokenInternal(config);\n}\n__name(createToken, \"createToken\");\nfunction createTokenInternal(config) {\n  const pattern = config.pattern;\n  const tokenType = {};\n  tokenType.name = config.name;\n  if (!isUndefined_default(pattern)) {\n    tokenType.PATTERN = pattern;\n  }\n  if (has_default(config, PARENT)) {\n    throw \"The parent property is no longer supported.\\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.\";\n  }\n  if (has_default(config, CATEGORIES)) {\n    tokenType.CATEGORIES = config[CATEGORIES];\n  }\n  augmentTokenTypes([tokenType]);\n  if (has_default(config, LABEL)) {\n    tokenType.LABEL = config[LABEL];\n  }\n  if (has_default(config, GROUP)) {\n    tokenType.GROUP = config[GROUP];\n  }\n  if (has_default(config, POP_MODE)) {\n    tokenType.POP_MODE = config[POP_MODE];\n  }\n  if (has_default(config, PUSH_MODE)) {\n    tokenType.PUSH_MODE = config[PUSH_MODE];\n  }\n  if (has_default(config, LONGER_ALT)) {\n    tokenType.LONGER_ALT = config[LONGER_ALT];\n  }\n  if (has_default(config, LINE_BREAKS)) {\n    tokenType.LINE_BREAKS = config[LINE_BREAKS];\n  }\n  if (has_default(config, START_CHARS_HINT)) {\n    tokenType.START_CHARS_HINT = config[START_CHARS_HINT];\n  }\n  return tokenType;\n}\n__name(createTokenInternal, \"createTokenInternal\");\nvar EOF = createToken({ name: \"EOF\", pattern: Lexer.NA });\naugmentTokenTypes([EOF]);\nfunction createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {\n  return {\n    image,\n    startOffset,\n    endOffset,\n    startLine,\n    endLine,\n    startColumn,\n    endColumn,\n    tokenTypeIdx: tokType.tokenTypeIdx,\n    tokenType: tokType\n  };\n}\n__name(createTokenInstance, \"createTokenInstance\");\nfunction tokenMatcher(token, tokType) {\n  return tokenStructuredMatcher(token, tokType);\n}\n__name(tokenMatcher, \"tokenMatcher\");\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/errors_public.js\nvar defaultParserErrorProvider = {\n  buildMismatchTokenMessage({ expected, actual, previous, ruleName }) {\n    const hasLabel = hasTokenLabel2(expected);\n    const expectedMsg = hasLabel ? `--> ${tokenLabel2(expected)} <--` : `token of type --> ${expected.name} <--`;\n    const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`;\n    return msg;\n  },\n  buildNotAllInputParsedMessage({ firstRedundant, ruleName }) {\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n  },\n  buildNoViableAltMessage({ expectedPathsPerAlt, actual, previous, customUserDescription, ruleName }) {\n    const errPrefix = \"Expecting: \";\n    const actualText = head_default(actual).image;\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      const allLookAheadPaths = reduce_default(expectedPathsPerAlt, (result, currAltPaths) => result.concat(currAltPaths), []);\n      const nextValidTokenSequences = map_default(allLookAheadPaths, (currPath) => `[${map_default(currPath, (currTokenType) => tokenLabel2(currTokenType)).join(\", \")}]`);\n      const nextValidSequenceItems = map_default(nextValidTokenSequences, (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`);\n      const calculatedDescription = `one of these possible Token sequences:\n${nextValidSequenceItems.join(\"\\n\")}`;\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  },\n  buildEarlyExitMessage({ expectedIterationPaths, actual, customUserDescription, ruleName }) {\n    const errPrefix = \"Expecting: \";\n    const actualText = head_default(actual).image;\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      const nextValidTokenSequences = map_default(expectedIterationPaths, (currPath) => `[${map_default(currPath, (currTokenType) => tokenLabel2(currTokenType)).join(\",\")}]`);\n      const calculatedDescription = `expecting at least one iteration which starts with one of these possible Token sequences::\n  <${nextValidTokenSequences.join(\" ,\")}>`;\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  }\n};\nObject.freeze(defaultParserErrorProvider);\nvar defaultGrammarResolverErrorProvider = {\n  buildRuleNotFoundError(topLevelRule, undefinedRule) {\n    const msg = \"Invalid grammar, reference to a rule which is not defined: ->\" + undefinedRule.nonTerminalName + \"<-\\ninside top level rule: ->\" + topLevelRule.name + \"<-\";\n    return msg;\n  }\n};\nvar defaultGrammarValidatorErrorProvider = {\n  buildDuplicateFoundError(topLevelRule, duplicateProds) {\n    function getExtraProductionArgument2(prod) {\n      if (prod instanceof Terminal) {\n        return prod.terminalType.name;\n      } else if (prod instanceof NonTerminal) {\n        return prod.nonTerminalName;\n      } else {\n        return \"\";\n      }\n    }\n    __name(getExtraProductionArgument2, \"getExtraProductionArgument\");\n    const topLevelName = topLevelRule.name;\n    const duplicateProd = head_default(duplicateProds);\n    const index = duplicateProd.idx;\n    const dslName = getProductionDslName(duplicateProd);\n    const extraArgument = getExtraProductionArgument2(duplicateProd);\n    const hasExplicitIndex = index > 0;\n    let msg = `->${dslName}${hasExplicitIndex ? index : \"\"}<- ${extraArgument ? `with argument: ->${extraArgument}<-` : \"\"}\n                  appears more than once (${duplicateProds.length} times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `;\n    msg = msg.replace(/[ \\t]+/g, \" \");\n    msg = msg.replace(/\\s\\s+/g, \"\\n\");\n    return msg;\n  },\n  buildNamespaceConflictError(rule) {\n    const errMsg = `Namespace conflict found in grammar.\nThe grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\nTo resolve this make sure each Terminal and Non-Terminal names are unique\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\nand Non-Terminal names start with a lower case letter.`;\n    return errMsg;\n  },\n  buildAlternationPrefixAmbiguityError(options) {\n    const pathMsg = map_default(options.prefixPath, (currTok) => tokenLabel2(currTok)).join(\", \");\n    const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    const errMsg = `Ambiguous alternatives: <${options.ambiguityIndices.join(\" ,\")}> due to common lookahead prefix\nin <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\n<${pathMsg}> may appears as a prefix path in all these alternatives.\nSee: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\nFor Further details.`;\n    return errMsg;\n  },\n  buildAlternationAmbiguityError(options) {\n    const pathMsg = map_default(options.prefixPath, (currtok) => tokenLabel2(currtok)).join(\", \");\n    const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\" ,\")}> in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\n<${pathMsg}> may appears as a prefix path in all these alternatives.\n`;\n    currMessage = currMessage + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\nFor Further details.`;\n    return currMessage;\n  },\n  buildEmptyRepetitionError(options) {\n    let dslName = getProductionDslName(options.repetition);\n    if (options.repetition.idx !== 0) {\n      dslName += options.repetition.idx;\n    }\n    const errMsg = `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\nThis could lead to an infinite loop.`;\n    return errMsg;\n  },\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildTokenNameError(options) {\n    return \"deprecated\";\n  },\n  buildEmptyAlternationError(options) {\n    const errMsg = `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}> in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\nOnly the last alternative may be an empty alternative.`;\n    return errMsg;\n  },\n  buildTooManyAlternativesError(options) {\n    const errMsg = `An Alternation cannot have more than 256 alternatives:\n<OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\n has ${options.alternation.definition.length + 1} alternatives.`;\n    return errMsg;\n  },\n  buildLeftRecursionError(options) {\n    const ruleName = options.topLevelRule.name;\n    const pathNames = map_default(options.leftRecursionPath, (currRule) => currRule.name);\n    const leftRecursivePath = `${ruleName} --> ${pathNames.concat([ruleName]).join(\" --> \")}`;\n    const errMsg = `Left Recursion found in grammar.\nrule: <${ruleName}> can be invoked from itself (directly or indirectly)\nwithout consuming any Tokens. The grammar path that causes this is: \n ${leftRecursivePath}\n To fix this refactor your grammar to remove the left recursion.\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;\n    return errMsg;\n  },\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildInvalidRuleNameError(options) {\n    return \"deprecated\";\n  },\n  buildDuplicateRuleNameError(options) {\n    let ruleName;\n    if (options.topLevelRule instanceof Rule) {\n      ruleName = options.topLevelRule.name;\n    } else {\n      ruleName = options.topLevelRule;\n    }\n    const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`;\n    return errMsg;\n  }\n};\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/grammar/resolver.js\nfunction resolveGrammar(topLevels, errMsgProvider) {\n  const refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);\n  refResolver.resolveRefs();\n  return refResolver.errors;\n}\n__name(resolveGrammar, \"resolveGrammar\");\nvar GastRefResolverVisitor = class extends GAstVisitor {\n  static {\n    __name(this, \"GastRefResolverVisitor\");\n  }\n  constructor(nameToTopRule, errMsgProvider) {\n    super();\n    this.nameToTopRule = nameToTopRule;\n    this.errMsgProvider = errMsgProvider;\n    this.errors = [];\n  }\n  resolveRefs() {\n    forEach_default(values_default(this.nameToTopRule), (prod) => {\n      this.currTopLevel = prod;\n      prod.accept(this);\n    });\n  }\n  visitNonTerminal(node) {\n    const ref = this.nameToTopRule[node.nonTerminalName];\n    if (!ref) {\n      const msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);\n      this.errors.push({\n        message: msg,\n        type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n        ruleName: this.currTopLevel.name,\n        unresolvedRefName: node.nonTerminalName\n      });\n    } else {\n      node.referencedRule = ref;\n    }\n  }\n};\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/grammar/interpreter.js\nvar AbstractNextPossibleTokensWalker = class extends RestWalker {\n  static {\n    __name(this, \"AbstractNextPossibleTokensWalker\");\n  }\n  constructor(topProd, path) {\n    super();\n    this.topProd = topProd;\n    this.path = path;\n    this.possibleTokTypes = [];\n    this.nextProductionName = \"\";\n    this.nextProductionOccurrence = 0;\n    this.found = false;\n    this.isAtEndOfPath = false;\n  }\n  startWalking() {\n    this.found = false;\n    if (this.path.ruleStack[0] !== this.topProd.name) {\n      throw Error(\"The path does not start with the walker's top Rule!\");\n    }\n    this.ruleStack = clone_default(this.path.ruleStack).reverse();\n    this.occurrenceStack = clone_default(this.path.occurrenceStack).reverse();\n    this.ruleStack.pop();\n    this.occurrenceStack.pop();\n    this.updateExpectedNext();\n    this.walk(this.topProd);\n    return this.possibleTokTypes;\n  }\n  walk(prod, prevRest = []) {\n    if (!this.found) {\n      super.walk(prod, prevRest);\n    }\n  }\n  walkProdRef(refProd, currRest, prevRest) {\n    if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {\n      const fullRest = currRest.concat(prevRest);\n      this.updateExpectedNext();\n      this.walk(refProd.referencedRule, fullRest);\n    }\n  }\n  updateExpectedNext() {\n    if (isEmpty_default(this.ruleStack)) {\n      this.nextProductionName = \"\";\n      this.nextProductionOccurrence = 0;\n      this.isAtEndOfPath = true;\n    } else {\n      this.nextProductionName = this.ruleStack.pop();\n      this.nextProductionOccurrence = this.occurrenceStack.pop();\n    }\n  }\n};\nvar NextAfterTokenWalker = class extends AbstractNextPossibleTokensWalker {\n  static {\n    __name(this, \"NextAfterTokenWalker\");\n  }\n  constructor(topProd, path) {\n    super(topProd, path);\n    this.path = path;\n    this.nextTerminalName = \"\";\n    this.nextTerminalOccurrence = 0;\n    this.nextTerminalName = this.path.lastTok.name;\n    this.nextTerminalOccurrence = this.path.lastTokOccurrence;\n  }\n  walkTerminal(terminal, currRest, prevRest) {\n    if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {\n      const fullRest = currRest.concat(prevRest);\n      const restProd = new Alternative({ definition: fullRest });\n      this.possibleTokTypes = first(restProd);\n      this.found = true;\n    }\n  }\n};\nvar AbstractNextTerminalAfterProductionWalker = class extends RestWalker {\n  static {\n    __name(this, \"AbstractNextTerminalAfterProductionWalker\");\n  }\n  constructor(topRule, occurrence) {\n    super();\n    this.topRule = topRule;\n    this.occurrence = occurrence;\n    this.result = {\n      token: void 0,\n      occurrence: void 0,\n      isEndOfRule: void 0\n    };\n  }\n  startWalking() {\n    this.walk(this.topRule);\n    return this.result;\n  }\n};\nvar NextTerminalAfterManyWalker = class extends AbstractNextTerminalAfterProductionWalker {\n  static {\n    __name(this, \"NextTerminalAfterManyWalker\");\n  }\n  walkMany(manyProd, currRest, prevRest) {\n    if (manyProd.idx === this.occurrence) {\n      const firstAfterMany = head_default(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterMany === void 0;\n      if (firstAfterMany instanceof Terminal) {\n        this.result.token = firstAfterMany.terminalType;\n        this.result.occurrence = firstAfterMany.idx;\n      }\n    } else {\n      super.walkMany(manyProd, currRest, prevRest);\n    }\n  }\n};\nvar NextTerminalAfterManySepWalker = class extends AbstractNextTerminalAfterProductionWalker {\n  static {\n    __name(this, \"NextTerminalAfterManySepWalker\");\n  }\n  walkManySep(manySepProd, currRest, prevRest) {\n    if (manySepProd.idx === this.occurrence) {\n      const firstAfterManySep = head_default(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterManySep === void 0;\n      if (firstAfterManySep instanceof Terminal) {\n        this.result.token = firstAfterManySep.terminalType;\n        this.result.occurrence = firstAfterManySep.idx;\n      }\n    } else {\n      super.walkManySep(manySepProd, currRest, prevRest);\n    }\n  }\n};\nvar NextTerminalAfterAtLeastOneWalker = class extends AbstractNextTerminalAfterProductionWalker {\n  static {\n    __name(this, \"NextTerminalAfterAtLeastOneWalker\");\n  }\n  walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n    if (atLeastOneProd.idx === this.occurrence) {\n      const firstAfterAtLeastOne = head_default(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterAtLeastOne === void 0;\n      if (firstAfterAtLeastOne instanceof Terminal) {\n        this.result.token = firstAfterAtLeastOne.terminalType;\n        this.result.occurrence = firstAfterAtLeastOne.idx;\n      }\n    } else {\n      super.walkAtLeastOne(atLeastOneProd, currRest, prevRest);\n    }\n  }\n};\nvar NextTerminalAfterAtLeastOneSepWalker = class extends AbstractNextTerminalAfterProductionWalker {\n  static {\n    __name(this, \"NextTerminalAfterAtLeastOneSepWalker\");\n  }\n  walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest) {\n    if (atleastOneSepProd.idx === this.occurrence) {\n      const firstAfterfirstAfterAtLeastOneSep = head_default(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === void 0;\n      if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n      }\n    } else {\n      super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest);\n    }\n  }\n};\nfunction possiblePathsFrom(targetDef, maxLength, currPath = []) {\n  currPath = clone_default(currPath);\n  let result = [];\n  let i = 0;\n  function remainingPathWith(nextDef) {\n    return nextDef.concat(drop_default(targetDef, i + 1));\n  }\n  __name(remainingPathWith, \"remainingPathWith\");\n  function getAlternativesForProd(definition) {\n    const alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n    return result.concat(alternatives);\n  }\n  __name(getAlternativesForProd, \"getAlternativesForProd\");\n  while (currPath.length < maxLength && i < targetDef.length) {\n    const prod = targetDef[i];\n    if (prod instanceof Alternative) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof NonTerminal) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof Option) {\n      result = getAlternativesForProd(prod.definition);\n    } else if (prod instanceof RepetitionMandatory) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: prod.definition\n        })\n      ]);\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      const newDef = [\n        new Alternative({ definition: prod.definition }),\n        new Repetition({\n          definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition)\n        })\n      ];\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition)\n        })\n      ]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Repetition) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: prod.definition\n        })\n      ]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Alternation) {\n      forEach_default(prod.definition, (currAlt) => {\n        if (isEmpty_default(currAlt.definition) === false) {\n          result = getAlternativesForProd(currAlt.definition);\n        }\n      });\n      return result;\n    } else if (prod instanceof Terminal) {\n      currPath.push(prod.terminalType);\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n    i++;\n  }\n  result.push({\n    partialPath: currPath,\n    suffixDef: drop_default(targetDef, i)\n  });\n  return result;\n}\n__name(possiblePathsFrom, \"possiblePathsFrom\");\nfunction nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n  const EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n  const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n  const EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n  let foundCompletePath = false;\n  const tokenVectorLength = tokenVector.length;\n  const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n  const result = [];\n  const possiblePaths = [];\n  possiblePaths.push({\n    idx: -1,\n    def: initialDef,\n    ruleStack: [],\n    occurrenceStack: []\n  });\n  while (!isEmpty_default(possiblePaths)) {\n    const currPath = possiblePaths.pop();\n    if (currPath === EXIT_ALTERNATIVE) {\n      if (foundCompletePath && last_default(possiblePaths).idx <= minimalAlternativesIndex) {\n        possiblePaths.pop();\n      }\n      continue;\n    }\n    const currDef = currPath.def;\n    const currIdx = currPath.idx;\n    const currRuleStack = currPath.ruleStack;\n    const currOccurrenceStack = currPath.occurrenceStack;\n    if (isEmpty_default(currDef)) {\n      continue;\n    }\n    const prod = currDef[0];\n    if (prod === EXIT_NON_TERMINAL) {\n      const nextPath = {\n        idx: currIdx,\n        def: drop_default(currDef),\n        ruleStack: dropRight_default(currRuleStack),\n        occurrenceStack: dropRight_default(currOccurrenceStack)\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Terminal) {\n      if (currIdx < tokenVectorLength - 1) {\n        const nextIdx = currIdx + 1;\n        const actualToken = tokenVector[nextIdx];\n        if (tokMatcher(actualToken, prod.terminalType)) {\n          const nextPath = {\n            idx: nextIdx,\n            def: drop_default(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(nextPath);\n        }\n      } else if (currIdx === tokenVectorLength - 1) {\n        result.push({\n          nextTokenType: prod.terminalType,\n          nextTokenOccurrence: prod.idx,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        });\n        foundCompletePath = true;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    } else if (prod instanceof NonTerminal) {\n      const newRuleStack = clone_default(currRuleStack);\n      newRuleStack.push(prod.nonTerminalName);\n      const newOccurrenceStack = clone_default(currOccurrenceStack);\n      newOccurrenceStack.push(prod.idx);\n      const nextPath = {\n        idx: currIdx,\n        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop_default(currDef)),\n        ruleStack: newRuleStack,\n        occurrenceStack: newOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Option) {\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop_default(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      const nextPathWith = {\n        idx: currIdx,\n        def: prod.definition.concat(drop_default(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof RepetitionMandatory) {\n      const secondIteration = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      const nextDef = prod.definition.concat([secondIteration], drop_default(currDef));\n      const nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      const separatorGast = new Terminal({\n        terminalType: prod.separator\n      });\n      const secondIteration = new Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      const nextDef = prod.definition.concat([secondIteration], drop_default(currDef));\n      const nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop_default(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      const separatorGast = new Terminal({\n        terminalType: prod.separator\n      });\n      const nthRepetition = new Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      const nextDef = prod.definition.concat([nthRepetition], drop_default(currDef));\n      const nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Repetition) {\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop_default(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      const nthRepetition = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      const nextDef = prod.definition.concat([nthRepetition], drop_default(currDef));\n      const nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Alternation) {\n      for (let i = prod.definition.length - 1; i >= 0; i--) {\n        const currAlt = prod.definition[i];\n        const currAltPath = {\n          idx: currIdx,\n          def: currAlt.definition.concat(drop_default(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        };\n        possiblePaths.push(currAltPath);\n        possiblePaths.push(EXIT_ALTERNATIVE);\n      }\n    } else if (prod instanceof Alternative) {\n      possiblePaths.push({\n        idx: currIdx,\n        def: prod.definition.concat(drop_default(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      });\n    } else if (prod instanceof Rule) {\n      possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n  return result;\n}\n__name(nextPossibleTokensAfter, \"nextPossibleTokensAfter\");\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n  const newRuleStack = clone_default(currRuleStack);\n  newRuleStack.push(topRule.name);\n  const newCurrOccurrenceStack = clone_default(currOccurrenceStack);\n  newCurrOccurrenceStack.push(1);\n  return {\n    idx: currIdx,\n    def: topRule.definition,\n    ruleStack: newRuleStack,\n    occurrenceStack: newCurrOccurrenceStack\n  };\n}\n__name(expandTopLevelRule, \"expandTopLevelRule\");\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/grammar/lookahead.js\nvar PROD_TYPE;\n(function(PROD_TYPE2) {\n  PROD_TYPE2[PROD_TYPE2[\"OPTION\"] = 0] = \"OPTION\";\n  PROD_TYPE2[PROD_TYPE2[\"REPETITION\"] = 1] = \"REPETITION\";\n  PROD_TYPE2[PROD_TYPE2[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n  PROD_TYPE2[PROD_TYPE2[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n  PROD_TYPE2[PROD_TYPE2[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n  PROD_TYPE2[PROD_TYPE2[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE || (PROD_TYPE = {}));\nfunction getProdType(prod) {\n  if (prod instanceof Option || prod === \"Option\") {\n    return PROD_TYPE.OPTION;\n  } else if (prod instanceof Repetition || prod === \"Repetition\") {\n    return PROD_TYPE.REPETITION;\n  } else if (prod instanceof RepetitionMandatory || prod === \"RepetitionMandatory\") {\n    return PROD_TYPE.REPETITION_MANDATORY;\n  } else if (prod instanceof RepetitionMandatoryWithSeparator || prod === \"RepetitionMandatoryWithSeparator\") {\n    return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n  } else if (prod instanceof RepetitionWithSeparator || prod === \"RepetitionWithSeparator\") {\n    return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n  } else if (prod instanceof Alternation || prod === \"Alternation\") {\n    return PROD_TYPE.ALTERNATION;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n__name(getProdType, \"getProdType\");\nfunction getLookaheadPaths(options) {\n  const { occurrence, rule, prodType, maxLookahead } = options;\n  const type = getProdType(prodType);\n  if (type === PROD_TYPE.ALTERNATION) {\n    return getLookaheadPathsForOr(occurrence, rule, maxLookahead);\n  } else {\n    return getLookaheadPathsForOptionalProd(occurrence, rule, type, maxLookahead);\n  }\n}\n__name(getLookaheadPaths, \"getLookaheadPaths\");\nfunction buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n  const lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n  const tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n  return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher2, dynamicTokensEnabled);\n}\n__name(buildLookaheadFuncForOr, \"buildLookaheadFuncForOr\");\nfunction buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n  const lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n  const tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n  return lookaheadBuilder(lookAheadPaths[0], tokenMatcher2, dynamicTokensEnabled);\n}\n__name(buildLookaheadFuncForOptionalProd, \"buildLookaheadFuncForOptionalProd\");\nfunction buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher2, dynamicTokensEnabled) {\n  const numOfAlts = alts.length;\n  const areAllOneTokenLookahead = every_default(alts, (currAlt) => {\n    return every_default(currAlt, (currPath) => {\n      return currPath.length === 1;\n    });\n  });\n  if (hasPredicates) {\n    return function(orAlts) {\n      const predicates = map_default(orAlts, (currAlt) => currAlt.GATE);\n      for (let t = 0; t < numOfAlts; t++) {\n        const currAlt = alts[t];\n        const currNumOfPaths = currAlt.length;\n        const currPredicate = predicates[t];\n        if (currPredicate !== void 0 && currPredicate.call(this) === false) {\n          continue;\n        }\n        nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n          const currPath = currAlt[j];\n          const currPathLength = currPath.length;\n          for (let i = 0; i < currPathLength; i++) {\n            const nextToken = this.LA(i + 1);\n            if (tokenMatcher2(nextToken, currPath[i]) === false) {\n              continue nextPath;\n            }\n          }\n          return t;\n        }\n      }\n      return void 0;\n    };\n  } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    const singleTokenAlts = map_default(alts, (currAlt) => {\n      return flatten_default(currAlt);\n    });\n    const choiceToAlt = reduce_default(singleTokenAlts, (result, currAlt, idx) => {\n      forEach_default(currAlt, (currTokType) => {\n        if (!has_default(result, currTokType.tokenTypeIdx)) {\n          result[currTokType.tokenTypeIdx] = idx;\n        }\n        forEach_default(currTokType.categoryMatches, (currExtendingType) => {\n          if (!has_default(result, currExtendingType)) {\n            result[currExtendingType] = idx;\n          }\n        });\n      });\n      return result;\n    }, {});\n    return function() {\n      const nextToken = this.LA(1);\n      return choiceToAlt[nextToken.tokenTypeIdx];\n    };\n  } else {\n    return function() {\n      for (let t = 0; t < numOfAlts; t++) {\n        const currAlt = alts[t];\n        const currNumOfPaths = currAlt.length;\n        nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n          const currPath = currAlt[j];\n          const currPathLength = currPath.length;\n          for (let i = 0; i < currPathLength; i++) {\n            const nextToken = this.LA(i + 1);\n            if (tokenMatcher2(nextToken, currPath[i]) === false) {\n              continue nextPath;\n            }\n          }\n          return t;\n        }\n      }\n      return void 0;\n    };\n  }\n}\n__name(buildAlternativesLookAheadFunc, \"buildAlternativesLookAheadFunc\");\nfunction buildSingleAlternativeLookaheadFunction(alt, tokenMatcher2, dynamicTokensEnabled) {\n  const areAllOneTokenLookahead = every_default(alt, (currPath) => {\n    return currPath.length === 1;\n  });\n  const numOfPaths = alt.length;\n  if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    const singleTokensTypes = flatten_default(alt);\n    if (singleTokensTypes.length === 1 && isEmpty_default(singleTokensTypes[0].categoryMatches)) {\n      const expectedTokenType = singleTokensTypes[0];\n      const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;\n      return function() {\n        return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n      };\n    } else {\n      const choiceToAlt = reduce_default(singleTokensTypes, (result, currTokType, idx) => {\n        result[currTokType.tokenTypeIdx] = true;\n        forEach_default(currTokType.categoryMatches, (currExtendingType) => {\n          result[currExtendingType] = true;\n        });\n        return result;\n      }, []);\n      return function() {\n        const nextToken = this.LA(1);\n        return choiceToAlt[nextToken.tokenTypeIdx] === true;\n      };\n    }\n  } else {\n    return function() {\n      nextPath: for (let j = 0; j < numOfPaths; j++) {\n        const currPath = alt[j];\n        const currPathLength = currPath.length;\n        for (let i = 0; i < currPathLength; i++) {\n          const nextToken = this.LA(i + 1);\n          if (tokenMatcher2(nextToken, currPath[i]) === false) {\n            continue nextPath;\n          }\n        }\n        return true;\n      }\n      return false;\n    };\n  }\n}\n__name(buildSingleAlternativeLookaheadFunction, \"buildSingleAlternativeLookaheadFunction\");\nvar RestDefinitionFinderWalker = class extends RestWalker {\n  static {\n    __name(this, \"RestDefinitionFinderWalker\");\n  }\n  constructor(topProd, targetOccurrence, targetProdType) {\n    super();\n    this.topProd = topProd;\n    this.targetOccurrence = targetOccurrence;\n    this.targetProdType = targetProdType;\n  }\n  startWalking() {\n    this.walk(this.topProd);\n    return this.restDef;\n  }\n  checkIsTarget(node, expectedProdType, currRest, prevRest) {\n    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {\n      this.restDef = currRest.concat(prevRest);\n      return true;\n    }\n    return false;\n  }\n  walkOption(optionProd, currRest, prevRest) {\n    if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n      super.walkOption(optionProd, currRest, prevRest);\n    }\n  }\n  walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n    if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n      super.walkOption(atLeastOneProd, currRest, prevRest);\n    }\n  }\n  walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n    if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n      super.walkOption(atLeastOneSepProd, currRest, prevRest);\n    }\n  }\n  walkMany(manyProd, currRest, prevRest) {\n    if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n      super.walkOption(manyProd, currRest, prevRest);\n    }\n  }\n  walkManySep(manySepProd, currRest, prevRest) {\n    if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n      super.walkOption(manySepProd, currRest, prevRest);\n    }\n  }\n};\nvar InsideDefinitionFinderVisitor = class extends GAstVisitor {\n  static {\n    __name(this, \"InsideDefinitionFinderVisitor\");\n  }\n  constructor(targetOccurrence, targetProdType, targetRef) {\n    super();\n    this.targetOccurrence = targetOccurrence;\n    this.targetProdType = targetProdType;\n    this.targetRef = targetRef;\n    this.result = [];\n  }\n  checkIsTarget(node, expectedProdName) {\n    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === void 0 || node === this.targetRef)) {\n      this.result = node.definition;\n    }\n  }\n  visitOption(node) {\n    this.checkIsTarget(node, PROD_TYPE.OPTION);\n  }\n  visitRepetition(node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION);\n  }\n  visitRepetitionMandatory(node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n  }\n  visitRepetitionMandatoryWithSeparator(node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n  }\n  visitRepetitionWithSeparator(node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n  }\n  visitAlternation(node) {\n    this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n  }\n};\nfunction initializeArrayOfArrays(size) {\n  const result = new Array(size);\n  for (let i = 0; i < size; i++) {\n    result[i] = [];\n  }\n  return result;\n}\n__name(initializeArrayOfArrays, \"initializeArrayOfArrays\");\nfunction pathToHashKeys(path) {\n  let keys = [\"\"];\n  for (let i = 0; i < path.length; i++) {\n    const tokType = path[i];\n    const longerKeys = [];\n    for (let j = 0; j < keys.length; j++) {\n      const currShorterKey = keys[j];\n      longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n      for (let t = 0; t < tokType.categoryMatches.length; t++) {\n        const categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n        longerKeys.push(currShorterKey + categoriesKeySuffix);\n      }\n    }\n    keys = longerKeys;\n  }\n  return keys;\n}\n__name(pathToHashKeys, \"pathToHashKeys\");\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n  for (let currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n    if (currAltIdx === idx) {\n      continue;\n    }\n    const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n    for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n      const searchKey = searchPathKeys[searchIdx];\n      if (otherAltKnownPathsKeys[searchKey] === true) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n__name(isUniquePrefixHash, \"isUniquePrefixHash\");\nfunction lookAheadSequenceFromAlternatives(altsDefs, k) {\n  const partialAlts = map_default(altsDefs, (currAlt) => possiblePathsFrom([currAlt], 1));\n  const finalResult = initializeArrayOfArrays(partialAlts.length);\n  const altsHashes = map_default(partialAlts, (currAltPaths) => {\n    const dict = {};\n    forEach_default(currAltPaths, (item) => {\n      const keys = pathToHashKeys(item.partialPath);\n      forEach_default(keys, (currKey) => {\n        dict[currKey] = true;\n      });\n    });\n    return dict;\n  });\n  let newData = partialAlts;\n  for (let pathLength = 1; pathLength <= k; pathLength++) {\n    const currDataset = newData;\n    newData = initializeArrayOfArrays(currDataset.length);\n    for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {\n      const currAltPathsAndSuffixes = currDataset[altIdx];\n      for (let currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n        const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n        const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n        const prefixKeys = pathToHashKeys(currPathPrefix);\n        const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n        if (isUnique || isEmpty_default(suffixDef) || currPathPrefix.length === k) {\n          const currAltResult = finalResult[altIdx];\n          if (containsPath(currAltResult, currPathPrefix) === false) {\n            currAltResult.push(currPathPrefix);\n            for (let j = 0; j < prefixKeys.length; j++) {\n              const currKey = prefixKeys[j];\n              altsHashes[altIdx][currKey] = true;\n            }\n          }\n        } else {\n          const newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);\n          newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n          forEach_default(newPartialPathsAndSuffixes, (item) => {\n            const prefixKeys2 = pathToHashKeys(item.partialPath);\n            forEach_default(prefixKeys2, (key) => {\n              altsHashes[altIdx][key] = true;\n            });\n          });\n        }\n      }\n    }\n  }\n  return finalResult;\n}\n__name(lookAheadSequenceFromAlternatives, \"lookAheadSequenceFromAlternatives\");\nfunction getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n  const visitor2 = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n  ruleGrammar.accept(visitor2);\n  return lookAheadSequenceFromAlternatives(visitor2.result, k);\n}\n__name(getLookaheadPathsForOr, \"getLookaheadPathsForOr\");\nfunction getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n  const insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n  ruleGrammar.accept(insideDefVisitor);\n  const insideDef = insideDefVisitor.result;\n  const afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n  const afterDef = afterDefWalker.startWalking();\n  const insideFlat = new Alternative({ definition: insideDef });\n  const afterFlat = new Alternative({ definition: afterDef });\n  return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\n__name(getLookaheadPathsForOptionalProd, \"getLookaheadPathsForOptionalProd\");\nfunction containsPath(alternative, searchPath) {\n  compareOtherPath: for (let i = 0; i < alternative.length; i++) {\n    const otherPath = alternative[i];\n    if (otherPath.length !== searchPath.length) {\n      continue;\n    }\n    for (let j = 0; j < otherPath.length; j++) {\n      const searchTok = searchPath[j];\n      const otherTok = otherPath[j];\n      const matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== void 0;\n      if (matchingTokens === false) {\n        continue compareOtherPath;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n__name(containsPath, \"containsPath\");\nfunction isStrictPrefixOfPath(prefix, other) {\n  return prefix.length < other.length && every_default(prefix, (tokType, idx) => {\n    const otherTokType = other[idx];\n    return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];\n  });\n}\n__name(isStrictPrefixOfPath, \"isStrictPrefixOfPath\");\nfunction areTokenCategoriesNotUsed(lookAheadPaths) {\n  return every_default(lookAheadPaths, (singleAltPaths) => every_default(singleAltPaths, (singlePath) => every_default(singlePath, (token) => isEmpty_default(token.categoryMatches))));\n}\n__name(areTokenCategoriesNotUsed, \"areTokenCategoriesNotUsed\");\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/grammar/checks.js\nfunction validateLookahead(options) {\n  const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n    rules: options.rules,\n    tokenTypes: options.tokenTypes,\n    grammarName: options.grammarName\n  });\n  return map_default(lookaheadValidationErrorMessages, (errorMessage) => Object.assign({ type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage));\n}\n__name(validateLookahead, \"validateLookahead\");\nfunction validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {\n  const duplicateErrors = flatMap_default(topLevels, (currTopLevel) => validateDuplicateProductions(currTopLevel, errMsgProvider));\n  const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n  const tooManyAltsErrors = flatMap_default(topLevels, (curRule) => validateTooManyAlts(curRule, errMsgProvider));\n  const duplicateRulesError = flatMap_default(topLevels, (curRule) => validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider));\n  return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n}\n__name(validateGrammar, \"validateGrammar\");\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n  const collectorVisitor2 = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor2);\n  const allRuleProductions = collectorVisitor2.allProductions;\n  const productionGroups = groupBy_default(allRuleProductions, identifyProductionForDuplicates);\n  const duplicates = pickBy_default(productionGroups, (currGroup) => {\n    return currGroup.length > 1;\n  });\n  const errors = map_default(values_default(duplicates), (currDuplicates) => {\n    const firstProd = head_default(currDuplicates);\n    const msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n    const dslName = getProductionDslName(firstProd);\n    const defError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName,\n      occurrence: firstProd.idx\n    };\n    const param = getExtraProductionArgument(firstProd);\n    if (param) {\n      defError.parameter = param;\n    }\n    return defError;\n  });\n  return errors;\n}\n__name(validateDuplicateProductions, \"validateDuplicateProductions\");\nfunction identifyProductionForDuplicates(prod) {\n  return `${getProductionDslName(prod)}_#_${prod.idx}_#_${getExtraProductionArgument(prod)}`;\n}\n__name(identifyProductionForDuplicates, \"identifyProductionForDuplicates\");\nfunction getExtraProductionArgument(prod) {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\n__name(getExtraProductionArgument, \"getExtraProductionArgument\");\nvar OccurrenceValidationCollector = class extends GAstVisitor {\n  static {\n    __name(this, \"OccurrenceValidationCollector\");\n  }\n  constructor() {\n    super(...arguments);\n    this.allProductions = [];\n  }\n  visitNonTerminal(subrule) {\n    this.allProductions.push(subrule);\n  }\n  visitOption(option2) {\n    this.allProductions.push(option2);\n  }\n  visitRepetitionWithSeparator(manySep) {\n    this.allProductions.push(manySep);\n  }\n  visitRepetitionMandatory(atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  }\n  visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  }\n  visitRepetition(many) {\n    this.allProductions.push(many);\n  }\n  visitAlternation(or) {\n    this.allProductions.push(or);\n  }\n  visitTerminal(terminal) {\n    this.allProductions.push(terminal);\n  }\n};\nfunction validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n  const errors = [];\n  const occurrences = reduce_default(allRules, (result, curRule) => {\n    if (curRule.name === rule.name) {\n      return result + 1;\n    }\n    return result;\n  }, 0);\n  if (occurrences > 1) {\n    const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    });\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    });\n  }\n  return errors;\n}\n__name(validateRuleDoesNotAlreadyExist, \"validateRuleDoesNotAlreadyExist\");\nfunction validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n  const errors = [];\n  let errMsg;\n  if (!includes_default(definedRulesNames, ruleName)) {\n    errMsg = `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-as it is not defined in any of the super grammars `;\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName\n    });\n  }\n  return errors;\n}\n__name(validateRuleIsOverridden, \"validateRuleIsOverridden\");\nfunction validateNoLeftRecursion(topRule, currRule, errMsgProvider, path = []) {\n  const errors = [];\n  const nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n  if (isEmpty_default(nextNonTerminals)) {\n    return [];\n  } else {\n    const ruleName = topRule.name;\n    const foundLeftRecursion = includes_default(nextNonTerminals, topRule);\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName\n      });\n    }\n    const validNextSteps = difference_default(nextNonTerminals, path.concat([topRule]));\n    const errorsFromNextSteps = flatMap_default(validNextSteps, (currRefRule) => {\n      const newPath = clone_default(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n    });\n    return errors.concat(errorsFromNextSteps);\n  }\n}\n__name(validateNoLeftRecursion, \"validateNoLeftRecursion\");\nfunction getFirstNoneTerminal(definition) {\n  let result = [];\n  if (isEmpty_default(definition)) {\n    return result;\n  }\n  const firstProd = head_default(definition);\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (firstProd instanceof Alternative || firstProd instanceof Option || firstProd instanceof RepetitionMandatory || firstProd instanceof RepetitionMandatoryWithSeparator || firstProd instanceof RepetitionWithSeparator || firstProd instanceof Repetition) {\n    result = result.concat(getFirstNoneTerminal(firstProd.definition));\n  } else if (firstProd instanceof Alternation) {\n    result = flatten_default(map_default(firstProd.definition, (currSubDef) => getFirstNoneTerminal(currSubDef.definition)));\n  } else if (firstProd instanceof Terminal) {\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n  const isFirstOptional = isOptionalProd(firstProd);\n  const hasMore = definition.length > 1;\n  if (isFirstOptional && hasMore) {\n    const rest = drop_default(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\n__name(getFirstNoneTerminal, \"getFirstNoneTerminal\");\nvar OrCollector = class extends GAstVisitor {\n  static {\n    __name(this, \"OrCollector\");\n  }\n  constructor() {\n    super(...arguments);\n    this.alternations = [];\n  }\n  visitAlternation(node) {\n    this.alternations.push(node);\n  }\n};\nfunction validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  const ors = orCollector.alternations;\n  const errors = flatMap_default(ors, (currOr) => {\n    const exceptLast = dropRight_default(currOr.definition);\n    return flatMap_default(exceptLast, (currAlternative, currAltIdx) => {\n      const possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], tokenStructuredMatcher, 1);\n      if (isEmpty_default(possibleFirstInAlt)) {\n        return [\n          {\n            message: errMsgProvider.buildEmptyAlternationError({\n              topLevelRule,\n              alternation: currOr,\n              emptyChoiceIdx: currAltIdx\n            }),\n            type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n            ruleName: topLevelRule.name,\n            occurrence: currOr.idx,\n            alternative: currAltIdx + 1\n          }\n        ];\n      } else {\n        return [];\n      }\n    });\n  });\n  return errors;\n}\n__name(validateEmptyOrAlternative, \"validateEmptyOrAlternative\");\nfunction validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  let ors = orCollector.alternations;\n  ors = reject_default(ors, (currOr) => currOr.ignoreAmbiguities === true);\n  const errors = flatMap_default(ors, (currOr) => {\n    const currOccurrence = currOr.idx;\n    const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    const alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n    const altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n  });\n  return errors;\n}\n__name(validateAmbiguousAlternationAlternatives, \"validateAmbiguousAlternationAlternatives\");\nvar RepetitionCollector = class extends GAstVisitor {\n  static {\n    __name(this, \"RepetitionCollector\");\n  }\n  constructor() {\n    super(...arguments);\n    this.allProductions = [];\n  }\n  visitRepetitionWithSeparator(manySep) {\n    this.allProductions.push(manySep);\n  }\n  visitRepetitionMandatory(atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  }\n  visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  }\n  visitRepetition(many) {\n    this.allProductions.push(many);\n  }\n};\nfunction validateTooManyAlts(topLevelRule, errMsgProvider) {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  const ors = orCollector.alternations;\n  const errors = flatMap_default(ors, (currOr) => {\n    if (currOr.definition.length > 255) {\n      return [\n        {\n          message: errMsgProvider.buildTooManyAlternativesError({\n            topLevelRule,\n            alternation: currOr\n          }),\n          type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx\n        }\n      ];\n    } else {\n      return [];\n    }\n  });\n  return errors;\n}\n__name(validateTooManyAlts, \"validateTooManyAlts\");\nfunction validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n  const errors = [];\n  forEach_default(topLevelRules, (currTopRule) => {\n    const collectorVisitor2 = new RepetitionCollector();\n    currTopRule.accept(collectorVisitor2);\n    const allRuleProductions = collectorVisitor2.allProductions;\n    forEach_default(allRuleProductions, (currProd) => {\n      const prodType = getProdType(currProd);\n      const actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      const currOccurrence = currProd.idx;\n      const paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n      const pathsInsideProduction = paths[0];\n      if (isEmpty_default(flatten_default(pathsInsideProduction))) {\n        const errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        });\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        });\n      }\n    });\n  });\n  return errors;\n}\n__name(validateSomeNonEmptyLookaheadPath, \"validateSomeNonEmptyLookaheadPath\");\nfunction checkAlternativesAmbiguities(alternatives, alternation2, rule, errMsgProvider) {\n  const foundAmbiguousPaths = [];\n  const identicalAmbiguities = reduce_default(alternatives, (result, currAlt, currAltIdx) => {\n    if (alternation2.definition[currAltIdx].ignoreAmbiguities === true) {\n      return result;\n    }\n    forEach_default(currAlt, (currPath) => {\n      const altsCurrPathAppearsIn = [currAltIdx];\n      forEach_default(alternatives, (currOtherAlt, currOtherAltIdx) => {\n        if (currAltIdx !== currOtherAltIdx && containsPath(currOtherAlt, currPath) && // ignore (skip) ambiguities with this \"other\" alternative\n        alternation2.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n          altsCurrPathAppearsIn.push(currOtherAltIdx);\n        }\n      });\n      if (altsCurrPathAppearsIn.length > 1 && !containsPath(foundAmbiguousPaths, currPath)) {\n        foundAmbiguousPaths.push(currPath);\n        result.push({\n          alts: altsCurrPathAppearsIn,\n          path: currPath\n        });\n      }\n    });\n    return result;\n  }, []);\n  const currErrors = map_default(identicalAmbiguities, (currAmbDescriptor) => {\n    const ambgIndices = map_default(currAmbDescriptor.alts, (currAltIdx) => currAltIdx + 1);\n    const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation2,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    });\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation2.idx,\n      alternatives: currAmbDescriptor.alts\n    };\n  });\n  return currErrors;\n}\n__name(checkAlternativesAmbiguities, \"checkAlternativesAmbiguities\");\nfunction checkPrefixAlternativesAmbiguities(alternatives, alternation2, rule, errMsgProvider) {\n  const pathsAndIndices = reduce_default(alternatives, (result, currAlt, idx) => {\n    const currPathsAndIdx = map_default(currAlt, (currPath) => {\n      return { idx, path: currPath };\n    });\n    return result.concat(currPathsAndIdx);\n  }, []);\n  const errors = compact_default(flatMap_default(pathsAndIndices, (currPathAndIdx) => {\n    const alternativeGast = alternation2.definition[currPathAndIdx.idx];\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return [];\n    }\n    const targetIdx = currPathAndIdx.idx;\n    const targetPath = currPathAndIdx.path;\n    const prefixAmbiguitiesPathsAndIndices = filter_default(pathsAndIndices, (searchPathAndIdx) => {\n      return (\n        // ignore (skip) ambiguities with this \"other\" alternative\n        alternation2.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads\n        // will be be detected using a different validation.\n        isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n      );\n    });\n    const currPathPrefixErrors = map_default(prefixAmbiguitiesPathsAndIndices, (currAmbPathAndIdx) => {\n      const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n      const occurrence = alternation2.idx === 0 ? \"\" : alternation2.idx;\n      const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation2,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbPathAndIdx.path\n      });\n      return {\n        message,\n        type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n        ruleName: rule.name,\n        occurrence,\n        alternatives: ambgIndices\n      };\n    });\n    return currPathPrefixErrors;\n  }));\n  return errors;\n}\n__name(checkPrefixAlternativesAmbiguities, \"checkPrefixAlternativesAmbiguities\");\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n  const errors = [];\n  const tokenNames = map_default(tokenTypes, (currToken) => currToken.name);\n  forEach_default(topLevels, (currRule) => {\n    const currRuleName = currRule.name;\n    if (includes_default(tokenNames, currRuleName)) {\n      const errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      });\n    }\n  });\n  return errors;\n}\n__name(checkTerminalAndNoneTerminalsNameSpace, \"checkTerminalAndNoneTerminalsNameSpace\");\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js\nfunction resolveGrammar2(options) {\n  const actualOptions = defaults_default(options, {\n    errMsgProvider: defaultGrammarResolverErrorProvider\n  });\n  const topRulesTable = {};\n  forEach_default(options.rules, (rule) => {\n    topRulesTable[rule.name] = rule;\n  });\n  return resolveGrammar(topRulesTable, actualOptions.errMsgProvider);\n}\n__name(resolveGrammar2, \"resolveGrammar\");\nfunction validateGrammar2(options) {\n  options = defaults_default(options, {\n    errMsgProvider: defaultGrammarValidatorErrorProvider\n  });\n  return validateGrammar(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);\n}\n__name(validateGrammar2, \"validateGrammar\");\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/exceptions_public.js\nvar MISMATCHED_TOKEN_EXCEPTION = \"MismatchedTokenException\";\nvar NO_VIABLE_ALT_EXCEPTION = \"NoViableAltException\";\nvar EARLY_EXIT_EXCEPTION = \"EarlyExitException\";\nvar NOT_ALL_INPUT_PARSED_EXCEPTION = \"NotAllInputParsedException\";\nvar RECOGNITION_EXCEPTION_NAMES = [\n  MISMATCHED_TOKEN_EXCEPTION,\n  NO_VIABLE_ALT_EXCEPTION,\n  EARLY_EXIT_EXCEPTION,\n  NOT_ALL_INPUT_PARSED_EXCEPTION\n];\nObject.freeze(RECOGNITION_EXCEPTION_NAMES);\nfunction isRecognitionException(error) {\n  return includes_default(RECOGNITION_EXCEPTION_NAMES, error.name);\n}\n__name(isRecognitionException, \"isRecognitionException\");\nvar RecognitionException = class extends Error {\n  static {\n    __name(this, \"RecognitionException\");\n  }\n  constructor(message, token) {\n    super(message);\n    this.token = token;\n    this.resyncedTokens = [];\n    Object.setPrototypeOf(this, new.target.prototype);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n};\nvar MismatchedTokenException = class extends RecognitionException {\n  static {\n    __name(this, \"MismatchedTokenException\");\n  }\n  constructor(message, token, previousToken) {\n    super(message, token);\n    this.previousToken = previousToken;\n    this.name = MISMATCHED_TOKEN_EXCEPTION;\n  }\n};\nvar NoViableAltException = class extends RecognitionException {\n  static {\n    __name(this, \"NoViableAltException\");\n  }\n  constructor(message, token, previousToken) {\n    super(message, token);\n    this.previousToken = previousToken;\n    this.name = NO_VIABLE_ALT_EXCEPTION;\n  }\n};\nvar NotAllInputParsedException = class extends RecognitionException {\n  static {\n    __name(this, \"NotAllInputParsedException\");\n  }\n  constructor(message, token) {\n    super(message, token);\n    this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;\n  }\n};\nvar EarlyExitException = class extends RecognitionException {\n  static {\n    __name(this, \"EarlyExitException\");\n  }\n  constructor(message, token, previousToken) {\n    super(message, token);\n    this.previousToken = previousToken;\n    this.name = EARLY_EXIT_EXCEPTION;\n  }\n};\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js\nvar EOF_FOLLOW_KEY = {};\nvar IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nvar InRuleRecoveryException = class extends Error {\n  static {\n    __name(this, \"InRuleRecoveryException\");\n  }\n  constructor(message) {\n    super(message);\n    this.name = IN_RULE_RECOVERY_EXCEPTION;\n  }\n};\nvar Recoverable = class {\n  static {\n    __name(this, \"Recoverable\");\n  }\n  initRecoverable(config) {\n    this.firstAfterRepMap = {};\n    this.resyncFollows = {};\n    this.recoveryEnabled = has_default(config, \"recoveryEnabled\") ? config.recoveryEnabled : DEFAULT_PARSER_CONFIG.recoveryEnabled;\n    if (this.recoveryEnabled) {\n      this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n    }\n  }\n  getTokenToInsert(tokType) {\n    const tokToInsert = createTokenInstance(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n    tokToInsert.isInsertedInRecovery = true;\n    return tokToInsert;\n  }\n  canTokenTypeBeInsertedInRecovery(tokType) {\n    return true;\n  }\n  canTokenTypeBeDeletedInRecovery(tokType) {\n    return true;\n  }\n  tryInRepetitionRecovery(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n    const reSyncTokType = this.findReSyncTokenType();\n    const savedLexerState = this.exportLexerState();\n    const resyncedTokens = [];\n    let passedResyncPoint = false;\n    const nextTokenWithoutResync = this.LA(1);\n    let currToken = this.LA(1);\n    const generateErrorMessage = /* @__PURE__ */ __name(() => {\n      const previousToken = this.LA(0);\n      const msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: expectedTokType,\n        actual: nextTokenWithoutResync,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      });\n      const error = new MismatchedTokenException(msg, nextTokenWithoutResync, this.LA(0));\n      error.resyncedTokens = dropRight_default(resyncedTokens);\n      this.SAVE_ERROR(error);\n    }, \"generateErrorMessage\");\n    while (!passedResyncPoint) {\n      if (this.tokenMatcher(currToken, expectedTokType)) {\n        generateErrorMessage();\n        return;\n      } else if (lookAheadFunc.call(this)) {\n        generateErrorMessage();\n        grammarRule.apply(this, grammarRuleArgs);\n        return;\n      } else if (this.tokenMatcher(currToken, reSyncTokType)) {\n        passedResyncPoint = true;\n      } else {\n        currToken = this.SKIP_TOKEN();\n        this.addToResyncTokens(currToken, resyncedTokens);\n      }\n    }\n    this.importLexerState(savedLexerState);\n  }\n  shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck) {\n    if (notStuck === false) {\n      return false;\n    }\n    if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n      return false;\n    }\n    if (this.isBackTracking()) {\n      return false;\n    }\n    if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n      return false;\n    }\n    return true;\n  }\n  // Error Recovery functionality\n  getFollowsForInRuleRecovery(tokType, tokIdxInRule) {\n    const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n    const follows = this.getNextPossibleTokenTypes(grammarPath);\n    return follows;\n  }\n  tryInRuleRecovery(expectedTokType, follows) {\n    if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n      const tokToInsert = this.getTokenToInsert(expectedTokType);\n      return tokToInsert;\n    }\n    if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n      const nextTok = this.SKIP_TOKEN();\n      this.consumeToken();\n      return nextTok;\n    }\n    throw new InRuleRecoveryException(\"sad sad panda\");\n  }\n  canPerformInRuleRecovery(expectedToken, follows) {\n    return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);\n  }\n  canRecoverWithSingleTokenInsertion(expectedTokType, follows) {\n    if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n      return false;\n    }\n    if (isEmpty_default(follows)) {\n      return false;\n    }\n    const mismatchedTok = this.LA(1);\n    const isMisMatchedTokInFollows = find_default(follows, (possibleFollowsTokType) => {\n      return this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n    }) !== void 0;\n    return isMisMatchedTokInFollows;\n  }\n  canRecoverWithSingleTokenDeletion(expectedTokType) {\n    if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n      return false;\n    }\n    const isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n    return isNextTokenWhatIsExpected;\n  }\n  isInCurrentRuleReSyncSet(tokenTypeIdx) {\n    const followKey = this.getCurrFollowKey();\n    const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n    return includes_default(currentRuleReSyncSet, tokenTypeIdx);\n  }\n  findReSyncTokenType() {\n    const allPossibleReSyncTokTypes = this.flattenFollowSet();\n    let nextToken = this.LA(1);\n    let k = 2;\n    while (true) {\n      const foundMatch = find_default(allPossibleReSyncTokTypes, (resyncTokType) => {\n        const canMatch = tokenMatcher(nextToken, resyncTokType);\n        return canMatch;\n      });\n      if (foundMatch !== void 0) {\n        return foundMatch;\n      }\n      nextToken = this.LA(k);\n      k++;\n    }\n  }\n  getCurrFollowKey() {\n    if (this.RULE_STACK.length === 1) {\n      return EOF_FOLLOW_KEY;\n    }\n    const currRuleShortName = this.getLastExplicitRuleShortName();\n    const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n    const prevRuleShortName = this.getPreviousExplicitRuleShortName();\n    return {\n      ruleName: this.shortRuleNameToFullName(currRuleShortName),\n      idxInCallingRule: currRuleIdx,\n      inRule: this.shortRuleNameToFullName(prevRuleShortName)\n    };\n  }\n  buildFullFollowKeyStack() {\n    const explicitRuleStack = this.RULE_STACK;\n    const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return map_default(explicitRuleStack, (ruleName, idx) => {\n      if (idx === 0) {\n        return EOF_FOLLOW_KEY;\n      }\n      return {\n        ruleName: this.shortRuleNameToFullName(ruleName),\n        idxInCallingRule: explicitOccurrenceStack[idx],\n        inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n      };\n    });\n  }\n  flattenFollowSet() {\n    const followStack = map_default(this.buildFullFollowKeyStack(), (currKey) => {\n      return this.getFollowSetFromFollowKey(currKey);\n    });\n    return flatten_default(followStack);\n  }\n  getFollowSetFromFollowKey(followKey) {\n    if (followKey === EOF_FOLLOW_KEY) {\n      return [EOF];\n    }\n    const followName = followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule;\n    return this.resyncFollows[followName];\n  }\n  // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n  // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n  addToResyncTokens(token, resyncTokens) {\n    if (!this.tokenMatcher(token, EOF)) {\n      resyncTokens.push(token);\n    }\n    return resyncTokens;\n  }\n  reSyncTo(tokType) {\n    const resyncedTokens = [];\n    let nextTok = this.LA(1);\n    while (this.tokenMatcher(nextTok, tokType) === false) {\n      nextTok = this.SKIP_TOKEN();\n      this.addToResyncTokens(nextTok, resyncedTokens);\n    }\n    return dropRight_default(resyncedTokens);\n  }\n  attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n  }\n  getCurrentGrammarPath(tokType, tokIdxInRule) {\n    const pathRuleStack = this.getHumanReadableRuleStack();\n    const pathOccurrenceStack = clone_default(this.RULE_OCCURRENCE_STACK);\n    const grammarPath = {\n      ruleStack: pathRuleStack,\n      occurrenceStack: pathOccurrenceStack,\n      lastTok: tokType,\n      lastTokOccurrence: tokIdxInRule\n    };\n    return grammarPath;\n  }\n  getHumanReadableRuleStack() {\n    return map_default(this.RULE_STACK, (currShortName) => this.shortRuleNameToFullName(currShortName));\n  }\n};\nfunction attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n  const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n  let firstAfterRepInfo = this.firstAfterRepMap[key];\n  if (firstAfterRepInfo === void 0) {\n    const currRuleName = this.getCurrRuleFullName();\n    const ruleGrammar = this.getGAstProductions()[currRuleName];\n    const walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n    firstAfterRepInfo = walker.startWalking();\n    this.firstAfterRepMap[key] = firstAfterRepInfo;\n  }\n  let expectTokAfterLastMatch = firstAfterRepInfo.token;\n  let nextTokIdx = firstAfterRepInfo.occurrence;\n  const isEndOfRule = firstAfterRepInfo.isEndOfRule;\n  if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === void 0) {\n    expectTokAfterLastMatch = EOF;\n    nextTokIdx = 1;\n  }\n  if (expectTokAfterLastMatch === void 0 || nextTokIdx === void 0) {\n    return;\n  }\n  if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n    this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n  }\n}\n__name(attemptInRepetitionRecovery, \"attemptInRepetitionRecovery\");\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/grammar/keys.js\nvar BITS_FOR_METHOD_TYPE = 4;\nvar BITS_FOR_OCCURRENCE_IDX = 8;\nvar BITS_FOR_ALT_IDX = 8;\nvar OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;\nvar OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;\nvar MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;\nvar AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;\nvar MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;\nvar AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;\nfunction getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {\n  return occurrence | dslMethodIdx | ruleIdx;\n}\n__name(getKeyForAutomaticLookahead, \"getKeyForAutomaticLookahead\");\nvar BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js\nvar LLkLookaheadStrategy = class {\n  static {\n    __name(this, \"LLkLookaheadStrategy\");\n  }\n  constructor(options) {\n    var _a;\n    this.maxLookahead = (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : DEFAULT_PARSER_CONFIG.maxLookahead;\n  }\n  validate(options) {\n    const leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\n    if (isEmpty_default(leftRecursionErrors)) {\n      const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\n      const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);\n      const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);\n      const allErrors = [\n        ...leftRecursionErrors,\n        ...emptyAltErrors,\n        ...ambiguousAltsErrors,\n        ...emptyRepetitionErrors\n      ];\n      return allErrors;\n    }\n    return leftRecursionErrors;\n  }\n  validateNoLeftRecursion(rules) {\n    return flatMap_default(rules, (currTopRule) => validateNoLeftRecursion(currTopRule, currTopRule, defaultGrammarValidatorErrorProvider));\n  }\n  validateEmptyOrAlternatives(rules) {\n    return flatMap_default(rules, (currTopRule) => validateEmptyOrAlternative(currTopRule, defaultGrammarValidatorErrorProvider));\n  }\n  validateAmbiguousAlternationAlternatives(rules, maxLookahead) {\n    return flatMap_default(rules, (currTopRule) => validateAmbiguousAlternationAlternatives(currTopRule, maxLookahead, defaultGrammarValidatorErrorProvider));\n  }\n  validateSomeNonEmptyLookaheadPath(rules, maxLookahead) {\n    return validateSomeNonEmptyLookaheadPath(rules, maxLookahead, defaultGrammarValidatorErrorProvider);\n  }\n  buildLookaheadForAlternation(options) {\n    return buildLookaheadFuncForOr(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, buildAlternativesLookAheadFunc);\n  }\n  buildLookaheadForOptional(options) {\n    return buildLookaheadFuncForOptionalProd(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, getProdType(options.prodType), buildSingleAlternativeLookaheadFunction);\n  }\n};\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js\nvar LooksAhead = class {\n  static {\n    __name(this, \"LooksAhead\");\n  }\n  initLooksAhead(config) {\n    this.dynamicTokensEnabled = has_default(config, \"dynamicTokensEnabled\") ? config.dynamicTokensEnabled : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n    this.maxLookahead = has_default(config, \"maxLookahead\") ? config.maxLookahead : DEFAULT_PARSER_CONFIG.maxLookahead;\n    this.lookaheadStrategy = has_default(config, \"lookaheadStrategy\") ? config.lookaheadStrategy : new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });\n    this.lookAheadFuncsCache = /* @__PURE__ */ new Map();\n  }\n  preComputeLookaheadFunctions(rules) {\n    forEach_default(rules, (currRule) => {\n      this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n        const { alternation: alternation2, repetition: repetition2, option: option2, repetitionMandatory: repetitionMandatory2, repetitionMandatoryWithSeparator, repetitionWithSeparator } = collectMethods(currRule);\n        forEach_default(alternation2, (currProd) => {\n          const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n          this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\n            const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({\n              prodOccurrence: currProd.idx,\n              rule: currRule,\n              maxLookahead: currProd.maxLookahead || this.maxLookahead,\n              hasPredicates: currProd.hasPredicates,\n              dynamicTokensEnabled: this.dynamicTokensEnabled\n            });\n            const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[currRule.name], OR_IDX, currProd.idx);\n            this.setLaFuncCache(key, laFunc);\n          });\n        });\n        forEach_default(repetition2, (currProd) => {\n          this.computeLookaheadFunc(currRule, currProd.idx, MANY_IDX, \"Repetition\", currProd.maxLookahead, getProductionDslName(currProd));\n        });\n        forEach_default(option2, (currProd) => {\n          this.computeLookaheadFunc(currRule, currProd.idx, OPTION_IDX, \"Option\", currProd.maxLookahead, getProductionDslName(currProd));\n        });\n        forEach_default(repetitionMandatory2, (currProd) => {\n          this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_IDX, \"RepetitionMandatory\", currProd.maxLookahead, getProductionDslName(currProd));\n        });\n        forEach_default(repetitionMandatoryWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_SEP_IDX, \"RepetitionMandatoryWithSeparator\", currProd.maxLookahead, getProductionDslName(currProd));\n        });\n        forEach_default(repetitionWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(currRule, currProd.idx, MANY_SEP_IDX, \"RepetitionWithSeparator\", currProd.maxLookahead, getProductionDslName(currProd));\n        });\n      });\n    });\n  }\n  computeLookaheadFunc(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n    this.TRACE_INIT(`${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`, () => {\n      const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({\n        prodOccurrence,\n        rule,\n        maxLookahead: prodMaxLookahead || this.maxLookahead,\n        dynamicTokensEnabled: this.dynamicTokensEnabled,\n        prodType\n      });\n      const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n      this.setLaFuncCache(key, laFunc);\n    });\n  }\n  // this actually returns a number, but it is always used as a string (object prop key)\n  getKeyForAutomaticLookahead(dslMethodIdx, occurrence) {\n    const currRuleShortName = this.getLastExplicitRuleShortName();\n    return getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence);\n  }\n  getLaFuncFromCache(key) {\n    return this.lookAheadFuncsCache.get(key);\n  }\n  /* istanbul ignore next */\n  setLaFuncCache(key, value) {\n    this.lookAheadFuncsCache.set(key, value);\n  }\n};\nvar DslMethodsCollectorVisitor = class extends GAstVisitor {\n  static {\n    __name(this, \"DslMethodsCollectorVisitor\");\n  }\n  constructor() {\n    super(...arguments);\n    this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: []\n    };\n  }\n  reset() {\n    this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: []\n    };\n  }\n  visitOption(option2) {\n    this.dslMethods.option.push(option2);\n  }\n  visitRepetitionWithSeparator(manySep) {\n    this.dslMethods.repetitionWithSeparator.push(manySep);\n  }\n  visitRepetitionMandatory(atLeastOne) {\n    this.dslMethods.repetitionMandatory.push(atLeastOne);\n  }\n  visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n    this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n  }\n  visitRepetition(many) {\n    this.dslMethods.repetition.push(many);\n  }\n  visitAlternation(or) {\n    this.dslMethods.alternation.push(or);\n  }\n};\nvar collectorVisitor = new DslMethodsCollectorVisitor();\nfunction collectMethods(rule) {\n  collectorVisitor.reset();\n  rule.accept(collectorVisitor);\n  const dslMethods = collectorVisitor.dslMethods;\n  collectorVisitor.reset();\n  return dslMethods;\n}\n__name(collectMethods, \"collectMethods\");\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/cst/cst.js\nfunction setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  }\n}\n__name(setNodeLocationOnlyOffset, \"setNodeLocationOnlyOffset\");\nfunction setNodeLocationFull(currNodeLocation, newLocationInfo) {\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.startColumn = newLocationInfo.startColumn;\n    currNodeLocation.startLine = newLocationInfo.startLine;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  }\n}\n__name(setNodeLocationFull, \"setNodeLocationFull\");\nfunction addTerminalToCst(node, token, tokenTypeName) {\n  if (node.children[tokenTypeName] === void 0) {\n    node.children[tokenTypeName] = [token];\n  } else {\n    node.children[tokenTypeName].push(token);\n  }\n}\n__name(addTerminalToCst, \"addTerminalToCst\");\nfunction addNoneTerminalToCst(node, ruleName, ruleResult) {\n  if (node.children[ruleName] === void 0) {\n    node.children[ruleName] = [ruleResult];\n  } else {\n    node.children[ruleName].push(ruleResult);\n  }\n}\n__name(addNoneTerminalToCst, \"addNoneTerminalToCst\");\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/lang/lang_extensions.js\nvar NAME = \"name\";\nfunction defineNameProp(obj, nameValue) {\n  Object.defineProperty(obj, NAME, {\n    enumerable: false,\n    configurable: true,\n    writable: false,\n    value: nameValue\n  });\n}\n__name(defineNameProp, \"defineNameProp\");\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js\nfunction defaultVisit(ctx, param) {\n  const childrenNames = keys_default(ctx);\n  const childrenNamesLength = childrenNames.length;\n  for (let i = 0; i < childrenNamesLength; i++) {\n    const currChildName = childrenNames[i];\n    const currChildArray = ctx[currChildName];\n    const currChildArrayLength = currChildArray.length;\n    for (let j = 0; j < currChildArrayLength; j++) {\n      const currChild = currChildArray[j];\n      if (currChild.tokenTypeIdx === void 0) {\n        this[currChild.name](currChild.children, param);\n      }\n    }\n  }\n}\n__name(defaultVisit, \"defaultVisit\");\nfunction createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n  const derivedConstructor = /* @__PURE__ */ __name(function() {\n  }, \"derivedConstructor\");\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\");\n  const semanticProto = {\n    visit: /* @__PURE__ */ __name(function(cstNode, param) {\n      if (isArray_default(cstNode)) {\n        cstNode = cstNode[0];\n      }\n      if (isUndefined_default(cstNode)) {\n        return void 0;\n      }\n      return this[cstNode.name](cstNode.children, param);\n    }, \"visit\"),\n    validateVisitor: /* @__PURE__ */ __name(function() {\n      const semanticDefinitionErrors = validateVisitor(this, ruleNames);\n      if (!isEmpty_default(semanticDefinitionErrors)) {\n        const errorMessages = map_default(semanticDefinitionErrors, (currDefError) => currDefError.msg);\n        throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:\n\t${errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\t\")}`);\n      }\n    }, \"validateVisitor\")\n  };\n  derivedConstructor.prototype = semanticProto;\n  derivedConstructor.prototype.constructor = derivedConstructor;\n  derivedConstructor._RULE_NAMES = ruleNames;\n  return derivedConstructor;\n}\n__name(createBaseSemanticVisitorConstructor, \"createBaseSemanticVisitorConstructor\");\nfunction createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n  const derivedConstructor = /* @__PURE__ */ __name(function() {\n  }, \"derivedConstructor\");\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n  const withDefaultsProto = Object.create(baseConstructor.prototype);\n  forEach_default(ruleNames, (ruleName) => {\n    withDefaultsProto[ruleName] = defaultVisit;\n  });\n  derivedConstructor.prototype = withDefaultsProto;\n  derivedConstructor.prototype.constructor = derivedConstructor;\n  return derivedConstructor;\n}\n__name(createBaseVisitorConstructorWithDefaults, \"createBaseVisitorConstructorWithDefaults\");\nvar CstVisitorDefinitionError;\n(function(CstVisitorDefinitionError2) {\n  CstVisitorDefinitionError2[CstVisitorDefinitionError2[\"REDUNDANT_METHOD\"] = 0] = \"REDUNDANT_METHOD\";\n  CstVisitorDefinitionError2[CstVisitorDefinitionError2[\"MISSING_METHOD\"] = 1] = \"MISSING_METHOD\";\n})(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));\nfunction validateVisitor(visitorInstance, ruleNames) {\n  const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n  return missingErrors;\n}\n__name(validateVisitor, \"validateVisitor\");\nfunction validateMissingCstMethods(visitorInstance, ruleNames) {\n  const missingRuleNames = filter_default(ruleNames, (currRuleName) => {\n    return isFunction_default(visitorInstance[currRuleName]) === false;\n  });\n  const errors = map_default(missingRuleNames, (currRuleName) => {\n    return {\n      msg: `Missing visitor method: <${currRuleName}> on ${visitorInstance.constructor.name} CST Visitor.`,\n      type: CstVisitorDefinitionError.MISSING_METHOD,\n      methodName: currRuleName\n    };\n  });\n  return compact_default(errors);\n}\n__name(validateMissingCstMethods, \"validateMissingCstMethods\");\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js\nvar TreeBuilder = class {\n  static {\n    __name(this, \"TreeBuilder\");\n  }\n  initTreeBuilder(config) {\n    this.CST_STACK = [];\n    this.outputCst = config.outputCst;\n    this.nodeLocationTracking = has_default(config, \"nodeLocationTracking\") ? config.nodeLocationTracking : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = noop_default;\n      this.cstFinallyStateUpdate = noop_default;\n      this.cstPostTerminal = noop_default;\n      this.cstPostNonTerminal = noop_default;\n      this.cstPostRule = noop_default;\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationFull;\n          this.setNodeLocationFromNode = setNodeLocationFull;\n          this.cstPostRule = noop_default;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n        } else {\n          this.setNodeLocationFromToken = noop_default;\n          this.setNodeLocationFromNode = noop_default;\n          this.cstPostRule = this.cstPostRuleFull;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationOnlyOffset;\n          this.setNodeLocationFromNode = setNodeLocationOnlyOffset;\n          this.cstPostRule = noop_default;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n        } else {\n          this.setNodeLocationFromToken = noop_default;\n          this.setNodeLocationFromNode = noop_default;\n          this.cstPostRule = this.cstPostRuleOnlyOffset;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = noop_default;\n        this.setNodeLocationFromNode = noop_default;\n        this.cstPostRule = noop_default;\n        this.setInitialNodeLocation = noop_default;\n      } else {\n        throw Error(`Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`);\n      }\n    }\n  }\n  setInitialNodeLocationOnlyOffsetRecovery(cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN\n    };\n  }\n  setInitialNodeLocationOnlyOffsetRegular(cstNode) {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN\n    };\n  }\n  setInitialNodeLocationFullRecovery(cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  }\n  /**\n       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n  \n       * @param cstNode\n       */\n  setInitialNodeLocationFullRegular(cstNode) {\n    const nextToken = this.LA(1);\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  }\n  cstInvocationStateUpdate(fullRuleName) {\n    const cstNode = {\n      name: fullRuleName,\n      children: /* @__PURE__ */ Object.create(null)\n    };\n    this.setInitialNodeLocation(cstNode);\n    this.CST_STACK.push(cstNode);\n  }\n  cstFinallyStateUpdate() {\n    this.CST_STACK.pop();\n  }\n  cstPostRuleFull(ruleCstNode) {\n    const prevToken = this.LA(0);\n    const loc = ruleCstNode.location;\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n      loc.endLine = prevToken.endLine;\n      loc.endColumn = prevToken.endColumn;\n    } else {\n      loc.startOffset = NaN;\n      loc.startLine = NaN;\n      loc.startColumn = NaN;\n    }\n  }\n  cstPostRuleOnlyOffset(ruleCstNode) {\n    const prevToken = this.LA(0);\n    const loc = ruleCstNode.location;\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n    } else {\n      loc.startOffset = NaN;\n    }\n  }\n  cstPostTerminal(key, consumedToken) {\n    const rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n    addTerminalToCst(rootCst, consumedToken, key);\n    this.setNodeLocationFromToken(rootCst.location, consumedToken);\n  }\n  cstPostNonTerminal(ruleCstResult, ruleName) {\n    const preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n    addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n    this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n  }\n  getBaseCstVisitorConstructor() {\n    if (isUndefined_default(this.baseCstVisitorConstructor)) {\n      const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, keys_default(this.gastProductionsCache));\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n      return newBaseCstVisitorConstructor;\n    }\n    return this.baseCstVisitorConstructor;\n  }\n  getBaseCstVisitorConstructorWithDefaults() {\n    if (isUndefined_default(this.baseCstVisitorWithDefaultsConstructor)) {\n      const newConstructor = createBaseVisitorConstructorWithDefaults(this.className, keys_default(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n      return newConstructor;\n    }\n    return this.baseCstVisitorWithDefaultsConstructor;\n  }\n  getLastExplicitRuleShortName() {\n    const ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 1];\n  }\n  getPreviousExplicitRuleShortName() {\n    const ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 2];\n  }\n  getLastExplicitRuleOccurrenceIndex() {\n    const occurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return occurrenceStack[occurrenceStack.length - 1];\n  }\n};\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js\nvar LexerAdapter = class {\n  static {\n    __name(this, \"LexerAdapter\");\n  }\n  initLexerAdapter() {\n    this.tokVector = [];\n    this.tokVectorLength = 0;\n    this.currIdx = -1;\n  }\n  set input(newInput) {\n    if (this.selfAnalysisDone !== true) {\n      throw Error(`Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`);\n    }\n    this.reset();\n    this.tokVector = newInput;\n    this.tokVectorLength = newInput.length;\n  }\n  get input() {\n    return this.tokVector;\n  }\n  // skips a token and returns the next token\n  SKIP_TOKEN() {\n    if (this.currIdx <= this.tokVector.length - 2) {\n      this.consumeToken();\n      return this.LA(1);\n    } else {\n      return END_OF_FILE;\n    }\n  }\n  // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n  // or lexers dependent on parser context.\n  LA(howMuch) {\n    const soughtIdx = this.currIdx + howMuch;\n    if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n      return END_OF_FILE;\n    } else {\n      return this.tokVector[soughtIdx];\n    }\n  }\n  consumeToken() {\n    this.currIdx++;\n  }\n  exportLexerState() {\n    return this.currIdx;\n  }\n  importLexerState(newState2) {\n    this.currIdx = newState2;\n  }\n  resetLexerState() {\n    this.currIdx = -1;\n  }\n  moveToTerminatedState() {\n    this.currIdx = this.tokVector.length - 1;\n  }\n  getLexerPosition() {\n    return this.exportLexerState();\n  }\n};\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js\nvar RecognizerApi = class {\n  static {\n    __name(this, \"RecognizerApi\");\n  }\n  ACTION(impl) {\n    return impl.call(this);\n  }\n  consume(idx, tokType, options) {\n    return this.consumeInternal(tokType, idx, options);\n  }\n  subrule(idx, ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, idx, options);\n  }\n  option(idx, actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, idx);\n  }\n  or(idx, altsOrOpts) {\n    return this.orInternal(altsOrOpts, idx);\n  }\n  many(idx, actionORMethodDef) {\n    return this.manyInternal(idx, actionORMethodDef);\n  }\n  atLeastOne(idx, actionORMethodDef) {\n    return this.atLeastOneInternal(idx, actionORMethodDef);\n  }\n  CONSUME(tokType, options) {\n    return this.consumeInternal(tokType, 0, options);\n  }\n  CONSUME1(tokType, options) {\n    return this.consumeInternal(tokType, 1, options);\n  }\n  CONSUME2(tokType, options) {\n    return this.consumeInternal(tokType, 2, options);\n  }\n  CONSUME3(tokType, options) {\n    return this.consumeInternal(tokType, 3, options);\n  }\n  CONSUME4(tokType, options) {\n    return this.consumeInternal(tokType, 4, options);\n  }\n  CONSUME5(tokType, options) {\n    return this.consumeInternal(tokType, 5, options);\n  }\n  CONSUME6(tokType, options) {\n    return this.consumeInternal(tokType, 6, options);\n  }\n  CONSUME7(tokType, options) {\n    return this.consumeInternal(tokType, 7, options);\n  }\n  CONSUME8(tokType, options) {\n    return this.consumeInternal(tokType, 8, options);\n  }\n  CONSUME9(tokType, options) {\n    return this.consumeInternal(tokType, 9, options);\n  }\n  SUBRULE(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 0, options);\n  }\n  SUBRULE1(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 1, options);\n  }\n  SUBRULE2(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 2, options);\n  }\n  SUBRULE3(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 3, options);\n  }\n  SUBRULE4(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 4, options);\n  }\n  SUBRULE5(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 5, options);\n  }\n  SUBRULE6(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 6, options);\n  }\n  SUBRULE7(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 7, options);\n  }\n  SUBRULE8(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 8, options);\n  }\n  SUBRULE9(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 9, options);\n  }\n  OPTION(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 0);\n  }\n  OPTION1(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 1);\n  }\n  OPTION2(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 2);\n  }\n  OPTION3(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 3);\n  }\n  OPTION4(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 4);\n  }\n  OPTION5(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 5);\n  }\n  OPTION6(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 6);\n  }\n  OPTION7(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 7);\n  }\n  OPTION8(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 8);\n  }\n  OPTION9(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 9);\n  }\n  OR(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 0);\n  }\n  OR1(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 1);\n  }\n  OR2(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 2);\n  }\n  OR3(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 3);\n  }\n  OR4(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 4);\n  }\n  OR5(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 5);\n  }\n  OR6(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 6);\n  }\n  OR7(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 7);\n  }\n  OR8(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 8);\n  }\n  OR9(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 9);\n  }\n  MANY(actionORMethodDef) {\n    this.manyInternal(0, actionORMethodDef);\n  }\n  MANY1(actionORMethodDef) {\n    this.manyInternal(1, actionORMethodDef);\n  }\n  MANY2(actionORMethodDef) {\n    this.manyInternal(2, actionORMethodDef);\n  }\n  MANY3(actionORMethodDef) {\n    this.manyInternal(3, actionORMethodDef);\n  }\n  MANY4(actionORMethodDef) {\n    this.manyInternal(4, actionORMethodDef);\n  }\n  MANY5(actionORMethodDef) {\n    this.manyInternal(5, actionORMethodDef);\n  }\n  MANY6(actionORMethodDef) {\n    this.manyInternal(6, actionORMethodDef);\n  }\n  MANY7(actionORMethodDef) {\n    this.manyInternal(7, actionORMethodDef);\n  }\n  MANY8(actionORMethodDef) {\n    this.manyInternal(8, actionORMethodDef);\n  }\n  MANY9(actionORMethodDef) {\n    this.manyInternal(9, actionORMethodDef);\n  }\n  MANY_SEP(options) {\n    this.manySepFirstInternal(0, options);\n  }\n  MANY_SEP1(options) {\n    this.manySepFirstInternal(1, options);\n  }\n  MANY_SEP2(options) {\n    this.manySepFirstInternal(2, options);\n  }\n  MANY_SEP3(options) {\n    this.manySepFirstInternal(3, options);\n  }\n  MANY_SEP4(options) {\n    this.manySepFirstInternal(4, options);\n  }\n  MANY_SEP5(options) {\n    this.manySepFirstInternal(5, options);\n  }\n  MANY_SEP6(options) {\n    this.manySepFirstInternal(6, options);\n  }\n  MANY_SEP7(options) {\n    this.manySepFirstInternal(7, options);\n  }\n  MANY_SEP8(options) {\n    this.manySepFirstInternal(8, options);\n  }\n  MANY_SEP9(options) {\n    this.manySepFirstInternal(9, options);\n  }\n  AT_LEAST_ONE(actionORMethodDef) {\n    this.atLeastOneInternal(0, actionORMethodDef);\n  }\n  AT_LEAST_ONE1(actionORMethodDef) {\n    return this.atLeastOneInternal(1, actionORMethodDef);\n  }\n  AT_LEAST_ONE2(actionORMethodDef) {\n    this.atLeastOneInternal(2, actionORMethodDef);\n  }\n  AT_LEAST_ONE3(actionORMethodDef) {\n    this.atLeastOneInternal(3, actionORMethodDef);\n  }\n  AT_LEAST_ONE4(actionORMethodDef) {\n    this.atLeastOneInternal(4, actionORMethodDef);\n  }\n  AT_LEAST_ONE5(actionORMethodDef) {\n    this.atLeastOneInternal(5, actionORMethodDef);\n  }\n  AT_LEAST_ONE6(actionORMethodDef) {\n    this.atLeastOneInternal(6, actionORMethodDef);\n  }\n  AT_LEAST_ONE7(actionORMethodDef) {\n    this.atLeastOneInternal(7, actionORMethodDef);\n  }\n  AT_LEAST_ONE8(actionORMethodDef) {\n    this.atLeastOneInternal(8, actionORMethodDef);\n  }\n  AT_LEAST_ONE9(actionORMethodDef) {\n    this.atLeastOneInternal(9, actionORMethodDef);\n  }\n  AT_LEAST_ONE_SEP(options) {\n    this.atLeastOneSepFirstInternal(0, options);\n  }\n  AT_LEAST_ONE_SEP1(options) {\n    this.atLeastOneSepFirstInternal(1, options);\n  }\n  AT_LEAST_ONE_SEP2(options) {\n    this.atLeastOneSepFirstInternal(2, options);\n  }\n  AT_LEAST_ONE_SEP3(options) {\n    this.atLeastOneSepFirstInternal(3, options);\n  }\n  AT_LEAST_ONE_SEP4(options) {\n    this.atLeastOneSepFirstInternal(4, options);\n  }\n  AT_LEAST_ONE_SEP5(options) {\n    this.atLeastOneSepFirstInternal(5, options);\n  }\n  AT_LEAST_ONE_SEP6(options) {\n    this.atLeastOneSepFirstInternal(6, options);\n  }\n  AT_LEAST_ONE_SEP7(options) {\n    this.atLeastOneSepFirstInternal(7, options);\n  }\n  AT_LEAST_ONE_SEP8(options) {\n    this.atLeastOneSepFirstInternal(8, options);\n  }\n  AT_LEAST_ONE_SEP9(options) {\n    this.atLeastOneSepFirstInternal(9, options);\n  }\n  RULE(name, implementation, config = DEFAULT_RULE_CONFIG) {\n    if (includes_default(this.definedRulesNames, name)) {\n      const errMsg = defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\n        topLevelRule: name,\n        grammarName: this.className\n      });\n      const error = {\n        message: errMsg,\n        type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n        ruleName: name\n      };\n      this.definitionErrors.push(error);\n    }\n    this.definedRulesNames.push(name);\n    const ruleImplementation = this.defineRule(name, implementation, config);\n    this[name] = ruleImplementation;\n    return ruleImplementation;\n  }\n  OVERRIDE_RULE(name, impl, config = DEFAULT_RULE_CONFIG) {\n    const ruleErrors = validateRuleIsOverridden(name, this.definedRulesNames, this.className);\n    this.definitionErrors = this.definitionErrors.concat(ruleErrors);\n    const ruleImplementation = this.defineRule(name, impl, config);\n    this[name] = ruleImplementation;\n    return ruleImplementation;\n  }\n  BACKTRACK(grammarRule, args) {\n    return function() {\n      this.isBackTrackingStack.push(1);\n      const orgState = this.saveRecogState();\n      try {\n        grammarRule.apply(this, args);\n        return true;\n      } catch (e) {\n        if (isRecognitionException(e)) {\n          return false;\n        } else {\n          throw e;\n        }\n      } finally {\n        this.reloadRecogState(orgState);\n        this.isBackTrackingStack.pop();\n      }\n    };\n  }\n  // GAST export APIs\n  getGAstProductions() {\n    return this.gastProductionsCache;\n  }\n  getSerializedGastProductions() {\n    return serializeGrammar(values_default(this.gastProductionsCache));\n  }\n};\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js\nvar RecognizerEngine = class {\n  static {\n    __name(this, \"RecognizerEngine\");\n  }\n  initRecognizerEngine(tokenVocabulary, config) {\n    this.className = this.constructor.name;\n    this.shortRuleNameToFull = {};\n    this.fullRuleNameToShort = {};\n    this.ruleShortNameIdx = 256;\n    this.tokenMatcher = tokenStructuredMatcherNoCategories;\n    this.subruleIdx = 0;\n    this.definedRulesNames = [];\n    this.tokensMap = {};\n    this.isBackTrackingStack = [];\n    this.RULE_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n    this.gastProductionsCache = {};\n    if (has_default(config, \"serializedGrammar\")) {\n      throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\tFor Further details.\");\n    }\n    if (isArray_default(tokenVocabulary)) {\n      if (isEmpty_default(tokenVocabulary)) {\n        throw Error(\"A Token Vocabulary cannot be empty.\\n\tNote that the first argument for the parser constructor\\n\tis no longer a Token vector (since v4.0).\");\n      }\n      if (typeof tokenVocabulary[0].startOffset === \"number\") {\n        throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\tFor Further details.\");\n      }\n    }\n    if (isArray_default(tokenVocabulary)) {\n      this.tokensMap = reduce_default(tokenVocabulary, (acc, tokType) => {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if (has_default(tokenVocabulary, \"modes\") && every_default(flatten_default(values_default(tokenVocabulary.modes)), isTokenType)) {\n      const allTokenTypes2 = flatten_default(values_default(tokenVocabulary.modes));\n      const uniqueTokens = uniq_default(allTokenTypes2);\n      this.tokensMap = reduce_default(uniqueTokens, (acc, tokType) => {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if (isObject_default(tokenVocabulary)) {\n      this.tokensMap = clone_default(tokenVocabulary);\n    } else {\n      throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n    }\n    this.tokensMap[\"EOF\"] = EOF;\n    const allTokenTypes = has_default(tokenVocabulary, \"modes\") ? flatten_default(values_default(tokenVocabulary.modes)) : values_default(tokenVocabulary);\n    const noTokenCategoriesUsed = every_default(allTokenTypes, (tokenConstructor) => isEmpty_default(tokenConstructor.categoryMatches));\n    this.tokenMatcher = noTokenCategoriesUsed ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n    augmentTokenTypes(values_default(this.tokensMap));\n  }\n  defineRule(ruleName, impl, config) {\n    if (this.selfAnalysisDone) {\n      throw Error(`Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\nMake sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);\n    }\n    const resyncEnabled = has_default(config, \"resyncEnabled\") ? config.resyncEnabled : DEFAULT_RULE_CONFIG.resyncEnabled;\n    const recoveryValueFunc = has_default(config, \"recoveryValueFunc\") ? config.recoveryValueFunc : DEFAULT_RULE_CONFIG.recoveryValueFunc;\n    const shortName = this.ruleShortNameIdx << BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX;\n    this.ruleShortNameIdx++;\n    this.shortRuleNameToFull[shortName] = ruleName;\n    this.fullRuleNameToShort[ruleName] = shortName;\n    let invokeRuleWithTry;\n    if (this.outputCst === true) {\n      invokeRuleWithTry = /* @__PURE__ */ __name(function invokeRuleWithTry2(...args) {\n        try {\n          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n          impl.apply(this, args);\n          const cst = this.CST_STACK[this.CST_STACK.length - 1];\n          this.cstPostRule(cst);\n          return cst;\n        } catch (e) {\n          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n        } finally {\n          this.ruleFinallyStateUpdate();\n        }\n      }, \"invokeRuleWithTry\");\n    } else {\n      invokeRuleWithTry = /* @__PURE__ */ __name(function invokeRuleWithTryCst(...args) {\n        try {\n          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n          return impl.apply(this, args);\n        } catch (e) {\n          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n        } finally {\n          this.ruleFinallyStateUpdate();\n        }\n      }, \"invokeRuleWithTryCst\");\n    }\n    const wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl });\n    return wrappedGrammarRule;\n  }\n  invokeRuleCatch(e, resyncEnabledConfig, recoveryValueFunc) {\n    const isFirstInvokedRule = this.RULE_STACK.length === 1;\n    const reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n    if (isRecognitionException(e)) {\n      const recogError = e;\n      if (reSyncEnabled) {\n        const reSyncTokType = this.findReSyncTokenType();\n        if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n          recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n          if (this.outputCst) {\n            const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            return partialCstResult;\n          } else {\n            return recoveryValueFunc(e);\n          }\n        } else {\n          if (this.outputCst) {\n            const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            recogError.partialCstResult = partialCstResult;\n          }\n          throw recogError;\n        }\n      } else if (isFirstInvokedRule) {\n        this.moveToTerminatedState();\n        return recoveryValueFunc(e);\n      } else {\n        throw recogError;\n      }\n    } else {\n      throw e;\n    }\n  }\n  // Implementation of parsing DSL\n  optionInternal(actionORMethodDef, occurrence) {\n    const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n    return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n  }\n  optionInternalLogic(actionORMethodDef, occurrence, key) {\n    let lookAheadFunc = this.getLaFuncFromCache(key);\n    let action;\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      const predicate = actionORMethodDef.GATE;\n      if (predicate !== void 0) {\n        const orgLookaheadFunction = lookAheadFunc;\n        lookAheadFunc = /* @__PURE__ */ __name(() => {\n          return predicate.call(this) && orgLookaheadFunction.call(this);\n        }, \"lookAheadFunc\");\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n    if (lookAheadFunc.call(this) === true) {\n      return action.call(this);\n    }\n    return void 0;\n  }\n  atLeastOneInternal(prodOccurrence, actionORMethodDef) {\n    const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);\n    return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  }\n  atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key) {\n    let lookAheadFunc = this.getLaFuncFromCache(key);\n    let action;\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      const predicate = actionORMethodDef.GATE;\n      if (predicate !== void 0) {\n        const orgLookaheadFunction = lookAheadFunc;\n        lookAheadFunc = /* @__PURE__ */ __name(() => {\n          return predicate.call(this) && orgLookaheadFunction.call(this);\n        }, \"lookAheadFunc\");\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n    if (lookAheadFunc.call(this) === true) {\n      let notStuck = this.doSingleRepetition(action);\n      while (lookAheadFunc.call(this) === true && notStuck === true) {\n        notStuck = this.doSingleRepetition(action);\n      }\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n    }\n    this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, AT_LEAST_ONE_IDX, prodOccurrence, NextTerminalAfterAtLeastOneWalker);\n  }\n  atLeastOneSepFirstInternal(prodOccurrence, options) {\n    const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n    this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n  }\n  atLeastOneSepFirstInternalLogic(prodOccurrence, options, key) {\n    const action = options.DEF;\n    const separator = options.SEP;\n    const firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n    if (firstIterationLookaheadFunc.call(this) === true) {\n      action.call(this);\n      const separatorLookAheadFunc = /* @__PURE__ */ __name(() => {\n        return this.tokenMatcher(this.LA(1), separator);\n      }, \"separatorLookAheadFunc\");\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        this.CONSUME(separator);\n        action.call(this);\n      }\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n        prodOccurrence,\n        separator,\n        separatorLookAheadFunc,\n        action,\n        NextTerminalAfterAtLeastOneSepWalker\n      ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, NextTerminalAfterAtLeastOneSepWalker);\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n    }\n  }\n  manyInternal(prodOccurrence, actionORMethodDef) {\n    const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n    return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  }\n  manyInternalLogic(prodOccurrence, actionORMethodDef, key) {\n    let lookaheadFunction = this.getLaFuncFromCache(key);\n    let action;\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      const predicate = actionORMethodDef.GATE;\n      if (predicate !== void 0) {\n        const orgLookaheadFunction = lookaheadFunction;\n        lookaheadFunction = /* @__PURE__ */ __name(() => {\n          return predicate.call(this) && orgLookaheadFunction.call(this);\n        }, \"lookaheadFunction\");\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n    let notStuck = true;\n    while (lookaheadFunction.call(this) === true && notStuck === true) {\n      notStuck = this.doSingleRepetition(action);\n    }\n    this.attemptInRepetitionRecovery(\n      this.manyInternal,\n      [prodOccurrence, actionORMethodDef],\n      lookaheadFunction,\n      MANY_IDX,\n      prodOccurrence,\n      NextTerminalAfterManyWalker,\n      // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n      // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n      // An infinite loop cannot occur as:\n      // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n      // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n      notStuck\n    );\n  }\n  manySepFirstInternal(prodOccurrence, options) {\n    const laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);\n    this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n  }\n  manySepFirstInternalLogic(prodOccurrence, options, key) {\n    const action = options.DEF;\n    const separator = options.SEP;\n    const firstIterationLaFunc = this.getLaFuncFromCache(key);\n    if (firstIterationLaFunc.call(this) === true) {\n      action.call(this);\n      const separatorLookAheadFunc = /* @__PURE__ */ __name(() => {\n        return this.tokenMatcher(this.LA(1), separator);\n      }, \"separatorLookAheadFunc\");\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        this.CONSUME(separator);\n        action.call(this);\n      }\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n        prodOccurrence,\n        separator,\n        separatorLookAheadFunc,\n        action,\n        NextTerminalAfterManySepWalker\n      ], separatorLookAheadFunc, MANY_SEP_IDX, prodOccurrence, NextTerminalAfterManySepWalker);\n    }\n  }\n  repetitionSepSecondInternal(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n    while (separatorLookAheadFunc()) {\n      this.CONSUME(separator);\n      action.call(this);\n    }\n    this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n      prodOccurrence,\n      separator,\n      separatorLookAheadFunc,\n      action,\n      nextTerminalAfterWalker\n    ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n  }\n  doSingleRepetition(action) {\n    const beforeIteration = this.getLexerPosition();\n    action.call(this);\n    const afterIteration = this.getLexerPosition();\n    return afterIteration > beforeIteration;\n  }\n  orInternal(altsOrOpts, occurrence) {\n    const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n    const alts = isArray_default(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n    const laFunc = this.getLaFuncFromCache(laKey);\n    const altIdxToTake = laFunc.call(this, alts);\n    if (altIdxToTake !== void 0) {\n      const chosenAlternative = alts[altIdxToTake];\n      return chosenAlternative.ALT.call(this);\n    }\n    this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n  }\n  ruleFinallyStateUpdate() {\n    this.RULE_STACK.pop();\n    this.RULE_OCCURRENCE_STACK.pop();\n    this.cstFinallyStateUpdate();\n    if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n      const firstRedundantTok = this.LA(1);\n      const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n        firstRedundant: firstRedundantTok,\n        ruleName: this.getCurrRuleFullName()\n      });\n      this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok));\n    }\n  }\n  subruleInternal(ruleToCall, idx, options) {\n    let ruleResult;\n    try {\n      const args = options !== void 0 ? options.ARGS : void 0;\n      this.subruleIdx = idx;\n      ruleResult = ruleToCall.apply(this, args);\n      this.cstPostNonTerminal(ruleResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleToCall.ruleName);\n      return ruleResult;\n    } catch (e) {\n      throw this.subruleInternalError(e, options, ruleToCall.ruleName);\n    }\n  }\n  subruleInternalError(e, options, ruleName) {\n    if (isRecognitionException(e) && e.partialCstResult !== void 0) {\n      this.cstPostNonTerminal(e.partialCstResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleName);\n      delete e.partialCstResult;\n    }\n    throw e;\n  }\n  consumeInternal(tokType, idx, options) {\n    let consumedToken;\n    try {\n      const nextToken = this.LA(1);\n      if (this.tokenMatcher(nextToken, tokType) === true) {\n        this.consumeToken();\n        consumedToken = nextToken;\n      } else {\n        this.consumeInternalError(tokType, nextToken, options);\n      }\n    } catch (eFromConsumption) {\n      consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n    }\n    this.cstPostTerminal(options !== void 0 && options.LABEL !== void 0 ? options.LABEL : tokType.name, consumedToken);\n    return consumedToken;\n  }\n  consumeInternalError(tokType, nextToken, options) {\n    let msg;\n    const previousToken = this.LA(0);\n    if (options !== void 0 && options.ERR_MSG) {\n      msg = options.ERR_MSG;\n    } else {\n      msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: tokType,\n        actual: nextToken,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      });\n    }\n    throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken));\n  }\n  consumeInternalRecovery(tokType, idx, eFromConsumption) {\n    if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n    eFromConsumption.name === \"MismatchedTokenException\" && !this.isBackTracking()) {\n      const follows = this.getFollowsForInRuleRecovery(tokType, idx);\n      try {\n        return this.tryInRuleRecovery(tokType, follows);\n      } catch (eFromInRuleRecovery) {\n        if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n          throw eFromConsumption;\n        } else {\n          throw eFromInRuleRecovery;\n        }\n      }\n    } else {\n      throw eFromConsumption;\n    }\n  }\n  saveRecogState() {\n    const savedErrors = this.errors;\n    const savedRuleStack = clone_default(this.RULE_STACK);\n    return {\n      errors: savedErrors,\n      lexerState: this.exportLexerState(),\n      RULE_STACK: savedRuleStack,\n      CST_STACK: this.CST_STACK\n    };\n  }\n  reloadRecogState(newState2) {\n    this.errors = newState2.errors;\n    this.importLexerState(newState2.lexerState);\n    this.RULE_STACK = newState2.RULE_STACK;\n  }\n  ruleInvocationStateUpdate(shortName, fullName, idxInCallingRule) {\n    this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n    this.RULE_STACK.push(shortName);\n    this.cstInvocationStateUpdate(fullName);\n  }\n  isBackTracking() {\n    return this.isBackTrackingStack.length !== 0;\n  }\n  getCurrRuleFullName() {\n    const shortName = this.getLastExplicitRuleShortName();\n    return this.shortRuleNameToFull[shortName];\n  }\n  shortRuleNameToFullName(shortName) {\n    return this.shortRuleNameToFull[shortName];\n  }\n  isAtEndOfInput() {\n    return this.tokenMatcher(this.LA(1), EOF);\n  }\n  reset() {\n    this.resetLexerState();\n    this.subruleIdx = 0;\n    this.isBackTrackingStack = [];\n    this.errors = [];\n    this.RULE_STACK = [];\n    this.CST_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n  }\n};\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js\nvar ErrorHandler = class {\n  static {\n    __name(this, \"ErrorHandler\");\n  }\n  initErrorHandler(config) {\n    this._errors = [];\n    this.errorMessageProvider = has_default(config, \"errorMessageProvider\") ? config.errorMessageProvider : DEFAULT_PARSER_CONFIG.errorMessageProvider;\n  }\n  SAVE_ERROR(error) {\n    if (isRecognitionException(error)) {\n      error.context = {\n        ruleStack: this.getHumanReadableRuleStack(),\n        ruleOccurrenceStack: clone_default(this.RULE_OCCURRENCE_STACK)\n      };\n      this._errors.push(error);\n      return error;\n    } else {\n      throw Error(\"Trying to save an Error which is not a RecognitionException\");\n    }\n  }\n  get errors() {\n    return clone_default(this._errors);\n  }\n  set errors(newErrors) {\n    this._errors = newErrors;\n  }\n  // TODO: consider caching the error message computed information\n  raiseEarlyExitException(occurrence, prodType, userDefinedErrMsg) {\n    const ruleName = this.getCurrRuleFullName();\n    const ruleGrammar = this.getGAstProductions()[ruleName];\n    const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);\n    const insideProdPaths = lookAheadPathsPerAlternative[0];\n    const actualTokens = [];\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n    const msg = this.errorMessageProvider.buildEarlyExitMessage({\n      expectedIterationPaths: insideProdPaths,\n      actual: actualTokens,\n      previous: this.LA(0),\n      customUserDescription: userDefinedErrMsg,\n      ruleName\n    });\n    throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));\n  }\n  // TODO: consider caching the error message computed information\n  raiseNoAltException(occurrence, errMsgTypes) {\n    const ruleName = this.getCurrRuleFullName();\n    const ruleGrammar = this.getGAstProductions()[ruleName];\n    const lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);\n    const actualTokens = [];\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n    const previousToken = this.LA(0);\n    const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n      expectedPathsPerAlt: lookAheadPathsPerAlternative,\n      actual: actualTokens,\n      previous: previousToken,\n      customUserDescription: errMsgTypes,\n      ruleName: this.getCurrRuleFullName()\n    });\n    throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken));\n  }\n};\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js\nvar ContentAssist = class {\n  static {\n    __name(this, \"ContentAssist\");\n  }\n  initContentAssist() {\n  }\n  computeContentAssist(startRuleName, precedingInput) {\n    const startRuleGast = this.gastProductionsCache[startRuleName];\n    if (isUndefined_default(startRuleGast)) {\n      throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`);\n    }\n    return nextPossibleTokensAfter([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);\n  }\n  // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n  // TODO: should this be more explicitly part of the public API?\n  getNextPossibleTokenTypes(grammarPath) {\n    const topRuleName = head_default(grammarPath.ruleStack);\n    const gastProductions = this.getGAstProductions();\n    const topProduction = gastProductions[topRuleName];\n    const nextPossibleTokenTypes = new NextAfterTokenWalker(topProduction, grammarPath).startWalking();\n    return nextPossibleTokenTypes;\n  }\n};\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js\nvar RECORDING_NULL_OBJECT = {\n  description: \"This Object indicates the Parser is during Recording Phase\"\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nvar HANDLE_SEPARATOR = true;\nvar MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;\nvar RFT = createToken({ name: \"RECORDING_PHASE_TOKEN\", pattern: Lexer.NA });\naugmentTokenTypes([RFT]);\nvar RECORDING_PHASE_TOKEN = createTokenInstance(\n  RFT,\n  \"This IToken indicates the Parser is in Recording Phase\\n\tSee: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n  // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1\n);\nObject.freeze(RECORDING_PHASE_TOKEN);\nvar RECORDING_PHASE_CSTNODE = {\n  name: \"This CSTNode indicates the Parser is in Recording Phase\\n\tSee: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  children: {}\n};\nvar GastRecorder = class {\n  static {\n    __name(this, \"GastRecorder\");\n  }\n  initGastRecorder(config) {\n    this.recordingProdStack = [];\n    this.RECORDING_PHASE = false;\n  }\n  enableRecording() {\n    this.RECORDING_PHASE = true;\n    this.TRACE_INIT(\"Enable Recording\", () => {\n      for (let i = 0; i < 10; i++) {\n        const idx = i > 0 ? i : \"\";\n        this[`CONSUME${idx}`] = function(arg1, arg2) {\n          return this.consumeInternalRecord(arg1, i, arg2);\n        };\n        this[`SUBRULE${idx}`] = function(arg1, arg2) {\n          return this.subruleInternalRecord(arg1, i, arg2);\n        };\n        this[`OPTION${idx}`] = function(arg1) {\n          return this.optionInternalRecord(arg1, i);\n        };\n        this[`OR${idx}`] = function(arg1) {\n          return this.orInternalRecord(arg1, i);\n        };\n        this[`MANY${idx}`] = function(arg1) {\n          this.manyInternalRecord(i, arg1);\n        };\n        this[`MANY_SEP${idx}`] = function(arg1) {\n          this.manySepFirstInternalRecord(i, arg1);\n        };\n        this[`AT_LEAST_ONE${idx}`] = function(arg1) {\n          this.atLeastOneInternalRecord(i, arg1);\n        };\n        this[`AT_LEAST_ONE_SEP${idx}`] = function(arg1) {\n          this.atLeastOneSepFirstInternalRecord(i, arg1);\n        };\n      }\n      this[`consume`] = function(idx, arg1, arg2) {\n        return this.consumeInternalRecord(arg1, idx, arg2);\n      };\n      this[`subrule`] = function(idx, arg1, arg2) {\n        return this.subruleInternalRecord(arg1, idx, arg2);\n      };\n      this[`option`] = function(idx, arg1) {\n        return this.optionInternalRecord(arg1, idx);\n      };\n      this[`or`] = function(idx, arg1) {\n        return this.orInternalRecord(arg1, idx);\n      };\n      this[`many`] = function(idx, arg1) {\n        this.manyInternalRecord(idx, arg1);\n      };\n      this[`atLeastOne`] = function(idx, arg1) {\n        this.atLeastOneInternalRecord(idx, arg1);\n      };\n      this.ACTION = this.ACTION_RECORD;\n      this.BACKTRACK = this.BACKTRACK_RECORD;\n      this.LA = this.LA_RECORD;\n    });\n  }\n  disableRecording() {\n    this.RECORDING_PHASE = false;\n    this.TRACE_INIT(\"Deleting Recording methods\", () => {\n      const that = this;\n      for (let i = 0; i < 10; i++) {\n        const idx = i > 0 ? i : \"\";\n        delete that[`CONSUME${idx}`];\n        delete that[`SUBRULE${idx}`];\n        delete that[`OPTION${idx}`];\n        delete that[`OR${idx}`];\n        delete that[`MANY${idx}`];\n        delete that[`MANY_SEP${idx}`];\n        delete that[`AT_LEAST_ONE${idx}`];\n        delete that[`AT_LEAST_ONE_SEP${idx}`];\n      }\n      delete that[`consume`];\n      delete that[`subrule`];\n      delete that[`option`];\n      delete that[`or`];\n      delete that[`many`];\n      delete that[`atLeastOne`];\n      delete that.ACTION;\n      delete that.BACKTRACK;\n      delete that.LA;\n    });\n  }\n  //   Parser methods are called inside an ACTION?\n  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n  // @ts-expect-error -- noop place holder\n  ACTION_RECORD(impl) {\n  }\n  // Executing backtracking logic will break our recording logic assumptions\n  BACKTRACK_RECORD(grammarRule, args) {\n    return () => true;\n  }\n  // LA is part of the official API and may be used for custom lookahead logic\n  // by end users who may forget to wrap it in ACTION or inside a GATE\n  LA_RECORD(howMuch) {\n    return END_OF_FILE;\n  }\n  topLevelRuleRecord(name, def) {\n    try {\n      const newTopLevelRule = new Rule({ definition: [], name });\n      newTopLevelRule.name = name;\n      this.recordingProdStack.push(newTopLevelRule);\n      def.call(this);\n      this.recordingProdStack.pop();\n      return newTopLevelRule;\n    } catch (originalError) {\n      if (originalError.KNOWN_RECORDER_ERROR !== true) {\n        try {\n          originalError.message = originalError.message + '\\n\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\thttps://chevrotain.io/docs/guide/internals.html#grammar-recording';\n        } catch (mutabilityError) {\n          throw originalError;\n        }\n      }\n      throw originalError;\n    }\n  }\n  // Implementation of parsing DSL\n  optionInternalRecord(actionORMethodDef, occurrence) {\n    return recordProd.call(this, Option, actionORMethodDef, occurrence);\n  }\n  atLeastOneInternalRecord(occurrence, actionORMethodDef) {\n    recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);\n  }\n  atLeastOneSepFirstInternalRecord(occurrence, options) {\n    recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  }\n  manyInternalRecord(occurrence, actionORMethodDef) {\n    recordProd.call(this, Repetition, actionORMethodDef, occurrence);\n  }\n  manySepFirstInternalRecord(occurrence, options) {\n    recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  }\n  orInternalRecord(altsOrOpts, occurrence) {\n    return recordOrProd.call(this, altsOrOpts, occurrence);\n  }\n  subruleInternalRecord(ruleToCall, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n    if (!ruleToCall || has_default(ruleToCall, \"ruleName\") === false) {\n      const error = new Error(`<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid expecting a Parser method reference but got: <${JSON.stringify(ruleToCall)}>\n inside top level rule: <${this.recordingProdStack[0].name}>`);\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n    const prevProd = last_default(this.recordingProdStack);\n    const ruleName = ruleToCall.ruleName;\n    const newNoneTerminal = new NonTerminal({\n      idx: occurrence,\n      nonTerminalName: ruleName,\n      label: options === null || options === void 0 ? void 0 : options.LABEL,\n      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n      referencedRule: void 0\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;\n  }\n  consumeInternalRecord(tokType, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n    if (!hasShortKeyProperty(tokType)) {\n      const error = new Error(`<CONSUME${getIdxSuffix(occurrence)}> argument is invalid expecting a TokenType reference but got: <${JSON.stringify(tokType)}>\n inside top level rule: <${this.recordingProdStack[0].name}>`);\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n    const prevProd = last_default(this.recordingProdStack);\n    const newNoneTerminal = new Terminal({\n      idx: occurrence,\n      terminalType: tokType,\n      label: options === null || options === void 0 ? void 0 : options.LABEL\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return RECORDING_PHASE_TOKEN;\n  }\n};\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep = false) {\n  assertMethodIdxIsValid(occurrence);\n  const prevProd = last_default(this.recordingProdStack);\n  const grammarAction = isFunction_default(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n  const newProd = new prodConstructor({ definition: [], idx: occurrence });\n  if (handleSep) {\n    newProd.separator = mainProdArg.SEP;\n  }\n  if (has_default(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n  this.recordingProdStack.push(newProd);\n  grammarAction.call(this);\n  prevProd.definition.push(newProd);\n  this.recordingProdStack.pop();\n  return RECORDING_NULL_OBJECT;\n}\n__name(recordProd, \"recordProd\");\nfunction recordOrProd(mainProdArg, occurrence) {\n  assertMethodIdxIsValid(occurrence);\n  const prevProd = last_default(this.recordingProdStack);\n  const hasOptions = isArray_default(mainProdArg) === false;\n  const alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n  const newOrProd = new Alternation({\n    definition: [],\n    idx: occurrence,\n    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n  });\n  if (has_default(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n  const hasPredicates = some_default(alts, (currAlt) => isFunction_default(currAlt.GATE));\n  newOrProd.hasPredicates = hasPredicates;\n  prevProd.definition.push(newOrProd);\n  forEach_default(alts, (currAlt) => {\n    const currAltFlat = new Alternative({ definition: [] });\n    newOrProd.definition.push(currAltFlat);\n    if (has_default(currAlt, \"IGNORE_AMBIGUITIES\")) {\n      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;\n    } else if (has_default(currAlt, \"GATE\")) {\n      currAltFlat.ignoreAmbiguities = true;\n    }\n    this.recordingProdStack.push(currAltFlat);\n    currAlt.ALT.call(this);\n    this.recordingProdStack.pop();\n  });\n  return RECORDING_NULL_OBJECT;\n}\n__name(recordOrProd, \"recordOrProd\");\nfunction getIdxSuffix(idx) {\n  return idx === 0 ? \"\" : `${idx}`;\n}\n__name(getIdxSuffix, \"getIdxSuffix\");\nfunction assertMethodIdxIsValid(idx) {\n  if (idx < 0 || idx > MAX_METHOD_IDX) {\n    const error = new Error(\n      // The stack trace will contain all the needed details\n      `Invalid DSL Method idx value: <${idx}>\n\tIdx value must be a none negative value smaller than ${MAX_METHOD_IDX + 1}`\n    );\n    error.KNOWN_RECORDER_ERROR = true;\n    throw error;\n  }\n}\n__name(assertMethodIdxIsValid, \"assertMethodIdxIsValid\");\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js\nvar PerformanceTracer = class {\n  static {\n    __name(this, \"PerformanceTracer\");\n  }\n  initPerformanceTracer(config) {\n    if (has_default(config, \"traceInitPerf\")) {\n      const userTraceInitPerf = config.traceInitPerf;\n      const traceIsNumber = typeof userTraceInitPerf === \"number\";\n      this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity;\n      this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf;\n    } else {\n      this.traceInitMaxIdent = 0;\n      this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf;\n    }\n    this.traceInitIndent = -1;\n  }\n  TRACE_INIT(phaseDesc, phaseImpl) {\n    if (this.traceInitPerf === true) {\n      this.traceInitIndent++;\n      const indent = new Array(this.traceInitIndent + 1).join(\"\t\");\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        console.log(`${indent}--> <${phaseDesc}>`);\n      }\n      const { time, value } = timer(phaseImpl);\n      const traceMethod = time > 10 ? console.warn : console.log;\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n      }\n      this.traceInitIndent--;\n      return value;\n    } else {\n      return phaseImpl();\n    }\n  }\n};\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js\nfunction applyMixins(derivedCtor, baseCtors) {\n  baseCtors.forEach((baseCtor) => {\n    const baseProto = baseCtor.prototype;\n    Object.getOwnPropertyNames(baseProto).forEach((propName) => {\n      if (propName === \"constructor\") {\n        return;\n      }\n      const basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);\n      if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) {\n        Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);\n      } else {\n        derivedCtor.prototype[propName] = baseCtor.prototype[propName];\n      }\n    });\n  });\n}\n__name(applyMixins, \"applyMixins\");\n\n// ../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/lib/src/parse/parser/parser.js\nvar END_OF_FILE = createTokenInstance(EOF, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\nObject.freeze(END_OF_FILE);\nvar DEFAULT_PARSER_CONFIG = Object.freeze({\n  recoveryEnabled: false,\n  maxLookahead: 3,\n  dynamicTokensEnabled: false,\n  outputCst: true,\n  errorMessageProvider: defaultParserErrorProvider,\n  nodeLocationTracking: \"none\",\n  traceInitPerf: false,\n  skipValidations: false\n});\nvar DEFAULT_RULE_CONFIG = Object.freeze({\n  recoveryValueFunc: /* @__PURE__ */ __name(() => void 0, \"recoveryValueFunc\"),\n  resyncEnabled: true\n});\nvar ParserDefinitionErrorType;\n(function(ParserDefinitionErrorType2) {\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"INVALID_RULE_NAME\"] = 0] = \"INVALID_RULE_NAME\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"DUPLICATE_RULE_NAME\"] = 1] = \"DUPLICATE_RULE_NAME\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"INVALID_RULE_OVERRIDE\"] = 2] = \"INVALID_RULE_OVERRIDE\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"DUPLICATE_PRODUCTIONS\"] = 3] = \"DUPLICATE_PRODUCTIONS\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"UNRESOLVED_SUBRULE_REF\"] = 4] = \"UNRESOLVED_SUBRULE_REF\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"LEFT_RECURSION\"] = 5] = \"LEFT_RECURSION\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"NONE_LAST_EMPTY_ALT\"] = 6] = \"NONE_LAST_EMPTY_ALT\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"AMBIGUOUS_ALTS\"] = 7] = \"AMBIGUOUS_ALTS\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"CONFLICT_TOKENS_RULES_NAMESPACE\"] = 8] = \"CONFLICT_TOKENS_RULES_NAMESPACE\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"INVALID_TOKEN_NAME\"] = 9] = \"INVALID_TOKEN_NAME\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"NO_NON_EMPTY_LOOKAHEAD\"] = 10] = \"NO_NON_EMPTY_LOOKAHEAD\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"AMBIGUOUS_PREFIX_ALTS\"] = 11] = \"AMBIGUOUS_PREFIX_ALTS\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"TOO_MANY_ALTS\"] = 12] = \"TOO_MANY_ALTS\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"CUSTOM_LOOKAHEAD_VALIDATION\"] = 13] = \"CUSTOM_LOOKAHEAD_VALIDATION\";\n})(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}));\nfunction EMPTY_ALT(value = void 0) {\n  return function() {\n    return value;\n  };\n}\n__name(EMPTY_ALT, \"EMPTY_ALT\");\nvar Parser = class _Parser {\n  static {\n    __name(this, \"Parser\");\n  }\n  /**\n   *  @deprecated use the **instance** method with the same name instead\n   */\n  static performSelfAnalysis(parserInstance) {\n    throw Error(\"The **static** `performSelfAnalysis` method has been deprecated.\t\\nUse the **instance** method with the same name instead.\");\n  }\n  performSelfAnalysis() {\n    this.TRACE_INIT(\"performSelfAnalysis\", () => {\n      let defErrorsMsgs;\n      this.selfAnalysisDone = true;\n      const className = this.className;\n      this.TRACE_INIT(\"toFastProps\", () => {\n        toFastProperties(this);\n      });\n      this.TRACE_INIT(\"Grammar Recording\", () => {\n        try {\n          this.enableRecording();\n          forEach_default(this.definedRulesNames, (currRuleName) => {\n            const wrappedRule = this[currRuleName];\n            const originalGrammarAction = wrappedRule[\"originalGrammarAction\"];\n            let recordedRuleGast;\n            this.TRACE_INIT(`${currRuleName} Rule`, () => {\n              recordedRuleGast = this.topLevelRuleRecord(currRuleName, originalGrammarAction);\n            });\n            this.gastProductionsCache[currRuleName] = recordedRuleGast;\n          });\n        } finally {\n          this.disableRecording();\n        }\n      });\n      let resolverErrors = [];\n      this.TRACE_INIT(\"Grammar Resolving\", () => {\n        resolverErrors = resolveGrammar2({\n          rules: values_default(this.gastProductionsCache)\n        });\n        this.definitionErrors = this.definitionErrors.concat(resolverErrors);\n      });\n      this.TRACE_INIT(\"Grammar Validations\", () => {\n        if (isEmpty_default(resolverErrors) && this.skipValidations === false) {\n          const validationErrors = validateGrammar2({\n            rules: values_default(this.gastProductionsCache),\n            tokenTypes: values_default(this.tokensMap),\n            errMsgProvider: defaultGrammarValidatorErrorProvider,\n            grammarName: className\n          });\n          const lookaheadValidationErrors = validateLookahead({\n            lookaheadStrategy: this.lookaheadStrategy,\n            rules: values_default(this.gastProductionsCache),\n            tokenTypes: values_default(this.tokensMap),\n            grammarName: className\n          });\n          this.definitionErrors = this.definitionErrors.concat(validationErrors, lookaheadValidationErrors);\n        }\n      });\n      if (isEmpty_default(this.definitionErrors)) {\n        if (this.recoveryEnabled) {\n          this.TRACE_INIT(\"computeAllProdsFollows\", () => {\n            const allFollows = computeAllProdsFollows(values_default(this.gastProductionsCache));\n            this.resyncFollows = allFollows;\n          });\n        }\n        this.TRACE_INIT(\"ComputeLookaheadFunctions\", () => {\n          var _a, _b;\n          (_b = (_a = this.lookaheadStrategy).initialize) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            rules: values_default(this.gastProductionsCache)\n          });\n          this.preComputeLookaheadFunctions(values_default(this.gastProductionsCache));\n        });\n      }\n      if (!_Parser.DEFER_DEFINITION_ERRORS_HANDLING && !isEmpty_default(this.definitionErrors)) {\n        defErrorsMsgs = map_default(this.definitionErrors, (defError) => defError.message);\n        throw new Error(`Parser Definition Errors detected:\n ${defErrorsMsgs.join(\"\\n-------------------------------\\n\")}`);\n      }\n    });\n  }\n  constructor(tokenVocabulary, config) {\n    this.definitionErrors = [];\n    this.selfAnalysisDone = false;\n    const that = this;\n    that.initErrorHandler(config);\n    that.initLexerAdapter();\n    that.initLooksAhead(config);\n    that.initRecognizerEngine(tokenVocabulary, config);\n    that.initRecoverable(config);\n    that.initTreeBuilder(config);\n    that.initContentAssist();\n    that.initGastRecorder(config);\n    that.initPerformanceTracer(config);\n    if (has_default(config, \"ignoredIssues\")) {\n      throw new Error(\"The <ignoredIssues> IParserConfig property has been deprecated.\\n\tPlease use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\tSee: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\tFor further details.\");\n    }\n    this.skipValidations = has_default(config, \"skipValidations\") ? config.skipValidations : DEFAULT_PARSER_CONFIG.skipValidations;\n  }\n};\nParser.DEFER_DEFINITION_ERRORS_HANDLING = false;\napplyMixins(Parser, [\n  Recoverable,\n  LooksAhead,\n  TreeBuilder,\n  LexerAdapter,\n  RecognizerEngine,\n  RecognizerApi,\n  ErrorHandler,\n  ContentAssist,\n  GastRecorder,\n  PerformanceTracer\n]);\nvar EmbeddedActionsParser = class extends Parser {\n  static {\n    __name(this, \"EmbeddedActionsParser\");\n  }\n  constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {\n    const configClone = clone_default(config);\n    configClone.outputCst = false;\n    super(tokenVocabulary, configClone);\n  }\n};\n\n// ../../node_modules/.pnpm/chevrotain-allstar@0.3.1_chevrotain@11.0.3/node_modules/chevrotain-allstar/lib/atn.js\nfunction buildATNKey(rule, type, occurrence) {\n  return `${rule.name}_${type}_${occurrence}`;\n}\n__name(buildATNKey, \"buildATNKey\");\nvar ATN_BASIC = 1;\nvar ATN_RULE_START = 2;\nvar ATN_PLUS_BLOCK_START = 4;\nvar ATN_STAR_BLOCK_START = 5;\nvar ATN_RULE_STOP = 7;\nvar ATN_BLOCK_END = 8;\nvar ATN_STAR_LOOP_BACK = 9;\nvar ATN_STAR_LOOP_ENTRY = 10;\nvar ATN_PLUS_LOOP_BACK = 11;\nvar ATN_LOOP_END = 12;\nvar AbstractTransition = class {\n  static {\n    __name(this, \"AbstractTransition\");\n  }\n  constructor(target) {\n    this.target = target;\n  }\n  isEpsilon() {\n    return false;\n  }\n};\nvar AtomTransition = class extends AbstractTransition {\n  static {\n    __name(this, \"AtomTransition\");\n  }\n  constructor(target, tokenType) {\n    super(target);\n    this.tokenType = tokenType;\n  }\n};\nvar EpsilonTransition = class extends AbstractTransition {\n  static {\n    __name(this, \"EpsilonTransition\");\n  }\n  constructor(target) {\n    super(target);\n  }\n  isEpsilon() {\n    return true;\n  }\n};\nvar RuleTransition = class extends AbstractTransition {\n  static {\n    __name(this, \"RuleTransition\");\n  }\n  constructor(ruleStart, rule, followState) {\n    super(ruleStart);\n    this.rule = rule;\n    this.followState = followState;\n  }\n  isEpsilon() {\n    return true;\n  }\n};\nfunction createATN(rules) {\n  const atn = {\n    decisionMap: {},\n    decisionStates: [],\n    ruleToStartState: /* @__PURE__ */ new Map(),\n    ruleToStopState: /* @__PURE__ */ new Map(),\n    states: []\n  };\n  createRuleStartAndStopATNStates(atn, rules);\n  const ruleLength = rules.length;\n  for (let i = 0; i < ruleLength; i++) {\n    const rule = rules[i];\n    const ruleBlock = block(atn, rule, rule);\n    if (ruleBlock === void 0) {\n      continue;\n    }\n    buildRuleHandle(atn, rule, ruleBlock);\n  }\n  return atn;\n}\n__name(createATN, \"createATN\");\nfunction createRuleStartAndStopATNStates(atn, rules) {\n  const ruleLength = rules.length;\n  for (let i = 0; i < ruleLength; i++) {\n    const rule = rules[i];\n    const start = newState(atn, rule, void 0, {\n      type: ATN_RULE_START\n    });\n    const stop = newState(atn, rule, void 0, {\n      type: ATN_RULE_STOP\n    });\n    start.stop = stop;\n    atn.ruleToStartState.set(rule, start);\n    atn.ruleToStopState.set(rule, stop);\n  }\n}\n__name(createRuleStartAndStopATNStates, \"createRuleStartAndStopATNStates\");\nfunction atom(atn, rule, production) {\n  if (production instanceof Terminal) {\n    return tokenRef(atn, rule, production.terminalType, production);\n  } else if (production instanceof NonTerminal) {\n    return ruleRef(atn, rule, production);\n  } else if (production instanceof Alternation) {\n    return alternation(atn, rule, production);\n  } else if (production instanceof Option) {\n    return option(atn, rule, production);\n  } else if (production instanceof Repetition) {\n    return repetition(atn, rule, production);\n  } else if (production instanceof RepetitionWithSeparator) {\n    return repetitionSep(atn, rule, production);\n  } else if (production instanceof RepetitionMandatory) {\n    return repetitionMandatory(atn, rule, production);\n  } else if (production instanceof RepetitionMandatoryWithSeparator) {\n    return repetitionMandatorySep(atn, rule, production);\n  } else {\n    return block(atn, rule, production);\n  }\n}\n__name(atom, \"atom\");\nfunction repetition(atn, rule, repetition2) {\n  const starState = newState(atn, rule, repetition2, {\n    type: ATN_STAR_BLOCK_START\n  });\n  defineDecisionState(atn, starState);\n  const handle = makeAlts(atn, rule, starState, repetition2, block(atn, rule, repetition2));\n  return star(atn, rule, repetition2, handle);\n}\n__name(repetition, \"repetition\");\nfunction repetitionSep(atn, rule, repetition2) {\n  const starState = newState(atn, rule, repetition2, {\n    type: ATN_STAR_BLOCK_START\n  });\n  defineDecisionState(atn, starState);\n  const handle = makeAlts(atn, rule, starState, repetition2, block(atn, rule, repetition2));\n  const sep = tokenRef(atn, rule, repetition2.separator, repetition2);\n  return star(atn, rule, repetition2, handle, sep);\n}\n__name(repetitionSep, \"repetitionSep\");\nfunction repetitionMandatory(atn, rule, repetition2) {\n  const plusState = newState(atn, rule, repetition2, {\n    type: ATN_PLUS_BLOCK_START\n  });\n  defineDecisionState(atn, plusState);\n  const handle = makeAlts(atn, rule, plusState, repetition2, block(atn, rule, repetition2));\n  return plus(atn, rule, repetition2, handle);\n}\n__name(repetitionMandatory, \"repetitionMandatory\");\nfunction repetitionMandatorySep(atn, rule, repetition2) {\n  const plusState = newState(atn, rule, repetition2, {\n    type: ATN_PLUS_BLOCK_START\n  });\n  defineDecisionState(atn, plusState);\n  const handle = makeAlts(atn, rule, plusState, repetition2, block(atn, rule, repetition2));\n  const sep = tokenRef(atn, rule, repetition2.separator, repetition2);\n  return plus(atn, rule, repetition2, handle, sep);\n}\n__name(repetitionMandatorySep, \"repetitionMandatorySep\");\nfunction alternation(atn, rule, alternation2) {\n  const start = newState(atn, rule, alternation2, {\n    type: ATN_BASIC\n  });\n  defineDecisionState(atn, start);\n  const alts = map_default(alternation2.definition, (e) => atom(atn, rule, e));\n  const handle = makeAlts(atn, rule, start, alternation2, ...alts);\n  return handle;\n}\n__name(alternation, \"alternation\");\nfunction option(atn, rule, option2) {\n  const start = newState(atn, rule, option2, {\n    type: ATN_BASIC\n  });\n  defineDecisionState(atn, start);\n  const handle = makeAlts(atn, rule, start, option2, block(atn, rule, option2));\n  return optional(atn, rule, option2, handle);\n}\n__name(option, \"option\");\nfunction block(atn, rule, block2) {\n  const handles = filter_default(map_default(block2.definition, (e) => atom(atn, rule, e)), (e) => e !== void 0);\n  if (handles.length === 1) {\n    return handles[0];\n  } else if (handles.length === 0) {\n    return void 0;\n  } else {\n    return makeBlock(atn, handles);\n  }\n}\n__name(block, \"block\");\nfunction plus(atn, rule, plus2, handle, sep) {\n  const blkStart = handle.left;\n  const blkEnd = handle.right;\n  const loop = newState(atn, rule, plus2, {\n    type: ATN_PLUS_LOOP_BACK\n  });\n  defineDecisionState(atn, loop);\n  const end = newState(atn, rule, plus2, {\n    type: ATN_LOOP_END\n  });\n  blkStart.loopback = loop;\n  end.loopback = loop;\n  atn.decisionMap[buildATNKey(rule, sep ? \"RepetitionMandatoryWithSeparator\" : \"RepetitionMandatory\", plus2.idx)] = loop;\n  epsilon(blkEnd, loop);\n  if (sep === void 0) {\n    epsilon(loop, blkStart);\n    epsilon(loop, end);\n  } else {\n    epsilon(loop, end);\n    epsilon(loop, sep.left);\n    epsilon(sep.right, blkStart);\n  }\n  return {\n    left: blkStart,\n    right: end\n  };\n}\n__name(plus, \"plus\");\nfunction star(atn, rule, star2, handle, sep) {\n  const start = handle.left;\n  const end = handle.right;\n  const entry = newState(atn, rule, star2, {\n    type: ATN_STAR_LOOP_ENTRY\n  });\n  defineDecisionState(atn, entry);\n  const loopEnd = newState(atn, rule, star2, {\n    type: ATN_LOOP_END\n  });\n  const loop = newState(atn, rule, star2, {\n    type: ATN_STAR_LOOP_BACK\n  });\n  entry.loopback = loop;\n  loopEnd.loopback = loop;\n  epsilon(entry, start);\n  epsilon(entry, loopEnd);\n  epsilon(end, loop);\n  if (sep !== void 0) {\n    epsilon(loop, loopEnd);\n    epsilon(loop, sep.left);\n    epsilon(sep.right, start);\n  } else {\n    epsilon(loop, entry);\n  }\n  atn.decisionMap[buildATNKey(rule, sep ? \"RepetitionWithSeparator\" : \"Repetition\", star2.idx)] = entry;\n  return {\n    left: entry,\n    right: loopEnd\n  };\n}\n__name(star, \"star\");\nfunction optional(atn, rule, optional2, handle) {\n  const start = handle.left;\n  const end = handle.right;\n  epsilon(start, end);\n  atn.decisionMap[buildATNKey(rule, \"Option\", optional2.idx)] = start;\n  return handle;\n}\n__name(optional, \"optional\");\nfunction defineDecisionState(atn, state) {\n  atn.decisionStates.push(state);\n  state.decision = atn.decisionStates.length - 1;\n  return state.decision;\n}\n__name(defineDecisionState, \"defineDecisionState\");\nfunction makeAlts(atn, rule, start, production, ...alts) {\n  const end = newState(atn, rule, production, {\n    type: ATN_BLOCK_END,\n    start\n  });\n  start.end = end;\n  for (const alt of alts) {\n    if (alt !== void 0) {\n      epsilon(start, alt.left);\n      epsilon(alt.right, end);\n    } else {\n      epsilon(start, end);\n    }\n  }\n  const handle = {\n    left: start,\n    right: end\n  };\n  atn.decisionMap[buildATNKey(rule, getProdType2(production), production.idx)] = start;\n  return handle;\n}\n__name(makeAlts, \"makeAlts\");\nfunction getProdType2(production) {\n  if (production instanceof Alternation) {\n    return \"Alternation\";\n  } else if (production instanceof Option) {\n    return \"Option\";\n  } else if (production instanceof Repetition) {\n    return \"Repetition\";\n  } else if (production instanceof RepetitionWithSeparator) {\n    return \"RepetitionWithSeparator\";\n  } else if (production instanceof RepetitionMandatory) {\n    return \"RepetitionMandatory\";\n  } else if (production instanceof RepetitionMandatoryWithSeparator) {\n    return \"RepetitionMandatoryWithSeparator\";\n  } else {\n    throw new Error(\"Invalid production type encountered\");\n  }\n}\n__name(getProdType2, \"getProdType\");\nfunction makeBlock(atn, alts) {\n  const altsLength = alts.length;\n  for (let i = 0; i < altsLength - 1; i++) {\n    const handle = alts[i];\n    let transition;\n    if (handle.left.transitions.length === 1) {\n      transition = handle.left.transitions[0];\n    }\n    const isRuleTransition = transition instanceof RuleTransition;\n    const ruleTransition = transition;\n    const next = alts[i + 1].left;\n    if (handle.left.type === ATN_BASIC && handle.right.type === ATN_BASIC && transition !== void 0 && (isRuleTransition && ruleTransition.followState === handle.right || transition.target === handle.right)) {\n      if (isRuleTransition) {\n        ruleTransition.followState = next;\n      } else {\n        transition.target = next;\n      }\n      removeState(atn, handle.right);\n    } else {\n      epsilon(handle.right, next);\n    }\n  }\n  const first2 = alts[0];\n  const last = alts[altsLength - 1];\n  return {\n    left: first2.left,\n    right: last.right\n  };\n}\n__name(makeBlock, \"makeBlock\");\nfunction tokenRef(atn, rule, tokenType, production) {\n  const left = newState(atn, rule, production, {\n    type: ATN_BASIC\n  });\n  const right = newState(atn, rule, production, {\n    type: ATN_BASIC\n  });\n  addTransition(left, new AtomTransition(right, tokenType));\n  return {\n    left,\n    right\n  };\n}\n__name(tokenRef, \"tokenRef\");\nfunction ruleRef(atn, currentRule, nonTerminal) {\n  const rule = nonTerminal.referencedRule;\n  const start = atn.ruleToStartState.get(rule);\n  const left = newState(atn, currentRule, nonTerminal, {\n    type: ATN_BASIC\n  });\n  const right = newState(atn, currentRule, nonTerminal, {\n    type: ATN_BASIC\n  });\n  const call = new RuleTransition(start, rule, right);\n  addTransition(left, call);\n  return {\n    left,\n    right\n  };\n}\n__name(ruleRef, \"ruleRef\");\nfunction buildRuleHandle(atn, rule, block2) {\n  const start = atn.ruleToStartState.get(rule);\n  epsilon(start, block2.left);\n  const stop = atn.ruleToStopState.get(rule);\n  epsilon(block2.right, stop);\n  const handle = {\n    left: start,\n    right: stop\n  };\n  return handle;\n}\n__name(buildRuleHandle, \"buildRuleHandle\");\nfunction epsilon(a, b) {\n  const transition = new EpsilonTransition(b);\n  addTransition(a, transition);\n}\n__name(epsilon, \"epsilon\");\nfunction newState(atn, rule, production, partial) {\n  const t = Object.assign({\n    atn,\n    production,\n    epsilonOnlyTransitions: false,\n    rule,\n    transitions: [],\n    nextTokenWithinRule: [],\n    stateNumber: atn.states.length\n  }, partial);\n  atn.states.push(t);\n  return t;\n}\n__name(newState, \"newState\");\nfunction addTransition(state, transition) {\n  if (state.transitions.length === 0) {\n    state.epsilonOnlyTransitions = transition.isEpsilon();\n  }\n  state.transitions.push(transition);\n}\n__name(addTransition, \"addTransition\");\nfunction removeState(atn, state) {\n  atn.states.splice(atn.states.indexOf(state), 1);\n}\n__name(removeState, \"removeState\");\n\n// ../../node_modules/.pnpm/chevrotain-allstar@0.3.1_chevrotain@11.0.3/node_modules/chevrotain-allstar/lib/dfa.js\nvar DFA_ERROR = {};\nvar ATNConfigSet = class {\n  static {\n    __name(this, \"ATNConfigSet\");\n  }\n  constructor() {\n    this.map = {};\n    this.configs = [];\n  }\n  get size() {\n    return this.configs.length;\n  }\n  finalize() {\n    this.map = {};\n  }\n  add(config) {\n    const key = getATNConfigKey(config);\n    if (!(key in this.map)) {\n      this.map[key] = this.configs.length;\n      this.configs.push(config);\n    }\n  }\n  get elements() {\n    return this.configs;\n  }\n  get alts() {\n    return map_default(this.configs, (e) => e.alt);\n  }\n  get key() {\n    let value = \"\";\n    for (const k in this.map) {\n      value += k + \":\";\n    }\n    return value;\n  }\n};\nfunction getATNConfigKey(config, alt = true) {\n  return `${alt ? `a${config.alt}` : \"\"}s${config.state.stateNumber}:${config.stack.map((e) => e.stateNumber.toString()).join(\"_\")}`;\n}\n__name(getATNConfigKey, \"getATNConfigKey\");\n\n// ../../node_modules/.pnpm/chevrotain-allstar@0.3.1_chevrotain@11.0.3/node_modules/chevrotain-allstar/lib/all-star-lookahead.js\nfunction createDFACache(startState, decision) {\n  const map = {};\n  return (predicateSet) => {\n    const key = predicateSet.toString();\n    let existing = map[key];\n    if (existing !== void 0) {\n      return existing;\n    } else {\n      existing = {\n        atnStartState: startState,\n        decision,\n        states: {}\n      };\n      map[key] = existing;\n      return existing;\n    }\n  };\n}\n__name(createDFACache, \"createDFACache\");\nvar PredicateSet = class {\n  static {\n    __name(this, \"PredicateSet\");\n  }\n  constructor() {\n    this.predicates = [];\n  }\n  is(index) {\n    return index >= this.predicates.length || this.predicates[index];\n  }\n  set(index, value) {\n    this.predicates[index] = value;\n  }\n  toString() {\n    let value = \"\";\n    const size = this.predicates.length;\n    for (let i = 0; i < size; i++) {\n      value += this.predicates[i] === true ? \"1\" : \"0\";\n    }\n    return value;\n  }\n};\nvar EMPTY_PREDICATES = new PredicateSet();\nvar LLStarLookaheadStrategy = class extends LLkLookaheadStrategy {\n  static {\n    __name(this, \"LLStarLookaheadStrategy\");\n  }\n  constructor(options) {\n    var _a;\n    super();\n    this.logging = (_a = options === null || options === void 0 ? void 0 : options.logging) !== null && _a !== void 0 ? _a : (message) => console.log(message);\n  }\n  initialize(options) {\n    this.atn = createATN(options.rules);\n    this.dfas = initATNSimulator(this.atn);\n  }\n  validateAmbiguousAlternationAlternatives() {\n    return [];\n  }\n  validateEmptyOrAlternatives() {\n    return [];\n  }\n  buildLookaheadForAlternation(options) {\n    const { prodOccurrence, rule, hasPredicates, dynamicTokensEnabled } = options;\n    const dfas = this.dfas;\n    const logging = this.logging;\n    const key = buildATNKey(rule, \"Alternation\", prodOccurrence);\n    const decisionState = this.atn.decisionMap[key];\n    const decisionIndex = decisionState.decision;\n    const partialAlts = map_default(getLookaheadPaths({\n      maxLookahead: 1,\n      occurrence: prodOccurrence,\n      prodType: \"Alternation\",\n      rule\n    }), (currAlt) => map_default(currAlt, (path) => path[0]));\n    if (isLL1Sequence(partialAlts, false) && !dynamicTokensEnabled) {\n      const choiceToAlt = reduce_default(partialAlts, (result, currAlt, idx) => {\n        forEach_default(currAlt, (currTokType) => {\n          if (currTokType) {\n            result[currTokType.tokenTypeIdx] = idx;\n            forEach_default(currTokType.categoryMatches, (currExtendingType) => {\n              result[currExtendingType] = idx;\n            });\n          }\n        });\n        return result;\n      }, {});\n      if (hasPredicates) {\n        return function(orAlts) {\n          var _a;\n          const nextToken = this.LA(1);\n          const prediction = choiceToAlt[nextToken.tokenTypeIdx];\n          if (orAlts !== void 0 && prediction !== void 0) {\n            const gate = (_a = orAlts[prediction]) === null || _a === void 0 ? void 0 : _a.GATE;\n            if (gate !== void 0 && gate.call(this) === false) {\n              return void 0;\n            }\n          }\n          return prediction;\n        };\n      } else {\n        return function() {\n          const nextToken = this.LA(1);\n          return choiceToAlt[nextToken.tokenTypeIdx];\n        };\n      }\n    } else if (hasPredicates) {\n      return function(orAlts) {\n        const predicates = new PredicateSet();\n        const length = orAlts === void 0 ? 0 : orAlts.length;\n        for (let i = 0; i < length; i++) {\n          const gate = orAlts === null || orAlts === void 0 ? void 0 : orAlts[i].GATE;\n          predicates.set(i, gate === void 0 || gate.call(this));\n        }\n        const result = adaptivePredict.call(this, dfas, decisionIndex, predicates, logging);\n        return typeof result === \"number\" ? result : void 0;\n      };\n    } else {\n      return function() {\n        const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);\n        return typeof result === \"number\" ? result : void 0;\n      };\n    }\n  }\n  buildLookaheadForOptional(options) {\n    const { prodOccurrence, rule, prodType, dynamicTokensEnabled } = options;\n    const dfas = this.dfas;\n    const logging = this.logging;\n    const key = buildATNKey(rule, prodType, prodOccurrence);\n    const decisionState = this.atn.decisionMap[key];\n    const decisionIndex = decisionState.decision;\n    const alts = map_default(getLookaheadPaths({\n      maxLookahead: 1,\n      occurrence: prodOccurrence,\n      prodType,\n      rule\n    }), (e) => {\n      return map_default(e, (g) => g[0]);\n    });\n    if (isLL1Sequence(alts) && alts[0][0] && !dynamicTokensEnabled) {\n      const alt = alts[0];\n      const singleTokensTypes = flatten_default(alt);\n      if (singleTokensTypes.length === 1 && isEmpty_default(singleTokensTypes[0].categoryMatches)) {\n        const expectedTokenType = singleTokensTypes[0];\n        const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;\n        return function() {\n          return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n        };\n      } else {\n        const choiceToAlt = reduce_default(singleTokensTypes, (result, currTokType) => {\n          if (currTokType !== void 0) {\n            result[currTokType.tokenTypeIdx] = true;\n            forEach_default(currTokType.categoryMatches, (currExtendingType) => {\n              result[currExtendingType] = true;\n            });\n          }\n          return result;\n        }, {});\n        return function() {\n          const nextToken = this.LA(1);\n          return choiceToAlt[nextToken.tokenTypeIdx] === true;\n        };\n      }\n    }\n    return function() {\n      const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);\n      return typeof result === \"object\" ? false : result === 0;\n    };\n  }\n};\nfunction isLL1Sequence(sequences, allowEmpty = true) {\n  const fullSet = /* @__PURE__ */ new Set();\n  for (const alt of sequences) {\n    const altSet = /* @__PURE__ */ new Set();\n    for (const tokType of alt) {\n      if (tokType === void 0) {\n        if (allowEmpty) {\n          break;\n        } else {\n          return false;\n        }\n      }\n      const indices = [tokType.tokenTypeIdx].concat(tokType.categoryMatches);\n      for (const index of indices) {\n        if (fullSet.has(index)) {\n          if (!altSet.has(index)) {\n            return false;\n          }\n        } else {\n          fullSet.add(index);\n          altSet.add(index);\n        }\n      }\n    }\n  }\n  return true;\n}\n__name(isLL1Sequence, \"isLL1Sequence\");\nfunction initATNSimulator(atn) {\n  const decisionLength = atn.decisionStates.length;\n  const decisionToDFA = Array(decisionLength);\n  for (let i = 0; i < decisionLength; i++) {\n    decisionToDFA[i] = createDFACache(atn.decisionStates[i], i);\n  }\n  return decisionToDFA;\n}\n__name(initATNSimulator, \"initATNSimulator\");\nfunction adaptivePredict(dfaCaches, decision, predicateSet, logging) {\n  const dfa = dfaCaches[decision](predicateSet);\n  let start = dfa.start;\n  if (start === void 0) {\n    const closure2 = computeStartState(dfa.atnStartState);\n    start = addDFAState(dfa, newDFAState(closure2));\n    dfa.start = start;\n  }\n  const alt = performLookahead.apply(this, [dfa, start, predicateSet, logging]);\n  return alt;\n}\n__name(adaptivePredict, \"adaptivePredict\");\nfunction performLookahead(dfa, s0, predicateSet, logging) {\n  let previousD = s0;\n  let i = 1;\n  const path = [];\n  let t = this.LA(i++);\n  while (true) {\n    let d = getExistingTargetState(previousD, t);\n    if (d === void 0) {\n      d = computeLookaheadTarget.apply(this, [dfa, previousD, t, i, predicateSet, logging]);\n    }\n    if (d === DFA_ERROR) {\n      return buildAdaptivePredictError(path, previousD, t);\n    }\n    if (d.isAcceptState === true) {\n      return d.prediction;\n    }\n    previousD = d;\n    path.push(t);\n    t = this.LA(i++);\n  }\n}\n__name(performLookahead, \"performLookahead\");\nfunction computeLookaheadTarget(dfa, previousD, token, lookahead, predicateSet, logging) {\n  const reach = computeReachSet(previousD.configs, token, predicateSet);\n  if (reach.size === 0) {\n    addDFAEdge(dfa, previousD, token, DFA_ERROR);\n    return DFA_ERROR;\n  }\n  let newState2 = newDFAState(reach);\n  const predictedAlt = getUniqueAlt(reach, predicateSet);\n  if (predictedAlt !== void 0) {\n    newState2.isAcceptState = true;\n    newState2.prediction = predictedAlt;\n    newState2.configs.uniqueAlt = predictedAlt;\n  } else if (hasConflictTerminatingPrediction(reach)) {\n    const prediction = min_default(reach.alts);\n    newState2.isAcceptState = true;\n    newState2.prediction = prediction;\n    newState2.configs.uniqueAlt = prediction;\n    reportLookaheadAmbiguity.apply(this, [dfa, lookahead, reach.alts, logging]);\n  }\n  newState2 = addDFAEdge(dfa, previousD, token, newState2);\n  return newState2;\n}\n__name(computeLookaheadTarget, \"computeLookaheadTarget\");\nfunction reportLookaheadAmbiguity(dfa, lookahead, ambiguityIndices, logging) {\n  const prefixPath = [];\n  for (let i = 1; i <= lookahead; i++) {\n    prefixPath.push(this.LA(i).tokenType);\n  }\n  const atnState = dfa.atnStartState;\n  const topLevelRule = atnState.rule;\n  const production = atnState.production;\n  const message = buildAmbiguityError({\n    topLevelRule,\n    ambiguityIndices,\n    production,\n    prefixPath\n  });\n  logging(message);\n}\n__name(reportLookaheadAmbiguity, \"reportLookaheadAmbiguity\");\nfunction buildAmbiguityError(options) {\n  const pathMsg = map_default(options.prefixPath, (currtok) => tokenLabel2(currtok)).join(\", \");\n  const occurrence = options.production.idx === 0 ? \"\" : options.production.idx;\n  let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\", \")}> in <${getProductionDslName2(options.production)}${occurrence}> inside <${options.topLevelRule.name}> Rule,\n<${pathMsg}> may appears as a prefix path in all these alternatives.\n`;\n  currMessage = currMessage + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\nFor Further details.`;\n  return currMessage;\n}\n__name(buildAmbiguityError, \"buildAmbiguityError\");\nfunction getProductionDslName2(prod) {\n  if (prod instanceof NonTerminal) {\n    return \"SUBRULE\";\n  } else if (prod instanceof Option) {\n    return \"OPTION\";\n  } else if (prod instanceof Alternation) {\n    return \"OR\";\n  } else if (prod instanceof RepetitionMandatory) {\n    return \"AT_LEAST_ONE\";\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n    return \"AT_LEAST_ONE_SEP\";\n  } else if (prod instanceof RepetitionWithSeparator) {\n    return \"MANY_SEP\";\n  } else if (prod instanceof Repetition) {\n    return \"MANY\";\n  } else if (prod instanceof Terminal) {\n    return \"CONSUME\";\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n__name(getProductionDslName2, \"getProductionDslName\");\nfunction buildAdaptivePredictError(path, previous, current) {\n  const nextTransitions = flatMap_default(previous.configs.elements, (e) => e.state.transitions);\n  const nextTokenTypes = uniqBy_default(nextTransitions.filter((e) => e instanceof AtomTransition).map((e) => e.tokenType), (e) => e.tokenTypeIdx);\n  return {\n    actualToken: current,\n    possibleTokenTypes: nextTokenTypes,\n    tokenPath: path\n  };\n}\n__name(buildAdaptivePredictError, \"buildAdaptivePredictError\");\nfunction getExistingTargetState(state, token) {\n  return state.edges[token.tokenTypeIdx];\n}\n__name(getExistingTargetState, \"getExistingTargetState\");\nfunction computeReachSet(configs, token, predicateSet) {\n  const intermediate = new ATNConfigSet();\n  const skippedStopStates = [];\n  for (const c of configs.elements) {\n    if (predicateSet.is(c.alt) === false) {\n      continue;\n    }\n    if (c.state.type === ATN_RULE_STOP) {\n      skippedStopStates.push(c);\n      continue;\n    }\n    const transitionLength = c.state.transitions.length;\n    for (let i = 0; i < transitionLength; i++) {\n      const transition = c.state.transitions[i];\n      const target = getReachableTarget(transition, token);\n      if (target !== void 0) {\n        intermediate.add({\n          state: target,\n          alt: c.alt,\n          stack: c.stack\n        });\n      }\n    }\n  }\n  let reach;\n  if (skippedStopStates.length === 0 && intermediate.size === 1) {\n    reach = intermediate;\n  }\n  if (reach === void 0) {\n    reach = new ATNConfigSet();\n    for (const c of intermediate.elements) {\n      closure(c, reach);\n    }\n  }\n  if (skippedStopStates.length > 0 && !hasConfigInRuleStopState(reach)) {\n    for (const c of skippedStopStates) {\n      reach.add(c);\n    }\n  }\n  return reach;\n}\n__name(computeReachSet, \"computeReachSet\");\nfunction getReachableTarget(transition, token) {\n  if (transition instanceof AtomTransition && tokenMatcher(token, transition.tokenType)) {\n    return transition.target;\n  }\n  return void 0;\n}\n__name(getReachableTarget, \"getReachableTarget\");\nfunction getUniqueAlt(configs, predicateSet) {\n  let alt;\n  for (const c of configs.elements) {\n    if (predicateSet.is(c.alt) === true) {\n      if (alt === void 0) {\n        alt = c.alt;\n      } else if (alt !== c.alt) {\n        return void 0;\n      }\n    }\n  }\n  return alt;\n}\n__name(getUniqueAlt, \"getUniqueAlt\");\nfunction newDFAState(closure2) {\n  return {\n    configs: closure2,\n    edges: {},\n    isAcceptState: false,\n    prediction: -1\n  };\n}\n__name(newDFAState, \"newDFAState\");\nfunction addDFAEdge(dfa, from, token, to) {\n  to = addDFAState(dfa, to);\n  from.edges[token.tokenTypeIdx] = to;\n  return to;\n}\n__name(addDFAEdge, \"addDFAEdge\");\nfunction addDFAState(dfa, state) {\n  if (state === DFA_ERROR) {\n    return state;\n  }\n  const mapKey = state.configs.key;\n  const existing = dfa.states[mapKey];\n  if (existing !== void 0) {\n    return existing;\n  }\n  state.configs.finalize();\n  dfa.states[mapKey] = state;\n  return state;\n}\n__name(addDFAState, \"addDFAState\");\nfunction computeStartState(atnState) {\n  const configs = new ATNConfigSet();\n  const numberOfTransitions = atnState.transitions.length;\n  for (let i = 0; i < numberOfTransitions; i++) {\n    const target = atnState.transitions[i].target;\n    const config = {\n      state: target,\n      alt: i,\n      stack: []\n    };\n    closure(config, configs);\n  }\n  return configs;\n}\n__name(computeStartState, \"computeStartState\");\nfunction closure(config, configs) {\n  const p = config.state;\n  if (p.type === ATN_RULE_STOP) {\n    if (config.stack.length > 0) {\n      const atnStack = [...config.stack];\n      const followState = atnStack.pop();\n      const followConfig = {\n        state: followState,\n        alt: config.alt,\n        stack: atnStack\n      };\n      closure(followConfig, configs);\n    } else {\n      configs.add(config);\n    }\n    return;\n  }\n  if (!p.epsilonOnlyTransitions) {\n    configs.add(config);\n  }\n  const transitionLength = p.transitions.length;\n  for (let i = 0; i < transitionLength; i++) {\n    const transition = p.transitions[i];\n    const c = getEpsilonTarget(config, transition);\n    if (c !== void 0) {\n      closure(c, configs);\n    }\n  }\n}\n__name(closure, \"closure\");\nfunction getEpsilonTarget(config, transition) {\n  if (transition instanceof EpsilonTransition) {\n    return {\n      state: transition.target,\n      alt: config.alt,\n      stack: config.stack\n    };\n  } else if (transition instanceof RuleTransition) {\n    const stack = [...config.stack, transition.followState];\n    return {\n      state: transition.target,\n      alt: config.alt,\n      stack\n    };\n  }\n  return void 0;\n}\n__name(getEpsilonTarget, \"getEpsilonTarget\");\nfunction hasConfigInRuleStopState(configs) {\n  for (const c of configs.elements) {\n    if (c.state.type === ATN_RULE_STOP) {\n      return true;\n    }\n  }\n  return false;\n}\n__name(hasConfigInRuleStopState, \"hasConfigInRuleStopState\");\nfunction allConfigsInRuleStopStates(configs) {\n  for (const c of configs.elements) {\n    if (c.state.type !== ATN_RULE_STOP) {\n      return false;\n    }\n  }\n  return true;\n}\n__name(allConfigsInRuleStopStates, \"allConfigsInRuleStopStates\");\nfunction hasConflictTerminatingPrediction(configs) {\n  if (allConfigsInRuleStopStates(configs)) {\n    return true;\n  }\n  const altSets = getConflictingAltSets(configs.elements);\n  const heuristic = hasConflictingAltSet(altSets) && !hasStateAssociatedWithOneAlt(altSets);\n  return heuristic;\n}\n__name(hasConflictTerminatingPrediction, \"hasConflictTerminatingPrediction\");\nfunction getConflictingAltSets(configs) {\n  const configToAlts = /* @__PURE__ */ new Map();\n  for (const c of configs) {\n    const key = getATNConfigKey(c, false);\n    let alts = configToAlts.get(key);\n    if (alts === void 0) {\n      alts = {};\n      configToAlts.set(key, alts);\n    }\n    alts[c.alt] = true;\n  }\n  return configToAlts;\n}\n__name(getConflictingAltSets, \"getConflictingAltSets\");\nfunction hasConflictingAltSet(altSets) {\n  for (const value of Array.from(altSets.values())) {\n    if (Object.keys(value).length > 1) {\n      return true;\n    }\n  }\n  return false;\n}\n__name(hasConflictingAltSet, \"hasConflictingAltSet\");\nfunction hasStateAssociatedWithOneAlt(altSets) {\n  for (const value of Array.from(altSets.values())) {\n    if (Object.keys(value).length === 1) {\n      return true;\n    }\n  }\n  return false;\n}\n__name(hasStateAssociatedWithOneAlt, \"hasStateAssociatedWithOneAlt\");\n\n// ../../node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/esm/main.js\nvar DocumentUri;\n(function(DocumentUri2) {\n  function is(value) {\n    return typeof value === \"string\";\n  }\n  __name(is, \"is\");\n  DocumentUri2.is = is;\n})(DocumentUri || (DocumentUri = {}));\nvar URI;\n(function(URI3) {\n  function is(value) {\n    return typeof value === \"string\";\n  }\n  __name(is, \"is\");\n  URI3.is = is;\n})(URI || (URI = {}));\nvar integer;\n(function(integer2) {\n  integer2.MIN_VALUE = -2147483648;\n  integer2.MAX_VALUE = 2147483647;\n  function is(value) {\n    return typeof value === \"number\" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;\n  }\n  __name(is, \"is\");\n  integer2.is = is;\n})(integer || (integer = {}));\nvar uinteger;\n(function(uinteger2) {\n  uinteger2.MIN_VALUE = 0;\n  uinteger2.MAX_VALUE = 2147483647;\n  function is(value) {\n    return typeof value === \"number\" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;\n  }\n  __name(is, \"is\");\n  uinteger2.is = is;\n})(uinteger || (uinteger = {}));\nvar Position;\n(function(Position2) {\n  function create(line, character) {\n    if (line === Number.MAX_VALUE) {\n      line = uinteger.MAX_VALUE;\n    }\n    if (character === Number.MAX_VALUE) {\n      character = uinteger.MAX_VALUE;\n    }\n    return { line, character };\n  }\n  __name(create, \"create\");\n  Position2.create = create;\n  function is(value) {\n    let candidate = value;\n    return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\n  }\n  __name(is, \"is\");\n  Position2.is = is;\n})(Position || (Position = {}));\nvar Range;\n(function(Range2) {\n  function create(one, two, three, four) {\n    if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\n      return { start: Position.create(one, two), end: Position.create(three, four) };\n    } else if (Position.is(one) && Position.is(two)) {\n      return { start: one, end: two };\n    } else {\n      throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);\n    }\n  }\n  __name(create, \"create\");\n  Range2.create = create;\n  function is(value) {\n    let candidate = value;\n    return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\n  }\n  __name(is, \"is\");\n  Range2.is = is;\n})(Range || (Range = {}));\nvar Location;\n(function(Location2) {\n  function create(uri, range) {\n    return { uri, range };\n  }\n  __name(create, \"create\");\n  Location2.create = create;\n  function is(value) {\n    let candidate = value;\n    return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n  }\n  __name(is, \"is\");\n  Location2.is = is;\n})(Location || (Location = {}));\nvar LocationLink;\n(function(LocationLink2) {\n  function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n    return { targetUri, targetRange, targetSelectionRange, originSelectionRange };\n  }\n  __name(create, \"create\");\n  LocationLink2.create = create;\n  function is(value) {\n    let candidate = value;\n    return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n  }\n  __name(is, \"is\");\n  LocationLink2.is = is;\n})(LocationLink || (LocationLink = {}));\nvar Color;\n(function(Color2) {\n  function create(red, green, blue, alpha) {\n    return {\n      red,\n      green,\n      blue,\n      alpha\n    };\n  }\n  __name(create, \"create\");\n  Color2.create = create;\n  function is(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);\n  }\n  __name(is, \"is\");\n  Color2.is = is;\n})(Color || (Color = {}));\nvar ColorInformation;\n(function(ColorInformation2) {\n  function create(range, color) {\n    return {\n      range,\n      color\n    };\n  }\n  __name(create, \"create\");\n  ColorInformation2.create = create;\n  function is(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);\n  }\n  __name(is, \"is\");\n  ColorInformation2.is = is;\n})(ColorInformation || (ColorInformation = {}));\nvar ColorPresentation;\n(function(ColorPresentation2) {\n  function create(label, textEdit, additionalTextEdits) {\n    return {\n      label,\n      textEdit,\n      additionalTextEdits\n    };\n  }\n  __name(create, \"create\");\n  ColorPresentation2.create = create;\n  function is(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n  }\n  __name(is, \"is\");\n  ColorPresentation2.is = is;\n})(ColorPresentation || (ColorPresentation = {}));\nvar FoldingRangeKind;\n(function(FoldingRangeKind2) {\n  FoldingRangeKind2.Comment = \"comment\";\n  FoldingRangeKind2.Imports = \"imports\";\n  FoldingRangeKind2.Region = \"region\";\n})(FoldingRangeKind || (FoldingRangeKind = {}));\nvar FoldingRange;\n(function(FoldingRange2) {\n  function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\n    const result = {\n      startLine,\n      endLine\n    };\n    if (Is.defined(startCharacter)) {\n      result.startCharacter = startCharacter;\n    }\n    if (Is.defined(endCharacter)) {\n      result.endCharacter = endCharacter;\n    }\n    if (Is.defined(kind)) {\n      result.kind = kind;\n    }\n    if (Is.defined(collapsedText)) {\n      result.collapsedText = collapsedText;\n    }\n    return result;\n  }\n  __name(create, \"create\");\n  FoldingRange2.create = create;\n  function is(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n  }\n  __name(is, \"is\");\n  FoldingRange2.is = is;\n})(FoldingRange || (FoldingRange = {}));\nvar DiagnosticRelatedInformation;\n(function(DiagnosticRelatedInformation2) {\n  function create(location, message) {\n    return {\n      location,\n      message\n    };\n  }\n  __name(create, \"create\");\n  DiagnosticRelatedInformation2.create = create;\n  function is(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n  }\n  __name(is, \"is\");\n  DiagnosticRelatedInformation2.is = is;\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\nvar DiagnosticSeverity;\n(function(DiagnosticSeverity2) {\n  DiagnosticSeverity2.Error = 1;\n  DiagnosticSeverity2.Warning = 2;\n  DiagnosticSeverity2.Information = 3;\n  DiagnosticSeverity2.Hint = 4;\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\nvar DiagnosticTag;\n(function(DiagnosticTag2) {\n  DiagnosticTag2.Unnecessary = 1;\n  DiagnosticTag2.Deprecated = 2;\n})(DiagnosticTag || (DiagnosticTag = {}));\nvar CodeDescription;\n(function(CodeDescription2) {\n  function is(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && Is.string(candidate.href);\n  }\n  __name(is, \"is\");\n  CodeDescription2.is = is;\n})(CodeDescription || (CodeDescription = {}));\nvar Diagnostic;\n(function(Diagnostic2) {\n  function create(range, message, severity, code, source, relatedInformation) {\n    let result = { range, message };\n    if (Is.defined(severity)) {\n      result.severity = severity;\n    }\n    if (Is.defined(code)) {\n      result.code = code;\n    }\n    if (Is.defined(source)) {\n      result.source = source;\n    }\n    if (Is.defined(relatedInformation)) {\n      result.relatedInformation = relatedInformation;\n    }\n    return result;\n  }\n  __name(create, \"create\");\n  Diagnostic2.create = create;\n  function is(value) {\n    var _a;\n    let candidate = value;\n    return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n  }\n  __name(is, \"is\");\n  Diagnostic2.is = is;\n})(Diagnostic || (Diagnostic = {}));\nvar Command;\n(function(Command2) {\n  function create(title, command, ...args) {\n    let result = { title, command };\n    if (Is.defined(args) && args.length > 0) {\n      result.arguments = args;\n    }\n    return result;\n  }\n  __name(create, \"create\");\n  Command2.create = create;\n  function is(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n  }\n  __name(is, \"is\");\n  Command2.is = is;\n})(Command || (Command = {}));\nvar TextEdit;\n(function(TextEdit2) {\n  function replace(range, newText) {\n    return { range, newText };\n  }\n  __name(replace, \"replace\");\n  TextEdit2.replace = replace;\n  function insert(position, newText) {\n    return { range: { start: position, end: position }, newText };\n  }\n  __name(insert, \"insert\");\n  TextEdit2.insert = insert;\n  function del(range) {\n    return { range, newText: \"\" };\n  }\n  __name(del, \"del\");\n  TextEdit2.del = del;\n  function is(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);\n  }\n  __name(is, \"is\");\n  TextEdit2.is = is;\n})(TextEdit || (TextEdit = {}));\nvar ChangeAnnotation;\n(function(ChangeAnnotation2) {\n  function create(label, needsConfirmation, description) {\n    const result = { label };\n    if (needsConfirmation !== void 0) {\n      result.needsConfirmation = needsConfirmation;\n    }\n    if (description !== void 0) {\n      result.description = description;\n    }\n    return result;\n  }\n  __name(create, \"create\");\n  ChangeAnnotation2.create = create;\n  function is(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);\n  }\n  __name(is, \"is\");\n  ChangeAnnotation2.is = is;\n})(ChangeAnnotation || (ChangeAnnotation = {}));\nvar ChangeAnnotationIdentifier;\n(function(ChangeAnnotationIdentifier2) {\n  function is(value) {\n    const candidate = value;\n    return Is.string(candidate);\n  }\n  __name(is, \"is\");\n  ChangeAnnotationIdentifier2.is = is;\n})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));\nvar AnnotatedTextEdit;\n(function(AnnotatedTextEdit2) {\n  function replace(range, newText, annotation) {\n    return { range, newText, annotationId: annotation };\n  }\n  __name(replace, \"replace\");\n  AnnotatedTextEdit2.replace = replace;\n  function insert(position, newText, annotation) {\n    return { range: { start: position, end: position }, newText, annotationId: annotation };\n  }\n  __name(insert, \"insert\");\n  AnnotatedTextEdit2.insert = insert;\n  function del(range, annotation) {\n    return { range, newText: \"\", annotationId: annotation };\n  }\n  __name(del, \"del\");\n  AnnotatedTextEdit2.del = del;\n  function is(value) {\n    const candidate = value;\n    return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n  }\n  __name(is, \"is\");\n  AnnotatedTextEdit2.is = is;\n})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));\nvar TextDocumentEdit;\n(function(TextDocumentEdit2) {\n  function create(textDocument, edits) {\n    return { textDocument, edits };\n  }\n  __name(create, \"create\");\n  TextDocumentEdit2.create = create;\n  function is(value) {\n    let candidate = value;\n    return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);\n  }\n  __name(is, \"is\");\n  TextDocumentEdit2.is = is;\n})(TextDocumentEdit || (TextDocumentEdit = {}));\nvar CreateFile;\n(function(CreateFile2) {\n  function create(uri, options, annotation) {\n    let result = {\n      kind: \"create\",\n      uri\n    };\n    if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\n      result.options = options;\n    }\n    if (annotation !== void 0) {\n      result.annotationId = annotation;\n    }\n    return result;\n  }\n  __name(create, \"create\");\n  CreateFile2.create = create;\n  function is(value) {\n    let candidate = value;\n    return candidate && candidate.kind === \"create\" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));\n  }\n  __name(is, \"is\");\n  CreateFile2.is = is;\n})(CreateFile || (CreateFile = {}));\nvar RenameFile;\n(function(RenameFile2) {\n  function create(oldUri, newUri, options, annotation) {\n    let result = {\n      kind: \"rename\",\n      oldUri,\n      newUri\n    };\n    if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\n      result.options = options;\n    }\n    if (annotation !== void 0) {\n      result.annotationId = annotation;\n    }\n    return result;\n  }\n  __name(create, \"create\");\n  RenameFile2.create = create;\n  function is(value) {\n    let candidate = value;\n    return candidate && candidate.kind === \"rename\" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));\n  }\n  __name(is, \"is\");\n  RenameFile2.is = is;\n})(RenameFile || (RenameFile = {}));\nvar DeleteFile;\n(function(DeleteFile2) {\n  function create(uri, options, annotation) {\n    let result = {\n      kind: \"delete\",\n      uri\n    };\n    if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {\n      result.options = options;\n    }\n    if (annotation !== void 0) {\n      result.annotationId = annotation;\n    }\n    return result;\n  }\n  __name(create, \"create\");\n  DeleteFile2.create = create;\n  function is(value) {\n    let candidate = value;\n    return candidate && candidate.kind === \"delete\" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));\n  }\n  __name(is, \"is\");\n  DeleteFile2.is = is;\n})(DeleteFile || (DeleteFile = {}));\nvar WorkspaceEdit;\n(function(WorkspaceEdit2) {\n  function is(value) {\n    let candidate = value;\n    return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every((change) => {\n      if (Is.string(change.kind)) {\n        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n      } else {\n        return TextDocumentEdit.is(change);\n      }\n    }));\n  }\n  __name(is, \"is\");\n  WorkspaceEdit2.is = is;\n})(WorkspaceEdit || (WorkspaceEdit = {}));\nvar TextDocumentIdentifier;\n(function(TextDocumentIdentifier2) {\n  function create(uri) {\n    return { uri };\n  }\n  __name(create, \"create\");\n  TextDocumentIdentifier2.create = create;\n  function is(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.uri);\n  }\n  __name(is, \"is\");\n  TextDocumentIdentifier2.is = is;\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\nvar VersionedTextDocumentIdentifier;\n(function(VersionedTextDocumentIdentifier2) {\n  function create(uri, version) {\n    return { uri, version };\n  }\n  __name(create, \"create\");\n  VersionedTextDocumentIdentifier2.create = create;\n  function is(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\n  }\n  __name(is, \"is\");\n  VersionedTextDocumentIdentifier2.is = is;\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\nvar OptionalVersionedTextDocumentIdentifier;\n(function(OptionalVersionedTextDocumentIdentifier2) {\n  function create(uri, version) {\n    return { uri, version };\n  }\n  __name(create, \"create\");\n  OptionalVersionedTextDocumentIdentifier2.create = create;\n  function is(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\n  }\n  __name(is, \"is\");\n  OptionalVersionedTextDocumentIdentifier2.is = is;\n})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));\nvar TextDocumentItem;\n(function(TextDocumentItem2) {\n  function create(uri, languageId, version, text) {\n    return { uri, languageId, version, text };\n  }\n  __name(create, \"create\");\n  TextDocumentItem2.create = create;\n  function is(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\n  }\n  __name(is, \"is\");\n  TextDocumentItem2.is = is;\n})(TextDocumentItem || (TextDocumentItem = {}));\nvar MarkupKind;\n(function(MarkupKind2) {\n  MarkupKind2.PlainText = \"plaintext\";\n  MarkupKind2.Markdown = \"markdown\";\n  function is(value) {\n    const candidate = value;\n    return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;\n  }\n  __name(is, \"is\");\n  MarkupKind2.is = is;\n})(MarkupKind || (MarkupKind = {}));\nvar MarkupContent;\n(function(MarkupContent2) {\n  function is(value) {\n    const candidate = value;\n    return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n  }\n  __name(is, \"is\");\n  MarkupContent2.is = is;\n})(MarkupContent || (MarkupContent = {}));\nvar CompletionItemKind;\n(function(CompletionItemKind2) {\n  CompletionItemKind2.Text = 1;\n  CompletionItemKind2.Method = 2;\n  CompletionItemKind2.Function = 3;\n  CompletionItemKind2.Constructor = 4;\n  CompletionItemKind2.Field = 5;\n  CompletionItemKind2.Variable = 6;\n  CompletionItemKind2.Class = 7;\n  CompletionItemKind2.Interface = 8;\n  CompletionItemKind2.Module = 9;\n  CompletionItemKind2.Property = 10;\n  CompletionItemKind2.Unit = 11;\n  CompletionItemKind2.Value = 12;\n  CompletionItemKind2.Enum = 13;\n  CompletionItemKind2.Keyword = 14;\n  CompletionItemKind2.Snippet = 15;\n  CompletionItemKind2.Color = 16;\n  CompletionItemKind2.File = 17;\n  CompletionItemKind2.Reference = 18;\n  CompletionItemKind2.Folder = 19;\n  CompletionItemKind2.EnumMember = 20;\n  CompletionItemKind2.Constant = 21;\n  CompletionItemKind2.Struct = 22;\n  CompletionItemKind2.Event = 23;\n  CompletionItemKind2.Operator = 24;\n  CompletionItemKind2.TypeParameter = 25;\n})(CompletionItemKind || (CompletionItemKind = {}));\nvar InsertTextFormat;\n(function(InsertTextFormat2) {\n  InsertTextFormat2.PlainText = 1;\n  InsertTextFormat2.Snippet = 2;\n})(InsertTextFormat || (InsertTextFormat = {}));\nvar CompletionItemTag;\n(function(CompletionItemTag2) {\n  CompletionItemTag2.Deprecated = 1;\n})(CompletionItemTag || (CompletionItemTag = {}));\nvar InsertReplaceEdit;\n(function(InsertReplaceEdit2) {\n  function create(newText, insert, replace) {\n    return { newText, insert, replace };\n  }\n  __name(create, \"create\");\n  InsertReplaceEdit2.create = create;\n  function is(value) {\n    const candidate = value;\n    return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\n  }\n  __name(is, \"is\");\n  InsertReplaceEdit2.is = is;\n})(InsertReplaceEdit || (InsertReplaceEdit = {}));\nvar InsertTextMode;\n(function(InsertTextMode2) {\n  InsertTextMode2.asIs = 1;\n  InsertTextMode2.adjustIndentation = 2;\n})(InsertTextMode || (InsertTextMode = {}));\nvar CompletionItemLabelDetails;\n(function(CompletionItemLabelDetails2) {\n  function is(value) {\n    const candidate = value;\n    return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);\n  }\n  __name(is, \"is\");\n  CompletionItemLabelDetails2.is = is;\n})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));\nvar CompletionItem;\n(function(CompletionItem2) {\n  function create(label) {\n    return { label };\n  }\n  __name(create, \"create\");\n  CompletionItem2.create = create;\n})(CompletionItem || (CompletionItem = {}));\nvar CompletionList;\n(function(CompletionList2) {\n  function create(items, isIncomplete) {\n    return { items: items ? items : [], isIncomplete: !!isIncomplete };\n  }\n  __name(create, \"create\");\n  CompletionList2.create = create;\n})(CompletionList || (CompletionList = {}));\nvar MarkedString;\n(function(MarkedString2) {\n  function fromPlainText(plainText) {\n    return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, \"\\\\$&\");\n  }\n  __name(fromPlainText, \"fromPlainText\");\n  MarkedString2.fromPlainText = fromPlainText;\n  function is(value) {\n    const candidate = value;\n    return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);\n  }\n  __name(is, \"is\");\n  MarkedString2.is = is;\n})(MarkedString || (MarkedString = {}));\nvar Hover;\n(function(Hover2) {\n  function is(value) {\n    let candidate = value;\n    return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));\n  }\n  __name(is, \"is\");\n  Hover2.is = is;\n})(Hover || (Hover = {}));\nvar ParameterInformation;\n(function(ParameterInformation2) {\n  function create(label, documentation) {\n    return documentation ? { label, documentation } : { label };\n  }\n  __name(create, \"create\");\n  ParameterInformation2.create = create;\n})(ParameterInformation || (ParameterInformation = {}));\nvar SignatureInformation;\n(function(SignatureInformation2) {\n  function create(label, documentation, ...parameters) {\n    let result = { label };\n    if (Is.defined(documentation)) {\n      result.documentation = documentation;\n    }\n    if (Is.defined(parameters)) {\n      result.parameters = parameters;\n    } else {\n      result.parameters = [];\n    }\n    return result;\n  }\n  __name(create, \"create\");\n  SignatureInformation2.create = create;\n})(SignatureInformation || (SignatureInformation = {}));\nvar DocumentHighlightKind;\n(function(DocumentHighlightKind2) {\n  DocumentHighlightKind2.Text = 1;\n  DocumentHighlightKind2.Read = 2;\n  DocumentHighlightKind2.Write = 3;\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\nvar DocumentHighlight;\n(function(DocumentHighlight2) {\n  function create(range, kind) {\n    let result = { range };\n    if (Is.number(kind)) {\n      result.kind = kind;\n    }\n    return result;\n  }\n  __name(create, \"create\");\n  DocumentHighlight2.create = create;\n})(DocumentHighlight || (DocumentHighlight = {}));\nvar SymbolKind;\n(function(SymbolKind2) {\n  SymbolKind2.File = 1;\n  SymbolKind2.Module = 2;\n  SymbolKind2.Namespace = 3;\n  SymbolKind2.Package = 4;\n  SymbolKind2.Class = 5;\n  SymbolKind2.Method = 6;\n  SymbolKind2.Property = 7;\n  SymbolKind2.Field = 8;\n  SymbolKind2.Constructor = 9;\n  SymbolKind2.Enum = 10;\n  SymbolKind2.Interface = 11;\n  SymbolKind2.Function = 12;\n  SymbolKind2.Variable = 13;\n  SymbolKind2.Constant = 14;\n  SymbolKind2.String = 15;\n  SymbolKind2.Number = 16;\n  SymbolKind2.Boolean = 17;\n  SymbolKind2.Array = 18;\n  SymbolKind2.Object = 19;\n  SymbolKind2.Key = 20;\n  SymbolKind2.Null = 21;\n  SymbolKind2.EnumMember = 22;\n  SymbolKind2.Struct = 23;\n  SymbolKind2.Event = 24;\n  SymbolKind2.Operator = 25;\n  SymbolKind2.TypeParameter = 26;\n})(SymbolKind || (SymbolKind = {}));\nvar SymbolTag;\n(function(SymbolTag2) {\n  SymbolTag2.Deprecated = 1;\n})(SymbolTag || (SymbolTag = {}));\nvar SymbolInformation;\n(function(SymbolInformation2) {\n  function create(name, kind, range, uri, containerName) {\n    let result = {\n      name,\n      kind,\n      location: { uri, range }\n    };\n    if (containerName) {\n      result.containerName = containerName;\n    }\n    return result;\n  }\n  __name(create, \"create\");\n  SymbolInformation2.create = create;\n})(SymbolInformation || (SymbolInformation = {}));\nvar WorkspaceSymbol;\n(function(WorkspaceSymbol2) {\n  function create(name, kind, uri, range) {\n    return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };\n  }\n  __name(create, \"create\");\n  WorkspaceSymbol2.create = create;\n})(WorkspaceSymbol || (WorkspaceSymbol = {}));\nvar DocumentSymbol;\n(function(DocumentSymbol2) {\n  function create(name, detail, kind, range, selectionRange, children) {\n    let result = {\n      name,\n      detail,\n      kind,\n      range,\n      selectionRange\n    };\n    if (children !== void 0) {\n      result.children = children;\n    }\n    return result;\n  }\n  __name(create, \"create\");\n  DocumentSymbol2.create = create;\n  function is(value) {\n    let candidate = value;\n    return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));\n  }\n  __name(is, \"is\");\n  DocumentSymbol2.is = is;\n})(DocumentSymbol || (DocumentSymbol = {}));\nvar CodeActionKind;\n(function(CodeActionKind2) {\n  CodeActionKind2.Empty = \"\";\n  CodeActionKind2.QuickFix = \"quickfix\";\n  CodeActionKind2.Refactor = \"refactor\";\n  CodeActionKind2.RefactorExtract = \"refactor.extract\";\n  CodeActionKind2.RefactorInline = \"refactor.inline\";\n  CodeActionKind2.RefactorRewrite = \"refactor.rewrite\";\n  CodeActionKind2.Source = \"source\";\n  CodeActionKind2.SourceOrganizeImports = \"source.organizeImports\";\n  CodeActionKind2.SourceFixAll = \"source.fixAll\";\n})(CodeActionKind || (CodeActionKind = {}));\nvar CodeActionTriggerKind;\n(function(CodeActionTriggerKind2) {\n  CodeActionTriggerKind2.Invoked = 1;\n  CodeActionTriggerKind2.Automatic = 2;\n})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));\nvar CodeActionContext;\n(function(CodeActionContext2) {\n  function create(diagnostics, only, triggerKind) {\n    let result = { diagnostics };\n    if (only !== void 0 && only !== null) {\n      result.only = only;\n    }\n    if (triggerKind !== void 0 && triggerKind !== null) {\n      result.triggerKind = triggerKind;\n    }\n    return result;\n  }\n  __name(create, \"create\");\n  CodeActionContext2.create = create;\n  function is(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);\n  }\n  __name(is, \"is\");\n  CodeActionContext2.is = is;\n})(CodeActionContext || (CodeActionContext = {}));\nvar CodeAction;\n(function(CodeAction2) {\n  function create(title, kindOrCommandOrEdit, kind) {\n    let result = { title };\n    let checkKind = true;\n    if (typeof kindOrCommandOrEdit === \"string\") {\n      checkKind = false;\n      result.kind = kindOrCommandOrEdit;\n    } else if (Command.is(kindOrCommandOrEdit)) {\n      result.command = kindOrCommandOrEdit;\n    } else {\n      result.edit = kindOrCommandOrEdit;\n    }\n    if (checkKind && kind !== void 0) {\n      result.kind = kind;\n    }\n    return result;\n  }\n  __name(create, \"create\");\n  CodeAction2.create = create;\n  function is(value) {\n    let candidate = value;\n    return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));\n  }\n  __name(is, \"is\");\n  CodeAction2.is = is;\n})(CodeAction || (CodeAction = {}));\nvar CodeLens;\n(function(CodeLens2) {\n  function create(range, data) {\n    let result = { range };\n    if (Is.defined(data)) {\n      result.data = data;\n    }\n    return result;\n  }\n  __name(create, \"create\");\n  CodeLens2.create = create;\n  function is(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n  }\n  __name(is, \"is\");\n  CodeLens2.is = is;\n})(CodeLens || (CodeLens = {}));\nvar FormattingOptions;\n(function(FormattingOptions2) {\n  function create(tabSize, insertSpaces) {\n    return { tabSize, insertSpaces };\n  }\n  __name(create, \"create\");\n  FormattingOptions2.create = create;\n  function is(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n  }\n  __name(is, \"is\");\n  FormattingOptions2.is = is;\n})(FormattingOptions || (FormattingOptions = {}));\nvar DocumentLink;\n(function(DocumentLink2) {\n  function create(range, target, data) {\n    return { range, target, data };\n  }\n  __name(create, \"create\");\n  DocumentLink2.create = create;\n  function is(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n  }\n  __name(is, \"is\");\n  DocumentLink2.is = is;\n})(DocumentLink || (DocumentLink = {}));\nvar SelectionRange;\n(function(SelectionRange2) {\n  function create(range, parent) {\n    return { range, parent };\n  }\n  __name(create, \"create\");\n  SelectionRange2.create = create;\n  function is(value) {\n    let candidate = value;\n    return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));\n  }\n  __name(is, \"is\");\n  SelectionRange2.is = is;\n})(SelectionRange || (SelectionRange = {}));\nvar SemanticTokenTypes;\n(function(SemanticTokenTypes2) {\n  SemanticTokenTypes2[\"namespace\"] = \"namespace\";\n  SemanticTokenTypes2[\"type\"] = \"type\";\n  SemanticTokenTypes2[\"class\"] = \"class\";\n  SemanticTokenTypes2[\"enum\"] = \"enum\";\n  SemanticTokenTypes2[\"interface\"] = \"interface\";\n  SemanticTokenTypes2[\"struct\"] = \"struct\";\n  SemanticTokenTypes2[\"typeParameter\"] = \"typeParameter\";\n  SemanticTokenTypes2[\"parameter\"] = \"parameter\";\n  SemanticTokenTypes2[\"variable\"] = \"variable\";\n  SemanticTokenTypes2[\"property\"] = \"property\";\n  SemanticTokenTypes2[\"enumMember\"] = \"enumMember\";\n  SemanticTokenTypes2[\"event\"] = \"event\";\n  SemanticTokenTypes2[\"function\"] = \"function\";\n  SemanticTokenTypes2[\"method\"] = \"method\";\n  SemanticTokenTypes2[\"macro\"] = \"macro\";\n  SemanticTokenTypes2[\"keyword\"] = \"keyword\";\n  SemanticTokenTypes2[\"modifier\"] = \"modifier\";\n  SemanticTokenTypes2[\"comment\"] = \"comment\";\n  SemanticTokenTypes2[\"string\"] = \"string\";\n  SemanticTokenTypes2[\"number\"] = \"number\";\n  SemanticTokenTypes2[\"regexp\"] = \"regexp\";\n  SemanticTokenTypes2[\"operator\"] = \"operator\";\n  SemanticTokenTypes2[\"decorator\"] = \"decorator\";\n})(SemanticTokenTypes || (SemanticTokenTypes = {}));\nvar SemanticTokenModifiers;\n(function(SemanticTokenModifiers2) {\n  SemanticTokenModifiers2[\"declaration\"] = \"declaration\";\n  SemanticTokenModifiers2[\"definition\"] = \"definition\";\n  SemanticTokenModifiers2[\"readonly\"] = \"readonly\";\n  SemanticTokenModifiers2[\"static\"] = \"static\";\n  SemanticTokenModifiers2[\"deprecated\"] = \"deprecated\";\n  SemanticTokenModifiers2[\"abstract\"] = \"abstract\";\n  SemanticTokenModifiers2[\"async\"] = \"async\";\n  SemanticTokenModifiers2[\"modification\"] = \"modification\";\n  SemanticTokenModifiers2[\"documentation\"] = \"documentation\";\n  SemanticTokenModifiers2[\"defaultLibrary\"] = \"defaultLibrary\";\n})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));\nvar SemanticTokens;\n(function(SemanticTokens2) {\n  function is(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === \"string\") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === \"number\");\n  }\n  __name(is, \"is\");\n  SemanticTokens2.is = is;\n})(SemanticTokens || (SemanticTokens = {}));\nvar InlineValueText;\n(function(InlineValueText2) {\n  function create(range, text) {\n    return { range, text };\n  }\n  __name(create, \"create\");\n  InlineValueText2.create = create;\n  function is(value) {\n    const candidate = value;\n    return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);\n  }\n  __name(is, \"is\");\n  InlineValueText2.is = is;\n})(InlineValueText || (InlineValueText = {}));\nvar InlineValueVariableLookup;\n(function(InlineValueVariableLookup2) {\n  function create(range, variableName, caseSensitiveLookup) {\n    return { range, variableName, caseSensitiveLookup };\n  }\n  __name(create, \"create\");\n  InlineValueVariableLookup2.create = create;\n  function is(value) {\n    const candidate = value;\n    return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);\n  }\n  __name(is, \"is\");\n  InlineValueVariableLookup2.is = is;\n})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));\nvar InlineValueEvaluatableExpression;\n(function(InlineValueEvaluatableExpression2) {\n  function create(range, expression) {\n    return { range, expression };\n  }\n  __name(create, \"create\");\n  InlineValueEvaluatableExpression2.create = create;\n  function is(value) {\n    const candidate = value;\n    return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);\n  }\n  __name(is, \"is\");\n  InlineValueEvaluatableExpression2.is = is;\n})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));\nvar InlineValueContext;\n(function(InlineValueContext2) {\n  function create(frameId, stoppedLocation) {\n    return { frameId, stoppedLocation };\n  }\n  __name(create, \"create\");\n  InlineValueContext2.create = create;\n  function is(value) {\n    const candidate = value;\n    return Is.defined(candidate) && Range.is(value.stoppedLocation);\n  }\n  __name(is, \"is\");\n  InlineValueContext2.is = is;\n})(InlineValueContext || (InlineValueContext = {}));\nvar InlayHintKind;\n(function(InlayHintKind2) {\n  InlayHintKind2.Type = 1;\n  InlayHintKind2.Parameter = 2;\n  function is(value) {\n    return value === 1 || value === 2;\n  }\n  __name(is, \"is\");\n  InlayHintKind2.is = is;\n})(InlayHintKind || (InlayHintKind = {}));\nvar InlayHintLabelPart;\n(function(InlayHintLabelPart2) {\n  function create(value) {\n    return { value };\n  }\n  __name(create, \"create\");\n  InlayHintLabelPart2.create = create;\n  function is(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));\n  }\n  __name(is, \"is\");\n  InlayHintLabelPart2.is = is;\n})(InlayHintLabelPart || (InlayHintLabelPart = {}));\nvar InlayHint;\n(function(InlayHint2) {\n  function create(position, label, kind) {\n    const result = { position, label };\n    if (kind !== void 0) {\n      result.kind = kind;\n    }\n    return result;\n  }\n  __name(create, \"create\");\n  InlayHint2.create = create;\n  function is(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));\n  }\n  __name(is, \"is\");\n  InlayHint2.is = is;\n})(InlayHint || (InlayHint = {}));\nvar StringValue;\n(function(StringValue2) {\n  function createSnippet(value) {\n    return { kind: \"snippet\", value };\n  }\n  __name(createSnippet, \"createSnippet\");\n  StringValue2.createSnippet = createSnippet;\n})(StringValue || (StringValue = {}));\nvar InlineCompletionItem;\n(function(InlineCompletionItem2) {\n  function create(insertText, filterText, range, command) {\n    return { insertText, filterText, range, command };\n  }\n  __name(create, \"create\");\n  InlineCompletionItem2.create = create;\n})(InlineCompletionItem || (InlineCompletionItem = {}));\nvar InlineCompletionList;\n(function(InlineCompletionList2) {\n  function create(items) {\n    return { items };\n  }\n  __name(create, \"create\");\n  InlineCompletionList2.create = create;\n})(InlineCompletionList || (InlineCompletionList = {}));\nvar InlineCompletionTriggerKind;\n(function(InlineCompletionTriggerKind2) {\n  InlineCompletionTriggerKind2.Invoked = 0;\n  InlineCompletionTriggerKind2.Automatic = 1;\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\nvar SelectedCompletionInfo;\n(function(SelectedCompletionInfo2) {\n  function create(range, text) {\n    return { range, text };\n  }\n  __name(create, \"create\");\n  SelectedCompletionInfo2.create = create;\n})(SelectedCompletionInfo || (SelectedCompletionInfo = {}));\nvar InlineCompletionContext;\n(function(InlineCompletionContext2) {\n  function create(triggerKind, selectedCompletionInfo) {\n    return { triggerKind, selectedCompletionInfo };\n  }\n  __name(create, \"create\");\n  InlineCompletionContext2.create = create;\n})(InlineCompletionContext || (InlineCompletionContext = {}));\nvar WorkspaceFolder;\n(function(WorkspaceFolder2) {\n  function is(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);\n  }\n  __name(is, \"is\");\n  WorkspaceFolder2.is = is;\n})(WorkspaceFolder || (WorkspaceFolder = {}));\nvar TextDocument;\n(function(TextDocument3) {\n  function create(uri, languageId, version, content) {\n    return new FullTextDocument(uri, languageId, version, content);\n  }\n  __name(create, \"create\");\n  TextDocument3.create = create;\n  function is(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n  }\n  __name(is, \"is\");\n  TextDocument3.is = is;\n  function applyEdits(document, edits) {\n    let text = document.getText();\n    let sortedEdits = mergeSort2(edits, (a, b) => {\n      let diff = a.range.start.line - b.range.start.line;\n      if (diff === 0) {\n        return a.range.start.character - b.range.start.character;\n      }\n      return diff;\n    });\n    let lastModifiedOffset = text.length;\n    for (let i = sortedEdits.length - 1; i >= 0; i--) {\n      let e = sortedEdits[i];\n      let startOffset = document.offsetAt(e.range.start);\n      let endOffset = document.offsetAt(e.range.end);\n      if (endOffset <= lastModifiedOffset) {\n        text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n      } else {\n        throw new Error(\"Overlapping edit\");\n      }\n      lastModifiedOffset = startOffset;\n    }\n    return text;\n  }\n  __name(applyEdits, \"applyEdits\");\n  TextDocument3.applyEdits = applyEdits;\n  function mergeSort2(data, compare) {\n    if (data.length <= 1) {\n      return data;\n    }\n    const p = data.length / 2 | 0;\n    const left = data.slice(0, p);\n    const right = data.slice(p);\n    mergeSort2(left, compare);\n    mergeSort2(right, compare);\n    let leftIdx = 0;\n    let rightIdx = 0;\n    let i = 0;\n    while (leftIdx < left.length && rightIdx < right.length) {\n      let ret = compare(left[leftIdx], right[rightIdx]);\n      if (ret <= 0) {\n        data[i++] = left[leftIdx++];\n      } else {\n        data[i++] = right[rightIdx++];\n      }\n    }\n    while (leftIdx < left.length) {\n      data[i++] = left[leftIdx++];\n    }\n    while (rightIdx < right.length) {\n      data[i++] = right[rightIdx++];\n    }\n    return data;\n  }\n  __name(mergeSort2, \"mergeSort\");\n})(TextDocument || (TextDocument = {}));\nvar FullTextDocument = class {\n  static {\n    __name(this, \"FullTextDocument\");\n  }\n  constructor(uri, languageId, version, content) {\n    this._uri = uri;\n    this._languageId = languageId;\n    this._version = version;\n    this._content = content;\n    this._lineOffsets = void 0;\n  }\n  get uri() {\n    return this._uri;\n  }\n  get languageId() {\n    return this._languageId;\n  }\n  get version() {\n    return this._version;\n  }\n  getText(range) {\n    if (range) {\n      let start = this.offsetAt(range.start);\n      let end = this.offsetAt(range.end);\n      return this._content.substring(start, end);\n    }\n    return this._content;\n  }\n  update(event, version) {\n    this._content = event.text;\n    this._version = version;\n    this._lineOffsets = void 0;\n  }\n  getLineOffsets() {\n    if (this._lineOffsets === void 0) {\n      let lineOffsets = [];\n      let text = this._content;\n      let isLineStart = true;\n      for (let i = 0; i < text.length; i++) {\n        if (isLineStart) {\n          lineOffsets.push(i);\n          isLineStart = false;\n        }\n        let ch = text.charAt(i);\n        isLineStart = ch === \"\\r\" || ch === \"\\n\";\n        if (ch === \"\\r\" && i + 1 < text.length && text.charAt(i + 1) === \"\\n\") {\n          i++;\n        }\n      }\n      if (isLineStart && text.length > 0) {\n        lineOffsets.push(text.length);\n      }\n      this._lineOffsets = lineOffsets;\n    }\n    return this._lineOffsets;\n  }\n  positionAt(offset) {\n    offset = Math.max(Math.min(offset, this._content.length), 0);\n    let lineOffsets = this.getLineOffsets();\n    let low = 0, high = lineOffsets.length;\n    if (high === 0) {\n      return Position.create(0, offset);\n    }\n    while (low < high) {\n      let mid = Math.floor((low + high) / 2);\n      if (lineOffsets[mid] > offset) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n    let line = low - 1;\n    return Position.create(line, offset - lineOffsets[line]);\n  }\n  offsetAt(position) {\n    let lineOffsets = this.getLineOffsets();\n    if (position.line >= lineOffsets.length) {\n      return this._content.length;\n    } else if (position.line < 0) {\n      return 0;\n    }\n    let lineOffset = lineOffsets[position.line];\n    let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;\n    return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n  }\n  get lineCount() {\n    return this.getLineOffsets().length;\n  }\n};\nvar Is;\n(function(Is2) {\n  const toString2 = Object.prototype.toString;\n  function defined(value) {\n    return typeof value !== \"undefined\";\n  }\n  __name(defined, \"defined\");\n  Is2.defined = defined;\n  function undefined2(value) {\n    return typeof value === \"undefined\";\n  }\n  __name(undefined2, \"undefined\");\n  Is2.undefined = undefined2;\n  function boolean(value) {\n    return value === true || value === false;\n  }\n  __name(boolean, \"boolean\");\n  Is2.boolean = boolean;\n  function string(value) {\n    return toString2.call(value) === \"[object String]\";\n  }\n  __name(string, \"string\");\n  Is2.string = string;\n  function number(value) {\n    return toString2.call(value) === \"[object Number]\";\n  }\n  __name(number, \"number\");\n  Is2.number = number;\n  function numberRange(value, min, max) {\n    return toString2.call(value) === \"[object Number]\" && min <= value && value <= max;\n  }\n  __name(numberRange, \"numberRange\");\n  Is2.numberRange = numberRange;\n  function integer2(value) {\n    return toString2.call(value) === \"[object Number]\" && -2147483648 <= value && value <= 2147483647;\n  }\n  __name(integer2, \"integer\");\n  Is2.integer = integer2;\n  function uinteger2(value) {\n    return toString2.call(value) === \"[object Number]\" && 0 <= value && value <= 2147483647;\n  }\n  __name(uinteger2, \"uinteger\");\n  Is2.uinteger = uinteger2;\n  function func(value) {\n    return toString2.call(value) === \"[object Function]\";\n  }\n  __name(func, \"func\");\n  Is2.func = func;\n  function objectLiteral(value) {\n    return value !== null && typeof value === \"object\";\n  }\n  __name(objectLiteral, \"objectLiteral\");\n  Is2.objectLiteral = objectLiteral;\n  function typedArray(value, check) {\n    return Array.isArray(value) && value.every(check);\n  }\n  __name(typedArray, \"typedArray\");\n  Is2.typedArray = typedArray;\n})(Is || (Is = {}));\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/parser/cst-node-builder.js\nvar CstNodeBuilder = class {\n  static {\n    __name(this, \"CstNodeBuilder\");\n  }\n  constructor() {\n    this.nodeStack = [];\n  }\n  get current() {\n    return this.nodeStack[this.nodeStack.length - 1];\n  }\n  buildRootNode(input) {\n    this.rootNode = new RootCstNodeImpl(input);\n    this.rootNode.root = this.rootNode;\n    this.nodeStack = [this.rootNode];\n    return this.rootNode;\n  }\n  buildCompositeNode(feature) {\n    const compositeNode = new CompositeCstNodeImpl();\n    compositeNode.grammarSource = feature;\n    compositeNode.root = this.rootNode;\n    this.current.content.push(compositeNode);\n    this.nodeStack.push(compositeNode);\n    return compositeNode;\n  }\n  buildLeafNode(token, feature) {\n    const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, false);\n    leafNode.grammarSource = feature;\n    leafNode.root = this.rootNode;\n    this.current.content.push(leafNode);\n    return leafNode;\n  }\n  removeNode(node) {\n    const parent = node.container;\n    if (parent) {\n      const index = parent.content.indexOf(node);\n      if (index >= 0) {\n        parent.content.splice(index, 1);\n      }\n    }\n  }\n  construct(item) {\n    const current = this.current;\n    if (typeof item.$type === \"string\") {\n      this.current.astNode = item;\n    }\n    item.$cstNode = current;\n    const node = this.nodeStack.pop();\n    if ((node === null || node === void 0 ? void 0 : node.content.length) === 0) {\n      this.removeNode(node);\n    }\n  }\n  addHiddenTokens(hiddenTokens) {\n    for (const token of hiddenTokens) {\n      const hiddenNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, true);\n      hiddenNode.root = this.rootNode;\n      this.addHiddenToken(this.rootNode, hiddenNode);\n    }\n  }\n  addHiddenToken(node, token) {\n    const { offset: tokenStart, end: tokenEnd } = token;\n    for (let i = 0; i < node.content.length; i++) {\n      const child = node.content[i];\n      const { offset: childStart, end: childEnd } = child;\n      if (isCompositeCstNode(child) && tokenStart > childStart && tokenEnd < childEnd) {\n        this.addHiddenToken(child, token);\n        return;\n      } else if (tokenEnd <= childStart) {\n        node.content.splice(i, 0, token);\n        return;\n      }\n    }\n    node.content.push(token);\n  }\n};\nvar AbstractCstNode = class {\n  static {\n    __name(this, \"AbstractCstNode\");\n  }\n  /** @deprecated use `container` instead. */\n  get parent() {\n    return this.container;\n  }\n  /** @deprecated use `grammarSource` instead. */\n  get feature() {\n    return this.grammarSource;\n  }\n  get hidden() {\n    return false;\n  }\n  get astNode() {\n    var _a, _b;\n    const node = typeof ((_a = this._astNode) === null || _a === void 0 ? void 0 : _a.$type) === \"string\" ? this._astNode : (_b = this.container) === null || _b === void 0 ? void 0 : _b.astNode;\n    if (!node) {\n      throw new Error(\"This node has no associated AST element\");\n    }\n    return node;\n  }\n  set astNode(value) {\n    this._astNode = value;\n  }\n  /** @deprecated use `astNode` instead. */\n  get element() {\n    return this.astNode;\n  }\n  get text() {\n    return this.root.fullText.substring(this.offset, this.end);\n  }\n};\nvar LeafCstNodeImpl = class extends AbstractCstNode {\n  static {\n    __name(this, \"LeafCstNodeImpl\");\n  }\n  get offset() {\n    return this._offset;\n  }\n  get length() {\n    return this._length;\n  }\n  get end() {\n    return this._offset + this._length;\n  }\n  get hidden() {\n    return this._hidden;\n  }\n  get tokenType() {\n    return this._tokenType;\n  }\n  get range() {\n    return this._range;\n  }\n  constructor(offset, length, range, tokenType, hidden = false) {\n    super();\n    this._hidden = hidden;\n    this._offset = offset;\n    this._tokenType = tokenType;\n    this._length = length;\n    this._range = range;\n  }\n};\nvar CompositeCstNodeImpl = class extends AbstractCstNode {\n  static {\n    __name(this, \"CompositeCstNodeImpl\");\n  }\n  constructor() {\n    super(...arguments);\n    this.content = new CstNodeContainer(this);\n  }\n  /** @deprecated use `content` instead. */\n  get children() {\n    return this.content;\n  }\n  get offset() {\n    var _a, _b;\n    return (_b = (_a = this.firstNonHiddenNode) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0;\n  }\n  get length() {\n    return this.end - this.offset;\n  }\n  get end() {\n    var _a, _b;\n    return (_b = (_a = this.lastNonHiddenNode) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : 0;\n  }\n  get range() {\n    const firstNode = this.firstNonHiddenNode;\n    const lastNode = this.lastNonHiddenNode;\n    if (firstNode && lastNode) {\n      if (this._rangeCache === void 0) {\n        const { range: firstRange } = firstNode;\n        const { range: lastRange } = lastNode;\n        this._rangeCache = { start: firstRange.start, end: lastRange.end.line < firstRange.start.line ? firstRange.start : lastRange.end };\n      }\n      return this._rangeCache;\n    } else {\n      return { start: Position.create(0, 0), end: Position.create(0, 0) };\n    }\n  }\n  get firstNonHiddenNode() {\n    for (const child of this.content) {\n      if (!child.hidden) {\n        return child;\n      }\n    }\n    return this.content[0];\n  }\n  get lastNonHiddenNode() {\n    for (let i = this.content.length - 1; i >= 0; i--) {\n      const child = this.content[i];\n      if (!child.hidden) {\n        return child;\n      }\n    }\n    return this.content[this.content.length - 1];\n  }\n};\nvar CstNodeContainer = class _CstNodeContainer extends Array {\n  static {\n    __name(this, \"CstNodeContainer\");\n  }\n  constructor(parent) {\n    super();\n    this.parent = parent;\n    Object.setPrototypeOf(this, _CstNodeContainer.prototype);\n  }\n  push(...items) {\n    this.addParents(items);\n    return super.push(...items);\n  }\n  unshift(...items) {\n    this.addParents(items);\n    return super.unshift(...items);\n  }\n  splice(start, count, ...items) {\n    this.addParents(items);\n    return super.splice(start, count, ...items);\n  }\n  addParents(items) {\n    for (const item of items) {\n      item.container = this.parent;\n    }\n  }\n};\nvar RootCstNodeImpl = class extends CompositeCstNodeImpl {\n  static {\n    __name(this, \"RootCstNodeImpl\");\n  }\n  get text() {\n    return this._text.substring(this.offset, this.end);\n  }\n  get fullText() {\n    return this._text;\n  }\n  constructor(input) {\n    super();\n    this._text = \"\";\n    this._text = input !== null && input !== void 0 ? input : \"\";\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/parser/langium-parser.js\nvar DatatypeSymbol = Symbol(\"Datatype\");\nfunction isDataTypeNode(node) {\n  return node.$type === DatatypeSymbol;\n}\n__name(isDataTypeNode, \"isDataTypeNode\");\nvar ruleSuffix = \"\\u200B\";\nvar withRuleSuffix = /* @__PURE__ */ __name((name) => name.endsWith(ruleSuffix) ? name : name + ruleSuffix, \"withRuleSuffix\");\nvar AbstractLangiumParser = class {\n  static {\n    __name(this, \"AbstractLangiumParser\");\n  }\n  constructor(services) {\n    this._unorderedGroups = /* @__PURE__ */ new Map();\n    this.lexer = services.parser.Lexer;\n    const tokens = this.lexer.definition;\n    this.wrapper = new ChevrotainWrapper(tokens, Object.assign(Object.assign({}, services.parser.ParserConfig), { errorMessageProvider: services.parser.ParserErrorMessageProvider }));\n  }\n  alternatives(idx, choices) {\n    this.wrapper.wrapOr(idx, choices);\n  }\n  optional(idx, callback) {\n    this.wrapper.wrapOption(idx, callback);\n  }\n  many(idx, callback) {\n    this.wrapper.wrapMany(idx, callback);\n  }\n  atLeastOne(idx, callback) {\n    this.wrapper.wrapAtLeastOne(idx, callback);\n  }\n  isRecording() {\n    return this.wrapper.IS_RECORDING;\n  }\n  get unorderedGroups() {\n    return this._unorderedGroups;\n  }\n  getRuleStack() {\n    return this.wrapper.RULE_STACK;\n  }\n  finalize() {\n    this.wrapper.wrapSelfAnalysis();\n  }\n};\nvar LangiumParser = class extends AbstractLangiumParser {\n  static {\n    __name(this, \"LangiumParser\");\n  }\n  get current() {\n    return this.stack[this.stack.length - 1];\n  }\n  constructor(services) {\n    super(services);\n    this.nodeBuilder = new CstNodeBuilder();\n    this.stack = [];\n    this.assignmentMap = /* @__PURE__ */ new Map();\n    this.linker = services.references.Linker;\n    this.converter = services.parser.ValueConverter;\n    this.astReflection = services.shared.AstReflection;\n  }\n  rule(rule, impl) {\n    const type = rule.fragment ? void 0 : isDataTypeRule(rule) ? DatatypeSymbol : getTypeName(rule);\n    const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(type, impl).bind(this));\n    if (rule.entry) {\n      this.mainRule = ruleMethod;\n    }\n    return ruleMethod;\n  }\n  parse(input) {\n    this.nodeBuilder.buildRootNode(input);\n    const lexerResult = this.lexer.tokenize(input);\n    this.wrapper.input = lexerResult.tokens;\n    const result = this.mainRule.call(this.wrapper, {});\n    this.nodeBuilder.addHiddenTokens(lexerResult.hidden);\n    this.unorderedGroups.clear();\n    return {\n      value: result,\n      lexerErrors: lexerResult.errors,\n      parserErrors: this.wrapper.errors\n    };\n  }\n  startImplementation($type, implementation) {\n    return (args) => {\n      if (!this.isRecording()) {\n        const node = { $type };\n        this.stack.push(node);\n        if ($type === DatatypeSymbol) {\n          node.value = \"\";\n        }\n      }\n      let result;\n      try {\n        result = implementation(args);\n      } catch (err) {\n        result = void 0;\n      }\n      if (!this.isRecording() && result === void 0) {\n        result = this.construct();\n      }\n      return result;\n    };\n  }\n  consume(idx, tokenType, feature) {\n    const token = this.wrapper.wrapConsume(idx, tokenType);\n    if (!this.isRecording() && this.isValidToken(token)) {\n      const leafNode = this.nodeBuilder.buildLeafNode(token, feature);\n      const { assignment, isCrossRef } = this.getAssignment(feature);\n      const current = this.current;\n      if (assignment) {\n        const convertedValue = isKeyword(feature) ? token.image : this.converter.convert(token.image, leafNode);\n        this.assign(assignment.operator, assignment.feature, convertedValue, leafNode, isCrossRef);\n      } else if (isDataTypeNode(current)) {\n        let text = token.image;\n        if (!isKeyword(feature)) {\n          text = this.converter.convert(text, leafNode).toString();\n        }\n        current.value += text;\n      }\n    }\n  }\n  /**\n   * Most consumed parser tokens are valid. However there are two cases in which they are not valid:\n   *\n   * 1. They were inserted during error recovery by the parser. These tokens don't really exist and should not be further processed\n   * 2. They contain invalid token ranges. This might include the special EOF token, or other tokens produced by invalid token builders.\n   */\n  isValidToken(token) {\n    return !token.isInsertedInRecovery && !isNaN(token.startOffset) && typeof token.endOffset === \"number\" && !isNaN(token.endOffset);\n  }\n  subrule(idx, rule, feature, args) {\n    let cstNode;\n    if (!this.isRecording()) {\n      cstNode = this.nodeBuilder.buildCompositeNode(feature);\n    }\n    const subruleResult = this.wrapper.wrapSubrule(idx, rule, args);\n    if (!this.isRecording() && cstNode && cstNode.length > 0) {\n      this.performSubruleAssignment(subruleResult, feature, cstNode);\n    }\n  }\n  performSubruleAssignment(result, feature, cstNode) {\n    const { assignment, isCrossRef } = this.getAssignment(feature);\n    if (assignment) {\n      this.assign(assignment.operator, assignment.feature, result, cstNode, isCrossRef);\n    } else if (!assignment) {\n      const current = this.current;\n      if (isDataTypeNode(current)) {\n        current.value += result.toString();\n      } else if (typeof result === \"object\" && result) {\n        const resultKind = result.$type;\n        const object = this.assignWithoutOverride(result, current);\n        if (resultKind) {\n          object.$type = resultKind;\n        }\n        const newItem = object;\n        this.stack.pop();\n        this.stack.push(newItem);\n      }\n    }\n  }\n  action($type, action) {\n    if (!this.isRecording()) {\n      let last = this.current;\n      if (!last.$cstNode && action.feature && action.operator) {\n        last = this.construct(false);\n        const feature = last.$cstNode.feature;\n        this.nodeBuilder.buildCompositeNode(feature);\n      }\n      const newItem = { $type };\n      this.stack.pop();\n      this.stack.push(newItem);\n      if (action.feature && action.operator) {\n        this.assign(action.operator, action.feature, last, last.$cstNode, false);\n      }\n    }\n  }\n  construct(pop = true) {\n    if (this.isRecording()) {\n      return void 0;\n    }\n    const obj = this.current;\n    linkContentToContainer(obj);\n    this.nodeBuilder.construct(obj);\n    if (pop) {\n      this.stack.pop();\n    }\n    if (isDataTypeNode(obj)) {\n      return this.converter.convert(obj.value, obj.$cstNode);\n    } else {\n      assignMandatoryProperties(this.astReflection, obj);\n    }\n    return obj;\n  }\n  getAssignment(feature) {\n    if (!this.assignmentMap.has(feature)) {\n      const assignment = getContainerOfType(feature, isAssignment);\n      this.assignmentMap.set(feature, {\n        assignment,\n        isCrossRef: assignment ? isCrossReference(assignment.terminal) : false\n      });\n    }\n    return this.assignmentMap.get(feature);\n  }\n  assign(operator, feature, value, cstNode, isCrossRef) {\n    const obj = this.current;\n    let item;\n    if (isCrossRef && typeof value === \"string\") {\n      item = this.linker.buildReference(obj, feature, cstNode, value);\n    } else {\n      item = value;\n    }\n    switch (operator) {\n      case \"=\": {\n        obj[feature] = item;\n        break;\n      }\n      case \"?=\": {\n        obj[feature] = true;\n        break;\n      }\n      case \"+=\": {\n        if (!Array.isArray(obj[feature])) {\n          obj[feature] = [];\n        }\n        obj[feature].push(item);\n      }\n    }\n  }\n  assignWithoutOverride(target, source) {\n    for (const [name, existingValue] of Object.entries(source)) {\n      const newValue = target[name];\n      if (newValue === void 0) {\n        target[name] = existingValue;\n      } else if (Array.isArray(newValue) && Array.isArray(existingValue)) {\n        existingValue.push(...newValue);\n        target[name] = existingValue;\n      }\n    }\n    return target;\n  }\n  get definitionErrors() {\n    return this.wrapper.definitionErrors;\n  }\n};\nvar AbstractParserErrorMessageProvider = class {\n  static {\n    __name(this, \"AbstractParserErrorMessageProvider\");\n  }\n  buildMismatchTokenMessage(options) {\n    return defaultParserErrorProvider.buildMismatchTokenMessage(options);\n  }\n  buildNotAllInputParsedMessage(options) {\n    return defaultParserErrorProvider.buildNotAllInputParsedMessage(options);\n  }\n  buildNoViableAltMessage(options) {\n    return defaultParserErrorProvider.buildNoViableAltMessage(options);\n  }\n  buildEarlyExitMessage(options) {\n    return defaultParserErrorProvider.buildEarlyExitMessage(options);\n  }\n};\nvar LangiumParserErrorMessageProvider = class extends AbstractParserErrorMessageProvider {\n  static {\n    __name(this, \"LangiumParserErrorMessageProvider\");\n  }\n  buildMismatchTokenMessage({ expected, actual }) {\n    const expectedMsg = expected.LABEL ? \"`\" + expected.LABEL + \"`\" : expected.name.endsWith(\":KW\") ? `keyword '${expected.name.substring(0, expected.name.length - 3)}'` : `token of type '${expected.name}'`;\n    return `Expecting ${expectedMsg} but found \\`${actual.image}\\`.`;\n  }\n  buildNotAllInputParsedMessage({ firstRedundant }) {\n    return `Expecting end of file but found \\`${firstRedundant.image}\\`.`;\n  }\n};\nvar LangiumCompletionParser = class extends AbstractLangiumParser {\n  static {\n    __name(this, \"LangiumCompletionParser\");\n  }\n  constructor() {\n    super(...arguments);\n    this.tokens = [];\n    this.elementStack = [];\n    this.lastElementStack = [];\n    this.nextTokenIndex = 0;\n    this.stackSize = 0;\n  }\n  action() {\n  }\n  construct() {\n    return void 0;\n  }\n  parse(input) {\n    this.resetState();\n    const tokens = this.lexer.tokenize(input);\n    this.tokens = tokens.tokens;\n    this.wrapper.input = [...this.tokens];\n    this.mainRule.call(this.wrapper, {});\n    this.unorderedGroups.clear();\n    return {\n      tokens: this.tokens,\n      elementStack: [...this.lastElementStack],\n      tokenIndex: this.nextTokenIndex\n    };\n  }\n  rule(rule, impl) {\n    const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(impl).bind(this));\n    if (rule.entry) {\n      this.mainRule = ruleMethod;\n    }\n    return ruleMethod;\n  }\n  resetState() {\n    this.elementStack = [];\n    this.lastElementStack = [];\n    this.nextTokenIndex = 0;\n    this.stackSize = 0;\n  }\n  startImplementation(implementation) {\n    return (args) => {\n      const size = this.keepStackSize();\n      try {\n        implementation(args);\n      } finally {\n        this.resetStackSize(size);\n      }\n    };\n  }\n  removeUnexpectedElements() {\n    this.elementStack.splice(this.stackSize);\n  }\n  keepStackSize() {\n    const size = this.elementStack.length;\n    this.stackSize = size;\n    return size;\n  }\n  resetStackSize(size) {\n    this.removeUnexpectedElements();\n    this.stackSize = size;\n  }\n  consume(idx, tokenType, feature) {\n    this.wrapper.wrapConsume(idx, tokenType);\n    if (!this.isRecording()) {\n      this.lastElementStack = [...this.elementStack, feature];\n      this.nextTokenIndex = this.currIdx + 1;\n    }\n  }\n  subrule(idx, rule, feature, args) {\n    this.before(feature);\n    this.wrapper.wrapSubrule(idx, rule, args);\n    this.after(feature);\n  }\n  before(element) {\n    if (!this.isRecording()) {\n      this.elementStack.push(element);\n    }\n  }\n  after(element) {\n    if (!this.isRecording()) {\n      const index = this.elementStack.lastIndexOf(element);\n      if (index >= 0) {\n        this.elementStack.splice(index);\n      }\n    }\n  }\n  get currIdx() {\n    return this.wrapper.currIdx;\n  }\n};\nvar defaultConfig = {\n  recoveryEnabled: true,\n  nodeLocationTracking: \"full\",\n  skipValidations: true,\n  errorMessageProvider: new LangiumParserErrorMessageProvider()\n};\nvar ChevrotainWrapper = class extends EmbeddedActionsParser {\n  static {\n    __name(this, \"ChevrotainWrapper\");\n  }\n  constructor(tokens, config) {\n    const useDefaultLookahead = config && \"maxLookahead\" in config;\n    super(tokens, Object.assign(Object.assign(Object.assign({}, defaultConfig), { lookaheadStrategy: useDefaultLookahead ? new LLkLookaheadStrategy({ maxLookahead: config.maxLookahead }) : new LLStarLookaheadStrategy() }), config));\n  }\n  get IS_RECORDING() {\n    return this.RECORDING_PHASE;\n  }\n  DEFINE_RULE(name, impl) {\n    return this.RULE(name, impl);\n  }\n  wrapSelfAnalysis() {\n    this.performSelfAnalysis();\n  }\n  wrapConsume(idx, tokenType) {\n    return this.consume(idx, tokenType);\n  }\n  wrapSubrule(idx, rule, args) {\n    return this.subrule(idx, rule, {\n      ARGS: [args]\n    });\n  }\n  wrapOr(idx, choices) {\n    this.or(idx, choices);\n  }\n  wrapOption(idx, callback) {\n    this.option(idx, callback);\n  }\n  wrapMany(idx, callback) {\n    this.many(idx, callback);\n  }\n  wrapAtLeastOne(idx, callback) {\n    this.atLeastOne(idx, callback);\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/parser/parser-builder-base.js\nfunction createParser(grammar, parser, tokens) {\n  const rules = /* @__PURE__ */ new Map();\n  const parserContext = {\n    parser,\n    tokens,\n    rules,\n    ruleNames: /* @__PURE__ */ new Map()\n  };\n  buildRules(parserContext, grammar);\n  return parser;\n}\n__name(createParser, \"createParser\");\nfunction buildRules(parserContext, grammar) {\n  const reachable = getAllReachableRules(grammar, false);\n  const parserRules = stream(grammar.rules).filter(isParserRule).filter((rule) => reachable.has(rule));\n  for (const rule of parserRules) {\n    const ctx = Object.assign(Object.assign({}, parserContext), { consume: 1, optional: 1, subrule: 1, many: 1, or: 1 });\n    ctx.rules.set(rule.name, parserContext.parser.rule(rule, buildElement(ctx, rule.definition)));\n  }\n}\n__name(buildRules, \"buildRules\");\nfunction buildElement(ctx, element, ignoreGuard = false) {\n  let method;\n  if (isKeyword(element)) {\n    method = buildKeyword(ctx, element);\n  } else if (isAction(element)) {\n    method = buildAction(ctx, element);\n  } else if (isAssignment(element)) {\n    method = buildElement(ctx, element.terminal);\n  } else if (isCrossReference(element)) {\n    method = buildCrossReference(ctx, element);\n  } else if (isRuleCall(element)) {\n    method = buildRuleCall(ctx, element);\n  } else if (isAlternatives(element)) {\n    method = buildAlternatives(ctx, element);\n  } else if (isUnorderedGroup(element)) {\n    method = buildUnorderedGroup(ctx, element);\n  } else if (isGroup(element)) {\n    method = buildGroup(ctx, element);\n  } else if (isEndOfFile(element)) {\n    const idx = ctx.consume++;\n    method = /* @__PURE__ */ __name(() => ctx.parser.consume(idx, EOF, element), \"method\");\n  } else {\n    throw new ErrorWithLocation(element.$cstNode, `Unexpected element type: ${element.$type}`);\n  }\n  return wrap(ctx, ignoreGuard ? void 0 : getGuardCondition(element), method, element.cardinality);\n}\n__name(buildElement, \"buildElement\");\nfunction buildAction(ctx, action) {\n  const actionType = getTypeName(action);\n  return () => ctx.parser.action(actionType, action);\n}\n__name(buildAction, \"buildAction\");\nfunction buildRuleCall(ctx, ruleCall) {\n  const rule = ruleCall.rule.ref;\n  if (isParserRule(rule)) {\n    const idx = ctx.subrule++;\n    const predicate = ruleCall.arguments.length > 0 ? buildRuleCallPredicate(rule, ruleCall.arguments) : () => ({});\n    return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), ruleCall, predicate(args));\n  } else if (isTerminalRule(rule)) {\n    const idx = ctx.consume++;\n    const method = getToken(ctx, rule.name);\n    return () => ctx.parser.consume(idx, method, ruleCall);\n  } else if (!rule) {\n    throw new ErrorWithLocation(ruleCall.$cstNode, `Undefined rule type: ${ruleCall.$type}`);\n  } else {\n    assertUnreachable(rule);\n  }\n}\n__name(buildRuleCall, \"buildRuleCall\");\nfunction buildRuleCallPredicate(rule, namedArgs) {\n  const predicates = namedArgs.map((e) => buildPredicate(e.value));\n  return (args) => {\n    const ruleArgs = {};\n    for (let i = 0; i < predicates.length; i++) {\n      const ruleTarget = rule.parameters[i];\n      const predicate = predicates[i];\n      ruleArgs[ruleTarget.name] = predicate(args);\n    }\n    return ruleArgs;\n  };\n}\n__name(buildRuleCallPredicate, \"buildRuleCallPredicate\");\nfunction buildPredicate(condition) {\n  if (isDisjunction(condition)) {\n    const left = buildPredicate(condition.left);\n    const right = buildPredicate(condition.right);\n    return (args) => left(args) || right(args);\n  } else if (isConjunction(condition)) {\n    const left = buildPredicate(condition.left);\n    const right = buildPredicate(condition.right);\n    return (args) => left(args) && right(args);\n  } else if (isNegation(condition)) {\n    const value = buildPredicate(condition.value);\n    return (args) => !value(args);\n  } else if (isParameterReference(condition)) {\n    const name = condition.parameter.ref.name;\n    return (args) => args !== void 0 && args[name] === true;\n  } else if (isBooleanLiteral(condition)) {\n    const value = Boolean(condition.true);\n    return () => value;\n  }\n  assertUnreachable(condition);\n}\n__name(buildPredicate, \"buildPredicate\");\nfunction buildAlternatives(ctx, alternatives) {\n  if (alternatives.elements.length === 1) {\n    return buildElement(ctx, alternatives.elements[0]);\n  } else {\n    const methods = [];\n    for (const element of alternatives.elements) {\n      const predicatedMethod = {\n        // Since we handle the guard condition in the alternative already\n        // We can ignore the group guard condition inside\n        ALT: buildElement(ctx, element, true)\n      };\n      const guard = getGuardCondition(element);\n      if (guard) {\n        predicatedMethod.GATE = buildPredicate(guard);\n      }\n      methods.push(predicatedMethod);\n    }\n    const idx = ctx.or++;\n    return (args) => ctx.parser.alternatives(idx, methods.map((method) => {\n      const alt = {\n        ALT: /* @__PURE__ */ __name(() => method.ALT(args), \"ALT\")\n      };\n      const gate = method.GATE;\n      if (gate) {\n        alt.GATE = () => gate(args);\n      }\n      return alt;\n    }));\n  }\n}\n__name(buildAlternatives, \"buildAlternatives\");\nfunction buildUnorderedGroup(ctx, group) {\n  if (group.elements.length === 1) {\n    return buildElement(ctx, group.elements[0]);\n  }\n  const methods = [];\n  for (const element of group.elements) {\n    const predicatedMethod = {\n      // Since we handle the guard condition in the alternative already\n      // We can ignore the group guard condition inside\n      ALT: buildElement(ctx, element, true)\n    };\n    const guard = getGuardCondition(element);\n    if (guard) {\n      predicatedMethod.GATE = buildPredicate(guard);\n    }\n    methods.push(predicatedMethod);\n  }\n  const orIdx = ctx.or++;\n  const idFunc = /* @__PURE__ */ __name((groupIdx, lParser) => {\n    const stackId = lParser.getRuleStack().join(\"-\");\n    return `uGroup_${groupIdx}_${stackId}`;\n  }, \"idFunc\");\n  const alternatives = /* @__PURE__ */ __name((args) => ctx.parser.alternatives(orIdx, methods.map((method, idx) => {\n    const alt = { ALT: /* @__PURE__ */ __name(() => true, \"ALT\") };\n    const parser = ctx.parser;\n    alt.ALT = () => {\n      method.ALT(args);\n      if (!parser.isRecording()) {\n        const key = idFunc(orIdx, parser);\n        if (!parser.unorderedGroups.get(key)) {\n          parser.unorderedGroups.set(key, []);\n        }\n        const groupState = parser.unorderedGroups.get(key);\n        if (typeof (groupState === null || groupState === void 0 ? void 0 : groupState[idx]) === \"undefined\") {\n          groupState[idx] = true;\n        }\n      }\n    };\n    const gate = method.GATE;\n    if (gate) {\n      alt.GATE = () => gate(args);\n    } else {\n      alt.GATE = () => {\n        const trackedAlternatives = parser.unorderedGroups.get(idFunc(orIdx, parser));\n        const allow = !(trackedAlternatives === null || trackedAlternatives === void 0 ? void 0 : trackedAlternatives[idx]);\n        return allow;\n      };\n    }\n    return alt;\n  })), \"alternatives\");\n  const wrapped = wrap(ctx, getGuardCondition(group), alternatives, \"*\");\n  return (args) => {\n    wrapped(args);\n    if (!ctx.parser.isRecording()) {\n      ctx.parser.unorderedGroups.delete(idFunc(orIdx, ctx.parser));\n    }\n  };\n}\n__name(buildUnorderedGroup, \"buildUnorderedGroup\");\nfunction buildGroup(ctx, group) {\n  const methods = group.elements.map((e) => buildElement(ctx, e));\n  return (args) => methods.forEach((method) => method(args));\n}\n__name(buildGroup, \"buildGroup\");\nfunction getGuardCondition(element) {\n  if (isGroup(element)) {\n    return element.guardCondition;\n  }\n  return void 0;\n}\n__name(getGuardCondition, \"getGuardCondition\");\nfunction buildCrossReference(ctx, crossRef, terminal = crossRef.terminal) {\n  if (!terminal) {\n    if (!crossRef.type.ref) {\n      throw new Error(\"Could not resolve reference to type: \" + crossRef.type.$refText);\n    }\n    const assignment = findNameAssignment(crossRef.type.ref);\n    const assignTerminal = assignment === null || assignment === void 0 ? void 0 : assignment.terminal;\n    if (!assignTerminal) {\n      throw new Error(\"Could not find name assignment for type: \" + getTypeName(crossRef.type.ref));\n    }\n    return buildCrossReference(ctx, crossRef, assignTerminal);\n  } else if (isRuleCall(terminal) && isParserRule(terminal.rule.ref)) {\n    const idx = ctx.subrule++;\n    return (args) => ctx.parser.subrule(idx, getRule(ctx, terminal.rule.ref), crossRef, args);\n  } else if (isRuleCall(terminal) && isTerminalRule(terminal.rule.ref)) {\n    const idx = ctx.consume++;\n    const terminalRule = getToken(ctx, terminal.rule.ref.name);\n    return () => ctx.parser.consume(idx, terminalRule, crossRef);\n  } else if (isKeyword(terminal)) {\n    const idx = ctx.consume++;\n    const keyword = getToken(ctx, terminal.value);\n    return () => ctx.parser.consume(idx, keyword, crossRef);\n  } else {\n    throw new Error(\"Could not build cross reference parser\");\n  }\n}\n__name(buildCrossReference, \"buildCrossReference\");\nfunction buildKeyword(ctx, keyword) {\n  const idx = ctx.consume++;\n  const token = ctx.tokens[keyword.value];\n  if (!token) {\n    throw new Error(\"Could not find token for keyword: \" + keyword.value);\n  }\n  return () => ctx.parser.consume(idx, token, keyword);\n}\n__name(buildKeyword, \"buildKeyword\");\nfunction wrap(ctx, guard, method, cardinality) {\n  const gate = guard && buildPredicate(guard);\n  if (!cardinality) {\n    if (gate) {\n      const idx = ctx.or++;\n      return (args) => ctx.parser.alternatives(idx, [\n        {\n          ALT: /* @__PURE__ */ __name(() => method(args), \"ALT\"),\n          GATE: /* @__PURE__ */ __name(() => gate(args), \"GATE\")\n        },\n        {\n          ALT: EMPTY_ALT(),\n          GATE: /* @__PURE__ */ __name(() => !gate(args), \"GATE\")\n        }\n      ]);\n    } else {\n      return method;\n    }\n  }\n  if (cardinality === \"*\") {\n    const idx = ctx.many++;\n    return (args) => ctx.parser.many(idx, {\n      DEF: /* @__PURE__ */ __name(() => method(args), \"DEF\"),\n      GATE: gate ? () => gate(args) : void 0\n    });\n  } else if (cardinality === \"+\") {\n    const idx = ctx.many++;\n    if (gate) {\n      const orIdx = ctx.or++;\n      return (args) => ctx.parser.alternatives(orIdx, [\n        {\n          ALT: /* @__PURE__ */ __name(() => ctx.parser.atLeastOne(idx, {\n            DEF: /* @__PURE__ */ __name(() => method(args), \"DEF\")\n          }), \"ALT\"),\n          GATE: /* @__PURE__ */ __name(() => gate(args), \"GATE\")\n        },\n        {\n          ALT: EMPTY_ALT(),\n          GATE: /* @__PURE__ */ __name(() => !gate(args), \"GATE\")\n        }\n      ]);\n    } else {\n      return (args) => ctx.parser.atLeastOne(idx, {\n        DEF: /* @__PURE__ */ __name(() => method(args), \"DEF\")\n      });\n    }\n  } else if (cardinality === \"?\") {\n    const idx = ctx.optional++;\n    return (args) => ctx.parser.optional(idx, {\n      DEF: /* @__PURE__ */ __name(() => method(args), \"DEF\"),\n      GATE: gate ? () => gate(args) : void 0\n    });\n  } else {\n    assertUnreachable(cardinality);\n  }\n}\n__name(wrap, \"wrap\");\nfunction getRule(ctx, element) {\n  const name = getRuleName(ctx, element);\n  const rule = ctx.rules.get(name);\n  if (!rule)\n    throw new Error(`Rule \"${name}\" not found.\"`);\n  return rule;\n}\n__name(getRule, \"getRule\");\nfunction getRuleName(ctx, element) {\n  if (isParserRule(element)) {\n    return element.name;\n  } else if (ctx.ruleNames.has(element)) {\n    return ctx.ruleNames.get(element);\n  } else {\n    let item = element;\n    let parent = item.$container;\n    let ruleName = element.$type;\n    while (!isParserRule(parent)) {\n      if (isGroup(parent) || isAlternatives(parent) || isUnorderedGroup(parent)) {\n        const index = parent.elements.indexOf(item);\n        ruleName = index.toString() + \":\" + ruleName;\n      }\n      item = parent;\n      parent = parent.$container;\n    }\n    const rule = parent;\n    ruleName = rule.name + \":\" + ruleName;\n    ctx.ruleNames.set(element, ruleName);\n    return ruleName;\n  }\n}\n__name(getRuleName, \"getRuleName\");\nfunction getToken(ctx, name) {\n  const token = ctx.tokens[name];\n  if (!token)\n    throw new Error(`Token \"${name}\" not found.\"`);\n  return token;\n}\n__name(getToken, \"getToken\");\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/parser/completion-parser-builder.js\nfunction createCompletionParser(services) {\n  const grammar = services.Grammar;\n  const lexer = services.parser.Lexer;\n  const parser = new LangiumCompletionParser(services);\n  createParser(grammar, parser, lexer.definition);\n  parser.finalize();\n  return parser;\n}\n__name(createCompletionParser, \"createCompletionParser\");\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/parser/langium-parser-builder.js\nfunction createLangiumParser(services) {\n  const parser = prepareLangiumParser(services);\n  parser.finalize();\n  return parser;\n}\n__name(createLangiumParser, \"createLangiumParser\");\nfunction prepareLangiumParser(services) {\n  const grammar = services.Grammar;\n  const lexer = services.parser.Lexer;\n  const parser = new LangiumParser(services);\n  return createParser(grammar, parser, lexer.definition);\n}\n__name(prepareLangiumParser, \"prepareLangiumParser\");\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/parser/token-builder.js\nvar DefaultTokenBuilder = class {\n  static {\n    __name(this, \"DefaultTokenBuilder\");\n  }\n  buildTokens(grammar, options) {\n    const reachableRules = stream(getAllReachableRules(grammar, false));\n    const terminalTokens = this.buildTerminalTokens(reachableRules);\n    const tokens = this.buildKeywordTokens(reachableRules, terminalTokens, options);\n    terminalTokens.forEach((terminalToken) => {\n      const pattern = terminalToken.PATTERN;\n      if (typeof pattern === \"object\" && pattern && \"test\" in pattern && isWhitespace(pattern)) {\n        tokens.unshift(terminalToken);\n      } else {\n        tokens.push(terminalToken);\n      }\n    });\n    return tokens;\n  }\n  buildTerminalTokens(rules) {\n    return rules.filter(isTerminalRule).filter((e) => !e.fragment).map((terminal) => this.buildTerminalToken(terminal)).toArray();\n  }\n  buildTerminalToken(terminal) {\n    const regex = terminalRegex(terminal);\n    const pattern = this.requiresCustomPattern(regex) ? this.regexPatternFunction(regex) : regex;\n    const tokenType = {\n      name: terminal.name,\n      PATTERN: pattern,\n      LINE_BREAKS: true\n    };\n    if (terminal.hidden) {\n      tokenType.GROUP = isWhitespace(regex) ? Lexer.SKIPPED : \"hidden\";\n    }\n    return tokenType;\n  }\n  requiresCustomPattern(regex) {\n    if (regex.flags.includes(\"u\")) {\n      return true;\n    } else if (regex.source.includes(\"?<=\") || regex.source.includes(\"?<!\")) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  regexPatternFunction(regex) {\n    const stickyRegex = new RegExp(regex, regex.flags + \"y\");\n    return (text, offset) => {\n      stickyRegex.lastIndex = offset;\n      const execResult = stickyRegex.exec(text);\n      return execResult;\n    };\n  }\n  buildKeywordTokens(rules, terminalTokens, options) {\n    return rules.filter(isParserRule).flatMap((rule) => streamAllContents(rule).filter(isKeyword)).distinct((e) => e.value).toArray().sort((a, b) => b.value.length - a.value.length).map((keyword) => this.buildKeywordToken(keyword, terminalTokens, Boolean(options === null || options === void 0 ? void 0 : options.caseInsensitive)));\n  }\n  buildKeywordToken(keyword, terminalTokens, caseInsensitive) {\n    return {\n      name: keyword.value,\n      PATTERN: this.buildKeywordPattern(keyword, caseInsensitive),\n      LONGER_ALT: this.findLongerAlt(keyword, terminalTokens)\n    };\n  }\n  buildKeywordPattern(keyword, caseInsensitive) {\n    return caseInsensitive ? new RegExp(getCaseInsensitivePattern(keyword.value)) : keyword.value;\n  }\n  findLongerAlt(keyword, terminalTokens) {\n    return terminalTokens.reduce((longerAlts, token) => {\n      const pattern = token === null || token === void 0 ? void 0 : token.PATTERN;\n      if ((pattern === null || pattern === void 0 ? void 0 : pattern.source) && partialMatches(\"^\" + pattern.source + \"$\", keyword.value)) {\n        longerAlts.push(token);\n      }\n      return longerAlts;\n    }, []);\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/parser/value-converter.js\nvar DefaultValueConverter = class {\n  static {\n    __name(this, \"DefaultValueConverter\");\n  }\n  convert(input, cstNode) {\n    let feature = cstNode.grammarSource;\n    if (isCrossReference(feature)) {\n      feature = getCrossReferenceTerminal(feature);\n    }\n    if (isRuleCall(feature)) {\n      const rule = feature.rule.ref;\n      if (!rule) {\n        throw new Error(\"This cst node was not parsed by a rule.\");\n      }\n      return this.runConverter(rule, input, cstNode);\n    }\n    return input;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  runConverter(rule, input, cstNode) {\n    var _a;\n    switch (rule.name.toUpperCase()) {\n      case \"INT\":\n        return ValueConverter.convertInt(input);\n      case \"STRING\":\n        return ValueConverter.convertString(input);\n      case \"ID\":\n        return ValueConverter.convertID(input);\n    }\n    switch ((_a = getRuleType(rule)) === null || _a === void 0 ? void 0 : _a.toLowerCase()) {\n      case \"number\":\n        return ValueConverter.convertNumber(input);\n      case \"boolean\":\n        return ValueConverter.convertBoolean(input);\n      case \"bigint\":\n        return ValueConverter.convertBigint(input);\n      case \"date\":\n        return ValueConverter.convertDate(input);\n      default:\n        return input;\n    }\n  }\n};\nvar ValueConverter;\n(function(ValueConverter2) {\n  function convertString(input) {\n    let result = \"\";\n    for (let i = 1; i < input.length - 1; i++) {\n      const c = input.charAt(i);\n      if (c === \"\\\\\") {\n        const c1 = input.charAt(++i);\n        result += convertEscapeCharacter(c1);\n      } else {\n        result += c;\n      }\n    }\n    return result;\n  }\n  __name(convertString, \"convertString\");\n  ValueConverter2.convertString = convertString;\n  function convertEscapeCharacter(char) {\n    switch (char) {\n      case \"b\":\n        return \"\\b\";\n      case \"f\":\n        return \"\\f\";\n      case \"n\":\n        return \"\\n\";\n      case \"r\":\n        return \"\\r\";\n      case \"t\":\n        return \"\t\";\n      case \"v\":\n        return \"\\v\";\n      case \"0\":\n        return \"\\0\";\n      default:\n        return char;\n    }\n  }\n  __name(convertEscapeCharacter, \"convertEscapeCharacter\");\n  function convertID(input) {\n    if (input.charAt(0) === \"^\") {\n      return input.substring(1);\n    } else {\n      return input;\n    }\n  }\n  __name(convertID, \"convertID\");\n  ValueConverter2.convertID = convertID;\n  function convertInt(input) {\n    return parseInt(input);\n  }\n  __name(convertInt, \"convertInt\");\n  ValueConverter2.convertInt = convertInt;\n  function convertBigint(input) {\n    return BigInt(input);\n  }\n  __name(convertBigint, \"convertBigint\");\n  ValueConverter2.convertBigint = convertBigint;\n  function convertDate(input) {\n    return new Date(input);\n  }\n  __name(convertDate, \"convertDate\");\n  ValueConverter2.convertDate = convertDate;\n  function convertNumber(input) {\n    return Number(input);\n  }\n  __name(convertNumber, \"convertNumber\");\n  ValueConverter2.convertNumber = convertNumber;\n  function convertBoolean(input) {\n    return input.toLowerCase() === \"true\";\n  }\n  __name(convertBoolean, \"convertBoolean\");\n  ValueConverter2.convertBoolean = convertBoolean;\n})(ValueConverter || (ValueConverter = {}));\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/cancellation.js\nvar cancellation_exports = {};\n__reExport(cancellation_exports, __toESM(require_cancellation(), 1));\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/promise-utils.js\nfunction delayNextTick() {\n  return new Promise((resolve) => {\n    if (typeof setImmediate === \"undefined\") {\n      setTimeout(resolve, 0);\n    } else {\n      setImmediate(resolve);\n    }\n  });\n}\n__name(delayNextTick, \"delayNextTick\");\nvar lastTick = 0;\nvar globalInterruptionPeriod = 10;\nfunction startCancelableOperation() {\n  lastTick = Date.now();\n  return new cancellation_exports.CancellationTokenSource();\n}\n__name(startCancelableOperation, \"startCancelableOperation\");\nfunction setInterruptionPeriod(period) {\n  globalInterruptionPeriod = period;\n}\n__name(setInterruptionPeriod, \"setInterruptionPeriod\");\nvar OperationCancelled = Symbol(\"OperationCancelled\");\nfunction isOperationCancelled(err) {\n  return err === OperationCancelled;\n}\n__name(isOperationCancelled, \"isOperationCancelled\");\nasync function interruptAndCheck(token) {\n  if (token === cancellation_exports.CancellationToken.None) {\n    return;\n  }\n  const current = Date.now();\n  if (current - lastTick >= globalInterruptionPeriod) {\n    lastTick = current;\n    await delayNextTick();\n  }\n  if (token.isCancellationRequested) {\n    throw OperationCancelled;\n  }\n}\n__name(interruptAndCheck, \"interruptAndCheck\");\nvar Deferred = class {\n  static {\n    __name(this, \"Deferred\");\n  }\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = (arg) => {\n        resolve(arg);\n        return this;\n      };\n      this.reject = (err) => {\n        reject(err);\n        return this;\n      };\n    });\n  }\n};\n\n// ../../node_modules/.pnpm/vscode-languageserver-textdocument@1.0.12/node_modules/vscode-languageserver-textdocument/lib/esm/main.js\nvar FullTextDocument2 = class _FullTextDocument {\n  static {\n    __name(this, \"FullTextDocument\");\n  }\n  constructor(uri, languageId, version, content) {\n    this._uri = uri;\n    this._languageId = languageId;\n    this._version = version;\n    this._content = content;\n    this._lineOffsets = void 0;\n  }\n  get uri() {\n    return this._uri;\n  }\n  get languageId() {\n    return this._languageId;\n  }\n  get version() {\n    return this._version;\n  }\n  getText(range) {\n    if (range) {\n      const start = this.offsetAt(range.start);\n      const end = this.offsetAt(range.end);\n      return this._content.substring(start, end);\n    }\n    return this._content;\n  }\n  update(changes, version) {\n    for (const change of changes) {\n      if (_FullTextDocument.isIncremental(change)) {\n        const range = getWellformedRange(change.range);\n        const startOffset = this.offsetAt(range.start);\n        const endOffset = this.offsetAt(range.end);\n        this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n        const startLine = Math.max(range.start.line, 0);\n        const endLine = Math.max(range.end.line, 0);\n        let lineOffsets = this._lineOffsets;\n        const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n        if (endLine - startLine === addedLineOffsets.length) {\n          for (let i = 0, len = addedLineOffsets.length; i < len; i++) {\n            lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n          }\n        } else {\n          if (addedLineOffsets.length < 1e4) {\n            lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);\n          } else {\n            this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n          }\n        }\n        const diff = change.text.length - (endOffset - startOffset);\n        if (diff !== 0) {\n          for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\n            lineOffsets[i] = lineOffsets[i] + diff;\n          }\n        }\n      } else if (_FullTextDocument.isFull(change)) {\n        this._content = change.text;\n        this._lineOffsets = void 0;\n      } else {\n        throw new Error(\"Unknown change event received\");\n      }\n    }\n    this._version = version;\n  }\n  getLineOffsets() {\n    if (this._lineOffsets === void 0) {\n      this._lineOffsets = computeLineOffsets(this._content, true);\n    }\n    return this._lineOffsets;\n  }\n  positionAt(offset) {\n    offset = Math.max(Math.min(offset, this._content.length), 0);\n    const lineOffsets = this.getLineOffsets();\n    let low = 0, high = lineOffsets.length;\n    if (high === 0) {\n      return { line: 0, character: offset };\n    }\n    while (low < high) {\n      const mid = Math.floor((low + high) / 2);\n      if (lineOffsets[mid] > offset) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n    const line = low - 1;\n    offset = this.ensureBeforeEOL(offset, lineOffsets[line]);\n    return { line, character: offset - lineOffsets[line] };\n  }\n  offsetAt(position) {\n    const lineOffsets = this.getLineOffsets();\n    if (position.line >= lineOffsets.length) {\n      return this._content.length;\n    } else if (position.line < 0) {\n      return 0;\n    }\n    const lineOffset = lineOffsets[position.line];\n    if (position.character <= 0) {\n      return lineOffset;\n    }\n    const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;\n    const offset = Math.min(lineOffset + position.character, nextLineOffset);\n    return this.ensureBeforeEOL(offset, lineOffset);\n  }\n  ensureBeforeEOL(offset, lineOffset) {\n    while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {\n      offset--;\n    }\n    return offset;\n  }\n  get lineCount() {\n    return this.getLineOffsets().length;\n  }\n  static isIncremental(event) {\n    const candidate = event;\n    return candidate !== void 0 && candidate !== null && typeof candidate.text === \"string\" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === \"number\");\n  }\n  static isFull(event) {\n    const candidate = event;\n    return candidate !== void 0 && candidate !== null && typeof candidate.text === \"string\" && candidate.range === void 0 && candidate.rangeLength === void 0;\n  }\n};\nvar TextDocument2;\n(function(TextDocument3) {\n  function create(uri, languageId, version, content) {\n    return new FullTextDocument2(uri, languageId, version, content);\n  }\n  __name(create, \"create\");\n  TextDocument3.create = create;\n  function update(document, changes, version) {\n    if (document instanceof FullTextDocument2) {\n      document.update(changes, version);\n      return document;\n    } else {\n      throw new Error(\"TextDocument.update: document must be created by TextDocument.create\");\n    }\n  }\n  __name(update, \"update\");\n  TextDocument3.update = update;\n  function applyEdits(document, edits) {\n    const text = document.getText();\n    const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {\n      const diff = a.range.start.line - b.range.start.line;\n      if (diff === 0) {\n        return a.range.start.character - b.range.start.character;\n      }\n      return diff;\n    });\n    let lastModifiedOffset = 0;\n    const spans = [];\n    for (const e of sortedEdits) {\n      const startOffset = document.offsetAt(e.range.start);\n      if (startOffset < lastModifiedOffset) {\n        throw new Error(\"Overlapping edit\");\n      } else if (startOffset > lastModifiedOffset) {\n        spans.push(text.substring(lastModifiedOffset, startOffset));\n      }\n      if (e.newText.length) {\n        spans.push(e.newText);\n      }\n      lastModifiedOffset = document.offsetAt(e.range.end);\n    }\n    spans.push(text.substr(lastModifiedOffset));\n    return spans.join(\"\");\n  }\n  __name(applyEdits, \"applyEdits\");\n  TextDocument3.applyEdits = applyEdits;\n})(TextDocument2 || (TextDocument2 = {}));\nfunction mergeSort(data, compare) {\n  if (data.length <= 1) {\n    return data;\n  }\n  const p = data.length / 2 | 0;\n  const left = data.slice(0, p);\n  const right = data.slice(p);\n  mergeSort(left, compare);\n  mergeSort(right, compare);\n  let leftIdx = 0;\n  let rightIdx = 0;\n  let i = 0;\n  while (leftIdx < left.length && rightIdx < right.length) {\n    const ret = compare(left[leftIdx], right[rightIdx]);\n    if (ret <= 0) {\n      data[i++] = left[leftIdx++];\n    } else {\n      data[i++] = right[rightIdx++];\n    }\n  }\n  while (leftIdx < left.length) {\n    data[i++] = left[leftIdx++];\n  }\n  while (rightIdx < right.length) {\n    data[i++] = right[rightIdx++];\n  }\n  return data;\n}\n__name(mergeSort, \"mergeSort\");\nfunction computeLineOffsets(text, isAtLineStart, textOffset = 0) {\n  const result = isAtLineStart ? [textOffset] : [];\n  for (let i = 0; i < text.length; i++) {\n    const ch = text.charCodeAt(i);\n    if (isEOL(ch)) {\n      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {\n        i++;\n      }\n      result.push(textOffset + i + 1);\n    }\n  }\n  return result;\n}\n__name(computeLineOffsets, \"computeLineOffsets\");\nfunction isEOL(char) {\n  return char === 13 || char === 10;\n}\n__name(isEOL, \"isEOL\");\nfunction getWellformedRange(range) {\n  const start = range.start;\n  const end = range.end;\n  if (start.line > end.line || start.line === end.line && start.character > end.character) {\n    return { start: end, end: start };\n  }\n  return range;\n}\n__name(getWellformedRange, \"getWellformedRange\");\nfunction getWellformedEdit(textEdit) {\n  const range = getWellformedRange(textEdit.range);\n  if (range !== textEdit.range) {\n    return { newText: textEdit.newText, range };\n  }\n  return textEdit;\n}\n__name(getWellformedEdit, \"getWellformedEdit\");\n\n// ../../node_modules/.pnpm/vscode-uri@3.0.8/node_modules/vscode-uri/lib/esm/index.mjs\nvar LIB;\n(() => {\n  \"use strict\";\n  var t = { 470: (t2) => {\n    function e2(t3) {\n      if (\"string\" != typeof t3) throw new TypeError(\"Path must be a string. Received \" + JSON.stringify(t3));\n    }\n    __name(e2, \"e\");\n    function r2(t3, e3) {\n      for (var r3, n3 = \"\", i = 0, o = -1, s = 0, h = 0; h <= t3.length; ++h) {\n        if (h < t3.length) r3 = t3.charCodeAt(h);\n        else {\n          if (47 === r3) break;\n          r3 = 47;\n        }\n        if (47 === r3) {\n          if (o === h - 1 || 1 === s) ;\n          else if (o !== h - 1 && 2 === s) {\n            if (n3.length < 2 || 2 !== i || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {\n              if (n3.length > 2) {\n                var a = n3.lastIndexOf(\"/\");\n                if (a !== n3.length - 1) {\n                  -1 === a ? (n3 = \"\", i = 0) : i = (n3 = n3.slice(0, a)).length - 1 - n3.lastIndexOf(\"/\"), o = h, s = 0;\n                  continue;\n                }\n              } else if (2 === n3.length || 1 === n3.length) {\n                n3 = \"\", i = 0, o = h, s = 0;\n                continue;\n              }\n            }\n            e3 && (n3.length > 0 ? n3 += \"/..\" : n3 = \"..\", i = 2);\n          } else n3.length > 0 ? n3 += \"/\" + t3.slice(o + 1, h) : n3 = t3.slice(o + 1, h), i = h - o - 1;\n          o = h, s = 0;\n        } else 46 === r3 && -1 !== s ? ++s : s = -1;\n      }\n      return n3;\n    }\n    __name(r2, \"r\");\n    var n2 = { resolve: /* @__PURE__ */ __name(function() {\n      for (var t3, n3 = \"\", i = false, o = arguments.length - 1; o >= -1 && !i; o--) {\n        var s;\n        o >= 0 ? s = arguments[o] : (void 0 === t3 && (t3 = process.cwd()), s = t3), e2(s), 0 !== s.length && (n3 = s + \"/\" + n3, i = 47 === s.charCodeAt(0));\n      }\n      return n3 = r2(n3, !i), i ? n3.length > 0 ? \"/\" + n3 : \"/\" : n3.length > 0 ? n3 : \".\";\n    }, \"resolve\"), normalize: /* @__PURE__ */ __name(function(t3) {\n      if (e2(t3), 0 === t3.length) return \".\";\n      var n3 = 47 === t3.charCodeAt(0), i = 47 === t3.charCodeAt(t3.length - 1);\n      return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = \".\"), t3.length > 0 && i && (t3 += \"/\"), n3 ? \"/\" + t3 : t3;\n    }, \"normalize\"), isAbsolute: /* @__PURE__ */ __name(function(t3) {\n      return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);\n    }, \"isAbsolute\"), join: /* @__PURE__ */ __name(function() {\n      if (0 === arguments.length) return \".\";\n      for (var t3, r3 = 0; r3 < arguments.length; ++r3) {\n        var i = arguments[r3];\n        e2(i), i.length > 0 && (void 0 === t3 ? t3 = i : t3 += \"/\" + i);\n      }\n      return void 0 === t3 ? \".\" : n2.normalize(t3);\n    }, \"join\"), relative: /* @__PURE__ */ __name(function(t3, r3) {\n      if (e2(t3), e2(r3), t3 === r3) return \"\";\n      if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3))) return \"\";\n      for (var i = 1; i < t3.length && 47 === t3.charCodeAt(i); ++i) ;\n      for (var o = t3.length, s = o - i, h = 1; h < r3.length && 47 === r3.charCodeAt(h); ++h) ;\n      for (var a = r3.length - h, c = s < a ? s : a, f = -1, u = 0; u <= c; ++u) {\n        if (u === c) {\n          if (a > c) {\n            if (47 === r3.charCodeAt(h + u)) return r3.slice(h + u + 1);\n            if (0 === u) return r3.slice(h + u);\n          } else s > c && (47 === t3.charCodeAt(i + u) ? f = u : 0 === u && (f = 0));\n          break;\n        }\n        var l = t3.charCodeAt(i + u);\n        if (l !== r3.charCodeAt(h + u)) break;\n        47 === l && (f = u);\n      }\n      var g = \"\";\n      for (u = i + f + 1; u <= o; ++u) u !== o && 47 !== t3.charCodeAt(u) || (0 === g.length ? g += \"..\" : g += \"/..\");\n      return g.length > 0 ? g + r3.slice(h + f) : (h += f, 47 === r3.charCodeAt(h) && ++h, r3.slice(h));\n    }, \"relative\"), _makeLong: /* @__PURE__ */ __name(function(t3) {\n      return t3;\n    }, \"_makeLong\"), dirname: /* @__PURE__ */ __name(function(t3) {\n      if (e2(t3), 0 === t3.length) return \".\";\n      for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, i = -1, o = true, s = t3.length - 1; s >= 1; --s) if (47 === (r3 = t3.charCodeAt(s))) {\n        if (!o) {\n          i = s;\n          break;\n        }\n      } else o = false;\n      return -1 === i ? n3 ? \"/\" : \".\" : n3 && 1 === i ? \"//\" : t3.slice(0, i);\n    }, \"dirname\"), basename: /* @__PURE__ */ __name(function(t3, r3) {\n      if (void 0 !== r3 && \"string\" != typeof r3) throw new TypeError('\"ext\" argument must be a string');\n      e2(t3);\n      var n3, i = 0, o = -1, s = true;\n      if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {\n        if (r3.length === t3.length && r3 === t3) return \"\";\n        var h = r3.length - 1, a = -1;\n        for (n3 = t3.length - 1; n3 >= 0; --n3) {\n          var c = t3.charCodeAt(n3);\n          if (47 === c) {\n            if (!s) {\n              i = n3 + 1;\n              break;\n            }\n          } else -1 === a && (s = false, a = n3 + 1), h >= 0 && (c === r3.charCodeAt(h) ? -1 == --h && (o = n3) : (h = -1, o = a));\n        }\n        return i === o ? o = a : -1 === o && (o = t3.length), t3.slice(i, o);\n      }\n      for (n3 = t3.length - 1; n3 >= 0; --n3) if (47 === t3.charCodeAt(n3)) {\n        if (!s) {\n          i = n3 + 1;\n          break;\n        }\n      } else -1 === o && (s = false, o = n3 + 1);\n      return -1 === o ? \"\" : t3.slice(i, o);\n    }, \"basename\"), extname: /* @__PURE__ */ __name(function(t3) {\n      e2(t3);\n      for (var r3 = -1, n3 = 0, i = -1, o = true, s = 0, h = t3.length - 1; h >= 0; --h) {\n        var a = t3.charCodeAt(h);\n        if (47 !== a) -1 === i && (o = false, i = h + 1), 46 === a ? -1 === r3 ? r3 = h : 1 !== s && (s = 1) : -1 !== r3 && (s = -1);\n        else if (!o) {\n          n3 = h + 1;\n          break;\n        }\n      }\n      return -1 === r3 || -1 === i || 0 === s || 1 === s && r3 === i - 1 && r3 === n3 + 1 ? \"\" : t3.slice(r3, i);\n    }, \"extname\"), format: /* @__PURE__ */ __name(function(t3) {\n      if (null === t3 || \"object\" != typeof t3) throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof t3);\n      return function(t4, e3) {\n        var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || \"\") + (e3.ext || \"\");\n        return r3 ? r3 === e3.root ? r3 + n3 : r3 + \"/\" + n3 : n3;\n      }(0, t3);\n    }, \"format\"), parse: /* @__PURE__ */ __name(function(t3) {\n      e2(t3);\n      var r3 = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n      if (0 === t3.length) return r3;\n      var n3, i = t3.charCodeAt(0), o = 47 === i;\n      o ? (r3.root = \"/\", n3 = 1) : n3 = 0;\n      for (var s = -1, h = 0, a = -1, c = true, f = t3.length - 1, u = 0; f >= n3; --f) if (47 !== (i = t3.charCodeAt(f))) -1 === a && (c = false, a = f + 1), 46 === i ? -1 === s ? s = f : 1 !== u && (u = 1) : -1 !== s && (u = -1);\n      else if (!c) {\n        h = f + 1;\n        break;\n      }\n      return -1 === s || -1 === a || 0 === u || 1 === u && s === a - 1 && s === h + 1 ? -1 !== a && (r3.base = r3.name = 0 === h && o ? t3.slice(1, a) : t3.slice(h, a)) : (0 === h && o ? (r3.name = t3.slice(1, s), r3.base = t3.slice(1, a)) : (r3.name = t3.slice(h, s), r3.base = t3.slice(h, a)), r3.ext = t3.slice(s, a)), h > 0 ? r3.dir = t3.slice(0, h - 1) : o && (r3.dir = \"/\"), r3;\n    }, \"parse\"), sep: \"/\", delimiter: \":\", win32: null, posix: null };\n    n2.posix = n2, t2.exports = n2;\n  } }, e = {};\n  function r(n2) {\n    var i = e[n2];\n    if (void 0 !== i) return i.exports;\n    var o = e[n2] = { exports: {} };\n    return t[n2](o, o.exports, r), o.exports;\n  }\n  __name(r, \"r\");\n  r.d = (t2, e2) => {\n    for (var n2 in e2) r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });\n  }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(t2, \"__esModule\", { value: true });\n  };\n  var n = {};\n  (() => {\n    let t2;\n    if (r.r(n), r.d(n, { URI: /* @__PURE__ */ __name(() => f, \"URI\"), Utils: /* @__PURE__ */ __name(() => P, \"Utils\") }), \"object\" == typeof process) t2 = \"win32\" === process.platform;\n    else if (\"object\" == typeof navigator) {\n      let e3 = navigator.userAgent;\n      t2 = e3.indexOf(\"Windows\") >= 0;\n    }\n    const e2 = /^\\w[\\w\\d+.-]*$/, i = /^\\//, o = /^\\/\\//;\n    function s(t3, r2) {\n      if (!t3.scheme && r2) throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${t3.authority}\", path: \"${t3.path}\", query: \"${t3.query}\", fragment: \"${t3.fragment}\"}`);\n      if (t3.scheme && !e2.test(t3.scheme)) throw new Error(\"[UriError]: Scheme contains illegal characters.\");\n      if (t3.path) {\n        if (t3.authority) {\n          if (!i.test(t3.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n        } else if (o.test(t3.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n      }\n    }\n    __name(s, \"s\");\n    const h = \"\", a = \"/\", c = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n    class f {\n      static {\n        __name(this, \"f\");\n      }\n      static isUri(t3) {\n        return t3 instanceof f || !!t3 && \"string\" == typeof t3.authority && \"string\" == typeof t3.fragment && \"string\" == typeof t3.path && \"string\" == typeof t3.query && \"string\" == typeof t3.scheme && \"string\" == typeof t3.fsPath && \"function\" == typeof t3.with && \"function\" == typeof t3.toString;\n      }\n      scheme;\n      authority;\n      path;\n      query;\n      fragment;\n      constructor(t3, e3, r2, n2, i2, o2 = false) {\n        \"object\" == typeof t3 ? (this.scheme = t3.scheme || h, this.authority = t3.authority || h, this.path = t3.path || h, this.query = t3.query || h, this.fragment = t3.fragment || h) : (this.scheme = /* @__PURE__ */ function(t4, e4) {\n          return t4 || e4 ? t4 : \"file\";\n        }(t3, o2), this.authority = e3 || h, this.path = function(t4, e4) {\n          switch (t4) {\n            case \"https\":\n            case \"http\":\n            case \"file\":\n              e4 ? e4[0] !== a && (e4 = a + e4) : e4 = a;\n          }\n          return e4;\n        }(this.scheme, r2 || h), this.query = n2 || h, this.fragment = i2 || h, s(this, o2));\n      }\n      get fsPath() {\n        return m(this, false);\n      }\n      with(t3) {\n        if (!t3) return this;\n        let { scheme: e3, authority: r2, path: n2, query: i2, fragment: o2 } = t3;\n        return void 0 === e3 ? e3 = this.scheme : null === e3 && (e3 = h), void 0 === r2 ? r2 = this.authority : null === r2 && (r2 = h), void 0 === n2 ? n2 = this.path : null === n2 && (n2 = h), void 0 === i2 ? i2 = this.query : null === i2 && (i2 = h), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = h), e3 === this.scheme && r2 === this.authority && n2 === this.path && i2 === this.query && o2 === this.fragment ? this : new l(e3, r2, n2, i2, o2);\n      }\n      static parse(t3, e3 = false) {\n        const r2 = c.exec(t3);\n        return r2 ? new l(r2[2] || h, C(r2[4] || h), C(r2[5] || h), C(r2[7] || h), C(r2[9] || h), e3) : new l(h, h, h, h, h);\n      }\n      static file(e3) {\n        let r2 = h;\n        if (t2 && (e3 = e3.replace(/\\\\/g, a)), e3[0] === a && e3[1] === a) {\n          const t3 = e3.indexOf(a, 2);\n          -1 === t3 ? (r2 = e3.substring(2), e3 = a) : (r2 = e3.substring(2, t3), e3 = e3.substring(t3) || a);\n        }\n        return new l(\"file\", r2, e3, h, h);\n      }\n      static from(t3) {\n        const e3 = new l(t3.scheme, t3.authority, t3.path, t3.query, t3.fragment);\n        return s(e3, true), e3;\n      }\n      toString(t3 = false) {\n        return y(this, t3);\n      }\n      toJSON() {\n        return this;\n      }\n      static revive(t3) {\n        if (t3) {\n          if (t3 instanceof f) return t3;\n          {\n            const e3 = new l(t3);\n            return e3._formatted = t3.external, e3._fsPath = t3._sep === u ? t3.fsPath : null, e3;\n          }\n        }\n        return t3;\n      }\n    }\n    const u = t2 ? 1 : void 0;\n    class l extends f {\n      static {\n        __name(this, \"l\");\n      }\n      _formatted = null;\n      _fsPath = null;\n      get fsPath() {\n        return this._fsPath || (this._fsPath = m(this, false)), this._fsPath;\n      }\n      toString(t3 = false) {\n        return t3 ? y(this, true) : (this._formatted || (this._formatted = y(this, false)), this._formatted);\n      }\n      toJSON() {\n        const t3 = { $mid: 1 };\n        return this._fsPath && (t3.fsPath = this._fsPath, t3._sep = u), this._formatted && (t3.external = this._formatted), this.path && (t3.path = this.path), this.scheme && (t3.scheme = this.scheme), this.authority && (t3.authority = this.authority), this.query && (t3.query = this.query), this.fragment && (t3.fragment = this.fragment), t3;\n      }\n    }\n    const g = { 58: \"%3A\", 47: \"%2F\", 63: \"%3F\", 35: \"%23\", 91: \"%5B\", 93: \"%5D\", 64: \"%40\", 33: \"%21\", 36: \"%24\", 38: \"%26\", 39: \"%27\", 40: \"%28\", 41: \"%29\", 42: \"%2A\", 43: \"%2B\", 44: \"%2C\", 59: \"%3B\", 61: \"%3D\", 32: \"%20\" };\n    function d(t3, e3, r2) {\n      let n2, i2 = -1;\n      for (let o2 = 0; o2 < t3.length; o2++) {\n        const s2 = t3.charCodeAt(o2);\n        if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e3 && 47 === s2 || r2 && 91 === s2 || r2 && 93 === s2 || r2 && 58 === s2) -1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), void 0 !== n2 && (n2 += t3.charAt(o2));\n        else {\n          void 0 === n2 && (n2 = t3.substr(0, o2));\n          const e4 = g[s2];\n          void 0 !== e4 ? (-1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), n2 += e4) : -1 === i2 && (i2 = o2);\n        }\n      }\n      return -1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2))), void 0 !== n2 ? n2 : t3;\n    }\n    __name(d, \"d\");\n    function p(t3) {\n      let e3;\n      for (let r2 = 0; r2 < t3.length; r2++) {\n        const n2 = t3.charCodeAt(r2);\n        35 === n2 || 63 === n2 ? (void 0 === e3 && (e3 = t3.substr(0, r2)), e3 += g[n2]) : void 0 !== e3 && (e3 += t3[r2]);\n      }\n      return void 0 !== e3 ? e3 : t3;\n    }\n    __name(p, \"p\");\n    function m(e3, r2) {\n      let n2;\n      return n2 = e3.authority && e3.path.length > 1 && \"file\" === e3.scheme ? `//${e3.authority}${e3.path}` : 47 === e3.path.charCodeAt(0) && (e3.path.charCodeAt(1) >= 65 && e3.path.charCodeAt(1) <= 90 || e3.path.charCodeAt(1) >= 97 && e3.path.charCodeAt(1) <= 122) && 58 === e3.path.charCodeAt(2) ? r2 ? e3.path.substr(1) : e3.path[1].toLowerCase() + e3.path.substr(2) : e3.path, t2 && (n2 = n2.replace(/\\//g, \"\\\\\")), n2;\n    }\n    __name(m, \"m\");\n    function y(t3, e3) {\n      const r2 = e3 ? p : d;\n      let n2 = \"\", { scheme: i2, authority: o2, path: s2, query: h2, fragment: c2 } = t3;\n      if (i2 && (n2 += i2, n2 += \":\"), (o2 || \"file\" === i2) && (n2 += a, n2 += a), o2) {\n        let t4 = o2.indexOf(\"@\");\n        if (-1 !== t4) {\n          const e4 = o2.substr(0, t4);\n          o2 = o2.substr(t4 + 1), t4 = e4.lastIndexOf(\":\"), -1 === t4 ? n2 += r2(e4, false, false) : (n2 += r2(e4.substr(0, t4), false, false), n2 += \":\", n2 += r2(e4.substr(t4 + 1), false, true)), n2 += \"@\";\n        }\n        o2 = o2.toLowerCase(), t4 = o2.lastIndexOf(\":\"), -1 === t4 ? n2 += r2(o2, false, true) : (n2 += r2(o2.substr(0, t4), false, true), n2 += o2.substr(t4));\n      }\n      if (s2) {\n        if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {\n          const t4 = s2.charCodeAt(1);\n          t4 >= 65 && t4 <= 90 && (s2 = `/${String.fromCharCode(t4 + 32)}:${s2.substr(3)}`);\n        } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {\n          const t4 = s2.charCodeAt(0);\n          t4 >= 65 && t4 <= 90 && (s2 = `${String.fromCharCode(t4 + 32)}:${s2.substr(2)}`);\n        }\n        n2 += r2(s2, true, false);\n      }\n      return h2 && (n2 += \"?\", n2 += r2(h2, false, false)), c2 && (n2 += \"#\", n2 += e3 ? c2 : d(c2, false, false)), n2;\n    }\n    __name(y, \"y\");\n    function v(t3) {\n      try {\n        return decodeURIComponent(t3);\n      } catch {\n        return t3.length > 3 ? t3.substr(0, 3) + v(t3.substr(3)) : t3;\n      }\n    }\n    __name(v, \"v\");\n    const b = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n    function C(t3) {\n      return t3.match(b) ? t3.replace(b, (t4) => v(t4)) : t3;\n    }\n    __name(C, \"C\");\n    var A = r(470);\n    const w = A.posix || A, x = \"/\";\n    var P;\n    !function(t3) {\n      t3.joinPath = function(t4, ...e3) {\n        return t4.with({ path: w.join(t4.path, ...e3) });\n      }, t3.resolvePath = function(t4, ...e3) {\n        let r2 = t4.path, n2 = false;\n        r2[0] !== x && (r2 = x + r2, n2 = true);\n        let i2 = w.resolve(r2, ...e3);\n        return n2 && i2[0] === x && !t4.authority && (i2 = i2.substring(1)), t4.with({ path: i2 });\n      }, t3.dirname = function(t4) {\n        if (0 === t4.path.length || t4.path === x) return t4;\n        let e3 = w.dirname(t4.path);\n        return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = \"\"), t4.with({ path: e3 });\n      }, t3.basename = function(t4) {\n        return w.basename(t4.path);\n      }, t3.extname = function(t4) {\n        return w.extname(t4.path);\n      };\n    }(P || (P = {}));\n  })(), LIB = n;\n})();\nvar { URI: URI2, Utils } = LIB;\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/uri-utils.js\nvar UriUtils;\n(function(UriUtils2) {\n  UriUtils2.basename = Utils.basename;\n  UriUtils2.dirname = Utils.dirname;\n  UriUtils2.extname = Utils.extname;\n  UriUtils2.joinPath = Utils.joinPath;\n  UriUtils2.resolvePath = Utils.resolvePath;\n  function equals(a, b) {\n    return (a === null || a === void 0 ? void 0 : a.toString()) === (b === null || b === void 0 ? void 0 : b.toString());\n  }\n  __name(equals, \"equals\");\n  UriUtils2.equals = equals;\n  function relative(from, to) {\n    const fromPath = typeof from === \"string\" ? from : from.path;\n    const toPath = typeof to === \"string\" ? to : to.path;\n    const fromParts = fromPath.split(\"/\").filter((e) => e.length > 0);\n    const toParts = toPath.split(\"/\").filter((e) => e.length > 0);\n    let i = 0;\n    for (; i < fromParts.length; i++) {\n      if (fromParts[i] !== toParts[i]) {\n        break;\n      }\n    }\n    const backPart = \"../\".repeat(fromParts.length - i);\n    const toPart = toParts.slice(i).join(\"/\");\n    return backPart + toPart;\n  }\n  __name(relative, \"relative\");\n  UriUtils2.relative = relative;\n})(UriUtils || (UriUtils = {}));\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/workspace/documents.js\nvar DocumentState;\n(function(DocumentState2) {\n  DocumentState2[DocumentState2[\"Changed\"] = 0] = \"Changed\";\n  DocumentState2[DocumentState2[\"Parsed\"] = 1] = \"Parsed\";\n  DocumentState2[DocumentState2[\"IndexedContent\"] = 2] = \"IndexedContent\";\n  DocumentState2[DocumentState2[\"ComputedScopes\"] = 3] = \"ComputedScopes\";\n  DocumentState2[DocumentState2[\"Linked\"] = 4] = \"Linked\";\n  DocumentState2[DocumentState2[\"IndexedReferences\"] = 5] = \"IndexedReferences\";\n  DocumentState2[DocumentState2[\"Validated\"] = 6] = \"Validated\";\n})(DocumentState || (DocumentState = {}));\nvar DefaultLangiumDocumentFactory = class {\n  static {\n    __name(this, \"DefaultLangiumDocumentFactory\");\n  }\n  constructor(services) {\n    this.serviceRegistry = services.ServiceRegistry;\n    this.textDocuments = services.workspace.TextDocuments;\n    this.fileSystemProvider = services.workspace.FileSystemProvider;\n  }\n  async fromUri(uri, cancellationToken = cancellation_exports.CancellationToken.None) {\n    const content = await this.fileSystemProvider.readFile(uri);\n    return this.createAsync(uri, content, cancellationToken);\n  }\n  fromTextDocument(textDocument, uri, cancellationToken) {\n    uri = uri !== null && uri !== void 0 ? uri : URI2.parse(textDocument.uri);\n    if (cancellationToken) {\n      return this.createAsync(uri, textDocument, cancellationToken);\n    } else {\n      return this.create(uri, textDocument);\n    }\n  }\n  fromString(text, uri, cancellationToken) {\n    if (cancellationToken) {\n      return this.createAsync(uri, text, cancellationToken);\n    } else {\n      return this.create(uri, text);\n    }\n  }\n  fromModel(model, uri) {\n    return this.create(uri, { $model: model });\n  }\n  create(uri, content) {\n    if (typeof content === \"string\") {\n      const parseResult = this.parse(uri, content);\n      return this.createLangiumDocument(parseResult, uri, void 0, content);\n    } else if (\"$model\" in content) {\n      const parseResult = { value: content.$model, parserErrors: [], lexerErrors: [] };\n      return this.createLangiumDocument(parseResult, uri);\n    } else {\n      const parseResult = this.parse(uri, content.getText());\n      return this.createLangiumDocument(parseResult, uri, content);\n    }\n  }\n  async createAsync(uri, content, cancelToken) {\n    if (typeof content === \"string\") {\n      const parseResult = await this.parseAsync(uri, content, cancelToken);\n      return this.createLangiumDocument(parseResult, uri, void 0, content);\n    } else {\n      const parseResult = await this.parseAsync(uri, content.getText(), cancelToken);\n      return this.createLangiumDocument(parseResult, uri, content);\n    }\n  }\n  /**\n   * Create a LangiumDocument from a given parse result.\n   *\n   * A TextDocument is created on demand if it is not provided as argument here. Usually this\n   * should not be necessary because the main purpose of the TextDocument is to convert between\n   * text ranges and offsets, which is done solely in LSP request handling.\n   *\n   * With the introduction of {@link update} below this method is supposed to be mainly called\n   * during workspace initialization and on addition/recognition of new files, while changes in\n   * existing documents are processed via {@link update}.\n   */\n  createLangiumDocument(parseResult, uri, textDocument, text) {\n    let document;\n    if (textDocument) {\n      document = {\n        parseResult,\n        uri,\n        state: DocumentState.Parsed,\n        references: [],\n        textDocument\n      };\n    } else {\n      const textDocumentGetter = this.createTextDocumentGetter(uri, text);\n      document = {\n        parseResult,\n        uri,\n        state: DocumentState.Parsed,\n        references: [],\n        get textDocument() {\n          return textDocumentGetter();\n        }\n      };\n    }\n    parseResult.value.$document = document;\n    return document;\n  }\n  async update(document, cancellationToken) {\n    var _a, _b;\n    const oldText = (_a = document.parseResult.value.$cstNode) === null || _a === void 0 ? void 0 : _a.root.fullText;\n    const textDocument = (_b = this.textDocuments) === null || _b === void 0 ? void 0 : _b.get(document.uri.toString());\n    const text = textDocument ? textDocument.getText() : await this.fileSystemProvider.readFile(document.uri);\n    if (textDocument) {\n      Object.defineProperty(document, \"textDocument\", {\n        value: textDocument\n      });\n    } else {\n      const textDocumentGetter = this.createTextDocumentGetter(document.uri, text);\n      Object.defineProperty(document, \"textDocument\", {\n        get: textDocumentGetter\n      });\n    }\n    if (oldText !== text) {\n      document.parseResult = await this.parseAsync(document.uri, text, cancellationToken);\n      document.parseResult.value.$document = document;\n    }\n    document.state = DocumentState.Parsed;\n    return document;\n  }\n  parse(uri, text) {\n    const services = this.serviceRegistry.getServices(uri);\n    return services.parser.LangiumParser.parse(text);\n  }\n  parseAsync(uri, text, cancellationToken) {\n    const services = this.serviceRegistry.getServices(uri);\n    return services.parser.AsyncParser.parse(text, cancellationToken);\n  }\n  createTextDocumentGetter(uri, text) {\n    const serviceRegistry = this.serviceRegistry;\n    let textDoc = void 0;\n    return () => {\n      return textDoc !== null && textDoc !== void 0 ? textDoc : textDoc = TextDocument2.create(uri.toString(), serviceRegistry.getServices(uri).LanguageMetaData.languageId, 0, text !== null && text !== void 0 ? text : \"\");\n    };\n  }\n};\nvar DefaultLangiumDocuments = class {\n  static {\n    __name(this, \"DefaultLangiumDocuments\");\n  }\n  constructor(services) {\n    this.documentMap = /* @__PURE__ */ new Map();\n    this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\n  }\n  get all() {\n    return stream(this.documentMap.values());\n  }\n  addDocument(document) {\n    const uriString = document.uri.toString();\n    if (this.documentMap.has(uriString)) {\n      throw new Error(`A document with the URI '${uriString}' is already present.`);\n    }\n    this.documentMap.set(uriString, document);\n  }\n  getDocument(uri) {\n    const uriString = uri.toString();\n    return this.documentMap.get(uriString);\n  }\n  async getOrCreateDocument(uri, cancellationToken) {\n    let document = this.getDocument(uri);\n    if (document) {\n      return document;\n    }\n    document = await this.langiumDocumentFactory.fromUri(uri, cancellationToken);\n    this.addDocument(document);\n    return document;\n  }\n  createDocument(uri, text, cancellationToken) {\n    if (cancellationToken) {\n      return this.langiumDocumentFactory.fromString(text, uri, cancellationToken).then((document) => {\n        this.addDocument(document);\n        return document;\n      });\n    } else {\n      const document = this.langiumDocumentFactory.fromString(text, uri);\n      this.addDocument(document);\n      return document;\n    }\n  }\n  hasDocument(uri) {\n    return this.documentMap.has(uri.toString());\n  }\n  invalidateDocument(uri) {\n    const uriString = uri.toString();\n    const langiumDoc = this.documentMap.get(uriString);\n    if (langiumDoc) {\n      langiumDoc.state = DocumentState.Changed;\n      langiumDoc.precomputedScopes = void 0;\n      langiumDoc.references = [];\n      langiumDoc.diagnostics = void 0;\n    }\n    return langiumDoc;\n  }\n  deleteDocument(uri) {\n    const uriString = uri.toString();\n    const langiumDoc = this.documentMap.get(uriString);\n    if (langiumDoc) {\n      langiumDoc.state = DocumentState.Changed;\n      this.documentMap.delete(uriString);\n    }\n    return langiumDoc;\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/references/linker.js\nvar DefaultLinker = class {\n  static {\n    __name(this, \"DefaultLinker\");\n  }\n  constructor(services) {\n    this.reflection = services.shared.AstReflection;\n    this.langiumDocuments = () => services.shared.workspace.LangiumDocuments;\n    this.scopeProvider = services.references.ScopeProvider;\n    this.astNodeLocator = services.workspace.AstNodeLocator;\n  }\n  async link(document, cancelToken = cancellation_exports.CancellationToken.None) {\n    for (const node of streamAst(document.parseResult.value)) {\n      await interruptAndCheck(cancelToken);\n      streamReferences(node).forEach((ref) => this.doLink(ref, document));\n    }\n  }\n  doLink(refInfo, document) {\n    const ref = refInfo.reference;\n    if (ref._ref === void 0) {\n      try {\n        const description = this.getCandidate(refInfo);\n        if (isLinkingError(description)) {\n          ref._ref = description;\n        } else {\n          ref._nodeDescription = description;\n          if (this.langiumDocuments().hasDocument(description.documentUri)) {\n            const linkedNode = this.loadAstNode(description);\n            ref._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : this.createLinkingError(refInfo, description);\n          }\n        }\n      } catch (err) {\n        ref._ref = Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${ref.$refText}': ${err}` });\n      }\n    }\n    document.references.push(ref);\n  }\n  unlink(document) {\n    for (const ref of document.references) {\n      delete ref._ref;\n      delete ref._nodeDescription;\n    }\n    document.references = [];\n  }\n  getCandidate(refInfo) {\n    const scope = this.scopeProvider.getScope(refInfo);\n    const description = scope.getElement(refInfo.reference.$refText);\n    return description !== null && description !== void 0 ? description : this.createLinkingError(refInfo);\n  }\n  buildReference(node, property, refNode, refText) {\n    const linker = this;\n    const reference = {\n      $refNode: refNode,\n      $refText: refText,\n      get ref() {\n        var _a;\n        if (isAstNode(this._ref)) {\n          return this._ref;\n        } else if (isAstNodeDescription(this._nodeDescription)) {\n          const linkedNode = linker.loadAstNode(this._nodeDescription);\n          this._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : linker.createLinkingError({ reference, container: node, property }, this._nodeDescription);\n        } else if (this._ref === void 0) {\n          const refData = linker.getLinkedNode({ reference, container: node, property });\n          if (refData.error && getDocument(node).state < DocumentState.ComputedScopes) {\n            return void 0;\n          }\n          this._ref = (_a = refData.node) !== null && _a !== void 0 ? _a : refData.error;\n          this._nodeDescription = refData.descr;\n        }\n        return isAstNode(this._ref) ? this._ref : void 0;\n      },\n      get $nodeDescription() {\n        return this._nodeDescription;\n      },\n      get error() {\n        return isLinkingError(this._ref) ? this._ref : void 0;\n      }\n    };\n    return reference;\n  }\n  getLinkedNode(refInfo) {\n    try {\n      const description = this.getCandidate(refInfo);\n      if (isLinkingError(description)) {\n        return { error: description };\n      }\n      const linkedNode = this.loadAstNode(description);\n      if (linkedNode) {\n        return { node: linkedNode, descr: description };\n      } else {\n        return {\n          descr: description,\n          error: this.createLinkingError(refInfo, description)\n        };\n      }\n    } catch (err) {\n      return {\n        error: Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${refInfo.reference.$refText}': ${err}` })\n      };\n    }\n  }\n  loadAstNode(nodeDescription) {\n    if (nodeDescription.node) {\n      return nodeDescription.node;\n    }\n    const doc = this.langiumDocuments().getDocument(nodeDescription.documentUri);\n    if (!doc) {\n      return void 0;\n    }\n    return this.astNodeLocator.getAstNode(doc.parseResult.value, nodeDescription.path);\n  }\n  createLinkingError(refInfo, targetDescription) {\n    const document = getDocument(refInfo.container);\n    if (document.state < DocumentState.ComputedScopes) {\n      console.warn(`Attempted reference resolution before document reached ComputedScopes state (${document.uri}).`);\n    }\n    const referenceType = this.reflection.getReferenceType(refInfo);\n    return Object.assign(Object.assign({}, refInfo), { message: `Could not resolve reference to ${referenceType} named '${refInfo.reference.$refText}'.`, targetDescription });\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/references/name-provider.js\nfunction isNamed(node) {\n  return typeof node.name === \"string\";\n}\n__name(isNamed, \"isNamed\");\nvar DefaultNameProvider = class {\n  static {\n    __name(this, \"DefaultNameProvider\");\n  }\n  getName(node) {\n    if (isNamed(node)) {\n      return node.name;\n    }\n    return void 0;\n  }\n  getNameNode(node) {\n    return findNodeForProperty(node.$cstNode, \"name\");\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/references/references.js\nvar DefaultReferences = class {\n  static {\n    __name(this, \"DefaultReferences\");\n  }\n  constructor(services) {\n    this.nameProvider = services.references.NameProvider;\n    this.index = services.shared.workspace.IndexManager;\n    this.nodeLocator = services.workspace.AstNodeLocator;\n  }\n  findDeclaration(sourceCstNode) {\n    if (sourceCstNode) {\n      const assignment = findAssignment(sourceCstNode);\n      const nodeElem = sourceCstNode.astNode;\n      if (assignment && nodeElem) {\n        const reference = nodeElem[assignment.feature];\n        if (isReference(reference)) {\n          return reference.ref;\n        } else if (Array.isArray(reference)) {\n          for (const ref of reference) {\n            if (isReference(ref) && ref.$refNode && ref.$refNode.offset <= sourceCstNode.offset && ref.$refNode.end >= sourceCstNode.end) {\n              return ref.ref;\n            }\n          }\n        }\n      }\n      if (nodeElem) {\n        const nameNode = this.nameProvider.getNameNode(nodeElem);\n        if (nameNode && (nameNode === sourceCstNode || isChildNode(sourceCstNode, nameNode))) {\n          return nodeElem;\n        }\n      }\n    }\n    return void 0;\n  }\n  findDeclarationNode(sourceCstNode) {\n    const astNode = this.findDeclaration(sourceCstNode);\n    if (astNode === null || astNode === void 0 ? void 0 : astNode.$cstNode) {\n      const targetNode = this.nameProvider.getNameNode(astNode);\n      return targetNode !== null && targetNode !== void 0 ? targetNode : astNode.$cstNode;\n    }\n    return void 0;\n  }\n  findReferences(targetNode, options) {\n    const refs = [];\n    if (options.includeDeclaration) {\n      const ref = this.getReferenceToSelf(targetNode);\n      if (ref) {\n        refs.push(ref);\n      }\n    }\n    let indexReferences = this.index.findAllReferences(targetNode, this.nodeLocator.getAstNodePath(targetNode));\n    if (options.documentUri) {\n      indexReferences = indexReferences.filter((ref) => UriUtils.equals(ref.sourceUri, options.documentUri));\n    }\n    refs.push(...indexReferences);\n    return stream(refs);\n  }\n  getReferenceToSelf(targetNode) {\n    const nameNode = this.nameProvider.getNameNode(targetNode);\n    if (nameNode) {\n      const doc = getDocument(targetNode);\n      const path = this.nodeLocator.getAstNodePath(targetNode);\n      return {\n        sourceUri: doc.uri,\n        sourcePath: path,\n        targetUri: doc.uri,\n        targetPath: path,\n        segment: toDocumentSegment(nameNode),\n        local: true\n      };\n    }\n    return void 0;\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/collections.js\nvar MultiMap = class {\n  static {\n    __name(this, \"MultiMap\");\n  }\n  constructor(elements) {\n    this.map = /* @__PURE__ */ new Map();\n    if (elements) {\n      for (const [key, value] of elements) {\n        this.add(key, value);\n      }\n    }\n  }\n  /**\n   * The total number of values in the multimap.\n   */\n  get size() {\n    return Reduction.sum(stream(this.map.values()).map((a) => a.length));\n  }\n  /**\n   * Clear all entries in the multimap.\n   */\n  clear() {\n    this.map.clear();\n  }\n  /**\n   * Operates differently depending on whether a `value` is given:\n   *  * With a value, this method deletes the specific key / value pair from the multimap.\n   *  * Without a value, all values associated with the given key are deleted.\n   *\n   * @returns `true` if a value existed and has been removed, or `false` if the specified\n   *     key / value does not exist.\n   */\n  delete(key, value) {\n    if (value === void 0) {\n      return this.map.delete(key);\n    } else {\n      const values = this.map.get(key);\n      if (values) {\n        const index = values.indexOf(value);\n        if (index >= 0) {\n          if (values.length === 1) {\n            this.map.delete(key);\n          } else {\n            values.splice(index, 1);\n          }\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n  /**\n   * Returns an array of all values associated with the given key. If no value exists,\n   * an empty array is returned.\n   *\n   * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a\n   * value and `delete` to remove a value from the multimap.\n   */\n  get(key) {\n    var _a;\n    return (_a = this.map.get(key)) !== null && _a !== void 0 ? _a : [];\n  }\n  /**\n   * Operates differently depending on whether a `value` is given:\n   *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.\n   *  * Without a value, this method returns `true` if the given key is present in the multimap.\n   */\n  has(key, value) {\n    if (value === void 0) {\n      return this.map.has(key);\n    } else {\n      const values = this.map.get(key);\n      if (values) {\n        return values.indexOf(value) >= 0;\n      }\n      return false;\n    }\n  }\n  /**\n   * Add the given key / value pair to the multimap.\n   */\n  add(key, value) {\n    if (this.map.has(key)) {\n      this.map.get(key).push(value);\n    } else {\n      this.map.set(key, [value]);\n    }\n    return this;\n  }\n  /**\n   * Add the given set of key / value pairs to the multimap.\n   */\n  addAll(key, values) {\n    if (this.map.has(key)) {\n      this.map.get(key).push(...values);\n    } else {\n      this.map.set(key, Array.from(values));\n    }\n    return this;\n  }\n  /**\n   * Invokes the given callback function for every key / value pair in the multimap.\n   */\n  forEach(callbackfn) {\n    this.map.forEach((array, key) => array.forEach((value) => callbackfn(value, key, this)));\n  }\n  /**\n   * Returns an iterator of key, value pairs for every entry in the map.\n   */\n  [Symbol.iterator]() {\n    return this.entries().iterator();\n  }\n  /**\n   * Returns a stream of key, value pairs for every entry in the map.\n   */\n  entries() {\n    return stream(this.map.entries()).flatMap(([key, array]) => array.map((value) => [key, value]));\n  }\n  /**\n   * Returns a stream of keys in the map.\n   */\n  keys() {\n    return stream(this.map.keys());\n  }\n  /**\n   * Returns a stream of values in the map.\n   */\n  values() {\n    return stream(this.map.values()).flat();\n  }\n  /**\n   * Returns a stream of key, value set pairs for every key in the map.\n   */\n  entriesGroupedByKey() {\n    return stream(this.map.entries());\n  }\n};\nvar BiMap = class {\n  static {\n    __name(this, \"BiMap\");\n  }\n  get size() {\n    return this.map.size;\n  }\n  constructor(elements) {\n    this.map = /* @__PURE__ */ new Map();\n    this.inverse = /* @__PURE__ */ new Map();\n    if (elements) {\n      for (const [key, value] of elements) {\n        this.set(key, value);\n      }\n    }\n  }\n  clear() {\n    this.map.clear();\n    this.inverse.clear();\n  }\n  set(key, value) {\n    this.map.set(key, value);\n    this.inverse.set(value, key);\n    return this;\n  }\n  get(key) {\n    return this.map.get(key);\n  }\n  getKey(value) {\n    return this.inverse.get(value);\n  }\n  delete(key) {\n    const value = this.map.get(key);\n    if (value !== void 0) {\n      this.map.delete(key);\n      this.inverse.delete(value);\n      return true;\n    }\n    return false;\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/references/scope-computation.js\nvar DefaultScopeComputation = class {\n  static {\n    __name(this, \"DefaultScopeComputation\");\n  }\n  constructor(services) {\n    this.nameProvider = services.references.NameProvider;\n    this.descriptions = services.workspace.AstNodeDescriptionProvider;\n  }\n  async computeExports(document, cancelToken = cancellation_exports.CancellationToken.None) {\n    return this.computeExportsForNode(document.parseResult.value, document, void 0, cancelToken);\n  }\n  /**\n   * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.\n   * The list of children to be considered is determined by the function parameter {@link children}.\n   * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.\n   *\n   * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.\n   * @param document The document containing the AST node to be exported.\n   * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.\n   * @param cancelToken Indicates when to cancel the current operation.\n   * @throws `OperationCanceled` if a user action occurs during execution.\n   * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.\n   */\n  async computeExportsForNode(parentNode, document, children = streamContents, cancelToken = cancellation_exports.CancellationToken.None) {\n    const exports = [];\n    this.exportNode(parentNode, exports, document);\n    for (const node of children(parentNode)) {\n      await interruptAndCheck(cancelToken);\n      this.exportNode(node, exports, document);\n    }\n    return exports;\n  }\n  /**\n   * Add a single node to the list of exports if it has a name. Override this method to change how\n   * symbols are exported, e.g. by modifying their exported name.\n   */\n  exportNode(node, exports, document) {\n    const name = this.nameProvider.getName(node);\n    if (name) {\n      exports.push(this.descriptions.createDescription(node, name, document));\n    }\n  }\n  async computeLocalScopes(document, cancelToken = cancellation_exports.CancellationToken.None) {\n    const rootNode = document.parseResult.value;\n    const scopes = new MultiMap();\n    for (const node of streamAllContents(rootNode)) {\n      await interruptAndCheck(cancelToken);\n      this.processNode(node, document, scopes);\n    }\n    return scopes;\n  }\n  /**\n   * Process a single node during scopes computation. The default implementation makes the node visible\n   * in the subtree of its container (if the node has a name). Override this method to change this,\n   * e.g. by increasing the visibility to a higher level in the AST.\n   */\n  processNode(node, document, scopes) {\n    const container = node.$container;\n    if (container) {\n      const name = this.nameProvider.getName(node);\n      if (name) {\n        scopes.add(container, this.descriptions.createDescription(node, name, document));\n      }\n    }\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/references/scope.js\nvar StreamScope = class {\n  static {\n    __name(this, \"StreamScope\");\n  }\n  constructor(elements, outerScope, options) {\n    var _a;\n    this.elements = elements;\n    this.outerScope = outerScope;\n    this.caseInsensitive = (_a = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null && _a !== void 0 ? _a : false;\n  }\n  getAllElements() {\n    if (this.outerScope) {\n      return this.elements.concat(this.outerScope.getAllElements());\n    } else {\n      return this.elements;\n    }\n  }\n  getElement(name) {\n    const local = this.caseInsensitive ? this.elements.find((e) => e.name.toLowerCase() === name.toLowerCase()) : this.elements.find((e) => e.name === name);\n    if (local) {\n      return local;\n    }\n    if (this.outerScope) {\n      return this.outerScope.getElement(name);\n    }\n    return void 0;\n  }\n};\nvar MapScope = class {\n  static {\n    __name(this, \"MapScope\");\n  }\n  constructor(elements, outerScope, options) {\n    var _a;\n    this.elements = /* @__PURE__ */ new Map();\n    this.caseInsensitive = (_a = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null && _a !== void 0 ? _a : false;\n    for (const element of elements) {\n      const name = this.caseInsensitive ? element.name.toLowerCase() : element.name;\n      this.elements.set(name, element);\n    }\n    this.outerScope = outerScope;\n  }\n  getElement(name) {\n    const localName = this.caseInsensitive ? name.toLowerCase() : name;\n    const local = this.elements.get(localName);\n    if (local) {\n      return local;\n    }\n    if (this.outerScope) {\n      return this.outerScope.getElement(name);\n    }\n    return void 0;\n  }\n  getAllElements() {\n    let elementStream = stream(this.elements.values());\n    if (this.outerScope) {\n      elementStream = elementStream.concat(this.outerScope.getAllElements());\n    }\n    return elementStream;\n  }\n};\nvar EMPTY_SCOPE = {\n  getElement() {\n    return void 0;\n  },\n  getAllElements() {\n    return EMPTY_STREAM;\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/caching.js\nvar DisposableCache = class {\n  static {\n    __name(this, \"DisposableCache\");\n  }\n  constructor() {\n    this.toDispose = [];\n    this.isDisposed = false;\n  }\n  onDispose(disposable) {\n    this.toDispose.push(disposable);\n  }\n  dispose() {\n    this.throwIfDisposed();\n    this.clear();\n    this.isDisposed = true;\n    this.toDispose.forEach((disposable) => disposable.dispose());\n  }\n  throwIfDisposed() {\n    if (this.isDisposed) {\n      throw new Error(\"This cache has already been disposed\");\n    }\n  }\n};\nvar SimpleCache = class extends DisposableCache {\n  static {\n    __name(this, \"SimpleCache\");\n  }\n  constructor() {\n    super(...arguments);\n    this.cache = /* @__PURE__ */ new Map();\n  }\n  has(key) {\n    this.throwIfDisposed();\n    return this.cache.has(key);\n  }\n  set(key, value) {\n    this.throwIfDisposed();\n    this.cache.set(key, value);\n  }\n  get(key, provider) {\n    this.throwIfDisposed();\n    if (this.cache.has(key)) {\n      return this.cache.get(key);\n    } else if (provider) {\n      const value = provider();\n      this.cache.set(key, value);\n      return value;\n    } else {\n      return void 0;\n    }\n  }\n  delete(key) {\n    this.throwIfDisposed();\n    return this.cache.delete(key);\n  }\n  clear() {\n    this.throwIfDisposed();\n    this.cache.clear();\n  }\n};\nvar ContextCache = class extends DisposableCache {\n  static {\n    __name(this, \"ContextCache\");\n  }\n  constructor(converter) {\n    super();\n    this.cache = /* @__PURE__ */ new Map();\n    this.converter = converter !== null && converter !== void 0 ? converter : (value) => value;\n  }\n  has(contextKey, key) {\n    this.throwIfDisposed();\n    return this.cacheForContext(contextKey).has(key);\n  }\n  set(contextKey, key, value) {\n    this.throwIfDisposed();\n    this.cacheForContext(contextKey).set(key, value);\n  }\n  get(contextKey, key, provider) {\n    this.throwIfDisposed();\n    const contextCache = this.cacheForContext(contextKey);\n    if (contextCache.has(key)) {\n      return contextCache.get(key);\n    } else if (provider) {\n      const value = provider();\n      contextCache.set(key, value);\n      return value;\n    } else {\n      return void 0;\n    }\n  }\n  delete(contextKey, key) {\n    this.throwIfDisposed();\n    return this.cacheForContext(contextKey).delete(key);\n  }\n  clear(contextKey) {\n    this.throwIfDisposed();\n    if (contextKey) {\n      const mapKey = this.converter(contextKey);\n      this.cache.delete(mapKey);\n    } else {\n      this.cache.clear();\n    }\n  }\n  cacheForContext(contextKey) {\n    const mapKey = this.converter(contextKey);\n    let documentCache = this.cache.get(mapKey);\n    if (!documentCache) {\n      documentCache = /* @__PURE__ */ new Map();\n      this.cache.set(mapKey, documentCache);\n    }\n    return documentCache;\n  }\n};\nvar DocumentCache = class extends ContextCache {\n  static {\n    __name(this, \"DocumentCache\");\n  }\n  constructor(sharedServices) {\n    super((uri) => uri.toString());\n    this.onDispose(sharedServices.workspace.DocumentBuilder.onUpdate((changed, deleted) => {\n      const allUris = changed.concat(deleted);\n      for (const uri of allUris) {\n        this.clear(uri);\n      }\n    }));\n  }\n};\nvar WorkspaceCache = class extends SimpleCache {\n  static {\n    __name(this, \"WorkspaceCache\");\n  }\n  constructor(sharedServices) {\n    super();\n    this.onDispose(sharedServices.workspace.DocumentBuilder.onUpdate(() => {\n      this.clear();\n    }));\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/references/scope-provider.js\nvar DefaultScopeProvider = class {\n  static {\n    __name(this, \"DefaultScopeProvider\");\n  }\n  constructor(services) {\n    this.reflection = services.shared.AstReflection;\n    this.nameProvider = services.references.NameProvider;\n    this.descriptions = services.workspace.AstNodeDescriptionProvider;\n    this.indexManager = services.shared.workspace.IndexManager;\n    this.globalScopeCache = new WorkspaceCache(services.shared);\n  }\n  getScope(context) {\n    const scopes = [];\n    const referenceType = this.reflection.getReferenceType(context);\n    const precomputed = getDocument(context.container).precomputedScopes;\n    if (precomputed) {\n      let currentNode = context.container;\n      do {\n        const allDescriptions = precomputed.get(currentNode);\n        if (allDescriptions.length > 0) {\n          scopes.push(stream(allDescriptions).filter((desc) => this.reflection.isSubtype(desc.type, referenceType)));\n        }\n        currentNode = currentNode.$container;\n      } while (currentNode);\n    }\n    let result = this.getGlobalScope(referenceType, context);\n    for (let i = scopes.length - 1; i >= 0; i--) {\n      result = this.createScope(scopes[i], result);\n    }\n    return result;\n  }\n  /**\n   * Create a scope for the given collection of AST node descriptions.\n   */\n  createScope(elements, outerScope, options) {\n    return new StreamScope(stream(elements), outerScope, options);\n  }\n  /**\n   * Create a scope for the given collection of AST nodes, which need to be transformed into respective\n   * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.\n   */\n  createScopeForNodes(elements, outerScope, options) {\n    const s = stream(elements).map((e) => {\n      const name = this.nameProvider.getName(e);\n      if (name) {\n        return this.descriptions.createDescription(e, name);\n      }\n      return void 0;\n    }).nonNullable();\n    return new StreamScope(s, outerScope, options);\n  }\n  /**\n   * Create a global scope filtered for the given reference type.\n   */\n  getGlobalScope(referenceType, _context) {\n    return this.globalScopeCache.get(referenceType, () => new MapScope(this.indexManager.allElements(referenceType)));\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/serializer/json-serializer.js\nfunction isAstNodeWithComment(node) {\n  return typeof node.$comment === \"string\";\n}\n__name(isAstNodeWithComment, \"isAstNodeWithComment\");\nfunction isIntermediateReference(obj) {\n  return typeof obj === \"object\" && !!obj && (\"$ref\" in obj || \"$error\" in obj);\n}\n__name(isIntermediateReference, \"isIntermediateReference\");\nvar DefaultJsonSerializer = class {\n  static {\n    __name(this, \"DefaultJsonSerializer\");\n  }\n  constructor(services) {\n    this.ignoreProperties = /* @__PURE__ */ new Set([\"$container\", \"$containerProperty\", \"$containerIndex\", \"$document\", \"$cstNode\"]);\n    this.langiumDocuments = services.shared.workspace.LangiumDocuments;\n    this.astNodeLocator = services.workspace.AstNodeLocator;\n    this.nameProvider = services.references.NameProvider;\n    this.commentProvider = services.documentation.CommentProvider;\n  }\n  serialize(node, options = {}) {\n    const specificReplacer = options === null || options === void 0 ? void 0 : options.replacer;\n    const defaultReplacer = /* @__PURE__ */ __name((key, value) => this.replacer(key, value, options), \"defaultReplacer\");\n    const replacer = specificReplacer ? (key, value) => specificReplacer(key, value, defaultReplacer) : defaultReplacer;\n    try {\n      this.currentDocument = getDocument(node);\n      return JSON.stringify(node, replacer, options === null || options === void 0 ? void 0 : options.space);\n    } finally {\n      this.currentDocument = void 0;\n    }\n  }\n  deserialize(content, options = {}) {\n    const root = JSON.parse(content);\n    this.linkNode(root, root, options);\n    return root;\n  }\n  replacer(key, value, { refText, sourceText, textRegions, comments, uriConverter }) {\n    var _a, _b, _c, _d;\n    if (this.ignoreProperties.has(key)) {\n      return void 0;\n    } else if (isReference(value)) {\n      const refValue = value.ref;\n      const $refText = refText ? value.$refText : void 0;\n      if (refValue) {\n        const targetDocument = getDocument(refValue);\n        let targetUri = \"\";\n        if (this.currentDocument && this.currentDocument !== targetDocument) {\n          if (uriConverter) {\n            targetUri = uriConverter(targetDocument.uri, value);\n          } else {\n            targetUri = targetDocument.uri.toString();\n          }\n        }\n        const targetPath = this.astNodeLocator.getAstNodePath(refValue);\n        return {\n          $ref: `${targetUri}#${targetPath}`,\n          $refText\n        };\n      } else {\n        return {\n          $error: (_b = (_a = value.error) === null || _a === void 0 ? void 0 : _a.message) !== null && _b !== void 0 ? _b : \"Could not resolve reference\",\n          $refText\n        };\n      }\n    } else if (isAstNode(value)) {\n      let astNode = void 0;\n      if (textRegions) {\n        astNode = this.addAstNodeRegionWithAssignmentsTo(Object.assign({}, value));\n        if ((!key || value.$document) && (astNode === null || astNode === void 0 ? void 0 : astNode.$textRegion)) {\n          astNode.$textRegion.documentURI = (_c = this.currentDocument) === null || _c === void 0 ? void 0 : _c.uri.toString();\n        }\n      }\n      if (sourceText && !key) {\n        astNode !== null && astNode !== void 0 ? astNode : astNode = Object.assign({}, value);\n        astNode.$sourceText = (_d = value.$cstNode) === null || _d === void 0 ? void 0 : _d.text;\n      }\n      if (comments) {\n        astNode !== null && astNode !== void 0 ? astNode : astNode = Object.assign({}, value);\n        const comment = this.commentProvider.getComment(value);\n        if (comment) {\n          astNode.$comment = comment.replace(/\\r/g, \"\");\n        }\n      }\n      return astNode !== null && astNode !== void 0 ? astNode : value;\n    } else {\n      return value;\n    }\n  }\n  addAstNodeRegionWithAssignmentsTo(node) {\n    const createDocumentSegment = /* @__PURE__ */ __name((cstNode) => ({\n      offset: cstNode.offset,\n      end: cstNode.end,\n      length: cstNode.length,\n      range: cstNode.range\n    }), \"createDocumentSegment\");\n    if (node.$cstNode) {\n      const textRegion = node.$textRegion = createDocumentSegment(node.$cstNode);\n      const assignments = textRegion.assignments = {};\n      Object.keys(node).filter((key) => !key.startsWith(\"$\")).forEach((key) => {\n        const propertyAssignments = findNodesForProperty(node.$cstNode, key).map(createDocumentSegment);\n        if (propertyAssignments.length !== 0) {\n          assignments[key] = propertyAssignments;\n        }\n      });\n      return node;\n    }\n    return void 0;\n  }\n  linkNode(node, root, options, container, containerProperty, containerIndex) {\n    for (const [propertyName, item] of Object.entries(node)) {\n      if (Array.isArray(item)) {\n        for (let index = 0; index < item.length; index++) {\n          const element = item[index];\n          if (isIntermediateReference(element)) {\n            item[index] = this.reviveReference(node, propertyName, root, element, options);\n          } else if (isAstNode(element)) {\n            this.linkNode(element, root, options, node, propertyName, index);\n          }\n        }\n      } else if (isIntermediateReference(item)) {\n        node[propertyName] = this.reviveReference(node, propertyName, root, item, options);\n      } else if (isAstNode(item)) {\n        this.linkNode(item, root, options, node, propertyName);\n      }\n    }\n    const mutable = node;\n    mutable.$container = container;\n    mutable.$containerProperty = containerProperty;\n    mutable.$containerIndex = containerIndex;\n  }\n  reviveReference(container, property, root, reference, options) {\n    let refText = reference.$refText;\n    let error = reference.$error;\n    if (reference.$ref) {\n      const ref = this.getRefNode(root, reference.$ref, options.uriConverter);\n      if (isAstNode(ref)) {\n        if (!refText) {\n          refText = this.nameProvider.getName(ref);\n        }\n        return {\n          $refText: refText !== null && refText !== void 0 ? refText : \"\",\n          ref\n        };\n      } else {\n        error = ref;\n      }\n    }\n    if (error) {\n      const ref = {\n        $refText: refText !== null && refText !== void 0 ? refText : \"\"\n      };\n      ref.error = {\n        container,\n        property,\n        message: error,\n        reference: ref\n      };\n      return ref;\n    } else {\n      return void 0;\n    }\n  }\n  getRefNode(root, uri, uriConverter) {\n    try {\n      const fragmentIndex = uri.indexOf(\"#\");\n      if (fragmentIndex === 0) {\n        const node2 = this.astNodeLocator.getAstNode(root, uri.substring(1));\n        if (!node2) {\n          return \"Could not resolve path: \" + uri;\n        }\n        return node2;\n      }\n      if (fragmentIndex < 0) {\n        const documentUri2 = uriConverter ? uriConverter(uri) : URI2.parse(uri);\n        const document2 = this.langiumDocuments.getDocument(documentUri2);\n        if (!document2) {\n          return \"Could not find document for URI: \" + uri;\n        }\n        return document2.parseResult.value;\n      }\n      const documentUri = uriConverter ? uriConverter(uri.substring(0, fragmentIndex)) : URI2.parse(uri.substring(0, fragmentIndex));\n      const document = this.langiumDocuments.getDocument(documentUri);\n      if (!document) {\n        return \"Could not find document for URI: \" + uri;\n      }\n      if (fragmentIndex === uri.length - 1) {\n        return document.parseResult.value;\n      }\n      const node = this.astNodeLocator.getAstNode(document.parseResult.value, uri.substring(fragmentIndex + 1));\n      if (!node) {\n        return \"Could not resolve URI: \" + uri;\n      }\n      return node;\n    } catch (err) {\n      return String(err);\n    }\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/service-registry.js\nvar DefaultServiceRegistry = class {\n  static {\n    __name(this, \"DefaultServiceRegistry\");\n  }\n  register(language) {\n    if (!this.singleton && !this.map) {\n      this.singleton = language;\n      return;\n    }\n    if (!this.map) {\n      this.map = {};\n      if (this.singleton) {\n        for (const ext of this.singleton.LanguageMetaData.fileExtensions) {\n          this.map[ext] = this.singleton;\n        }\n        this.singleton = void 0;\n      }\n    }\n    for (const ext of language.LanguageMetaData.fileExtensions) {\n      if (this.map[ext] !== void 0 && this.map[ext] !== language) {\n        console.warn(`The file extension ${ext} is used by multiple languages. It is now assigned to '${language.LanguageMetaData.languageId}'.`);\n      }\n      this.map[ext] = language;\n    }\n  }\n  getServices(uri) {\n    if (this.singleton !== void 0) {\n      return this.singleton;\n    }\n    if (this.map === void 0) {\n      throw new Error(\"The service registry is empty. Use `register` to register the services of a language.\");\n    }\n    const ext = UriUtils.extname(uri);\n    const services = this.map[ext];\n    if (!services) {\n      throw new Error(`The service registry contains no services for the extension '${ext}'.`);\n    }\n    return services;\n  }\n  get all() {\n    if (this.singleton !== void 0) {\n      return [this.singleton];\n    }\n    if (this.map !== void 0) {\n      return Object.values(this.map);\n    }\n    return [];\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/validation/validation-registry.js\nfunction diagnosticData(code) {\n  return { code };\n}\n__name(diagnosticData, \"diagnosticData\");\nvar ValidationCategory;\n(function(ValidationCategory2) {\n  ValidationCategory2.all = [\"fast\", \"slow\", \"built-in\"];\n})(ValidationCategory || (ValidationCategory = {}));\nvar ValidationRegistry = class {\n  static {\n    __name(this, \"ValidationRegistry\");\n  }\n  constructor(services) {\n    this.entries = new MultiMap();\n    this.reflection = services.shared.AstReflection;\n  }\n  /**\n   * Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)\n   * or an array of validation checks.\n   *\n   * @param checksRecord Set of validation checks to register.\n   * @param category Optional category for the validation checks (defaults to `'fast'`).\n   * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n   */\n  register(checksRecord, thisObj = this, category = \"fast\") {\n    if (category === \"built-in\") {\n      throw new Error(\"The 'built-in' category is reserved for lexer, parser, and linker errors.\");\n    }\n    for (const [type, ch] of Object.entries(checksRecord)) {\n      const callbacks = ch;\n      if (Array.isArray(callbacks)) {\n        for (const check of callbacks) {\n          const entry = {\n            check: this.wrapValidationException(check, thisObj),\n            category\n          };\n          this.addEntry(type, entry);\n        }\n      } else if (typeof callbacks === \"function\") {\n        const entry = {\n          check: this.wrapValidationException(callbacks, thisObj),\n          category\n        };\n        this.addEntry(type, entry);\n      }\n    }\n  }\n  wrapValidationException(check, thisObj) {\n    return async (node, accept, cancelToken) => {\n      try {\n        await check.call(thisObj, node, accept, cancelToken);\n      } catch (err) {\n        if (isOperationCancelled(err)) {\n          throw err;\n        }\n        console.error(\"An error occurred during validation:\", err);\n        const message = err instanceof Error ? err.message : String(err);\n        if (err instanceof Error && err.stack) {\n          console.error(err.stack);\n        }\n        accept(\"error\", \"An error occurred during validation: \" + message, { node });\n      }\n    };\n  }\n  addEntry(type, entry) {\n    if (type === \"AstNode\") {\n      this.entries.add(\"AstNode\", entry);\n      return;\n    }\n    for (const subtype of this.reflection.getAllSubTypes(type)) {\n      this.entries.add(subtype, entry);\n    }\n  }\n  getChecks(type, categories) {\n    let checks = stream(this.entries.get(type)).concat(this.entries.get(\"AstNode\"));\n    if (categories) {\n      checks = checks.filter((entry) => categories.includes(entry.category));\n    }\n    return checks.map((entry) => entry.check);\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/validation/document-validator.js\nvar DefaultDocumentValidator = class {\n  static {\n    __name(this, \"DefaultDocumentValidator\");\n  }\n  constructor(services) {\n    this.validationRegistry = services.validation.ValidationRegistry;\n    this.metadata = services.LanguageMetaData;\n  }\n  async validateDocument(document, options = {}, cancelToken = cancellation_exports.CancellationToken.None) {\n    const parseResult = document.parseResult;\n    const diagnostics = [];\n    await interruptAndCheck(cancelToken);\n    if (!options.categories || options.categories.includes(\"built-in\")) {\n      this.processLexingErrors(parseResult, diagnostics, options);\n      if (options.stopAfterLexingErrors && diagnostics.some((d) => {\n        var _a;\n        return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.LexingError;\n      })) {\n        return diagnostics;\n      }\n      this.processParsingErrors(parseResult, diagnostics, options);\n      if (options.stopAfterParsingErrors && diagnostics.some((d) => {\n        var _a;\n        return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.ParsingError;\n      })) {\n        return diagnostics;\n      }\n      this.processLinkingErrors(document, diagnostics, options);\n      if (options.stopAfterLinkingErrors && diagnostics.some((d) => {\n        var _a;\n        return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.LinkingError;\n      })) {\n        return diagnostics;\n      }\n    }\n    try {\n      diagnostics.push(...await this.validateAst(parseResult.value, options, cancelToken));\n    } catch (err) {\n      if (isOperationCancelled(err)) {\n        throw err;\n      }\n      console.error(\"An error occurred during validation:\", err);\n    }\n    await interruptAndCheck(cancelToken);\n    return diagnostics;\n  }\n  processLexingErrors(parseResult, diagnostics, _options) {\n    for (const lexerError of parseResult.lexerErrors) {\n      const diagnostic = {\n        severity: toDiagnosticSeverity(\"error\"),\n        range: {\n          start: {\n            line: lexerError.line - 1,\n            character: lexerError.column - 1\n          },\n          end: {\n            line: lexerError.line - 1,\n            character: lexerError.column + lexerError.length - 1\n          }\n        },\n        message: lexerError.message,\n        data: diagnosticData(DocumentValidator.LexingError),\n        source: this.getSource()\n      };\n      diagnostics.push(diagnostic);\n    }\n  }\n  processParsingErrors(parseResult, diagnostics, _options) {\n    for (const parserError of parseResult.parserErrors) {\n      let range = void 0;\n      if (isNaN(parserError.token.startOffset)) {\n        if (\"previousToken\" in parserError) {\n          const token = parserError.previousToken;\n          if (!isNaN(token.startOffset)) {\n            const position = { line: token.endLine - 1, character: token.endColumn };\n            range = { start: position, end: position };\n          } else {\n            const position = { line: 0, character: 0 };\n            range = { start: position, end: position };\n          }\n        }\n      } else {\n        range = tokenToRange(parserError.token);\n      }\n      if (range) {\n        const diagnostic = {\n          severity: toDiagnosticSeverity(\"error\"),\n          range,\n          message: parserError.message,\n          data: diagnosticData(DocumentValidator.ParsingError),\n          source: this.getSource()\n        };\n        diagnostics.push(diagnostic);\n      }\n    }\n  }\n  processLinkingErrors(document, diagnostics, _options) {\n    for (const reference of document.references) {\n      const linkingError = reference.error;\n      if (linkingError) {\n        const info = {\n          node: linkingError.container,\n          property: linkingError.property,\n          index: linkingError.index,\n          data: {\n            code: DocumentValidator.LinkingError,\n            containerType: linkingError.container.$type,\n            property: linkingError.property,\n            refText: linkingError.reference.$refText\n          }\n        };\n        diagnostics.push(this.toDiagnostic(\"error\", linkingError.message, info));\n      }\n    }\n  }\n  async validateAst(rootNode, options, cancelToken = cancellation_exports.CancellationToken.None) {\n    const validationItems = [];\n    const acceptor = /* @__PURE__ */ __name((severity, message, info) => {\n      validationItems.push(this.toDiagnostic(severity, message, info));\n    }, \"acceptor\");\n    await Promise.all(streamAst(rootNode).map(async (node) => {\n      await interruptAndCheck(cancelToken);\n      const checks = this.validationRegistry.getChecks(node.$type, options.categories);\n      for (const check of checks) {\n        await check(node, acceptor, cancelToken);\n      }\n    }));\n    return validationItems;\n  }\n  toDiagnostic(severity, message, info) {\n    return {\n      message,\n      range: getDiagnosticRange(info),\n      severity: toDiagnosticSeverity(severity),\n      code: info.code,\n      codeDescription: info.codeDescription,\n      tags: info.tags,\n      relatedInformation: info.relatedInformation,\n      data: info.data,\n      source: this.getSource()\n    };\n  }\n  getSource() {\n    return this.metadata.languageId;\n  }\n};\nfunction getDiagnosticRange(info) {\n  if (info.range) {\n    return info.range;\n  }\n  let cstNode;\n  if (typeof info.property === \"string\") {\n    cstNode = findNodeForProperty(info.node.$cstNode, info.property, info.index);\n  } else if (typeof info.keyword === \"string\") {\n    cstNode = findNodeForKeyword(info.node.$cstNode, info.keyword, info.index);\n  }\n  cstNode !== null && cstNode !== void 0 ? cstNode : cstNode = info.node.$cstNode;\n  if (!cstNode) {\n    return {\n      start: { line: 0, character: 0 },\n      end: { line: 0, character: 0 }\n    };\n  }\n  return cstNode.range;\n}\n__name(getDiagnosticRange, \"getDiagnosticRange\");\nfunction toDiagnosticSeverity(severity) {\n  switch (severity) {\n    case \"error\":\n      return 1;\n    case \"warning\":\n      return 2;\n    case \"info\":\n      return 3;\n    case \"hint\":\n      return 4;\n    default:\n      throw new Error(\"Invalid diagnostic severity: \" + severity);\n  }\n}\n__name(toDiagnosticSeverity, \"toDiagnosticSeverity\");\nvar DocumentValidator;\n(function(DocumentValidator2) {\n  DocumentValidator2.LexingError = \"lexing-error\";\n  DocumentValidator2.ParsingError = \"parsing-error\";\n  DocumentValidator2.LinkingError = \"linking-error\";\n})(DocumentValidator || (DocumentValidator = {}));\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/workspace/ast-descriptions.js\nvar DefaultAstNodeDescriptionProvider = class {\n  static {\n    __name(this, \"DefaultAstNodeDescriptionProvider\");\n  }\n  constructor(services) {\n    this.astNodeLocator = services.workspace.AstNodeLocator;\n    this.nameProvider = services.references.NameProvider;\n  }\n  createDescription(node, name, document = getDocument(node)) {\n    name !== null && name !== void 0 ? name : name = this.nameProvider.getName(node);\n    const path = this.astNodeLocator.getAstNodePath(node);\n    if (!name) {\n      throw new Error(`Node at path ${path} has no name.`);\n    }\n    let nameNodeSegment;\n    const nameSegmentGetter = /* @__PURE__ */ __name(() => {\n      var _a;\n      return nameNodeSegment !== null && nameNodeSegment !== void 0 ? nameNodeSegment : nameNodeSegment = toDocumentSegment((_a = this.nameProvider.getNameNode(node)) !== null && _a !== void 0 ? _a : node.$cstNode);\n    }, \"nameSegmentGetter\");\n    return {\n      node,\n      name,\n      get nameSegment() {\n        return nameSegmentGetter();\n      },\n      selectionSegment: toDocumentSegment(node.$cstNode),\n      type: node.$type,\n      documentUri: document.uri,\n      path\n    };\n  }\n};\nvar DefaultReferenceDescriptionProvider = class {\n  static {\n    __name(this, \"DefaultReferenceDescriptionProvider\");\n  }\n  constructor(services) {\n    this.nodeLocator = services.workspace.AstNodeLocator;\n  }\n  async createDescriptions(document, cancelToken = cancellation_exports.CancellationToken.None) {\n    const descr = [];\n    const rootNode = document.parseResult.value;\n    for (const astNode of streamAst(rootNode)) {\n      await interruptAndCheck(cancelToken);\n      streamReferences(astNode).filter((refInfo) => !isLinkingError(refInfo)).forEach((refInfo) => {\n        const description = this.createDescription(refInfo);\n        if (description) {\n          descr.push(description);\n        }\n      });\n    }\n    return descr;\n  }\n  createDescription(refInfo) {\n    const targetNodeDescr = refInfo.reference.$nodeDescription;\n    const refCstNode = refInfo.reference.$refNode;\n    if (!targetNodeDescr || !refCstNode) {\n      return void 0;\n    }\n    const docUri = getDocument(refInfo.container).uri;\n    return {\n      sourceUri: docUri,\n      sourcePath: this.nodeLocator.getAstNodePath(refInfo.container),\n      targetUri: targetNodeDescr.documentUri,\n      targetPath: targetNodeDescr.path,\n      segment: toDocumentSegment(refCstNode),\n      local: UriUtils.equals(targetNodeDescr.documentUri, docUri)\n    };\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/workspace/ast-node-locator.js\nvar DefaultAstNodeLocator = class {\n  static {\n    __name(this, \"DefaultAstNodeLocator\");\n  }\n  constructor() {\n    this.segmentSeparator = \"/\";\n    this.indexSeparator = \"@\";\n  }\n  getAstNodePath(node) {\n    if (node.$container) {\n      const containerPath = this.getAstNodePath(node.$container);\n      const newSegment = this.getPathSegment(node);\n      const nodePath = containerPath + this.segmentSeparator + newSegment;\n      return nodePath;\n    }\n    return \"\";\n  }\n  getPathSegment({ $containerProperty, $containerIndex }) {\n    if (!$containerProperty) {\n      throw new Error(\"Missing '$containerProperty' in AST node.\");\n    }\n    if ($containerIndex !== void 0) {\n      return $containerProperty + this.indexSeparator + $containerIndex;\n    }\n    return $containerProperty;\n  }\n  getAstNode(node, path) {\n    const segments = path.split(this.segmentSeparator);\n    return segments.reduce((previousValue, currentValue) => {\n      if (!previousValue || currentValue.length === 0) {\n        return previousValue;\n      }\n      const propertyIndex = currentValue.indexOf(this.indexSeparator);\n      if (propertyIndex > 0) {\n        const property = currentValue.substring(0, propertyIndex);\n        const arrayIndex = parseInt(currentValue.substring(propertyIndex + 1));\n        const array = previousValue[property];\n        return array === null || array === void 0 ? void 0 : array[arrayIndex];\n      }\n      return previousValue[currentValue];\n    }, node);\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/workspace/configuration.js\nvar DefaultConfigurationProvider = class {\n  static {\n    __name(this, \"DefaultConfigurationProvider\");\n  }\n  constructor(services) {\n    this._ready = new Deferred();\n    this.settings = {};\n    this.workspaceConfig = false;\n    this.serviceRegistry = services.ServiceRegistry;\n  }\n  get ready() {\n    return this._ready.promise;\n  }\n  initialize(params) {\n    var _a, _b;\n    this.workspaceConfig = (_b = (_a = params.capabilities.workspace) === null || _a === void 0 ? void 0 : _a.configuration) !== null && _b !== void 0 ? _b : false;\n  }\n  async initialized(params) {\n    if (this.workspaceConfig) {\n      if (params.register) {\n        const languages = this.serviceRegistry.all;\n        params.register({\n          // Listen to configuration changes for all languages\n          section: languages.map((lang) => this.toSectionName(lang.LanguageMetaData.languageId))\n        });\n      }\n      if (params.fetchConfiguration) {\n        const configToUpdate = this.serviceRegistry.all.map((lang) => ({\n          // Fetch the configuration changes for all languages\n          section: this.toSectionName(lang.LanguageMetaData.languageId)\n        }));\n        const configs = await params.fetchConfiguration(configToUpdate);\n        configToUpdate.forEach((conf, idx) => {\n          this.updateSectionConfiguration(conf.section, configs[idx]);\n        });\n      }\n    }\n    this._ready.resolve();\n  }\n  /**\n   *  Updates the cached configurations using the `change` notification parameters.\n   *\n   * @param change The parameters of a change configuration notification.\n   * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`\n   */\n  updateConfiguration(change) {\n    if (!change.settings) {\n      return;\n    }\n    Object.keys(change.settings).forEach((section) => {\n      this.updateSectionConfiguration(section, change.settings[section]);\n    });\n  }\n  updateSectionConfiguration(section, configuration) {\n    this.settings[section] = configuration;\n  }\n  /**\n  * Returns a configuration value stored for the given language.\n  *\n  * @param language The language id\n  * @param configuration Configuration name\n  */\n  async getConfiguration(language, configuration) {\n    await this.ready;\n    const sectionName = this.toSectionName(language);\n    if (this.settings[sectionName]) {\n      return this.settings[sectionName][configuration];\n    }\n  }\n  toSectionName(languageId) {\n    return `${languageId}`;\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/disposable.js\nvar Disposable;\n(function(Disposable2) {\n  function create(callback) {\n    return {\n      dispose: /* @__PURE__ */ __name(async () => await callback(), \"dispose\")\n    };\n  }\n  __name(create, \"create\");\n  Disposable2.create = create;\n})(Disposable || (Disposable = {}));\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/workspace/document-builder.js\nvar DefaultDocumentBuilder = class {\n  static {\n    __name(this, \"DefaultDocumentBuilder\");\n  }\n  constructor(services) {\n    this.updateBuildOptions = {\n      // Default: run only the built-in validation checks and those in the _fast_ category (includes those without category)\n      validation: {\n        categories: [\"built-in\", \"fast\"]\n      }\n    };\n    this.updateListeners = [];\n    this.buildPhaseListeners = new MultiMap();\n    this.buildState = /* @__PURE__ */ new Map();\n    this.documentBuildWaiters = /* @__PURE__ */ new Map();\n    this.currentState = DocumentState.Changed;\n    this.langiumDocuments = services.workspace.LangiumDocuments;\n    this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\n    this.indexManager = services.workspace.IndexManager;\n    this.serviceRegistry = services.ServiceRegistry;\n  }\n  async build(documents, options = {}, cancelToken = cancellation_exports.CancellationToken.None) {\n    var _a, _b;\n    for (const document of documents) {\n      const key = document.uri.toString();\n      if (document.state === DocumentState.Validated) {\n        if (typeof options.validation === \"boolean\" && options.validation) {\n          document.state = DocumentState.IndexedReferences;\n          document.diagnostics = void 0;\n          this.buildState.delete(key);\n        } else if (typeof options.validation === \"object\") {\n          const buildState = this.buildState.get(key);\n          const previousCategories = (_a = buildState === null || buildState === void 0 ? void 0 : buildState.result) === null || _a === void 0 ? void 0 : _a.validationChecks;\n          if (previousCategories) {\n            const newCategories = (_b = options.validation.categories) !== null && _b !== void 0 ? _b : ValidationCategory.all;\n            const categories = newCategories.filter((c) => !previousCategories.includes(c));\n            if (categories.length > 0) {\n              this.buildState.set(key, {\n                completed: false,\n                options: {\n                  validation: Object.assign(Object.assign({}, options.validation), { categories })\n                },\n                result: buildState.result\n              });\n              document.state = DocumentState.IndexedReferences;\n            }\n          }\n        }\n      } else {\n        this.buildState.delete(key);\n      }\n    }\n    this.currentState = DocumentState.Changed;\n    await this.emitUpdate(documents.map((e) => e.uri), []);\n    await this.buildDocuments(documents, options, cancelToken);\n  }\n  async update(changed, deleted, cancelToken = cancellation_exports.CancellationToken.None) {\n    this.currentState = DocumentState.Changed;\n    for (const deletedUri of deleted) {\n      this.langiumDocuments.deleteDocument(deletedUri);\n      this.buildState.delete(deletedUri.toString());\n      this.indexManager.remove(deletedUri);\n    }\n    for (const changedUri of changed) {\n      const invalidated = this.langiumDocuments.invalidateDocument(changedUri);\n      if (!invalidated) {\n        const newDocument = this.langiumDocumentFactory.fromModel({ $type: \"INVALID\" }, changedUri);\n        newDocument.state = DocumentState.Changed;\n        this.langiumDocuments.addDocument(newDocument);\n      }\n      this.buildState.delete(changedUri.toString());\n    }\n    const allChangedUris = stream(changed).concat(deleted).map((uri) => uri.toString()).toSet();\n    this.langiumDocuments.all.filter((doc) => !allChangedUris.has(doc.uri.toString()) && this.shouldRelink(doc, allChangedUris)).forEach((doc) => {\n      const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\n      linker.unlink(doc);\n      doc.state = Math.min(doc.state, DocumentState.ComputedScopes);\n      doc.diagnostics = void 0;\n    });\n    await this.emitUpdate(changed, deleted);\n    await interruptAndCheck(cancelToken);\n    const rebuildDocuments = this.langiumDocuments.all.filter((doc) => {\n      var _a;\n      return doc.state < DocumentState.Linked || !((_a = this.buildState.get(doc.uri.toString())) === null || _a === void 0 ? void 0 : _a.completed);\n    }).toArray();\n    await this.buildDocuments(rebuildDocuments, this.updateBuildOptions, cancelToken);\n  }\n  async emitUpdate(changed, deleted) {\n    await Promise.all(this.updateListeners.map((listener) => listener(changed, deleted)));\n  }\n  /**\n   * Check whether the given document should be relinked after changes were found in the given URIs.\n   */\n  shouldRelink(document, changedUris) {\n    if (document.references.some((ref) => ref.error !== void 0)) {\n      return true;\n    }\n    return this.indexManager.isAffected(document, changedUris);\n  }\n  onUpdate(callback) {\n    this.updateListeners.push(callback);\n    return Disposable.create(() => {\n      const index = this.updateListeners.indexOf(callback);\n      if (index >= 0) {\n        this.updateListeners.splice(index, 1);\n      }\n    });\n  }\n  /**\n   * Build the given documents by stepping through all build phases. If a document's state indicates\n   * that a certain build phase is already done, the phase is skipped for that document.\n   */\n  async buildDocuments(documents, options, cancelToken) {\n    this.prepareBuild(documents, options);\n    await this.runCancelable(documents, DocumentState.Parsed, cancelToken, (doc) => this.langiumDocumentFactory.update(doc, cancelToken));\n    await this.runCancelable(documents, DocumentState.IndexedContent, cancelToken, (doc) => this.indexManager.updateContent(doc, cancelToken));\n    await this.runCancelable(documents, DocumentState.ComputedScopes, cancelToken, async (doc) => {\n      const scopeComputation = this.serviceRegistry.getServices(doc.uri).references.ScopeComputation;\n      doc.precomputedScopes = await scopeComputation.computeLocalScopes(doc, cancelToken);\n    });\n    await this.runCancelable(documents, DocumentState.Linked, cancelToken, (doc) => {\n      const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\n      return linker.link(doc, cancelToken);\n    });\n    await this.runCancelable(documents, DocumentState.IndexedReferences, cancelToken, (doc) => this.indexManager.updateReferences(doc, cancelToken));\n    const toBeValidated = documents.filter((doc) => this.shouldValidate(doc));\n    await this.runCancelable(toBeValidated, DocumentState.Validated, cancelToken, (doc) => this.validate(doc, cancelToken));\n    for (const doc of documents) {\n      const state = this.buildState.get(doc.uri.toString());\n      if (state) {\n        state.completed = true;\n      }\n    }\n  }\n  prepareBuild(documents, options) {\n    for (const doc of documents) {\n      const key = doc.uri.toString();\n      const state = this.buildState.get(key);\n      if (!state || state.completed) {\n        this.buildState.set(key, {\n          completed: false,\n          options,\n          result: state === null || state === void 0 ? void 0 : state.result\n        });\n      }\n    }\n  }\n  async runCancelable(documents, targetState, cancelToken, callback) {\n    const filtered = documents.filter((e) => e.state < targetState);\n    for (const document of filtered) {\n      await interruptAndCheck(cancelToken);\n      await callback(document);\n      document.state = targetState;\n    }\n    await this.notifyBuildPhase(filtered, targetState, cancelToken);\n    this.currentState = targetState;\n  }\n  onBuildPhase(targetState, callback) {\n    this.buildPhaseListeners.add(targetState, callback);\n    return Disposable.create(() => {\n      this.buildPhaseListeners.delete(targetState, callback);\n    });\n  }\n  waitUntil(state, uriOrToken, cancelToken) {\n    let uri = void 0;\n    if (uriOrToken && \"path\" in uriOrToken) {\n      uri = uriOrToken;\n    } else {\n      cancelToken = uriOrToken;\n    }\n    cancelToken !== null && cancelToken !== void 0 ? cancelToken : cancelToken = cancellation_exports.CancellationToken.None;\n    if (uri) {\n      const document = this.langiumDocuments.getDocument(uri);\n      if (document && document.state > state) {\n        return Promise.resolve(uri);\n      }\n    }\n    if (this.currentState >= state) {\n      return Promise.resolve(void 0);\n    } else if (cancelToken.isCancellationRequested) {\n      return Promise.reject(OperationCancelled);\n    }\n    return new Promise((resolve, reject) => {\n      const buildDisposable = this.onBuildPhase(state, () => {\n        buildDisposable.dispose();\n        cancelDisposable.dispose();\n        if (uri) {\n          const document = this.langiumDocuments.getDocument(uri);\n          resolve(document === null || document === void 0 ? void 0 : document.uri);\n        } else {\n          resolve(void 0);\n        }\n      });\n      const cancelDisposable = cancelToken.onCancellationRequested(() => {\n        buildDisposable.dispose();\n        cancelDisposable.dispose();\n        reject(OperationCancelled);\n      });\n    });\n  }\n  async notifyBuildPhase(documents, state, cancelToken) {\n    if (documents.length === 0) {\n      return;\n    }\n    const listeners = this.buildPhaseListeners.get(state);\n    for (const listener of listeners) {\n      await interruptAndCheck(cancelToken);\n      await listener(documents, cancelToken);\n    }\n  }\n  /**\n   * Determine whether the given document should be validated during a build. The default\n   * implementation checks the `validation` property of the build options. If it's set to `true`\n   * or a `ValidationOptions` object, the document is included in the validation phase.\n   */\n  shouldValidate(document) {\n    return Boolean(this.getBuildOptions(document).validation);\n  }\n  /**\n   * Run validation checks on the given document and store the resulting diagnostics in the document.\n   * If the document already contains diagnostics, the new ones are added to the list.\n   */\n  async validate(document, cancelToken) {\n    var _a, _b;\n    const validator = this.serviceRegistry.getServices(document.uri).validation.DocumentValidator;\n    const validationSetting = this.getBuildOptions(document).validation;\n    const options = typeof validationSetting === \"object\" ? validationSetting : void 0;\n    const diagnostics = await validator.validateDocument(document, options, cancelToken);\n    if (document.diagnostics) {\n      document.diagnostics.push(...diagnostics);\n    } else {\n      document.diagnostics = diagnostics;\n    }\n    const state = this.buildState.get(document.uri.toString());\n    if (state) {\n      (_a = state.result) !== null && _a !== void 0 ? _a : state.result = {};\n      const newCategories = (_b = options === null || options === void 0 ? void 0 : options.categories) !== null && _b !== void 0 ? _b : ValidationCategory.all;\n      if (state.result.validationChecks) {\n        state.result.validationChecks.push(...newCategories);\n      } else {\n        state.result.validationChecks = [...newCategories];\n      }\n    }\n  }\n  getBuildOptions(document) {\n    var _a, _b;\n    return (_b = (_a = this.buildState.get(document.uri.toString())) === null || _a === void 0 ? void 0 : _a.options) !== null && _b !== void 0 ? _b : {};\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/workspace/index-manager.js\nvar DefaultIndexManager = class {\n  static {\n    __name(this, \"DefaultIndexManager\");\n  }\n  constructor(services) {\n    this.symbolIndex = /* @__PURE__ */ new Map();\n    this.symbolByTypeIndex = new ContextCache();\n    this.referenceIndex = /* @__PURE__ */ new Map();\n    this.documents = services.workspace.LangiumDocuments;\n    this.serviceRegistry = services.ServiceRegistry;\n    this.astReflection = services.AstReflection;\n  }\n  findAllReferences(targetNode, astNodePath) {\n    const targetDocUri = getDocument(targetNode).uri;\n    const result = [];\n    this.referenceIndex.forEach((docRefs) => {\n      docRefs.forEach((refDescr) => {\n        if (UriUtils.equals(refDescr.targetUri, targetDocUri) && refDescr.targetPath === astNodePath) {\n          result.push(refDescr);\n        }\n      });\n    });\n    return stream(result);\n  }\n  allElements(nodeType, uris) {\n    let documentUris = stream(this.symbolIndex.keys());\n    if (uris) {\n      documentUris = documentUris.filter((uri) => !uris || uris.has(uri));\n    }\n    return documentUris.map((uri) => this.getFileDescriptions(uri, nodeType)).flat();\n  }\n  getFileDescriptions(uri, nodeType) {\n    var _a;\n    if (!nodeType) {\n      return (_a = this.symbolIndex.get(uri)) !== null && _a !== void 0 ? _a : [];\n    }\n    const descriptions = this.symbolByTypeIndex.get(uri, nodeType, () => {\n      var _a2;\n      const allFileDescriptions = (_a2 = this.symbolIndex.get(uri)) !== null && _a2 !== void 0 ? _a2 : [];\n      return allFileDescriptions.filter((e) => this.astReflection.isSubtype(e.type, nodeType));\n    });\n    return descriptions;\n  }\n  remove(uri) {\n    const uriString = uri.toString();\n    this.symbolIndex.delete(uriString);\n    this.symbolByTypeIndex.clear(uriString);\n    this.referenceIndex.delete(uriString);\n  }\n  async updateContent(document, cancelToken = cancellation_exports.CancellationToken.None) {\n    const services = this.serviceRegistry.getServices(document.uri);\n    const exports = await services.references.ScopeComputation.computeExports(document, cancelToken);\n    const uri = document.uri.toString();\n    this.symbolIndex.set(uri, exports);\n    this.symbolByTypeIndex.clear(uri);\n  }\n  async updateReferences(document, cancelToken = cancellation_exports.CancellationToken.None) {\n    const services = this.serviceRegistry.getServices(document.uri);\n    const indexData = await services.workspace.ReferenceDescriptionProvider.createDescriptions(document, cancelToken);\n    this.referenceIndex.set(document.uri.toString(), indexData);\n  }\n  isAffected(document, changedUris) {\n    const references = this.referenceIndex.get(document.uri.toString());\n    if (!references) {\n      return false;\n    }\n    return references.some((ref) => !ref.local && changedUris.has(ref.targetUri.toString()));\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/workspace/workspace-manager.js\nvar DefaultWorkspaceManager = class {\n  static {\n    __name(this, \"DefaultWorkspaceManager\");\n  }\n  constructor(services) {\n    this.initialBuildOptions = {};\n    this._ready = new Deferred();\n    this.serviceRegistry = services.ServiceRegistry;\n    this.langiumDocuments = services.workspace.LangiumDocuments;\n    this.documentBuilder = services.workspace.DocumentBuilder;\n    this.fileSystemProvider = services.workspace.FileSystemProvider;\n    this.mutex = services.workspace.WorkspaceLock;\n  }\n  get ready() {\n    return this._ready.promise;\n  }\n  initialize(params) {\n    var _a;\n    this.folders = (_a = params.workspaceFolders) !== null && _a !== void 0 ? _a : void 0;\n  }\n  initialized(_params) {\n    return this.mutex.write((token) => {\n      var _a;\n      return this.initializeWorkspace((_a = this.folders) !== null && _a !== void 0 ? _a : [], token);\n    });\n  }\n  async initializeWorkspace(folders, cancelToken = cancellation_exports.CancellationToken.None) {\n    const documents = await this.performStartup(folders);\n    await interruptAndCheck(cancelToken);\n    await this.documentBuilder.build(documents, this.initialBuildOptions, cancelToken);\n  }\n  /**\n   * Performs the uninterruptable startup sequence of the workspace manager.\n   * This methods loads all documents in the workspace and other documents and returns them.\n   */\n  async performStartup(folders) {\n    const fileExtensions = this.serviceRegistry.all.flatMap((e) => e.LanguageMetaData.fileExtensions);\n    const documents = [];\n    const collector = /* @__PURE__ */ __name((document) => {\n      documents.push(document);\n      if (!this.langiumDocuments.hasDocument(document.uri)) {\n        this.langiumDocuments.addDocument(document);\n      }\n    }, \"collector\");\n    await this.loadAdditionalDocuments(folders, collector);\n    await Promise.all(folders.map((wf) => [wf, this.getRootFolder(wf)]).map(async (entry) => this.traverseFolder(...entry, fileExtensions, collector)));\n    this._ready.resolve();\n    return documents;\n  }\n  /**\n   * Load all additional documents that shall be visible in the context of the given workspace\n   * folders and add them to the collector. This can be used to include built-in libraries of\n   * your language, which can be either loaded from provided files or constructed in memory.\n   */\n  loadAdditionalDocuments(_folders, _collector) {\n    return Promise.resolve();\n  }\n  /**\n   * Determine the root folder of the source documents in the given workspace folder.\n   * The default implementation returns the URI of the workspace folder, but you can override\n   * this to return a subfolder like `src` instead.\n   */\n  getRootFolder(workspaceFolder) {\n    return URI2.parse(workspaceFolder.uri);\n  }\n  /**\n   * Traverse the file system folder identified by the given URI and its subfolders. All\n   * contained files that match the file extensions are added to the collector.\n   */\n  async traverseFolder(workspaceFolder, folderPath, fileExtensions, collector) {\n    const content = await this.fileSystemProvider.readDirectory(folderPath);\n    await Promise.all(content.map(async (entry) => {\n      if (this.includeEntry(workspaceFolder, entry, fileExtensions)) {\n        if (entry.isDirectory) {\n          await this.traverseFolder(workspaceFolder, entry.uri, fileExtensions, collector);\n        } else if (entry.isFile) {\n          const document = await this.langiumDocuments.getOrCreateDocument(entry.uri);\n          collector(document);\n        }\n      }\n    }));\n  }\n  /**\n   * Determine whether the given folder entry shall be included while indexing the workspace.\n   */\n  includeEntry(_workspaceFolder, entry, fileExtensions) {\n    const name = UriUtils.basename(entry.uri);\n    if (name.startsWith(\".\")) {\n      return false;\n    }\n    if (entry.isDirectory) {\n      return name !== \"node_modules\" && name !== \"out\";\n    } else if (entry.isFile) {\n      const extname = UriUtils.extname(entry.uri);\n      return fileExtensions.includes(extname);\n    }\n    return false;\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/parser/lexer.js\nvar DefaultLexer = class {\n  static {\n    __name(this, \"DefaultLexer\");\n  }\n  constructor(services) {\n    const tokens = services.parser.TokenBuilder.buildTokens(services.Grammar, {\n      caseInsensitive: services.LanguageMetaData.caseInsensitive\n    });\n    this.tokenTypes = this.toTokenTypeDictionary(tokens);\n    const lexerTokens = isTokenTypeDictionary(tokens) ? Object.values(tokens) : tokens;\n    this.chevrotainLexer = new Lexer(lexerTokens, {\n      positionTracking: \"full\"\n    });\n  }\n  get definition() {\n    return this.tokenTypes;\n  }\n  tokenize(text) {\n    var _a;\n    const chevrotainResult = this.chevrotainLexer.tokenize(text);\n    return {\n      tokens: chevrotainResult.tokens,\n      errors: chevrotainResult.errors,\n      hidden: (_a = chevrotainResult.groups.hidden) !== null && _a !== void 0 ? _a : []\n    };\n  }\n  toTokenTypeDictionary(buildTokens) {\n    if (isTokenTypeDictionary(buildTokens))\n      return buildTokens;\n    const tokens = isIMultiModeLexerDefinition(buildTokens) ? Object.values(buildTokens.modes).flat() : buildTokens;\n    const res = {};\n    tokens.forEach((token) => res[token.name] = token);\n    return res;\n  }\n};\nfunction isTokenTypeArray(tokenVocabulary) {\n  return Array.isArray(tokenVocabulary) && (tokenVocabulary.length === 0 || \"name\" in tokenVocabulary[0]);\n}\n__name(isTokenTypeArray, \"isTokenTypeArray\");\nfunction isIMultiModeLexerDefinition(tokenVocabulary) {\n  return tokenVocabulary && \"modes\" in tokenVocabulary && \"defaultMode\" in tokenVocabulary;\n}\n__name(isIMultiModeLexerDefinition, \"isIMultiModeLexerDefinition\");\nfunction isTokenTypeDictionary(tokenVocabulary) {\n  return !isTokenTypeArray(tokenVocabulary) && !isIMultiModeLexerDefinition(tokenVocabulary);\n}\n__name(isTokenTypeDictionary, \"isTokenTypeDictionary\");\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/documentation/jsdoc.js\nfunction parseJSDoc(node, start, options) {\n  let opts;\n  let position;\n  if (typeof node === \"string\") {\n    position = start;\n    opts = options;\n  } else {\n    position = node.range.start;\n    opts = start;\n  }\n  if (!position) {\n    position = Position.create(0, 0);\n  }\n  const lines = getLines(node);\n  const normalizedOptions = normalizeOptions(opts);\n  const tokens = tokenize({\n    lines,\n    position,\n    options: normalizedOptions\n  });\n  return parseJSDocComment({\n    index: 0,\n    tokens,\n    position\n  });\n}\n__name(parseJSDoc, \"parseJSDoc\");\nfunction isJSDoc(node, options) {\n  const normalizedOptions = normalizeOptions(options);\n  const lines = getLines(node);\n  if (lines.length === 0) {\n    return false;\n  }\n  const first2 = lines[0];\n  const last = lines[lines.length - 1];\n  const firstRegex = normalizedOptions.start;\n  const lastRegex = normalizedOptions.end;\n  return Boolean(firstRegex === null || firstRegex === void 0 ? void 0 : firstRegex.exec(first2)) && Boolean(lastRegex === null || lastRegex === void 0 ? void 0 : lastRegex.exec(last));\n}\n__name(isJSDoc, \"isJSDoc\");\nfunction getLines(node) {\n  let content = \"\";\n  if (typeof node === \"string\") {\n    content = node;\n  } else {\n    content = node.text;\n  }\n  const lines = content.split(NEWLINE_REGEXP);\n  return lines;\n}\n__name(getLines, \"getLines\");\nvar tagRegex = /\\s*(@([\\p{L}][\\p{L}\\p{N}]*)?)/uy;\nvar inlineTagRegex = /\\{(@[\\p{L}][\\p{L}\\p{N}]*)(\\s*)([^\\r\\n}]+)?\\}/gu;\nfunction tokenize(context) {\n  var _a, _b, _c;\n  const tokens = [];\n  let currentLine = context.position.line;\n  let currentCharacter = context.position.character;\n  for (let i = 0; i < context.lines.length; i++) {\n    const first2 = i === 0;\n    const last = i === context.lines.length - 1;\n    let line = context.lines[i];\n    let index = 0;\n    if (first2 && context.options.start) {\n      const match = (_a = context.options.start) === null || _a === void 0 ? void 0 : _a.exec(line);\n      if (match) {\n        index = match.index + match[0].length;\n      }\n    } else {\n      const match = (_b = context.options.line) === null || _b === void 0 ? void 0 : _b.exec(line);\n      if (match) {\n        index = match.index + match[0].length;\n      }\n    }\n    if (last) {\n      const match = (_c = context.options.end) === null || _c === void 0 ? void 0 : _c.exec(line);\n      if (match) {\n        line = line.substring(0, match.index);\n      }\n    }\n    line = line.substring(0, lastCharacter(line));\n    const whitespaceEnd = skipWhitespace(line, index);\n    if (whitespaceEnd >= line.length) {\n      if (tokens.length > 0) {\n        const position = Position.create(currentLine, currentCharacter);\n        tokens.push({\n          type: \"break\",\n          content: \"\",\n          range: Range.create(position, position)\n        });\n      }\n    } else {\n      tagRegex.lastIndex = index;\n      const tagMatch = tagRegex.exec(line);\n      if (tagMatch) {\n        const fullMatch = tagMatch[0];\n        const value = tagMatch[1];\n        const start = Position.create(currentLine, currentCharacter + index);\n        const end = Position.create(currentLine, currentCharacter + index + fullMatch.length);\n        tokens.push({\n          type: \"tag\",\n          content: value,\n          range: Range.create(start, end)\n        });\n        index += fullMatch.length;\n        index = skipWhitespace(line, index);\n      }\n      if (index < line.length) {\n        const rest = line.substring(index);\n        const inlineTagMatches = Array.from(rest.matchAll(inlineTagRegex));\n        tokens.push(...buildInlineTokens(inlineTagMatches, rest, currentLine, currentCharacter + index));\n      }\n    }\n    currentLine++;\n    currentCharacter = 0;\n  }\n  if (tokens.length > 0 && tokens[tokens.length - 1].type === \"break\") {\n    return tokens.slice(0, -1);\n  }\n  return tokens;\n}\n__name(tokenize, \"tokenize\");\nfunction buildInlineTokens(tags, line, lineIndex, characterIndex) {\n  const tokens = [];\n  if (tags.length === 0) {\n    const start = Position.create(lineIndex, characterIndex);\n    const end = Position.create(lineIndex, characterIndex + line.length);\n    tokens.push({\n      type: \"text\",\n      content: line,\n      range: Range.create(start, end)\n    });\n  } else {\n    let lastIndex = 0;\n    for (const match of tags) {\n      const matchIndex = match.index;\n      const startContent = line.substring(lastIndex, matchIndex);\n      if (startContent.length > 0) {\n        tokens.push({\n          type: \"text\",\n          content: line.substring(lastIndex, matchIndex),\n          range: Range.create(Position.create(lineIndex, lastIndex + characterIndex), Position.create(lineIndex, matchIndex + characterIndex))\n        });\n      }\n      let offset = startContent.length + 1;\n      const tagName = match[1];\n      tokens.push({\n        type: \"inline-tag\",\n        content: tagName,\n        range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + tagName.length + characterIndex))\n      });\n      offset += tagName.length;\n      if (match.length === 4) {\n        offset += match[2].length;\n        const value = match[3];\n        tokens.push({\n          type: \"text\",\n          content: value,\n          range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + value.length + characterIndex))\n        });\n      } else {\n        tokens.push({\n          type: \"text\",\n          content: \"\",\n          range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + characterIndex))\n        });\n      }\n      lastIndex = matchIndex + match[0].length;\n    }\n    const endContent = line.substring(lastIndex);\n    if (endContent.length > 0) {\n      tokens.push({\n        type: \"text\",\n        content: endContent,\n        range: Range.create(Position.create(lineIndex, lastIndex + characterIndex), Position.create(lineIndex, lastIndex + characterIndex + endContent.length))\n      });\n    }\n  }\n  return tokens;\n}\n__name(buildInlineTokens, \"buildInlineTokens\");\nvar nonWhitespaceRegex = /\\S/;\nvar whitespaceEndRegex = /\\s*$/;\nfunction skipWhitespace(line, index) {\n  const match = line.substring(index).match(nonWhitespaceRegex);\n  if (match) {\n    return index + match.index;\n  } else {\n    return line.length;\n  }\n}\n__name(skipWhitespace, \"skipWhitespace\");\nfunction lastCharacter(line) {\n  const match = line.match(whitespaceEndRegex);\n  if (match && typeof match.index === \"number\") {\n    return match.index;\n  }\n  return void 0;\n}\n__name(lastCharacter, \"lastCharacter\");\nfunction parseJSDocComment(context) {\n  var _a, _b, _c, _d;\n  const startPosition = Position.create(context.position.line, context.position.character);\n  if (context.tokens.length === 0) {\n    return new JSDocCommentImpl([], Range.create(startPosition, startPosition));\n  }\n  const elements = [];\n  while (context.index < context.tokens.length) {\n    const element = parseJSDocElement(context, elements[elements.length - 1]);\n    if (element) {\n      elements.push(element);\n    }\n  }\n  const start = (_b = (_a = elements[0]) === null || _a === void 0 ? void 0 : _a.range.start) !== null && _b !== void 0 ? _b : startPosition;\n  const end = (_d = (_c = elements[elements.length - 1]) === null || _c === void 0 ? void 0 : _c.range.end) !== null && _d !== void 0 ? _d : startPosition;\n  return new JSDocCommentImpl(elements, Range.create(start, end));\n}\n__name(parseJSDocComment, \"parseJSDocComment\");\nfunction parseJSDocElement(context, last) {\n  const next = context.tokens[context.index];\n  if (next.type === \"tag\") {\n    return parseJSDocTag(context, false);\n  } else if (next.type === \"text\" || next.type === \"inline-tag\") {\n    return parseJSDocText(context);\n  } else {\n    appendEmptyLine(next, last);\n    context.index++;\n    return void 0;\n  }\n}\n__name(parseJSDocElement, \"parseJSDocElement\");\nfunction appendEmptyLine(token, element) {\n  if (element) {\n    const line = new JSDocLineImpl(\"\", token.range);\n    if (\"inlines\" in element) {\n      element.inlines.push(line);\n    } else {\n      element.content.inlines.push(line);\n    }\n  }\n}\n__name(appendEmptyLine, \"appendEmptyLine\");\nfunction parseJSDocText(context) {\n  let token = context.tokens[context.index];\n  const firstToken = token;\n  let lastToken = token;\n  const lines = [];\n  while (token && token.type !== \"break\" && token.type !== \"tag\") {\n    lines.push(parseJSDocInline(context));\n    lastToken = token;\n    token = context.tokens[context.index];\n  }\n  return new JSDocTextImpl(lines, Range.create(firstToken.range.start, lastToken.range.end));\n}\n__name(parseJSDocText, \"parseJSDocText\");\nfunction parseJSDocInline(context) {\n  const token = context.tokens[context.index];\n  if (token.type === \"inline-tag\") {\n    return parseJSDocTag(context, true);\n  } else {\n    return parseJSDocLine(context);\n  }\n}\n__name(parseJSDocInline, \"parseJSDocInline\");\nfunction parseJSDocTag(context, inline) {\n  const tagToken = context.tokens[context.index++];\n  const name = tagToken.content.substring(1);\n  const nextToken = context.tokens[context.index];\n  if ((nextToken === null || nextToken === void 0 ? void 0 : nextToken.type) === \"text\") {\n    if (inline) {\n      const docLine = parseJSDocLine(context);\n      return new JSDocTagImpl(name, new JSDocTextImpl([docLine], docLine.range), inline, Range.create(tagToken.range.start, docLine.range.end));\n    } else {\n      const textDoc = parseJSDocText(context);\n      return new JSDocTagImpl(name, textDoc, inline, Range.create(tagToken.range.start, textDoc.range.end));\n    }\n  } else {\n    const range = tagToken.range;\n    return new JSDocTagImpl(name, new JSDocTextImpl([], range), inline, range);\n  }\n}\n__name(parseJSDocTag, \"parseJSDocTag\");\nfunction parseJSDocLine(context) {\n  const token = context.tokens[context.index++];\n  return new JSDocLineImpl(token.content, token.range);\n}\n__name(parseJSDocLine, \"parseJSDocLine\");\nfunction normalizeOptions(options) {\n  if (!options) {\n    return normalizeOptions({\n      start: \"/**\",\n      end: \"*/\",\n      line: \"*\"\n    });\n  }\n  const { start, end, line } = options;\n  return {\n    start: normalizeOption(start, true),\n    end: normalizeOption(end, false),\n    line: normalizeOption(line, true)\n  };\n}\n__name(normalizeOptions, \"normalizeOptions\");\nfunction normalizeOption(option2, start) {\n  if (typeof option2 === \"string\" || typeof option2 === \"object\") {\n    const escaped = typeof option2 === \"string\" ? escapeRegExp(option2) : option2.source;\n    if (start) {\n      return new RegExp(`^\\\\s*${escaped}`);\n    } else {\n      return new RegExp(`\\\\s*${escaped}\\\\s*$`);\n    }\n  } else {\n    return option2;\n  }\n}\n__name(normalizeOption, \"normalizeOption\");\nvar JSDocCommentImpl = class {\n  static {\n    __name(this, \"JSDocCommentImpl\");\n  }\n  constructor(elements, range) {\n    this.elements = elements;\n    this.range = range;\n  }\n  getTag(name) {\n    return this.getAllTags().find((e) => e.name === name);\n  }\n  getTags(name) {\n    return this.getAllTags().filter((e) => e.name === name);\n  }\n  getAllTags() {\n    return this.elements.filter((e) => \"name\" in e);\n  }\n  toString() {\n    let value = \"\";\n    for (const element of this.elements) {\n      if (value.length === 0) {\n        value = element.toString();\n      } else {\n        const text = element.toString();\n        value += fillNewlines(value) + text;\n      }\n    }\n    return value.trim();\n  }\n  toMarkdown(options) {\n    let value = \"\";\n    for (const element of this.elements) {\n      if (value.length === 0) {\n        value = element.toMarkdown(options);\n      } else {\n        const text = element.toMarkdown(options);\n        value += fillNewlines(value) + text;\n      }\n    }\n    return value.trim();\n  }\n};\nvar JSDocTagImpl = class {\n  static {\n    __name(this, \"JSDocTagImpl\");\n  }\n  constructor(name, content, inline, range) {\n    this.name = name;\n    this.content = content;\n    this.inline = inline;\n    this.range = range;\n  }\n  toString() {\n    let text = `@${this.name}`;\n    const content = this.content.toString();\n    if (this.content.inlines.length === 1) {\n      text = `${text} ${content}`;\n    } else if (this.content.inlines.length > 1) {\n      text = `${text}\n${content}`;\n    }\n    if (this.inline) {\n      return `{${text}}`;\n    } else {\n      return text;\n    }\n  }\n  toMarkdown(options) {\n    var _a, _b;\n    return (_b = (_a = options === null || options === void 0 ? void 0 : options.renderTag) === null || _a === void 0 ? void 0 : _a.call(options, this)) !== null && _b !== void 0 ? _b : this.toMarkdownDefault(options);\n  }\n  toMarkdownDefault(options) {\n    const content = this.content.toMarkdown(options);\n    if (this.inline) {\n      const rendered = renderInlineTag(this.name, content, options !== null && options !== void 0 ? options : {});\n      if (typeof rendered === \"string\") {\n        return rendered;\n      }\n    }\n    let marker = \"\";\n    if ((options === null || options === void 0 ? void 0 : options.tag) === \"italic\" || (options === null || options === void 0 ? void 0 : options.tag) === void 0) {\n      marker = \"*\";\n    } else if ((options === null || options === void 0 ? void 0 : options.tag) === \"bold\") {\n      marker = \"**\";\n    } else if ((options === null || options === void 0 ? void 0 : options.tag) === \"bold-italic\") {\n      marker = \"***\";\n    }\n    let text = `${marker}@${this.name}${marker}`;\n    if (this.content.inlines.length === 1) {\n      text = `${text} \\u2014 ${content}`;\n    } else if (this.content.inlines.length > 1) {\n      text = `${text}\n${content}`;\n    }\n    if (this.inline) {\n      return `{${text}}`;\n    } else {\n      return text;\n    }\n  }\n};\nfunction renderInlineTag(tag, content, options) {\n  var _a, _b;\n  if (tag === \"linkplain\" || tag === \"linkcode\" || tag === \"link\") {\n    const index = content.indexOf(\" \");\n    let display = content;\n    if (index > 0) {\n      const displayStart = skipWhitespace(content, index);\n      display = content.substring(displayStart);\n      content = content.substring(0, index);\n    }\n    if (tag === \"linkcode\" || tag === \"link\" && options.link === \"code\") {\n      display = `\\`${display}\\``;\n    }\n    const renderedLink = (_b = (_a = options.renderLink) === null || _a === void 0 ? void 0 : _a.call(options, content, display)) !== null && _b !== void 0 ? _b : renderLinkDefault(content, display);\n    return renderedLink;\n  }\n  return void 0;\n}\n__name(renderInlineTag, \"renderInlineTag\");\nfunction renderLinkDefault(content, display) {\n  try {\n    URI2.parse(content, true);\n    return `[${display}](${content})`;\n  } catch (_a) {\n    return content;\n  }\n}\n__name(renderLinkDefault, \"renderLinkDefault\");\nvar JSDocTextImpl = class {\n  static {\n    __name(this, \"JSDocTextImpl\");\n  }\n  constructor(lines, range) {\n    this.inlines = lines;\n    this.range = range;\n  }\n  toString() {\n    let text = \"\";\n    for (let i = 0; i < this.inlines.length; i++) {\n      const inline = this.inlines[i];\n      const next = this.inlines[i + 1];\n      text += inline.toString();\n      if (next && next.range.start.line > inline.range.start.line) {\n        text += \"\\n\";\n      }\n    }\n    return text;\n  }\n  toMarkdown(options) {\n    let text = \"\";\n    for (let i = 0; i < this.inlines.length; i++) {\n      const inline = this.inlines[i];\n      const next = this.inlines[i + 1];\n      text += inline.toMarkdown(options);\n      if (next && next.range.start.line > inline.range.start.line) {\n        text += \"\\n\";\n      }\n    }\n    return text;\n  }\n};\nvar JSDocLineImpl = class {\n  static {\n    __name(this, \"JSDocLineImpl\");\n  }\n  constructor(text, range) {\n    this.text = text;\n    this.range = range;\n  }\n  toString() {\n    return this.text;\n  }\n  toMarkdown() {\n    return this.text;\n  }\n};\nfunction fillNewlines(text) {\n  if (text.endsWith(\"\\n\")) {\n    return \"\\n\";\n  } else {\n    return \"\\n\\n\";\n  }\n}\n__name(fillNewlines, \"fillNewlines\");\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/documentation/documentation-provider.js\nvar JSDocDocumentationProvider = class {\n  static {\n    __name(this, \"JSDocDocumentationProvider\");\n  }\n  constructor(services) {\n    this.indexManager = services.shared.workspace.IndexManager;\n    this.commentProvider = services.documentation.CommentProvider;\n  }\n  getDocumentation(node) {\n    const comment = this.commentProvider.getComment(node);\n    if (comment && isJSDoc(comment)) {\n      const parsedJSDoc = parseJSDoc(comment);\n      return parsedJSDoc.toMarkdown({\n        renderLink: /* @__PURE__ */ __name((link, display) => {\n          return this.documentationLinkRenderer(node, link, display);\n        }, \"renderLink\"),\n        renderTag: /* @__PURE__ */ __name((tag) => {\n          return this.documentationTagRenderer(node, tag);\n        }, \"renderTag\")\n      });\n    }\n    return void 0;\n  }\n  documentationLinkRenderer(node, name, display) {\n    var _a;\n    const description = (_a = this.findNameInPrecomputedScopes(node, name)) !== null && _a !== void 0 ? _a : this.findNameInGlobalScope(node, name);\n    if (description && description.nameSegment) {\n      const line = description.nameSegment.range.start.line + 1;\n      const character = description.nameSegment.range.start.character + 1;\n      const uri = description.documentUri.with({ fragment: `L${line},${character}` });\n      return `[${display}](${uri.toString()})`;\n    } else {\n      return void 0;\n    }\n  }\n  documentationTagRenderer(_node, _tag) {\n    return void 0;\n  }\n  findNameInPrecomputedScopes(node, name) {\n    const document = getDocument(node);\n    const precomputed = document.precomputedScopes;\n    if (!precomputed) {\n      return void 0;\n    }\n    let currentNode = node;\n    do {\n      const allDescriptions = precomputed.get(currentNode);\n      const description = allDescriptions.find((e) => e.name === name);\n      if (description) {\n        return description;\n      }\n      currentNode = currentNode.$container;\n    } while (currentNode);\n    return void 0;\n  }\n  findNameInGlobalScope(node, name) {\n    const description = this.indexManager.allElements().find((e) => e.name === name);\n    return description;\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/documentation/comment-provider.js\nvar DefaultCommentProvider = class {\n  static {\n    __name(this, \"DefaultCommentProvider\");\n  }\n  constructor(services) {\n    this.grammarConfig = () => services.parser.GrammarConfig;\n  }\n  getComment(node) {\n    var _a;\n    if (isAstNodeWithComment(node)) {\n      return node.$comment;\n    }\n    return (_a = findCommentNode(node.$cstNode, this.grammarConfig().multilineCommentRules)) === null || _a === void 0 ? void 0 : _a.text;\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/event.js\nvar event_exports = {};\n__reExport(event_exports, __toESM(require_events(), 1));\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/parser/async-parser.js\nvar DefaultAsyncParser = class {\n  static {\n    __name(this, \"DefaultAsyncParser\");\n  }\n  constructor(services) {\n    this.syncParser = services.parser.LangiumParser;\n  }\n  parse(text) {\n    return Promise.resolve(this.syncParser.parse(text));\n  }\n};\nvar AbstractThreadedAsyncParser = class {\n  static {\n    __name(this, \"AbstractThreadedAsyncParser\");\n  }\n  constructor(services) {\n    this.threadCount = 8;\n    this.terminationDelay = 200;\n    this.workerPool = [];\n    this.queue = [];\n    this.hydrator = services.serializer.Hydrator;\n  }\n  initializeWorkers() {\n    while (this.workerPool.length < this.threadCount) {\n      const worker = this.createWorker();\n      worker.onReady(() => {\n        if (this.queue.length > 0) {\n          const deferred = this.queue.shift();\n          if (deferred) {\n            worker.lock();\n            deferred.resolve(worker);\n          }\n        }\n      });\n      this.workerPool.push(worker);\n    }\n  }\n  async parse(text, cancelToken) {\n    const worker = await this.acquireParserWorker(cancelToken);\n    const deferred = new Deferred();\n    let timeout;\n    const cancellation = cancelToken.onCancellationRequested(() => {\n      timeout = setTimeout(() => {\n        this.terminateWorker(worker);\n      }, this.terminationDelay);\n    });\n    worker.parse(text).then((result) => {\n      const hydrated = this.hydrator.hydrate(result);\n      deferred.resolve(hydrated);\n    }).catch((err) => {\n      deferred.reject(err);\n    }).finally(() => {\n      cancellation.dispose();\n      clearTimeout(timeout);\n    });\n    return deferred.promise;\n  }\n  terminateWorker(worker) {\n    worker.terminate();\n    const index = this.workerPool.indexOf(worker);\n    if (index >= 0) {\n      this.workerPool.splice(index, 1);\n    }\n  }\n  async acquireParserWorker(cancelToken) {\n    this.initializeWorkers();\n    for (const worker of this.workerPool) {\n      if (worker.ready) {\n        worker.lock();\n        return worker;\n      }\n    }\n    const deferred = new Deferred();\n    cancelToken.onCancellationRequested(() => {\n      const index = this.queue.indexOf(deferred);\n      if (index >= 0) {\n        this.queue.splice(index, 1);\n      }\n      deferred.reject(OperationCancelled);\n    });\n    this.queue.push(deferred);\n    return deferred.promise;\n  }\n};\nvar ParserWorker = class {\n  static {\n    __name(this, \"ParserWorker\");\n  }\n  get ready() {\n    return this._ready;\n  }\n  get onReady() {\n    return this.onReadyEmitter.event;\n  }\n  constructor(sendMessage, onMessage, onError, terminate) {\n    this.onReadyEmitter = new event_exports.Emitter();\n    this.deferred = new Deferred();\n    this._ready = true;\n    this._parsing = false;\n    this.sendMessage = sendMessage;\n    this._terminate = terminate;\n    onMessage((result) => {\n      const parseResult = result;\n      this.deferred.resolve(parseResult);\n      this.unlock();\n    });\n    onError((error) => {\n      this.deferred.reject(error);\n      this.unlock();\n    });\n  }\n  terminate() {\n    this.deferred.reject(OperationCancelled);\n    this._terminate();\n  }\n  lock() {\n    this._ready = false;\n  }\n  unlock() {\n    this._parsing = false;\n    this._ready = true;\n    this.onReadyEmitter.fire();\n  }\n  parse(text) {\n    if (this._parsing) {\n      throw new Error(\"Parser worker is busy\");\n    }\n    this._parsing = true;\n    this.deferred = new Deferred();\n    this.sendMessage(text);\n    return this.deferred.promise;\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/workspace/workspace-lock.js\nvar DefaultWorkspaceLock = class {\n  static {\n    __name(this, \"DefaultWorkspaceLock\");\n  }\n  constructor() {\n    this.previousTokenSource = new cancellation_exports.CancellationTokenSource();\n    this.writeQueue = [];\n    this.readQueue = [];\n    this.done = true;\n  }\n  write(action) {\n    this.cancelWrite();\n    const tokenSource = new cancellation_exports.CancellationTokenSource();\n    this.previousTokenSource = tokenSource;\n    return this.enqueue(this.writeQueue, action, tokenSource.token);\n  }\n  read(action) {\n    return this.enqueue(this.readQueue, action);\n  }\n  enqueue(queue, action, cancellationToken) {\n    const deferred = new Deferred();\n    const entry = {\n      action,\n      deferred,\n      cancellationToken: cancellationToken !== null && cancellationToken !== void 0 ? cancellationToken : cancellation_exports.CancellationToken.None\n    };\n    queue.push(entry);\n    this.performNextOperation();\n    return deferred.promise;\n  }\n  async performNextOperation() {\n    if (!this.done) {\n      return;\n    }\n    const entries = [];\n    if (this.writeQueue.length > 0) {\n      entries.push(this.writeQueue.shift());\n    } else if (this.readQueue.length > 0) {\n      entries.push(...this.readQueue.splice(0, this.readQueue.length));\n    } else {\n      return;\n    }\n    this.done = false;\n    await Promise.all(entries.map(async ({ action, deferred, cancellationToken }) => {\n      try {\n        const result = await Promise.resolve().then(() => action(cancellationToken));\n        deferred.resolve(result);\n      } catch (err) {\n        if (isOperationCancelled(err)) {\n          deferred.resolve(void 0);\n        } else {\n          deferred.reject(err);\n        }\n      }\n    }));\n    this.done = true;\n    this.performNextOperation();\n  }\n  cancelWrite() {\n    this.previousTokenSource.cancel();\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/serializer/hydrator.js\nvar DefaultHydrator = class {\n  static {\n    __name(this, \"DefaultHydrator\");\n  }\n  constructor(services) {\n    this.grammarElementIdMap = new BiMap();\n    this.tokenTypeIdMap = new BiMap();\n    this.grammar = services.Grammar;\n    this.lexer = services.parser.Lexer;\n    this.linker = services.references.Linker;\n  }\n  dehydrate(result) {\n    return {\n      // We need to create shallow copies of the errors\n      // The original errors inherit from the `Error` class, which is not transferable across worker threads\n      lexerErrors: result.lexerErrors.map((e) => Object.assign({}, e)),\n      parserErrors: result.parserErrors.map((e) => Object.assign({}, e)),\n      value: this.dehydrateAstNode(result.value, this.createDehyrationContext(result.value))\n    };\n  }\n  createDehyrationContext(node) {\n    const astNodes = /* @__PURE__ */ new Map();\n    const cstNodes = /* @__PURE__ */ new Map();\n    for (const astNode of streamAst(node)) {\n      astNodes.set(astNode, {});\n    }\n    if (node.$cstNode) {\n      for (const cstNode of streamCst(node.$cstNode)) {\n        cstNodes.set(cstNode, {});\n      }\n    }\n    return {\n      astNodes,\n      cstNodes\n    };\n  }\n  dehydrateAstNode(node, context) {\n    const obj = context.astNodes.get(node);\n    obj.$type = node.$type;\n    obj.$containerIndex = node.$containerIndex;\n    obj.$containerProperty = node.$containerProperty;\n    if (node.$cstNode !== void 0) {\n      obj.$cstNode = this.dehydrateCstNode(node.$cstNode, context);\n    }\n    for (const [name, value] of Object.entries(node)) {\n      if (name.startsWith(\"$\")) {\n        continue;\n      }\n      if (Array.isArray(value)) {\n        const arr = [];\n        obj[name] = arr;\n        for (const item of value) {\n          if (isAstNode(item)) {\n            arr.push(this.dehydrateAstNode(item, context));\n          } else if (isReference(item)) {\n            arr.push(this.dehydrateReference(item, context));\n          } else {\n            arr.push(item);\n          }\n        }\n      } else if (isAstNode(value)) {\n        obj[name] = this.dehydrateAstNode(value, context);\n      } else if (isReference(value)) {\n        obj[name] = this.dehydrateReference(value, context);\n      } else if (value !== void 0) {\n        obj[name] = value;\n      }\n    }\n    return obj;\n  }\n  dehydrateReference(reference, context) {\n    const obj = {};\n    obj.$refText = reference.$refText;\n    if (reference.$refNode) {\n      obj.$refNode = context.cstNodes.get(reference.$refNode);\n    }\n    return obj;\n  }\n  dehydrateCstNode(node, context) {\n    const cstNode = context.cstNodes.get(node);\n    if (isRootCstNode(node)) {\n      cstNode.fullText = node.fullText;\n    } else {\n      cstNode.grammarSource = this.getGrammarElementId(node.grammarSource);\n    }\n    cstNode.hidden = node.hidden;\n    cstNode.astNode = context.astNodes.get(node.astNode);\n    if (isCompositeCstNode(node)) {\n      cstNode.content = node.content.map((child) => this.dehydrateCstNode(child, context));\n    } else if (isLeafCstNode(node)) {\n      cstNode.tokenType = node.tokenType.name;\n      cstNode.offset = node.offset;\n      cstNode.length = node.length;\n      cstNode.startLine = node.range.start.line;\n      cstNode.startColumn = node.range.start.character;\n      cstNode.endLine = node.range.end.line;\n      cstNode.endColumn = node.range.end.character;\n    }\n    return cstNode;\n  }\n  hydrate(result) {\n    const node = result.value;\n    const context = this.createHydrationContext(node);\n    if (\"$cstNode\" in node) {\n      this.hydrateCstNode(node.$cstNode, context);\n    }\n    return {\n      lexerErrors: result.lexerErrors,\n      parserErrors: result.parserErrors,\n      value: this.hydrateAstNode(node, context)\n    };\n  }\n  createHydrationContext(node) {\n    const astNodes = /* @__PURE__ */ new Map();\n    const cstNodes = /* @__PURE__ */ new Map();\n    for (const astNode of streamAst(node)) {\n      astNodes.set(astNode, {});\n    }\n    let root;\n    if (node.$cstNode) {\n      for (const cstNode of streamCst(node.$cstNode)) {\n        let cst;\n        if (\"fullText\" in cstNode) {\n          cst = new RootCstNodeImpl(cstNode.fullText);\n          root = cst;\n        } else if (\"content\" in cstNode) {\n          cst = new CompositeCstNodeImpl();\n        } else if (\"tokenType\" in cstNode) {\n          cst = this.hydrateCstLeafNode(cstNode);\n        }\n        if (cst) {\n          cstNodes.set(cstNode, cst);\n          cst.root = root;\n        }\n      }\n    }\n    return {\n      astNodes,\n      cstNodes\n    };\n  }\n  hydrateAstNode(node, context) {\n    const astNode = context.astNodes.get(node);\n    astNode.$type = node.$type;\n    astNode.$containerIndex = node.$containerIndex;\n    astNode.$containerProperty = node.$containerProperty;\n    if (node.$cstNode) {\n      astNode.$cstNode = context.cstNodes.get(node.$cstNode);\n    }\n    for (const [name, value] of Object.entries(node)) {\n      if (name.startsWith(\"$\")) {\n        continue;\n      }\n      if (Array.isArray(value)) {\n        const arr = [];\n        astNode[name] = arr;\n        for (const item of value) {\n          if (isAstNode(item)) {\n            arr.push(this.setParent(this.hydrateAstNode(item, context), astNode));\n          } else if (isReference(item)) {\n            arr.push(this.hydrateReference(item, astNode, name, context));\n          } else {\n            arr.push(item);\n          }\n        }\n      } else if (isAstNode(value)) {\n        astNode[name] = this.setParent(this.hydrateAstNode(value, context), astNode);\n      } else if (isReference(value)) {\n        astNode[name] = this.hydrateReference(value, astNode, name, context);\n      } else if (value !== void 0) {\n        astNode[name] = value;\n      }\n    }\n    return astNode;\n  }\n  setParent(node, parent) {\n    node.$container = parent;\n    return node;\n  }\n  hydrateReference(reference, node, name, context) {\n    return this.linker.buildReference(node, name, context.cstNodes.get(reference.$refNode), reference.$refText);\n  }\n  hydrateCstNode(cstNode, context, num = 0) {\n    const cstNodeObj = context.cstNodes.get(cstNode);\n    if (typeof cstNode.grammarSource === \"number\") {\n      cstNodeObj.grammarSource = this.getGrammarElement(cstNode.grammarSource);\n    }\n    cstNodeObj.astNode = context.astNodes.get(cstNode.astNode);\n    if (isCompositeCstNode(cstNodeObj)) {\n      for (const child of cstNode.content) {\n        const hydrated = this.hydrateCstNode(child, context, num++);\n        cstNodeObj.content.push(hydrated);\n      }\n    }\n    return cstNodeObj;\n  }\n  hydrateCstLeafNode(cstNode) {\n    const tokenType = this.getTokenType(cstNode.tokenType);\n    const offset = cstNode.offset;\n    const length = cstNode.length;\n    const startLine = cstNode.startLine;\n    const startColumn = cstNode.startColumn;\n    const endLine = cstNode.endLine;\n    const endColumn = cstNode.endColumn;\n    const hidden = cstNode.hidden;\n    const node = new LeafCstNodeImpl(offset, length, {\n      start: {\n        line: startLine,\n        character: startColumn\n      },\n      end: {\n        line: endLine,\n        character: endColumn\n      }\n    }, tokenType, hidden);\n    return node;\n  }\n  getTokenType(name) {\n    return this.lexer.definition[name];\n  }\n  getGrammarElementId(node) {\n    if (this.grammarElementIdMap.size === 0) {\n      this.createGrammarElementIdMap();\n    }\n    return this.grammarElementIdMap.get(node);\n  }\n  getGrammarElement(id) {\n    if (this.grammarElementIdMap.size === 0) {\n      this.createGrammarElementIdMap();\n    }\n    const element = this.grammarElementIdMap.getKey(id);\n    if (element) {\n      return element;\n    } else {\n      throw new Error(\"Invalid grammar element id: \" + id);\n    }\n  }\n  createGrammarElementIdMap() {\n    let id = 0;\n    for (const element of streamAst(this.grammar)) {\n      if (isAbstractElement(element)) {\n        this.grammarElementIdMap.set(element, id++);\n      }\n    }\n  }\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/default-module.js\nfunction createDefaultCoreModule(context) {\n  return {\n    documentation: {\n      CommentProvider: /* @__PURE__ */ __name((services) => new DefaultCommentProvider(services), \"CommentProvider\"),\n      DocumentationProvider: /* @__PURE__ */ __name((services) => new JSDocDocumentationProvider(services), \"DocumentationProvider\")\n    },\n    parser: {\n      AsyncParser: /* @__PURE__ */ __name((services) => new DefaultAsyncParser(services), \"AsyncParser\"),\n      GrammarConfig: /* @__PURE__ */ __name((services) => createGrammarConfig(services), \"GrammarConfig\"),\n      LangiumParser: /* @__PURE__ */ __name((services) => createLangiumParser(services), \"LangiumParser\"),\n      CompletionParser: /* @__PURE__ */ __name((services) => createCompletionParser(services), \"CompletionParser\"),\n      ValueConverter: /* @__PURE__ */ __name(() => new DefaultValueConverter(), \"ValueConverter\"),\n      TokenBuilder: /* @__PURE__ */ __name(() => new DefaultTokenBuilder(), \"TokenBuilder\"),\n      Lexer: /* @__PURE__ */ __name((services) => new DefaultLexer(services), \"Lexer\"),\n      ParserErrorMessageProvider: /* @__PURE__ */ __name(() => new LangiumParserErrorMessageProvider(), \"ParserErrorMessageProvider\")\n    },\n    workspace: {\n      AstNodeLocator: /* @__PURE__ */ __name(() => new DefaultAstNodeLocator(), \"AstNodeLocator\"),\n      AstNodeDescriptionProvider: /* @__PURE__ */ __name((services) => new DefaultAstNodeDescriptionProvider(services), \"AstNodeDescriptionProvider\"),\n      ReferenceDescriptionProvider: /* @__PURE__ */ __name((services) => new DefaultReferenceDescriptionProvider(services), \"ReferenceDescriptionProvider\")\n    },\n    references: {\n      Linker: /* @__PURE__ */ __name((services) => new DefaultLinker(services), \"Linker\"),\n      NameProvider: /* @__PURE__ */ __name(() => new DefaultNameProvider(), \"NameProvider\"),\n      ScopeProvider: /* @__PURE__ */ __name((services) => new DefaultScopeProvider(services), \"ScopeProvider\"),\n      ScopeComputation: /* @__PURE__ */ __name((services) => new DefaultScopeComputation(services), \"ScopeComputation\"),\n      References: /* @__PURE__ */ __name((services) => new DefaultReferences(services), \"References\")\n    },\n    serializer: {\n      Hydrator: /* @__PURE__ */ __name((services) => new DefaultHydrator(services), \"Hydrator\"),\n      JsonSerializer: /* @__PURE__ */ __name((services) => new DefaultJsonSerializer(services), \"JsonSerializer\")\n    },\n    validation: {\n      DocumentValidator: /* @__PURE__ */ __name((services) => new DefaultDocumentValidator(services), \"DocumentValidator\"),\n      ValidationRegistry: /* @__PURE__ */ __name((services) => new ValidationRegistry(services), \"ValidationRegistry\")\n    },\n    shared: /* @__PURE__ */ __name(() => context.shared, \"shared\")\n  };\n}\n__name(createDefaultCoreModule, \"createDefaultCoreModule\");\nfunction createDefaultSharedCoreModule(context) {\n  return {\n    ServiceRegistry: /* @__PURE__ */ __name(() => new DefaultServiceRegistry(), \"ServiceRegistry\"),\n    workspace: {\n      LangiumDocuments: /* @__PURE__ */ __name((services) => new DefaultLangiumDocuments(services), \"LangiumDocuments\"),\n      LangiumDocumentFactory: /* @__PURE__ */ __name((services) => new DefaultLangiumDocumentFactory(services), \"LangiumDocumentFactory\"),\n      DocumentBuilder: /* @__PURE__ */ __name((services) => new DefaultDocumentBuilder(services), \"DocumentBuilder\"),\n      IndexManager: /* @__PURE__ */ __name((services) => new DefaultIndexManager(services), \"IndexManager\"),\n      WorkspaceManager: /* @__PURE__ */ __name((services) => new DefaultWorkspaceManager(services), \"WorkspaceManager\"),\n      FileSystemProvider: /* @__PURE__ */ __name((services) => context.fileSystemProvider(services), \"FileSystemProvider\"),\n      WorkspaceLock: /* @__PURE__ */ __name(() => new DefaultWorkspaceLock(), \"WorkspaceLock\"),\n      ConfigurationProvider: /* @__PURE__ */ __name((services) => new DefaultConfigurationProvider(services), \"ConfigurationProvider\")\n    }\n  };\n}\n__name(createDefaultSharedCoreModule, \"createDefaultSharedCoreModule\");\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/dependency-injection.js\nvar Module;\n(function(Module2) {\n  Module2.merge = (m1, m2) => _merge(_merge({}, m1), m2);\n})(Module || (Module = {}));\nfunction inject(module1, module2, module3, module4, module5, module6, module7, module8, module9) {\n  const module = [module1, module2, module3, module4, module5, module6, module7, module8, module9].reduce(_merge, {});\n  return _inject(module);\n}\n__name(inject, \"inject\");\nvar isProxy = Symbol(\"isProxy\");\nfunction eagerLoad(item) {\n  if (item && item[isProxy]) {\n    for (const value of Object.values(item)) {\n      eagerLoad(value);\n    }\n  }\n  return item;\n}\n__name(eagerLoad, \"eagerLoad\");\nfunction _inject(module, injector) {\n  const proxy = new Proxy({}, {\n    deleteProperty: /* @__PURE__ */ __name(() => false, \"deleteProperty\"),\n    get: /* @__PURE__ */ __name((obj, prop) => _resolve(obj, prop, module, injector || proxy), \"get\"),\n    getOwnPropertyDescriptor: /* @__PURE__ */ __name((obj, prop) => (_resolve(obj, prop, module, injector || proxy), Object.getOwnPropertyDescriptor(obj, prop)), \"getOwnPropertyDescriptor\"),\n    has: /* @__PURE__ */ __name((_, prop) => prop in module, \"has\"),\n    ownKeys: /* @__PURE__ */ __name(() => [...Reflect.ownKeys(module), isProxy], \"ownKeys\")\n    // used by for..in\n  });\n  proxy[isProxy] = true;\n  return proxy;\n}\n__name(_inject, \"_inject\");\nvar __requested__ = Symbol();\nfunction _resolve(obj, prop, module, injector) {\n  if (prop in obj) {\n    if (obj[prop] instanceof Error) {\n      throw new Error(\"Construction failure. Please make sure that your dependencies are constructable.\", { cause: obj[prop] });\n    }\n    if (obj[prop] === __requested__) {\n      throw new Error('Cycle detected. Please make \"' + String(prop) + '\" lazy. See https://langium.org/docs/configuration-services/#resolving-cyclic-dependencies');\n    }\n    return obj[prop];\n  } else if (prop in module) {\n    const value = module[prop];\n    obj[prop] = __requested__;\n    try {\n      obj[prop] = typeof value === \"function\" ? value(injector) : _inject(value, injector);\n    } catch (error) {\n      obj[prop] = error instanceof Error ? error : void 0;\n      throw error;\n    }\n    return obj[prop];\n  } else {\n    return void 0;\n  }\n}\n__name(_resolve, \"_resolve\");\nfunction _merge(target, source) {\n  if (source) {\n    for (const [key, value2] of Object.entries(source)) {\n      if (value2 !== void 0) {\n        const value1 = target[key];\n        if (value1 !== null && value2 !== null && typeof value1 === \"object\" && typeof value2 === \"object\") {\n          target[key] = _merge(value1, value2);\n        } else {\n          target[key] = value2;\n        }\n      }\n    }\n  }\n  return target;\n}\n__name(_merge, \"_merge\");\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/index.js\nvar utils_exports = {};\n__export(utils_exports, {\n  AstUtils: () => ast_utils_exports,\n  BiMap: () => BiMap,\n  Cancellation: () => cancellation_exports,\n  ContextCache: () => ContextCache,\n  CstUtils: () => cst_utils_exports,\n  DONE_RESULT: () => DONE_RESULT,\n  Deferred: () => Deferred,\n  Disposable: () => Disposable,\n  DisposableCache: () => DisposableCache,\n  DocumentCache: () => DocumentCache,\n  EMPTY_STREAM: () => EMPTY_STREAM,\n  ErrorWithLocation: () => ErrorWithLocation,\n  GrammarUtils: () => grammar_utils_exports,\n  MultiMap: () => MultiMap,\n  OperationCancelled: () => OperationCancelled,\n  Reduction: () => Reduction,\n  RegExpUtils: () => regexp_utils_exports,\n  SimpleCache: () => SimpleCache,\n  StreamImpl: () => StreamImpl,\n  TreeStreamImpl: () => TreeStreamImpl,\n  URI: () => URI2,\n  UriUtils: () => UriUtils,\n  WorkspaceCache: () => WorkspaceCache,\n  assertUnreachable: () => assertUnreachable,\n  delayNextTick: () => delayNextTick,\n  interruptAndCheck: () => interruptAndCheck,\n  isOperationCancelled: () => isOperationCancelled,\n  loadGrammarFromJson: () => loadGrammarFromJson,\n  setInterruptionPeriod: () => setInterruptionPeriod,\n  startCancelableOperation: () => startCancelableOperation,\n  stream: () => stream\n});\n__reExport(utils_exports, event_exports);\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/workspace/file-system-provider.js\nvar EmptyFileSystemProvider = class {\n  static {\n    __name(this, \"EmptyFileSystemProvider\");\n  }\n  readFile() {\n    throw new Error(\"No file system is available.\");\n  }\n  async readDirectory() {\n    return [];\n  }\n};\nvar EmptyFileSystem = {\n  fileSystemProvider: /* @__PURE__ */ __name(() => new EmptyFileSystemProvider(), \"fileSystemProvider\")\n};\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/utils/grammar-loader.js\nvar minimalGrammarModule = {\n  Grammar: /* @__PURE__ */ __name(() => void 0, \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => ({\n    caseInsensitive: false,\n    fileExtensions: [\".langium\"],\n    languageId: \"langium\"\n  }), \"LanguageMetaData\")\n};\nvar minimalSharedGrammarModule = {\n  AstReflection: /* @__PURE__ */ __name(() => new LangiumGrammarAstReflection(), \"AstReflection\")\n};\nfunction createMinimalGrammarServices() {\n  const shared = inject(createDefaultSharedCoreModule(EmptyFileSystem), minimalSharedGrammarModule);\n  const grammar = inject(createDefaultCoreModule({ shared }), minimalGrammarModule);\n  shared.ServiceRegistry.register(grammar);\n  return grammar;\n}\n__name(createMinimalGrammarServices, \"createMinimalGrammarServices\");\nfunction loadGrammarFromJson(json) {\n  var _a;\n  const services = createMinimalGrammarServices();\n  const astNode = services.serializer.JsonSerializer.deserialize(json);\n  services.shared.workspace.LangiumDocumentFactory.fromModel(astNode, URI2.parse(`memory://${(_a = astNode.name) !== null && _a !== void 0 ? _a : \"grammar\"}.langium`));\n  return astNode;\n}\n__name(loadGrammarFromJson, \"loadGrammarFromJson\");\n\n// ../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/lib/index.js\n__reExport(lib_exports, utils_exports);\n\n// ../parser/dist/chunks/mermaid-parser.core/chunk-Y27MQZ3U.mjs\nvar __defProp = Object.defineProperty;\nvar __name2 = /* @__PURE__ */ __name((target, value) => __defProp(target, \"name\", { value, configurable: true }), \"__name\");\nvar Statement = \"Statement\";\nvar Architecture = \"Architecture\";\nfunction isArchitecture(item) {\n  return reflection2.isInstance(item, Architecture);\n}\n__name(isArchitecture, \"isArchitecture\");\n__name2(isArchitecture, \"isArchitecture\");\nvar Branch = \"Branch\";\nfunction isBranch(item) {\n  return reflection2.isInstance(item, Branch);\n}\n__name(isBranch, \"isBranch\");\n__name2(isBranch, \"isBranch\");\nvar Checkout = \"Checkout\";\nvar CherryPicking = \"CherryPicking\";\nvar Commit = \"Commit\";\nfunction isCommit(item) {\n  return reflection2.isInstance(item, Commit);\n}\n__name(isCommit, \"isCommit\");\n__name2(isCommit, \"isCommit\");\nvar Common = \"Common\";\nfunction isCommon(item) {\n  return reflection2.isInstance(item, Common);\n}\n__name(isCommon, \"isCommon\");\n__name2(isCommon, \"isCommon\");\nvar GitGraph = \"GitGraph\";\nfunction isGitGraph(item) {\n  return reflection2.isInstance(item, GitGraph);\n}\n__name(isGitGraph, \"isGitGraph\");\n__name2(isGitGraph, \"isGitGraph\");\nvar Info = \"Info\";\nfunction isInfo(item) {\n  return reflection2.isInstance(item, Info);\n}\n__name(isInfo, \"isInfo\");\n__name2(isInfo, \"isInfo\");\nvar Merge = \"Merge\";\nfunction isMerge(item) {\n  return reflection2.isInstance(item, Merge);\n}\n__name(isMerge, \"isMerge\");\n__name2(isMerge, \"isMerge\");\nvar Packet = \"Packet\";\nfunction isPacket(item) {\n  return reflection2.isInstance(item, Packet);\n}\n__name(isPacket, \"isPacket\");\n__name2(isPacket, \"isPacket\");\nvar PacketBlock = \"PacketBlock\";\nfunction isPacketBlock(item) {\n  return reflection2.isInstance(item, PacketBlock);\n}\n__name(isPacketBlock, \"isPacketBlock\");\n__name2(isPacketBlock, \"isPacketBlock\");\nvar Pie = \"Pie\";\nfunction isPie(item) {\n  return reflection2.isInstance(item, Pie);\n}\n__name(isPie, \"isPie\");\n__name2(isPie, \"isPie\");\nvar PieSection = \"PieSection\";\nfunction isPieSection(item) {\n  return reflection2.isInstance(item, PieSection);\n}\n__name(isPieSection, \"isPieSection\");\n__name2(isPieSection, \"isPieSection\");\nvar Direction = \"Direction\";\nvar MermaidAstReflection = class extends AbstractAstReflection {\n  static {\n    __name(this, \"MermaidAstReflection\");\n  }\n  static {\n    __name2(this, \"MermaidAstReflection\");\n  }\n  getAllTypes() {\n    return [\"Architecture\", \"Branch\", \"Checkout\", \"CherryPicking\", \"Commit\", \"Common\", \"Direction\", \"Edge\", \"GitGraph\", \"Group\", \"Info\", \"Junction\", \"Merge\", \"Packet\", \"PacketBlock\", \"Pie\", \"PieSection\", \"Service\", \"Statement\"];\n  }\n  computeIsSubtype(subtype, supertype) {\n    switch (subtype) {\n      case Branch:\n      case Checkout:\n      case CherryPicking:\n      case Commit:\n      case Merge: {\n        return this.isSubtype(Statement, supertype);\n      }\n      case Direction: {\n        return this.isSubtype(GitGraph, supertype);\n      }\n      default: {\n        return false;\n      }\n    }\n  }\n  getReferenceType(refInfo) {\n    const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n    switch (referenceId) {\n      default: {\n        throw new Error(`${referenceId} is not a valid reference id.`);\n      }\n    }\n  }\n  getTypeMetaData(type) {\n    switch (type) {\n      case \"Architecture\": {\n        return {\n          name: \"Architecture\",\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"edges\", defaultValue: [] },\n            { name: \"groups\", defaultValue: [] },\n            { name: \"junctions\", defaultValue: [] },\n            { name: \"services\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case \"Branch\": {\n        return {\n          name: \"Branch\",\n          properties: [\n            { name: \"name\" },\n            { name: \"order\" }\n          ]\n        };\n      }\n      case \"Checkout\": {\n        return {\n          name: \"Checkout\",\n          properties: [\n            { name: \"branch\" }\n          ]\n        };\n      }\n      case \"CherryPicking\": {\n        return {\n          name: \"CherryPicking\",\n          properties: [\n            { name: \"id\" },\n            { name: \"parent\" },\n            { name: \"tags\", defaultValue: [] }\n          ]\n        };\n      }\n      case \"Commit\": {\n        return {\n          name: \"Commit\",\n          properties: [\n            { name: \"id\" },\n            { name: \"message\" },\n            { name: \"tags\", defaultValue: [] },\n            { name: \"type\" }\n          ]\n        };\n      }\n      case \"Common\": {\n        return {\n          name: \"Common\",\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case \"Edge\": {\n        return {\n          name: \"Edge\",\n          properties: [\n            { name: \"lhsDir\" },\n            { name: \"lhsGroup\", defaultValue: false },\n            { name: \"lhsId\" },\n            { name: \"lhsInto\", defaultValue: false },\n            { name: \"rhsDir\" },\n            { name: \"rhsGroup\", defaultValue: false },\n            { name: \"rhsId\" },\n            { name: \"rhsInto\", defaultValue: false },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case \"GitGraph\": {\n        return {\n          name: \"GitGraph\",\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"statements\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case \"Group\": {\n        return {\n          name: \"Group\",\n          properties: [\n            { name: \"icon\" },\n            { name: \"id\" },\n            { name: \"in\" },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case \"Info\": {\n        return {\n          name: \"Info\",\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case \"Junction\": {\n        return {\n          name: \"Junction\",\n          properties: [\n            { name: \"id\" },\n            { name: \"in\" }\n          ]\n        };\n      }\n      case \"Merge\": {\n        return {\n          name: \"Merge\",\n          properties: [\n            { name: \"branch\" },\n            { name: \"id\" },\n            { name: \"tags\", defaultValue: [] },\n            { name: \"type\" }\n          ]\n        };\n      }\n      case \"Packet\": {\n        return {\n          name: \"Packet\",\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"blocks\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case \"PacketBlock\": {\n        return {\n          name: \"PacketBlock\",\n          properties: [\n            { name: \"end\" },\n            { name: \"label\" },\n            { name: \"start\" }\n          ]\n        };\n      }\n      case \"Pie\": {\n        return {\n          name: \"Pie\",\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"sections\", defaultValue: [] },\n            { name: \"showData\", defaultValue: false },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case \"PieSection\": {\n        return {\n          name: \"PieSection\",\n          properties: [\n            { name: \"label\" },\n            { name: \"value\" }\n          ]\n        };\n      }\n      case \"Service\": {\n        return {\n          name: \"Service\",\n          properties: [\n            { name: \"icon\" },\n            { name: \"iconText\" },\n            { name: \"id\" },\n            { name: \"in\" },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case \"Direction\": {\n        return {\n          name: \"Direction\",\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"dir\" },\n            { name: \"statements\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      default: {\n        return {\n          name: type,\n          properties: []\n        };\n      }\n    }\n  }\n};\nvar reflection2 = new MermaidAstReflection();\nvar loadedInfoGrammar;\nvar InfoGrammar = /* @__PURE__ */ __name2(() => loadedInfoGrammar ?? (loadedInfoGrammar = loadGrammarFromJson('{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Info\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"name\":\"Info\",\"entry\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"info\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"showInfo\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"*\"}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"TitleAndAccessibilities\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"EOL\",\"fragment\":true,\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}')), \"InfoGrammar\");\nvar loadedPacketGrammar;\nvar PacketGrammar = /* @__PURE__ */ __name2(() => loadedPacketGrammar ?? (loadedPacketGrammar = loadGrammarFromJson(`{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Packet\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"name\":\"Packet\",\"entry\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"packet-beta\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"blocks\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"Assignment\",\"feature\":\"blocks\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"+\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"PacketBlock\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"start\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"-\"},{\"$type\":\"Assignment\",\"feature\":\"end\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"label\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"INT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/0|[1-9][0-9]*/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]*\\\\\"|'[^']*'/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"name\":\"TitleAndAccessibilities\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"EOL\",\"fragment\":true,\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}`)), \"PacketGrammar\");\nvar loadedPieGrammar;\nvar PieGrammar = /* @__PURE__ */ __name2(() => loadedPieGrammar ?? (loadedPieGrammar = loadGrammarFromJson('{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Pie\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"name\":\"Pie\",\"entry\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"pie\"},{\"$type\":\"Assignment\",\"feature\":\"showData\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"showData\"},\"cardinality\":\"?\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"sections\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"Assignment\",\"feature\":\"sections\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"+\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"PieSection\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"label\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"PIE_SECTION_LABEL\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]+\\\\\"/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"PIE_SECTION_VALUE\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/(0|[1-9][0-9]*)(\\\\\\\\.[0-9]+)?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"name\":\"TitleAndAccessibilities\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"EOL\",\"fragment\":true,\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}')), \"PieGrammar\");\nvar loadedArchitectureGrammar;\nvar ArchitectureGrammar = /* @__PURE__ */ __name2(() => loadedArchitectureGrammar ?? (loadedArchitectureGrammar = loadGrammarFromJson('{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Architecture\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"name\":\"Architecture\",\"entry\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"architecture-beta\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[],\"cardinality\":\"*\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Statement\",\"fragment\":true,\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"groups\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"services\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"junctions\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"edges\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"LeftPort\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"lhsDir\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"RightPort\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"rhsDir\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\":\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Arrow\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"lhsInto\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"--\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"-\"},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\"-\"}]}]},{\"$type\":\"Assignment\",\"feature\":\"rhsInto\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Group\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"group\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"icon\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"in\"},{\"$type\":\"Assignment\",\"feature\":\"in\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Service\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"service\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"iconText\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"icon\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"in\"},{\"$type\":\"Assignment\",\"feature\":\"in\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Junction\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"junction\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"in\"},{\"$type\":\"Assignment\",\"feature\":\"in\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Edge\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"lhsId\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"lhsGroup\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"rhsId\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"rhsGroup\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARROW_DIRECTION\",\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"L\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"R\"}}]},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"T\"}}]},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"B\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_ID\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\w]+/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_TEXT_ICON\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\(\\\\\"[^\\\\\"]+\\\\\"\\\\\\\\)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_ICON\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\([\\\\\\\\w-:]+\\\\\\\\)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\[[\\\\\\\\w ]+\\\\\\\\]/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARROW_GROUP\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\{group\\\\\\\\}/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARROW_INTO\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/<|>/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"name\":\"TitleAndAccessibilities\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@21\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"EOL\",\"fragment\":true,\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}')), \"ArchitectureGrammar\");\nvar loadedGitGraphGrammar;\nvar GitGraphGrammar = /* @__PURE__ */ __name2(() => loadedGitGraphGrammar ?? (loadedGitGraphGrammar = loadGrammarFromJson(`{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"GitGraph\",\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"rules\":[{\"$type\":\"ParserRule\",\"name\":\"TitleAndAccessibilities\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"EOL\",\"fragment\":true,\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false},{\"$type\":\"ParserRule\",\"name\":\"GitGraph\",\"entry\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"gitGraph\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"gitGraph\"},{\"$type\":\"Keyword\",\"value\":\":\"}]},{\"$type\":\"Keyword\",\"value\":\"gitGraph:\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"gitGraph\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]},{\"$type\":\"Keyword\",\"value\":\":\"}]}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@0\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"statements\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Statement\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Direction\",\"definition\":{\"$type\":\"Assignment\",\"feature\":\"dir\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"LR\"},{\"$type\":\"Keyword\",\"value\":\"TB\"},{\"$type\":\"Keyword\",\"value\":\"BT\"}]}},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Commit\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"commit\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"id:\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"msg:\",\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"message\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"tag:\"},{\"$type\":\"Assignment\",\"feature\":\"tags\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"type:\"},{\"$type\":\"Assignment\",\"feature\":\"type\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"NORMAL\"},{\"$type\":\"Keyword\",\"value\":\"REVERSE\"},{\"$type\":\"Keyword\",\"value\":\"HIGHLIGHT\"}]}}]}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Branch\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"branch\"},{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"order:\"},{\"$type\":\"Assignment\",\"feature\":\"order\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Merge\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"merge\"},{\"$type\":\"Assignment\",\"feature\":\"branch\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}]}},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"id:\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"tag:\"},{\"$type\":\"Assignment\",\"feature\":\"tags\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"type:\"},{\"$type\":\"Assignment\",\"feature\":\"type\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"NORMAL\"},{\"$type\":\"Keyword\",\"value\":\"REVERSE\"},{\"$type\":\"Keyword\",\"value\":\"HIGHLIGHT\"}]}}]}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Checkout\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"checkout\"},{\"$type\":\"Keyword\",\"value\":\"switch\"}]},{\"$type\":\"Assignment\",\"feature\":\"branch\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"CherryPicking\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"cherry-pick\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"id:\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"tag:\"},{\"$type\":\"Assignment\",\"feature\":\"tags\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"parent:\"},{\"$type\":\"Assignment\",\"feature\":\"parent\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"INT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[0-9]+(?=\\\\\\\\s)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ID\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\w([-\\\\\\\\./\\\\\\\\w]*[-\\\\\\\\w])?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]*\\\\\"|'[^']*'/\"},\"fragment\":false,\"hidden\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"imports\":[],\"types\":[],\"usedGrammars\":[]}`)), \"GitGraphGrammar\");\nvar InfoLanguageMetaData = {\n  languageId: \"info\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false\n};\nvar PacketLanguageMetaData = {\n  languageId: \"packet\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false\n};\nvar PieLanguageMetaData = {\n  languageId: \"pie\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false\n};\nvar ArchitectureLanguageMetaData = {\n  languageId: \"architecture\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false\n};\nvar GitGraphLanguageMetaData = {\n  languageId: \"gitGraph\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false\n};\nvar MermaidGeneratedSharedModule = {\n  AstReflection: /* @__PURE__ */ __name2(() => new MermaidAstReflection(), \"AstReflection\")\n};\nvar InfoGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name2(() => InfoGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name2(() => InfoLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar PacketGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name2(() => PacketGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name2(() => PacketLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar PieGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name2(() => PieGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name2(() => PieLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar ArchitectureGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name2(() => ArchitectureGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name2(() => ArchitectureLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar GitGraphGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name2(() => GitGraphGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name2(() => GitGraphLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar accessibilityDescrRegex = /accDescr(?:[\\t ]*:([^\\n\\r]*)|\\s*{([^}]*)})/;\nvar accessibilityTitleRegex = /accTitle[\\t ]*:([^\\n\\r]*)/;\nvar titleRegex = /title([\\t ][^\\n\\r]*|)/;\nvar rulesRegexes = {\n  ACC_DESCR: accessibilityDescrRegex,\n  ACC_TITLE: accessibilityTitleRegex,\n  TITLE: titleRegex\n};\nvar AbstractMermaidValueConverter = class extends DefaultValueConverter {\n  static {\n    __name(this, \"AbstractMermaidValueConverter\");\n  }\n  static {\n    __name2(this, \"AbstractMermaidValueConverter\");\n  }\n  runConverter(rule, input, cstNode) {\n    let value = this.runCommonConverter(rule, input, cstNode);\n    if (value === void 0) {\n      value = this.runCustomConverter(rule, input, cstNode);\n    }\n    if (value === void 0) {\n      return super.runConverter(rule, input, cstNode);\n    }\n    return value;\n  }\n  runCommonConverter(rule, input, _cstNode) {\n    const regex = rulesRegexes[rule.name];\n    if (regex === void 0) {\n      return void 0;\n    }\n    const match = regex.exec(input);\n    if (match === null) {\n      return void 0;\n    }\n    if (match[1] !== void 0) {\n      return match[1].trim().replace(/[\\t ]{2,}/gm, \" \");\n    }\n    if (match[2] !== void 0) {\n      return match[2].replace(/^\\s*/gm, \"\").replace(/\\s+$/gm, \"\").replace(/[\\t ]{2,}/gm, \" \").replace(/[\\n\\r]{2,}/gm, \"\\n\");\n    }\n    return void 0;\n  }\n};\nvar CommonValueConverter = class extends AbstractMermaidValueConverter {\n  static {\n    __name(this, \"CommonValueConverter\");\n  }\n  static {\n    __name2(this, \"CommonValueConverter\");\n  }\n  runCustomConverter(_rule, _input, _cstNode) {\n    return void 0;\n  }\n};\nvar AbstractMermaidTokenBuilder = class extends DefaultTokenBuilder {\n  static {\n    __name(this, \"AbstractMermaidTokenBuilder\");\n  }\n  static {\n    __name2(this, \"AbstractMermaidTokenBuilder\");\n  }\n  constructor(keywords) {\n    super();\n    this.keywords = new Set(keywords);\n  }\n  buildKeywordTokens(rules, terminalTokens, options) {\n    const tokenTypes = super.buildKeywordTokens(rules, terminalTokens, options);\n    tokenTypes.forEach((tokenType) => {\n      if (this.keywords.has(tokenType.name) && tokenType.PATTERN !== void 0) {\n        tokenType.PATTERN = new RegExp(tokenType.PATTERN.toString() + \"(?:(?=%%)|(?!\\\\S))\");\n      }\n    });\n    return tokenTypes;\n  }\n};\nvar CommonTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"CommonTokenBuilder\");\n  }\n  static {\n    __name2(this, \"CommonTokenBuilder\");\n  }\n};\n\nexport {\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject,\n  EmptyFileSystem,\n  lib_exports,\n  __name2 as __name,\n  MermaidGeneratedSharedModule,\n  InfoGeneratedModule,\n  PacketGeneratedModule,\n  PieGeneratedModule,\n  ArchitectureGeneratedModule,\n  GitGraphGeneratedModule,\n  AbstractMermaidValueConverter,\n  CommonValueConverter,\n  AbstractMermaidTokenBuilder\n};\n","let load = require('./helpers/browser/esm-js-loader');\nmodule.exports = (load(\"8keGE\")).then(() => parcelRequire('djlbY'));","\"use strict\";\n\nfunction load(id) {\n  // eslint-disable-next-line no-undef\n  return __parcel__import__(require('../bundle-manifest').resolve(id));\n}\nmodule.exports = load;","\"use strict\";\n\nvar mapping = new Map();\nfunction register(baseUrl, manifest) {\n  for (var i = 0; i < manifest.length - 1; i += 2) {\n    mapping.set(manifest[i], {\n      baseUrl: baseUrl,\n      path: manifest[i + 1]\n    });\n  }\n}\nfunction resolve(id) {\n  var resolved = mapping.get(id);\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n  return new URL(resolved.path, resolved.baseUrl).toString();\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","let load = require('./helpers/browser/esm-js-loader');\nmodule.exports = (load(\"d6WIZ\")).then(() => parcelRequire('fLfFj'));","let load = require('./helpers/browser/esm-js-loader');\nmodule.exports = (load(\"8xVaV\")).then(() => parcelRequire('f8ywF'));","let load = require('./helpers/browser/esm-js-loader');\nmodule.exports = (load(\"8nmL9\")).then(() => parcelRequire('934lS'));","let load = require('./helpers/browser/esm-js-loader');\nmodule.exports = (load(\"hyTfq\")).then(() => parcelRequire('h7uU7'));","import {\n  AbstractMermaidTokenBuilder,\n  CommonValueConverter,\n  EmptyFileSystem,\n  InfoGeneratedModule,\n  MermaidGeneratedSharedModule,\n  __name as __name2,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject,\n  lib_exports\n} from \"./chunk-46UCTVYF.mjs\";\nimport {\n  __name\n} from \"./chunk-DLQEHMXD.mjs\";\n\n// ../parser/dist/chunks/mermaid-parser.core/chunk-4YFB5VUC.mjs\nvar InfoTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"InfoTokenBuilder\");\n  }\n  static {\n    __name2(this, \"InfoTokenBuilder\");\n  }\n  constructor() {\n    super([\"info\", \"showInfo\"]);\n  }\n};\nvar InfoModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name2(() => new InfoTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name2(() => new CommonValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createInfoServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Info = inject(\n    createDefaultCoreModule({ shared }),\n    InfoGeneratedModule,\n    InfoModule\n  );\n  shared.ServiceRegistry.register(Info);\n  return { shared, Info };\n}\n__name(createInfoServices, \"createInfoServices\");\n__name2(createInfoServices, \"createInfoServices\");\n\nexport {\n  InfoModule,\n  createInfoServices\n};\n","import {\n  AbstractMermaidTokenBuilder,\n  CommonValueConverter,\n  EmptyFileSystem,\n  MermaidGeneratedSharedModule,\n  PacketGeneratedModule,\n  __name as __name2,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject,\n  lib_exports\n} from \"./chunk-46UCTVYF.mjs\";\nimport {\n  __name\n} from \"./chunk-DLQEHMXD.mjs\";\n\n// ../parser/dist/chunks/mermaid-parser.core/chunk-EQFLFMNE.mjs\nvar PacketTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"PacketTokenBuilder\");\n  }\n  static {\n    __name2(this, \"PacketTokenBuilder\");\n  }\n  constructor() {\n    super([\"packet-beta\"]);\n  }\n};\nvar PacketModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name2(() => new PacketTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name2(() => new CommonValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createPacketServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Packet = inject(\n    createDefaultCoreModule({ shared }),\n    PacketGeneratedModule,\n    PacketModule\n  );\n  shared.ServiceRegistry.register(Packet);\n  return { shared, Packet };\n}\n__name(createPacketServices, \"createPacketServices\");\n__name2(createPacketServices, \"createPacketServices\");\n\nexport {\n  PacketModule,\n  createPacketServices\n};\n","import {\n  AbstractMermaidTokenBuilder,\n  AbstractMermaidValueConverter,\n  EmptyFileSystem,\n  MermaidGeneratedSharedModule,\n  PieGeneratedModule,\n  __name as __name2,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject,\n  lib_exports\n} from \"./chunk-46UCTVYF.mjs\";\nimport {\n  __name\n} from \"./chunk-DLQEHMXD.mjs\";\n\n// ../parser/dist/chunks/mermaid-parser.core/chunk-BI6EQKOQ.mjs\nvar PieTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"PieTokenBuilder\");\n  }\n  static {\n    __name2(this, \"PieTokenBuilder\");\n  }\n  constructor() {\n    super([\"pie\", \"showData\"]);\n  }\n};\nvar PieValueConverter = class extends AbstractMermaidValueConverter {\n  static {\n    __name(this, \"PieValueConverter\");\n  }\n  static {\n    __name2(this, \"PieValueConverter\");\n  }\n  runCustomConverter(rule, input, _cstNode) {\n    if (rule.name !== \"PIE_SECTION_LABEL\") {\n      return void 0;\n    }\n    return input.replace(/\"/g, \"\").trim();\n  }\n};\nvar PieModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name2(() => new PieTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name2(() => new PieValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createPieServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Pie = inject(\n    createDefaultCoreModule({ shared }),\n    PieGeneratedModule,\n    PieModule\n  );\n  shared.ServiceRegistry.register(Pie);\n  return { shared, Pie };\n}\n__name(createPieServices, \"createPieServices\");\n__name2(createPieServices, \"createPieServices\");\n\nexport {\n  PieModule,\n  createPieServices\n};\n","import {\n  AbstractMermaidTokenBuilder,\n  AbstractMermaidValueConverter,\n  ArchitectureGeneratedModule,\n  EmptyFileSystem,\n  MermaidGeneratedSharedModule,\n  __name as __name2,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject,\n  lib_exports\n} from \"./chunk-46UCTVYF.mjs\";\nimport {\n  __name\n} from \"./chunk-DLQEHMXD.mjs\";\n\n// ../parser/dist/chunks/mermaid-parser.core/chunk-FF7BQXOH.mjs\nvar ArchitectureTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"ArchitectureTokenBuilder\");\n  }\n  static {\n    __name2(this, \"ArchitectureTokenBuilder\");\n  }\n  constructor() {\n    super([\"architecture\"]);\n  }\n};\nvar ArchitectureValueConverter = class extends AbstractMermaidValueConverter {\n  static {\n    __name(this, \"ArchitectureValueConverter\");\n  }\n  static {\n    __name2(this, \"ArchitectureValueConverter\");\n  }\n  runCustomConverter(rule, input, _cstNode) {\n    if (rule.name === \"ARCH_ICON\") {\n      return input.replace(/[()]/g, \"\").trim();\n    } else if (rule.name === \"ARCH_TEXT_ICON\") {\n      return input.replace(/[\"()]/g, \"\");\n    } else if (rule.name === \"ARCH_TITLE\") {\n      return input.replace(/[[\\]]/g, \"\").trim();\n    }\n    return void 0;\n  }\n};\nvar ArchitectureModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name2(() => new ArchitectureTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name2(() => new ArchitectureValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createArchitectureServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Architecture = inject(\n    createDefaultCoreModule({ shared }),\n    ArchitectureGeneratedModule,\n    ArchitectureModule\n  );\n  shared.ServiceRegistry.register(Architecture);\n  return { shared, Architecture };\n}\n__name(createArchitectureServices, \"createArchitectureServices\");\n__name2(createArchitectureServices, \"createArchitectureServices\");\n\nexport {\n  ArchitectureModule,\n  createArchitectureServices\n};\n","import {\n  AbstractMermaidTokenBuilder,\n  CommonValueConverter,\n  EmptyFileSystem,\n  GitGraphGeneratedModule,\n  MermaidGeneratedSharedModule,\n  __name as __name2,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject,\n  lib_exports\n} from \"./chunk-46UCTVYF.mjs\";\nimport {\n  __name\n} from \"./chunk-DLQEHMXD.mjs\";\n\n// ../parser/dist/chunks/mermaid-parser.core/chunk-NCMFTTUW.mjs\nvar GitGraphTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"GitGraphTokenBuilder\");\n  }\n  static {\n    __name2(this, \"GitGraphTokenBuilder\");\n  }\n  constructor() {\n    super([\"gitGraph\"]);\n  }\n};\nvar GitGraphModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name2(() => new GitGraphTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name2(() => new CommonValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createGitGraphServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const GitGraph = inject(\n    createDefaultCoreModule({ shared }),\n    GitGraphGeneratedModule,\n    GitGraphModule\n  );\n  shared.ServiceRegistry.register(GitGraph);\n  return { shared, GitGraph };\n}\n__name(createGitGraphServices, \"createGitGraphServices\");\n__name2(createGitGraphServices, \"createGitGraphServices\");\n\nexport {\n  GitGraphModule,\n  createGitGraphServices\n};\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","$7efda43c46063a35$export$98e6a39c04603d36","$bYG2S","$7xxrv","$7efda43c46063a35$var$parsers","$7efda43c46063a35$var$initializers","info","__name","createInfoServices","createInfoServices2","parser","Info","LangiumParser","packet","createPacketServices","createPacketServices2","Packet","pie","createPieServices","createPieServices2","Pie","architecture","createArchitectureServices","createArchitectureServices2","Architecture","gitGraph","createGitGraphServices","createGitGraphServices2","GitGraph","diagramType","text","initializer","Error","result","parse","lexerErrors","length","parserErrors","$7efda43c46063a35$var$MermaidParseError","value","constructor","map","err","message","join","$1d44efb04eab6ceb$export$9849fb42e1532cce","$1d44efb04eab6ceb$export$eab5a4b5adef815d","$1d44efb04eab6ceb$export$dbab074a2a0a86aa","$1d44efb04eab6ceb$export$a976684a0efeb93f","$1d44efb04eab6ceb$export$3777ff4d263eb622","$1d44efb04eab6ceb$export$7b9033c24b3bcb4e","$1d44efb04eab6ceb$export$e4b0bc98a20a633a","$1d44efb04eab6ceb$export$d28586600dc40d43","$1d44efb04eab6ceb$export$9a9f13da65008281","$1d44efb04eab6ceb$export$28acc4e42f5f4855","$1d44efb04eab6ceb$export$3805a3057b70f628","$1d44efb04eab6ceb$export$6024982db2edb064","$1d44efb04eab6ceb$export$5814ff0710a44fb8","$1d44efb04eab6ceb$export$a487a80f9ea1e74e","RangeComparison2","LexerDefinitionErrorType2","PROD_TYPE2","CstVisitorDefinitionError2","ParserDefinitionErrorType2","FoldingRangeKind2","DiagnosticSeverity2","DiagnosticTag2","CompletionItemKind2","InsertTextFormat2","InsertTextMode2","DocumentHighlightKind2","SymbolKind2","CodeActionKind2","CodeActionTriggerKind2","SemanticTokenTypes2","SemanticTokenModifiers2","InlineCompletionTriggerKind2","DocumentState2","DocumentValidator2","$1d44efb04eab6ceb$var$Reduction","$1d44efb04eab6ceb$var$RangeComparison","$1d44efb04eab6ceb$var$LexerDefinitionErrorType","$1d44efb04eab6ceb$var$PROD_TYPE","$1d44efb04eab6ceb$var$CstVisitorDefinitionError","$1d44efb04eab6ceb$var$ParserDefinitionErrorType","$1d44efb04eab6ceb$var$DocumentUri","$1d44efb04eab6ceb$var$URI","$1d44efb04eab6ceb$var$integer","$1d44efb04eab6ceb$var$uinteger","$1d44efb04eab6ceb$var$Position","$1d44efb04eab6ceb$var$Range","$1d44efb04eab6ceb$var$Location","$1d44efb04eab6ceb$var$LocationLink","$1d44efb04eab6ceb$var$Color","$1d44efb04eab6ceb$var$ColorInformation","$1d44efb04eab6ceb$var$ColorPresentation","$1d44efb04eab6ceb$var$FoldingRangeKind","$1d44efb04eab6ceb$var$FoldingRange","$1d44efb04eab6ceb$var$DiagnosticRelatedInformation","$1d44efb04eab6ceb$var$DiagnosticSeverity","$1d44efb04eab6ceb$var$DiagnosticTag","$1d44efb04eab6ceb$var$CodeDescription","$1d44efb04eab6ceb$var$Diagnostic","$1d44efb04eab6ceb$var$Command","$1d44efb04eab6ceb$var$TextEdit","$1d44efb04eab6ceb$var$ChangeAnnotation","$1d44efb04eab6ceb$var$ChangeAnnotationIdentifier","$1d44efb04eab6ceb$var$AnnotatedTextEdit","$1d44efb04eab6ceb$var$TextDocumentEdit","$1d44efb04eab6ceb$var$CreateFile","$1d44efb04eab6ceb$var$RenameFile","$1d44efb04eab6ceb$var$DeleteFile","$1d44efb04eab6ceb$var$WorkspaceEdit","$1d44efb04eab6ceb$var$TextDocumentIdentifier","$1d44efb04eab6ceb$var$VersionedTextDocumentIdentifier","$1d44efb04eab6ceb$var$OptionalVersionedTextDocumentIdentifier","$1d44efb04eab6ceb$var$TextDocumentItem","$1d44efb04eab6ceb$var$MarkupKind","$1d44efb04eab6ceb$var$MarkupContent","$1d44efb04eab6ceb$var$CompletionItemKind","$1d44efb04eab6ceb$var$InsertTextFormat","$1d44efb04eab6ceb$var$CompletionItemTag","$1d44efb04eab6ceb$var$InsertReplaceEdit","$1d44efb04eab6ceb$var$InsertTextMode","$1d44efb04eab6ceb$var$CompletionItemLabelDetails","$1d44efb04eab6ceb$var$CompletionItem","$1d44efb04eab6ceb$var$CompletionList","$1d44efb04eab6ceb$var$MarkedString","$1d44efb04eab6ceb$var$Hover","$1d44efb04eab6ceb$var$ParameterInformation","$1d44efb04eab6ceb$var$SignatureInformation","$1d44efb04eab6ceb$var$DocumentHighlightKind","$1d44efb04eab6ceb$var$DocumentHighlight","$1d44efb04eab6ceb$var$SymbolKind","$1d44efb04eab6ceb$var$SymbolTag","$1d44efb04eab6ceb$var$SymbolInformation","$1d44efb04eab6ceb$var$WorkspaceSymbol","$1d44efb04eab6ceb$var$DocumentSymbol","$1d44efb04eab6ceb$var$CodeActionKind","$1d44efb04eab6ceb$var$CodeActionTriggerKind","$1d44efb04eab6ceb$var$CodeActionContext","$1d44efb04eab6ceb$var$CodeAction","$1d44efb04eab6ceb$var$CodeLens","$1d44efb04eab6ceb$var$FormattingOptions","$1d44efb04eab6ceb$var$DocumentLink","$1d44efb04eab6ceb$var$SelectionRange","$1d44efb04eab6ceb$var$SemanticTokenTypes","$1d44efb04eab6ceb$var$SemanticTokenModifiers","$1d44efb04eab6ceb$var$SemanticTokens","$1d44efb04eab6ceb$var$InlineValueText","$1d44efb04eab6ceb$var$InlineValueVariableLookup","$1d44efb04eab6ceb$var$InlineValueEvaluatableExpression","$1d44efb04eab6ceb$var$InlineValueContext","$1d44efb04eab6ceb$var$InlayHintKind","$1d44efb04eab6ceb$var$InlayHintLabelPart","$1d44efb04eab6ceb$var$InlayHint","$1d44efb04eab6ceb$var$StringValue","$1d44efb04eab6ceb$var$InlineCompletionItem","$1d44efb04eab6ceb$var$InlineCompletionList","$1d44efb04eab6ceb$var$InlineCompletionTriggerKind","$1d44efb04eab6ceb$var$SelectedCompletionInfo","$1d44efb04eab6ceb$var$InlineCompletionContext","$1d44efb04eab6ceb$var$WorkspaceFolder","$1d44efb04eab6ceb$var$TextDocument","$1d44efb04eab6ceb$var$Is","$1d44efb04eab6ceb$var$ValueConverter","$1d44efb04eab6ceb$var$TextDocument2","$1d44efb04eab6ceb$var$LIB","$1d44efb04eab6ceb$var$UriUtils","$1d44efb04eab6ceb$var$DocumentState","$1d44efb04eab6ceb$var$ValidationCategory","$1d44efb04eab6ceb$var$DocumentValidator","$1d44efb04eab6ceb$var$Disposable","$1d44efb04eab6ceb$var$Module","$1d44efb04eab6ceb$var$loadedInfoGrammar","$1d44efb04eab6ceb$var$loadedPacketGrammar","$1d44efb04eab6ceb$var$loadedPieGrammar","$1d44efb04eab6ceb$var$loadedArchitectureGrammar","$1d44efb04eab6ceb$var$loadedGitGraphGrammar","$76RTQ","$f34bP","$2266r","$hPtJY","$1d44efb04eab6ceb$var$require_ral","__commonJS","_ral","RAL","RAL2","install","ral","default","$1d44efb04eab6ceb$var$require_is","boolean","string","String","number","Number","error","func","array","Array","isArray","stringArray","every","elem","$1d44efb04eab6ceb$var$require_events","Emitter","Event","ral_1","Event2","_disposable","dispose","None","CallbackList","add","callback","context","bucket","_callbacks","_contexts","push","remove","foundCallbackWithDifferentContext","i","len","splice","invoke","args","ret","callbacks","slice","contexts","apply","console","isEmpty","Emitter2","_Emitter","_options","event","_event","listener","thisArgs","disposables","onFirstListenerAdd","_noop","onLastListenerRemove","fire","call","$1d44efb04eab6ceb$var$require_cancellation","CancellationTokenSource","CancellationToken","CancellationToken11","Is2","events_1","CancellationToken12","is","candidate","Cancelled","isCancellationRequested","onCancellationRequested","freeze","shortcutEvent","handle","timer","setTimeout","bind","MutableToken","_isCancelled","cancel","_emitter","CancellationTokenSource3","token","_token","$1d44efb04eab6ceb$export$d254ce2913df4585","__export","AbstractAstReflection","$1d44efb04eab6ceb$var$AbstractAstReflection","AbstractCstNode","$1d44efb04eab6ceb$var$AbstractCstNode","AbstractLangiumParser","$1d44efb04eab6ceb$var$AbstractLangiumParser","AbstractParserErrorMessageProvider","$1d44efb04eab6ceb$var$AbstractParserErrorMessageProvider","AbstractThreadedAsyncParser","$1d44efb04eab6ceb$var$AbstractThreadedAsyncParser","AstUtils","$1d44efb04eab6ceb$var$ast_utils_exports","BiMap","$1d44efb04eab6ceb$var$BiMap","Cancellation","$1d44efb04eab6ceb$var$cancellation_exports","CompositeCstNodeImpl","$1d44efb04eab6ceb$var$CompositeCstNodeImpl","ContextCache","$1d44efb04eab6ceb$var$ContextCache","CstNodeBuilder","$1d44efb04eab6ceb$var$CstNodeBuilder","CstUtils","$1d44efb04eab6ceb$var$cst_utils_exports","DONE_RESULT","$1d44efb04eab6ceb$var$DONE_RESULT","DatatypeSymbol","$1d44efb04eab6ceb$var$DatatypeSymbol","DefaultAstNodeDescriptionProvider","$1d44efb04eab6ceb$var$DefaultAstNodeDescriptionProvider","DefaultAstNodeLocator","$1d44efb04eab6ceb$var$DefaultAstNodeLocator","DefaultAsyncParser","$1d44efb04eab6ceb$var$DefaultAsyncParser","DefaultCommentProvider","$1d44efb04eab6ceb$var$DefaultCommentProvider","DefaultConfigurationProvider","$1d44efb04eab6ceb$var$DefaultConfigurationProvider","DefaultDocumentBuilder","$1d44efb04eab6ceb$var$DefaultDocumentBuilder","DefaultDocumentValidator","$1d44efb04eab6ceb$var$DefaultDocumentValidator","DefaultHydrator","$1d44efb04eab6ceb$var$DefaultHydrator","DefaultIndexManager","$1d44efb04eab6ceb$var$DefaultIndexManager","DefaultJsonSerializer","$1d44efb04eab6ceb$var$DefaultJsonSerializer","DefaultLangiumDocumentFactory","$1d44efb04eab6ceb$var$DefaultLangiumDocumentFactory","DefaultLangiumDocuments","$1d44efb04eab6ceb$var$DefaultLangiumDocuments","DefaultLexer","$1d44efb04eab6ceb$var$DefaultLexer","DefaultLinker","$1d44efb04eab6ceb$var$DefaultLinker","DefaultNameProvider","$1d44efb04eab6ceb$var$DefaultNameProvider","DefaultReferenceDescriptionProvider","$1d44efb04eab6ceb$var$DefaultReferenceDescriptionProvider","DefaultReferences","$1d44efb04eab6ceb$var$DefaultReferences","DefaultScopeComputation","$1d44efb04eab6ceb$var$DefaultScopeComputation","DefaultScopeProvider","$1d44efb04eab6ceb$var$DefaultScopeProvider","DefaultServiceRegistry","$1d44efb04eab6ceb$var$DefaultServiceRegistry","DefaultTokenBuilder","$1d44efb04eab6ceb$var$DefaultTokenBuilder","DefaultValueConverter","$1d44efb04eab6ceb$var$DefaultValueConverter","DefaultWorkspaceLock","$1d44efb04eab6ceb$var$DefaultWorkspaceLock","DefaultWorkspaceManager","$1d44efb04eab6ceb$var$DefaultWorkspaceManager","Deferred","$1d44efb04eab6ceb$var$Deferred","Disposable","DisposableCache","$1d44efb04eab6ceb$var$DisposableCache","DocumentCache","$1d44efb04eab6ceb$var$DocumentCache","DocumentState","DocumentValidator","EMPTY_SCOPE","$1d44efb04eab6ceb$var$EMPTY_SCOPE","EMPTY_STREAM","$1d44efb04eab6ceb$var$EMPTY_STREAM","EmptyFileSystem","EmptyFileSystemProvider","$1d44efb04eab6ceb$var$EmptyFileSystemProvider","ErrorWithLocation","$1d44efb04eab6ceb$var$ErrorWithLocation","GrammarAST","$1d44efb04eab6ceb$var$ast_exports","GrammarUtils","$1d44efb04eab6ceb$var$grammar_utils_exports","JSDocDocumentationProvider","$1d44efb04eab6ceb$var$JSDocDocumentationProvider","LangiumCompletionParser","$1d44efb04eab6ceb$var$LangiumCompletionParser","$1d44efb04eab6ceb$var$LangiumParser","LangiumParserErrorMessageProvider","$1d44efb04eab6ceb$var$LangiumParserErrorMessageProvider","LeafCstNodeImpl","$1d44efb04eab6ceb$var$LeafCstNodeImpl","MapScope","$1d44efb04eab6ceb$var$MapScope","Module","MultiMap","$1d44efb04eab6ceb$var$MultiMap","OperationCancelled","$1d44efb04eab6ceb$var$OperationCancelled","ParserWorker","$1d44efb04eab6ceb$var$ParserWorker","Reduction","RegExpUtils","$1d44efb04eab6ceb$var$regexp_utils_exports","RootCstNodeImpl","$1d44efb04eab6ceb$var$RootCstNodeImpl","SimpleCache","$1d44efb04eab6ceb$var$SimpleCache","StreamImpl","$1d44efb04eab6ceb$var$StreamImpl","StreamScope","$1d44efb04eab6ceb$var$StreamScope","TextDocument","TreeStreamImpl","$1d44efb04eab6ceb$var$TreeStreamImpl","URI","$1d44efb04eab6ceb$var$URI2","UriUtils","ValidationCategory","ValidationRegistry","$1d44efb04eab6ceb$var$ValidationRegistry","ValueConverter","WorkspaceCache","$1d44efb04eab6ceb$var$WorkspaceCache","assertUnreachable","$1d44efb04eab6ceb$var$assertUnreachable","createCompletionParser","$1d44efb04eab6ceb$var$createCompletionParser","createDefaultCoreModule","createDefaultSharedCoreModule","createGrammarConfig","$1d44efb04eab6ceb$var$createGrammarConfig","createLangiumParser","$1d44efb04eab6ceb$var$createLangiumParser","delayNextTick","$1d44efb04eab6ceb$var$delayNextTick","diagnosticData","$1d44efb04eab6ceb$var$diagnosticData","eagerLoad","$1d44efb04eab6ceb$var$eagerLoad","getDiagnosticRange","$1d44efb04eab6ceb$var$getDiagnosticRange","inject","interruptAndCheck","$1d44efb04eab6ceb$var$interruptAndCheck","isAstNode","$1d44efb04eab6ceb$var$isAstNode","isAstNodeDescription","$1d44efb04eab6ceb$var$isAstNodeDescription","isAstNodeWithComment","$1d44efb04eab6ceb$var$isAstNodeWithComment","isCompositeCstNode","$1d44efb04eab6ceb$var$isCompositeCstNode","isIMultiModeLexerDefinition","$1d44efb04eab6ceb$var$isIMultiModeLexerDefinition","isJSDoc","$1d44efb04eab6ceb$var$isJSDoc","isLeafCstNode","$1d44efb04eab6ceb$var$isLeafCstNode","isLinkingError","$1d44efb04eab6ceb$var$isLinkingError","isNamed","$1d44efb04eab6ceb$var$isNamed","isOperationCancelled","$1d44efb04eab6ceb$var$isOperationCancelled","isReference","$1d44efb04eab6ceb$var$isReference","isRootCstNode","$1d44efb04eab6ceb$var$isRootCstNode","isTokenTypeArray","$1d44efb04eab6ceb$var$isTokenTypeArray","isTokenTypeDictionary","$1d44efb04eab6ceb$var$isTokenTypeDictionary","loadGrammarFromJson","$1d44efb04eab6ceb$var$loadGrammarFromJson","parseJSDoc","$1d44efb04eab6ceb$var$parseJSDoc","prepareLangiumParser","$1d44efb04eab6ceb$var$prepareLangiumParser","setInterruptionPeriod","$1d44efb04eab6ceb$var$setInterruptionPeriod","startCancelableOperation","$1d44efb04eab6ceb$var$startCancelableOperation","stream","$1d44efb04eab6ceb$var$stream","toDiagnosticSeverity","$1d44efb04eab6ceb$var$toDiagnosticSeverity","obj","$type","$refText","name","type","path","container","reference","DefaultNameRegexp","$1d44efb04eab6ceb$var$DefaultNameRegexp","RangeComparison","compareRange","$1d44efb04eab6ceb$var$compareRange","findCommentNode","$1d44efb04eab6ceb$var$findCommentNode","findDeclarationNodeAtOffset","$1d44efb04eab6ceb$var$findDeclarationNodeAtOffset","findLeafNodeAtOffset","$1d44efb04eab6ceb$var$findLeafNodeAtOffset","findLeafNodeBeforeOffset","$1d44efb04eab6ceb$var$findLeafNodeBeforeOffset","flattenCst","$1d44efb04eab6ceb$var$flattenCst","getInteriorNodes","$1d44efb04eab6ceb$var$getInteriorNodes","getNextNode","$1d44efb04eab6ceb$var$getNextNode","getPreviousNode","$1d44efb04eab6ceb$var$getPreviousNode","getStartlineNode","$1d44efb04eab6ceb$var$getStartlineNode","inRange","$1d44efb04eab6ceb$var$inRange","isChildNode","$1d44efb04eab6ceb$var$isChildNode","isCommentNode","$1d44efb04eab6ceb$var$isCommentNode","streamCst","$1d44efb04eab6ceb$var$streamCst","toDocumentSegment","$1d44efb04eab6ceb$var$toDocumentSegment","tokenToRange","$1d44efb04eab6ceb$var$tokenToRange","subtypes","allSubtypes","isInstance","node","isSubtype","subtype","supertype","nested","existing","computeIsSubtype","getAllSubTypes","allTypes","getAllTypes","types","possibleSubType","content","tokenType","fullText","_StreamImpl","startFn","nextFn","iterator","state","next","Symbol","Boolean","done","count","toArray","toSet","Set","toMap","keyFn","valueFn","Map","element","toString","concat","other","first","firstDone","separator","addSeparator","$1d44efb04eab6ceb$var$toString","indexOf","searchElement","fromIndex","index","predicate","some","forEach","callbackfn","filter","nonNullable","reduce","initialValue","previousValue","reduceRight","recursiveReduce","find","findIndex","includes","flatMap","this","mapped","$1d44efb04eab6ceb$var$isIterable","flat","depth","stream2","head","tail","skipCount","limit","maxSize","size","distinct","by","has","exclude","key","otherKeySet","item","ownKey","prototype","collections","collection","collIndex","arrIndex","root","children","options","iterators","includeRoot","pruned","pop","prune","child","parent","start","character","startColumn","line","startLine","end","endColumn","endLine","offset","range","to","Before","After","startInside","endInside","Inside","OverlapBack","OverlapFront","comparison","Reduction2","sum","a","b","product","min","Math","max","cstNode","nameRegexp","localOffset","textAtOffset","charAt","test","commentNames","previous","endIndex","hidden","searchResult","$1d44efb04eab6ceb$var$binarySearch","closest","closestNode","left","right","middle","floor","middleNode","last","selfIndex","commonParent","$1d44efb04eab6ceb$var$getCommonParent","current","aParents","$1d44efb04eab6ceb$var$getParentChain","bParents","aParent","bParent","chain","reverse","findAssignment","$1d44efb04eab6ceb$var$findAssignment","findNameAssignment","$1d44efb04eab6ceb$var$findNameAssignment","findNodeForKeyword","$1d44efb04eab6ceb$var$findNodeForKeyword","findNodeForProperty","$1d44efb04eab6ceb$var$findNodeForProperty","findNodesForKeyword","$1d44efb04eab6ceb$var$findNodesForKeyword","findNodesForKeywordInternal","$1d44efb04eab6ceb$var$findNodesForKeywordInternal","findNodesForProperty","$1d44efb04eab6ceb$var$findNodesForProperty","getActionAtElement","$1d44efb04eab6ceb$var$getActionAtElement","getActionType","$1d44efb04eab6ceb$var$getActionType","getAllReachableRules","$1d44efb04eab6ceb$var$getAllReachableRules","getCrossReferenceTerminal","$1d44efb04eab6ceb$var$getCrossReferenceTerminal","getEntryRule","$1d44efb04eab6ceb$var$getEntryRule","getExplicitRuleType","$1d44efb04eab6ceb$var$getExplicitRuleType","getHiddenRules","$1d44efb04eab6ceb$var$getHiddenRules","getRuleType","$1d44efb04eab6ceb$var$getRuleType","getTypeName","$1d44efb04eab6ceb$var$getTypeName","isArrayCardinality","$1d44efb04eab6ceb$var$isArrayCardinality","isArrayOperator","$1d44efb04eab6ceb$var$isArrayOperator","isCommentTerminal","$1d44efb04eab6ceb$var$isCommentTerminal","isDataType","$1d44efb04eab6ceb$var$isDataType","isDataTypeRule","$1d44efb04eab6ceb$var$isDataTypeRule","isOptionalCardinality","$1d44efb04eab6ceb$var$isOptionalCardinality","terminalRegex","$1d44efb04eab6ceb$var$terminalRegex","_","AbstractElement","$1d44efb04eab6ceb$var$AbstractElement","AbstractRule","$1d44efb04eab6ceb$var$AbstractRule","AbstractType","$1d44efb04eab6ceb$var$AbstractType","Action","$1d44efb04eab6ceb$var$Action","Alternatives","$1d44efb04eab6ceb$var$Alternatives","ArrayLiteral","$1d44efb04eab6ceb$var$ArrayLiteral","ArrayType","$1d44efb04eab6ceb$var$ArrayType","Assignment","$1d44efb04eab6ceb$var$Assignment","BooleanLiteral","$1d44efb04eab6ceb$var$BooleanLiteral","CharacterRange","$1d44efb04eab6ceb$var$CharacterRange","Condition","$1d44efb04eab6ceb$var$Condition","Conjunction","$1d44efb04eab6ceb$var$Conjunction","CrossReference","$1d44efb04eab6ceb$var$CrossReference","Disjunction","$1d44efb04eab6ceb$var$Disjunction","EndOfFile","$1d44efb04eab6ceb$var$EndOfFile","Grammar","$1d44efb04eab6ceb$var$Grammar","GrammarImport","$1d44efb04eab6ceb$var$GrammarImport","Group","$1d44efb04eab6ceb$var$Group","InferredType","$1d44efb04eab6ceb$var$InferredType","Interface","$1d44efb04eab6ceb$var$Interface","Keyword","$1d44efb04eab6ceb$var$Keyword","LangiumGrammarAstReflection","$1d44efb04eab6ceb$var$LangiumGrammarAstReflection","LangiumGrammarTerminals","$1d44efb04eab6ceb$var$LangiumGrammarTerminals","NamedArgument","$1d44efb04eab6ceb$var$NamedArgument","NegatedToken","$1d44efb04eab6ceb$var$NegatedToken","Negation","$1d44efb04eab6ceb$var$Negation","NumberLiteral","$1d44efb04eab6ceb$var$NumberLiteral","Parameter","$1d44efb04eab6ceb$var$Parameter","ParameterReference","$1d44efb04eab6ceb$var$ParameterReference","ParserRule","$1d44efb04eab6ceb$var$ParserRule","ReferenceType","$1d44efb04eab6ceb$var$ReferenceType","RegexToken","$1d44efb04eab6ceb$var$RegexToken","ReturnType","$1d44efb04eab6ceb$var$ReturnType","RuleCall","$1d44efb04eab6ceb$var$RuleCall","SimpleType","$1d44efb04eab6ceb$var$SimpleType","StringLiteral","$1d44efb04eab6ceb$var$StringLiteral","TerminalAlternatives","$1d44efb04eab6ceb$var$TerminalAlternatives","TerminalGroup","$1d44efb04eab6ceb$var$TerminalGroup","TerminalRule","$1d44efb04eab6ceb$var$TerminalRule","TerminalRuleCall","$1d44efb04eab6ceb$var$TerminalRuleCall","Type","$1d44efb04eab6ceb$var$Type","TypeAttribute","$1d44efb04eab6ceb$var$TypeAttribute","TypeDefinition","$1d44efb04eab6ceb$var$TypeDefinition","UnionType","$1d44efb04eab6ceb$var$UnionType","UnorderedGroup","$1d44efb04eab6ceb$var$UnorderedGroup","UntilToken","$1d44efb04eab6ceb$var$UntilToken","ValueLiteral","$1d44efb04eab6ceb$var$ValueLiteral","Wildcard","$1d44efb04eab6ceb$var$Wildcard","isAbstractElement","$1d44efb04eab6ceb$var$isAbstractElement","isAbstractRule","$1d44efb04eab6ceb$var$isAbstractRule","isAbstractType","$1d44efb04eab6ceb$var$isAbstractType","isAction","$1d44efb04eab6ceb$var$isAction","isAlternatives","$1d44efb04eab6ceb$var$isAlternatives","isArrayLiteral","$1d44efb04eab6ceb$var$isArrayLiteral","isArrayType","$1d44efb04eab6ceb$var$isArrayType","isAssignment","$1d44efb04eab6ceb$var$isAssignment","isBooleanLiteral","$1d44efb04eab6ceb$var$isBooleanLiteral","isCharacterRange","$1d44efb04eab6ceb$var$isCharacterRange","isCondition","$1d44efb04eab6ceb$var$isCondition","isConjunction","$1d44efb04eab6ceb$var$isConjunction","isCrossReference","$1d44efb04eab6ceb$var$isCrossReference","isDisjunction","$1d44efb04eab6ceb$var$isDisjunction","isEndOfFile","$1d44efb04eab6ceb$var$isEndOfFile","isFeatureName","$1d44efb04eab6ceb$var$isFeatureName","isGrammar","$1d44efb04eab6ceb$var$isGrammar","isGrammarImport","$1d44efb04eab6ceb$var$isGrammarImport","isGroup","$1d44efb04eab6ceb$var$isGroup","isInferredType","$1d44efb04eab6ceb$var$isInferredType","isInterface","$1d44efb04eab6ceb$var$isInterface","isKeyword","$1d44efb04eab6ceb$var$isKeyword","isNamedArgument","$1d44efb04eab6ceb$var$isNamedArgument","isNegatedToken","$1d44efb04eab6ceb$var$isNegatedToken","isNegation","$1d44efb04eab6ceb$var$isNegation","isNumberLiteral","$1d44efb04eab6ceb$var$isNumberLiteral","isParameter","$1d44efb04eab6ceb$var$isParameter","isParameterReference","$1d44efb04eab6ceb$var$isParameterReference","isParserRule","$1d44efb04eab6ceb$var$isParserRule","isPrimitiveType","$1d44efb04eab6ceb$var$isPrimitiveType","isReferenceType","$1d44efb04eab6ceb$var$isReferenceType","isRegexToken","$1d44efb04eab6ceb$var$isRegexToken","isReturnType","$1d44efb04eab6ceb$var$isReturnType","isRuleCall","$1d44efb04eab6ceb$var$isRuleCall","isSimpleType","$1d44efb04eab6ceb$var$isSimpleType","isStringLiteral","$1d44efb04eab6ceb$var$isStringLiteral","isTerminalAlternatives","$1d44efb04eab6ceb$var$isTerminalAlternatives","isTerminalGroup","$1d44efb04eab6ceb$var$isTerminalGroup","isTerminalRule","$1d44efb04eab6ceb$var$isTerminalRule","isTerminalRuleCall","$1d44efb04eab6ceb$var$isTerminalRuleCall","isType","$1d44efb04eab6ceb$var$isType","isTypeAttribute","$1d44efb04eab6ceb$var$isTypeAttribute","isTypeDefinition","$1d44efb04eab6ceb$var$isTypeDefinition","isUnionType","$1d44efb04eab6ceb$var$isUnionType","isUnorderedGroup","$1d44efb04eab6ceb$var$isUnorderedGroup","isUntilToken","$1d44efb04eab6ceb$var$isUntilToken","isValueLiteral","$1d44efb04eab6ceb$var$isValueLiteral","isWildcard","$1d44efb04eab6ceb$var$isWildcard","reflection","$1d44efb04eab6ceb$var$reflection","ID","STRING","NUMBER","RegexLiteral","WS","ML_COMMENT","SL_COMMENT","getReferenceType","refInfo","referenceId","property","getTypeMetaData","properties","defaultValue","$1d44efb04eab6ceb$var$linkContentToContainer","entries","startsWith","$container","$containerProperty","$containerIndex","$1d44efb04eab6ceb$var$getContainerOfType","typePredicate","$1d44efb04eab6ceb$var$hasContainerOfType","$1d44efb04eab6ceb$var$getDocument","rootNode","$1d44efb04eab6ceb$var$findRootNode","$document","$1d44efb04eab6ceb$var$streamContents","keys","keyIndex","arrayIndex","$1d44efb04eab6ceb$var$isAstNodeInRange","$1d44efb04eab6ceb$var$streamAllContents","$1d44efb04eab6ceb$var$streamAst","astNode","_a","nodeRange","$cstNode","$1d44efb04eab6ceb$var$streamReferences","$1d44efb04eab6ceb$var$findLocalReferences","targetNode","lookup","parseResult","refs","ref","$1d44efb04eab6ceb$var$assignMandatoryProperties","reflection3","typeMetaData","genericNode","$1d44efb04eab6ceb$var$copyDefaultValue","propertyType","$1d44efb04eab6ceb$var$copyAstNode","buildReference","copy","$refNode","copiedArray","assignMandatoryProperties","copyAstNode","findLocalReferences","findRootNode","getContainerOfType","getDocument","hasContainerOfType","linkContentToContainer","streamAllContents","streamAst","streamContents","streamReferences","$1d44efb04eab6ceb$var$cc","char","charCodeAt","$1d44efb04eab6ceb$var$insertToSet","subItem","$1d44efb04eab6ceb$var$addFlag","flagObj","flagKey","$1d44efb04eab6ceb$var$ASSERT_EXISTS","$1d44efb04eab6ceb$var$ASSERT_NEVER_REACH_HERE","$1d44efb04eab6ceb$var$isCharacter","NEWLINE_REGEXP","$1d44efb04eab6ceb$var$NEWLINE_REGEXP","escapeRegExp","$1d44efb04eab6ceb$var$escapeRegExp","getCaseInsensitivePattern","$1d44efb04eab6ceb$var$getCaseInsensitivePattern","getTerminalParts","$1d44efb04eab6ceb$var$getTerminalParts","isMultilineComment","$1d44efb04eab6ceb$var$isMultilineComment","isWhitespace","$1d44efb04eab6ceb$var$isWhitespace","partialMatches","$1d44efb04eab6ceb$var$partialMatches","partialRegExp","$1d44efb04eab6ceb$var$partialRegExp","$1d44efb04eab6ceb$var$digitsCharCodes","$1d44efb04eab6ceb$var$wordCharCodes","$1d44efb04eab6ceb$var$whitespaceCodes","$1d44efb04eab6ceb$var$hexDigitPattern","$1d44efb04eab6ceb$var$decimalPattern","$1d44efb04eab6ceb$var$decimalPatternNoZero","$1d44efb04eab6ceb$var$RegExpParser","idx","input","groupIdx","saveState","restoreState","newState2","pattern","consumeChar","disjunction","flags","loc","begin","global","ignoreCase","multiLine","unicode","sticky","isRegExpFlag","popChar","substring","alts","alternative","peekChar","terms","isTerm","term","isAssertion","assertion","atom","quantifier","isBacktracking","atLeast","atMost","Infinity","integerIncludingZero","isDigit","greedy","atom2","dotAll","atomEscape","characterClass","group","isPatternCharacter","patternCharacter","isQuantifier","complement","decimalEscapeAtom","characterClassEscape","controlEscapeAtom","controlLetterEscapeAtom","nulCharacterAtom","hexEscapeSequenceAtom","regExpUnicodeEscapeSequenceAtom","identityEscapeAtom","positiveInteger","escapeCode","letter","toUpperCase","parseHexDigits","classPatternCharacterAtom","isClassAtom","from","classAtom","isRangeDash","classEscape","capturing","groupAst","parseInt","nextChar","howMuch","isAtom","prevState","howMany","hexString","hexChar","$1d44efb04eab6ceb$var$BaseRegExpVisitor","visitChildren","hasOwnProperty","visit","subChild","visitPattern","visitFlags","visitDisjunction","visitAlternative","visitStartAnchor","visitEndAnchor","visitWordBoundary","visitNonWordBoundary","visitLookahead","visitNegativeLookahead","visitCharacter","visitSet","visitGroup","visitGroupBackReference","visitQuantifier","$1d44efb04eab6ceb$var$regexpParser","$1d44efb04eab6ceb$var$visitor","arguments","isStarting","endRegexpStack","multiline","endRegex","reset","regex","startRegexp","fromCharCode","escapedChar","RegExp","match","regexp","source","parts","replace","keyword","toLowerCase","partial","re","process2","tmp","appendRaw","nbChars","substr","appendOptional","lastIndex","exec","grammar","rules","entry","allTerminals","ruleNames","entryRule","rule","$1d44efb04eab6ceb$var$ruleDfs","visitedSet","refRule","crossRef","terminal","nameAssigment","terminalRule","$1d44efb04eab6ceb$var$findNodesForPropertyInternal","nodes","first2","nodeFeature","grammarSource","feature","treeIterator","keywordNodes","childNode","assignment","startNode","$1d44efb04eab6ceb$var$findNameAssignmentInternal","cache","go","refType","childAssignment","typeRef","elements","action","cardinality","guardCondition","operator","$1d44efb04eab6ceb$var$isDataTypeRuleInternal","visited","definition","$1d44efb04eab6ceb$var$isDataTypeInternal","primitiveType","stringType","inferredType","dataType","returnType","actionType","_b","_c","u","$1d44efb04eab6ceb$var$abstractElementToRegex","$1d44efb04eab6ceb$var$WILDCARD","$1d44efb04eab6ceb$var$terminalAlternativesToRegex","$1d44efb04eab6ceb$var$terminalGroupToRegex","$1d44efb04eab6ceb$var$characterRangeToRegex","$1d44efb04eab6ceb$var$withCardinality","lookahead","$1d44efb04eab6ceb$var$negateTokenToRegex","$1d44efb04eab6ceb$var$untilTokenToRegex","lastSlash","lastIndexOf","regexFlags","wrap","alternatives","until","negate","$1d44efb04eab6ceb$var$keywordToRegex","services","multilineCommentRules","$1d44efb04eab6ceb$var$PRINT_ERROR","msg","$1d44efb04eab6ceb$var$PRINT_WARNING","warn","$1d44efb04eab6ceb$var$timer","Date","getTime","val","time","$1d44efb04eab6ceb$var$toFastProperties","toBecomeFast","FakeConstructor","fakeInstance","fakeAccess","bar","$1d44efb04eab6ceb$var$tokenLabel","tokType","$1d44efb04eab6ceb$var$hasTokenLabel","LABEL","isString_default","$1d44efb04eab6ceb$var$AbstractProduction","_definition","accept","visitor2","forEach_default","prod","$1d44efb04eab6ceb$var$NonTerminal","assign_default","pickBy_default","referencedRule","$1d44efb04eab6ceb$var$Rule","orgText","$1d44efb04eab6ceb$var$Alternative","ignoreAmbiguities","$1d44efb04eab6ceb$var$Option","$1d44efb04eab6ceb$var$RepetitionMandatory","$1d44efb04eab6ceb$var$RepetitionMandatoryWithSeparator","$1d44efb04eab6ceb$var$Repetition","$1d44efb04eab6ceb$var$RepetitionWithSeparator","$1d44efb04eab6ceb$var$Alternation","hasPredicates","$1d44efb04eab6ceb$var$Terminal","$1d44efb04eab6ceb$var$serializeGrammar","topRules","map_default","$1d44efb04eab6ceb$var$serializeProduction","convertDefinition","serializedNonTerminal","nonTerminalName","label","terminalType","serializedTerminal","terminalLabel","PATTERN","isRegExp_default","$1d44efb04eab6ceb$var$GAstVisitor","nodeAny","visitNonTerminal","visitOption","visitRepetitionMandatory","visitRepetitionMandatoryWithSeparator","visitRepetitionWithSeparator","visitRepetition","visitAlternation","visitTerminal","visitRule","$1d44efb04eab6ceb$var$isSequenceProd","$1d44efb04eab6ceb$var$isOptionalProd","alreadyVisited","some_default","subProd","includes_default","every_default","$1d44efb04eab6ceb$var$isBranchingProd","$1d44efb04eab6ceb$var$getProductionDslName","$1d44efb04eab6ceb$var$RestWalker","walk","prevRest","currRest","drop_default","walkProdRef","walkTerminal","walkFlat","walkOption","walkAtLeastOne","walkAtLeastOneSep","walkManySep","walkMany","walkOr","refProd","flatProd","fullOrRest","optionProd","atLeastOneProd","fullAtLeastOneRest","atLeastOneSepProd","fullAtLeastOneSepRest","$1d44efb04eab6ceb$var$restForRepetitionWithSeparator","manyProd","fullManyRest","manySepProd","fullManySepRest","orProd","alt","prodWrapper","repSepProd","repSepRest","$1d44efb04eab6ceb$var$first","$1d44efb04eab6ceb$var$firstForTerminal","$1d44efb04eab6ceb$var$firstForSequence","$1d44efb04eab6ceb$var$firstForBranching","currSubProd","firstSet","seq","nextSubProdIdx","hasInnerProdsRemaining","isLastInnerProdOptional","uniq_default","allAlternativesFirsts","innerProd","flatten_default","$1d44efb04eab6ceb$var$IN","$1d44efb04eab6ceb$var$ResyncFollowsWalker","topProd","follows","startWalking","followName","$1d44efb04eab6ceb$var$buildBetweenProdsFollowPrefix","t_in_topProd_follows","$1d44efb04eab6ceb$var$computeAllProdsFollows","topProductions","reSyncFollows","currRefsFollow","inner","occurenceInParent","$1d44efb04eab6ceb$var$regExpAstCache","$1d44efb04eab6ceb$var$regExpParser","$1d44efb04eab6ceb$var$getRegExpAst","regExp","regExpStr","regExpAst","$1d44efb04eab6ceb$var$clearRegExpParserCache","$1d44efb04eab6ceb$var$complementErrorMessage","$1d44efb04eab6ceb$var$failedOptimizationPrefixMsg","$1d44efb04eab6ceb$var$getOptimizedStartCodesIndices","ensureOptimizations","ast","$1d44efb04eab6ceb$var$firstCharOptimizedIndices","msgSuffix","$1d44efb04eab6ceb$var$addOptimizedIdxToResult","code","rangeCode","$1d44efb04eab6ceb$var$minOptimizationVal","minUnOptVal","maxUnOptVal","minOptIdx","$1d44efb04eab6ceb$var$charCodeToOptimizedIndex","maxOptIdx","currOptIdx","isOptionalQuantifier","$1d44efb04eab6ceb$var$isWholeOptional","values_default","optimizedCharIdx","$1d44efb04eab6ceb$var$handleIgnoreCase","upperChar","lowerChar","$1d44efb04eab6ceb$var$findCode","setNode","targetCharCodes","find_default","codeOrRange","targetCode","isArray_default","$1d44efb04eab6ceb$var$CharCodeFinder","found","$1d44efb04eab6ceb$var$canMatchCharCode","charCodes","charCodeFinder","$1d44efb04eab6ceb$var$PATTERN","$1d44efb04eab6ceb$var$DEFAULT_MODE","$1d44efb04eab6ceb$var$MODES","$1d44efb04eab6ceb$var$SUPPORT_STICKY","$1d44efb04eab6ceb$var$analyzeTokenTypes","tokenTypes","onlyRelevantTypes","allTransformedPatterns","patternIdxToType","patternIdxToGroup","patternIdxToLongerAltIdxArr","patternIdxToPushMode","patternIdxToPopMode","patternIdxToCanLineTerminator","patternIdxToIsCustom","patternIdxToShort","emptyGroups","patternIdxToConfig","tracer","defaults_default","useSticky","debug","safeMode","positionTracking","lineTerminatorCharacters","$1d44efb04eab6ceb$var$initCharCodeToOptimizedIndexMap","reject_default","currType","$1d44efb04eab6ceb$var$Lexer","NA","hasCustom","currPattern","regExpSource","$1d44efb04eab6ceb$var$addStickyFlag","$1d44efb04eab6ceb$var$addStartOfInput","isFunction_default","wrappedRegExp","tokenTypeIdx","clazz","groupName","GROUP","SKIPPED","isUndefined_default","longerAltType","LONGER_ALT","indexOf_default","PUSH_MODE","has_default","lineTerminatorCharCodes","$1d44efb04eab6ceb$var$getCharCodes","LINE_BREAKS","$1d44efb04eab6ceb$var$checkLineBreaksIssues","$1d44efb04eab6ceb$var$isCustomPattern","$1d44efb04eab6ceb$var$isShortPattern","reduce_default","acc","x","longerAlt","canLineTerminator","isCustom","short","canBeOptimized","charCodeToPatternIdxToConfig","currTokType","$1d44efb04eab6ceb$var$addToMapOfArrays","START_CHARS_HINT","lastOptimizedIdx","charOrInt","currOptimizedIdx","optimizedCodes","isEmpty_default","$1d44efb04eab6ceb$var$validatePatterns","validModesNames","errors","missingResult","$1d44efb04eab6ceb$var$findMissingPatterns","invalidResult","$1d44efb04eab6ceb$var$findInvalidPatterns","valid","validTokenTypes","$1d44efb04eab6ceb$var$validateRegExpPattern","$1d44efb04eab6ceb$var$findInvalidGroupType","$1d44efb04eab6ceb$var$findModesThatDoNotExist","$1d44efb04eab6ceb$var$findUnreachablePatterns","withRegExpPatterns","filter_default","$1d44efb04eab6ceb$var$findEndOfInputAnchor","$1d44efb04eab6ceb$var$findStartOfInputAnchor","$1d44efb04eab6ceb$var$findUnsupportedFlags","$1d44efb04eab6ceb$var$findDuplicatePatterns","$1d44efb04eab6ceb$var$findEmptyMatchRegExps","tokenTypesWithMissingPattern","MISSING_PATTERN","difference_default","tokenTypesWithInvalidPattern","INVALID_PATTERN","$1d44efb04eab6ceb$var$end_of_input","EndAnchorFinder","invalidRegex","regexpAst","endAnchorVisitor","EOI_ANCHOR_FOUND","matchesEmptyString","EMPTY_MATCH_PATTERN","$1d44efb04eab6ceb$var$start_of_input","StartAnchorFinder","startAnchorVisitor","SOI_ANCHOR_FOUND","invalidFlags","UNSUPPORTED_FLAGS_FOUND","identicalPatterns","outerType","innerType","compact_default","duplicatePatterns","currIdenticalSet","setOfIdentical","tokenTypeNames","dupPatternSrc","head_default","DUPLICATE_PATTERNS_FOUND","invalidTypes","INVALID_GROUP_TYPE_FOUND","validModes","invalidModes","PUSH_MODE_DOES_NOT_EXIST","canBeTested","str","$1d44efb04eab6ceb$var$noMetaChar","testIdx","$1d44efb04eab6ceb$var$testTokenType","UNREACHABLE_PATTERN","regExpArray","$1d44efb04eab6ceb$var$performRuntimeChecks","lexerDefinition","trackLines","MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE","MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY","modes","defaultMode","MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST","currModeValue","currModeName","currIdx","LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED","currLongerAlt","MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE","$1d44efb04eab6ceb$var$performWarningRuntimeChecks","warnings","hasAnyLineBreak","allTokenTypes","concreteTokenTypes","terminatorCharCodes","currIssue","warningDescriptor","$1d44efb04eab6ceb$var$buildLineBreakIssueMessage","issue","NO_LINE_BREAKS_FLAGS","$1d44efb04eab6ceb$var$cloneEmptyGroups","clonedResult","groupKeys","keys_default","currKey","currGroupValue","$1d44efb04eab6ceb$var$LineTerminatorOptimizedTester","c","IDENTIFY_TERMINATOR","errMsg","CUSTOM_LINE_BREAK","details","charsOrCodes","numOrString","$1d44efb04eab6ceb$var$charCodeToOptimizedIdxMap","charCode","$1d44efb04eab6ceb$var$tokenStructuredMatcher","tokInstance","tokConstructor","instanceType","isParent","categoryMatchesMap","$1d44efb04eab6ceb$var$tokenStructuredMatcherNoCategories","$1d44efb04eab6ceb$var$tokenShortNameIdx","$1d44efb04eab6ceb$var$tokenIdxToClass","$1d44efb04eab6ceb$var$augmentTokenTypes","tokenTypesAndParents","$1d44efb04eab6ceb$var$expandCategories","$1d44efb04eab6ceb$var$assignTokenDefaultProps","$1d44efb04eab6ceb$var$assignCategoriesMapProp","$1d44efb04eab6ceb$var$assignCategoriesTokensProp","categoryMatches","clone_default","categories","searching","CATEGORIES","newCategories","$1d44efb04eab6ceb$var$hasShortKeyProperty","$1d44efb04eab6ceb$var$hasCategoriesProperty","$1d44efb04eab6ceb$var$hasExtendingTokensTypesProperty","$1d44efb04eab6ceb$var$hasExtendingTokensTypesMapProperty","$1d44efb04eab6ceb$var$singleAssignCategoriesToksMap","nextNode","pathNode","nextCategory","newPath","$1d44efb04eab6ceb$var$isTokenType","$1d44efb04eab6ceb$var$DEFAULT_LEXER_CONFIG","deferDefinitionErrorsHandling","lineTerminatorsPattern","errorMessageProvider","buildUnableToPopLexerModeMessage","image","buildUnexpectedCharactersMessage","startOffset","column","traceInitPerf","skipValidations","recoveryEnabled","config","lexerDefinitionErrors","lexerDefinitionWarning","trackStartLines","trackEndLines","canModeBeOptimized","TRACE_INIT","phaseDesc","phaseImpl","traceInitIndent","indent","traceInitMaxIdent","log","traceMethod","traceInitVal","actualDefinition","hasOnlySingleMode","allModeNames","currModDef","currModName","currAnalyzeResult","allErrMessages","chopInput","identity_default","matchWithTest","updateLastIndex","noop_default","matchWithExec","handleModes","computeNewColumn","updateTokenEndLineColumnLocation","createTokenInstance","createFullToken","createStartOnlyToken","createOffsetOnlyToken","addToken","addTokenUsingPush","handlePayload","handlePayloadWithCustom","addTokenUsingMemberAccess","handlePayloadNoCustom","unOptimizedModes","cannotBeOptimized","modeName","tokenize","initialMode","tokenizeInternal","j","k","matchAltImage","matchedImage","payload","altPayload","imageLength","newToken","errLength","getPossiblePatterns","currConfig","orgLength","matchedTokensIndex","matchedTokens","groups","lineTerminatorPattern","currModePatternsLength","currCharCodeToPatternIdxToConfig","modeStack","emptyArray","getPossiblePatternsSlow","getPossiblePatternsOptimized","possiblePatterns","pop_mode","popToken","msg2","newMode","last_default","modeCanBeOptimized","push_mode","nextCharCode","chosenPatternIdxToConfig","chosenPatternsLength","singleCharCode","longerAltLength","longerAltConfig","longerAltPattern","foundTerminator","lastLTEndOffset","numOfLTsInMatch","errorStartOffset","errorLine","errorColumn","foundResyncPoint","currConfig2","tokens","pushMode","newLastIndex","lastLTIdx","lastCharIsLT","fixForEndingInLT","oldColumn","endOffset","tokenVector","tokenToAdd","$1d44efb04eab6ceb$var$tokenLabel2","$1d44efb04eab6ceb$var$hasTokenLabel2","$1d44efb04eab6ceb$var$CATEGORIES","$1d44efb04eab6ceb$var$LABEL","$1d44efb04eab6ceb$var$GROUP","$1d44efb04eab6ceb$var$PUSH_MODE","$1d44efb04eab6ceb$var$POP_MODE","$1d44efb04eab6ceb$var$LONGER_ALT","$1d44efb04eab6ceb$var$LINE_BREAKS","$1d44efb04eab6ceb$var$START_CHARS_HINT","$1d44efb04eab6ceb$var$createToken","$1d44efb04eab6ceb$var$createTokenInternal","POP_MODE","$1d44efb04eab6ceb$var$EOF","$1d44efb04eab6ceb$var$createTokenInstance","$1d44efb04eab6ceb$var$tokenMatcher","$1d44efb04eab6ceb$var$defaultParserErrorProvider","buildMismatchTokenMessage","expected","actual","ruleName","expectedMsg","hasLabel","buildNotAllInputParsedMessage","firstRedundant","buildNoViableAltMessage","expectedPathsPerAlt","customUserDescription","errPrefix","errSuffix","allLookAheadPaths","currAltPaths","nextValidTokenSequences","currPath","currTokenType","nextValidSequenceItems","itemMsg","buildEarlyExitMessage","expectedIterationPaths","$1d44efb04eab6ceb$var$defaultGrammarResolverErrorProvider","buildRuleNotFoundError","topLevelRule","undefinedRule","$1d44efb04eab6ceb$var$defaultGrammarValidatorErrorProvider","buildDuplicateFoundError","duplicateProds","getExtraProductionArgument2","topLevelName","duplicateProd","dslName","extraArgument","hasExplicitIndex","buildNamespaceConflictError","buildAlternationPrefixAmbiguityError","pathMsg","prefixPath","currTok","occurrence","alternation","ambiguityIndices","buildAlternationAmbiguityError","currtok","buildEmptyRepetitionError","repetition","buildTokenNameError","buildEmptyAlternationError","emptyChoiceIdx","buildTooManyAlternativesError","buildLeftRecursionError","pathNames","leftRecursionPath","currRule","leftRecursivePath","buildInvalidRuleNameError","buildDuplicateRuleNameError","grammarName","$1d44efb04eab6ceb$var$resolveGrammar","topLevels","errMsgProvider","refResolver","$1d44efb04eab6ceb$var$GastRefResolverVisitor","resolveRefs","nameToTopRule","currTopLevel","UNRESOLVED_SUBRULE_REF","unresolvedRefName","$1d44efb04eab6ceb$var$AbstractNextPossibleTokensWalker","possibleTokTypes","nextProductionName","nextProductionOccurrence","isAtEndOfPath","ruleStack","occurrenceStack","updateExpectedNext","fullRest","$1d44efb04eab6ceb$var$NextAfterTokenWalker","nextTerminalName","nextTerminalOccurrence","lastTok","lastTokOccurrence","restProd","$1d44efb04eab6ceb$var$AbstractNextTerminalAfterProductionWalker","topRule","isEndOfRule","$1d44efb04eab6ceb$var$NextTerminalAfterManyWalker","firstAfterMany","$1d44efb04eab6ceb$var$NextTerminalAfterManySepWalker","firstAfterManySep","$1d44efb04eab6ceb$var$NextTerminalAfterAtLeastOneWalker","firstAfterAtLeastOne","$1d44efb04eab6ceb$var$NextTerminalAfterAtLeastOneSepWalker","atleastOneSepProd","firstAfterfirstAfterAtLeastOneSep","$1d44efb04eab6ceb$var$possiblePathsFrom","targetDef","maxLength","remainingPathWith","nextDef","getAlternativesForProd","currAlt","partialPath","suffixDef","$1d44efb04eab6ceb$var$nextPossibleTokensAfter","initialDef","tokMatcher","maxLookAhead","EXIT_NON_TERMINAL","EXIT_NON_TERMINAL_ARR","EXIT_ALTERNATIVE","foundCompletePath","tokenVectorLength","minimalAlternativesIndex","possiblePaths","def","currDef","currRuleStack","currOccurrenceStack","nextPath","dropRight_default","nextIdx","nextTokenType","nextTokenOccurrence","newRuleStack","newOccurrenceStack","nextPathWithout","nextPathWith","secondIteration","nthRepetition","currAltPath","$1d44efb04eab6ceb$var$expandTopLevelRule","newCurrOccurrenceStack","$1d44efb04eab6ceb$var$getProdType","OPTION","REPETITION","REPETITION_MANDATORY","REPETITION_MANDATORY_WITH_SEPARATOR","REPETITION_WITH_SEPARATOR","ALTERNATION","$1d44efb04eab6ceb$var$getLookaheadPaths","prodType","maxLookahead","$1d44efb04eab6ceb$var$getLookaheadPathsForOr","$1d44efb04eab6ceb$var$getLookaheadPathsForOptionalProd","$1d44efb04eab6ceb$var$buildLookaheadFuncForOr","ruleGrammar","dynamicTokensEnabled","laFuncBuilder","lookAheadPaths","tokenMatcher2","$1d44efb04eab6ceb$var$areTokenCategoriesNotUsed","$1d44efb04eab6ceb$var$buildLookaheadFuncForOptionalProd","lookaheadBuilder","$1d44efb04eab6ceb$var$buildAlternativesLookAheadFunc","numOfAlts","areAllOneTokenLookahead","orAlts","predicates","GATE","t","currNumOfPaths","currPredicate","currPathLength","LA","singleTokenAlts","choiceToAlt","currExtendingType","nextToken","$1d44efb04eab6ceb$var$buildSingleAlternativeLookaheadFunction","numOfPaths","singleTokensTypes","expectedTokenUniqueKey","expectedTokenType","$1d44efb04eab6ceb$var$RestDefinitionFinderWalker","targetOccurrence","targetProdType","restDef","checkIsTarget","expectedProdType","$1d44efb04eab6ceb$var$InsideDefinitionFinderVisitor","targetRef","expectedProdName","$1d44efb04eab6ceb$var$initializeArrayOfArrays","$1d44efb04eab6ceb$var$pathToHashKeys","longerKeys","currShorterKey","categoriesKeySuffix","$1d44efb04eab6ceb$var$isUniquePrefixHash","altKnownPathsKeys","searchPathKeys","currAltIdx","otherAltKnownPathsKeys","searchIdx","$1d44efb04eab6ceb$var$lookAheadSequenceFromAlternatives","altsDefs","partialAlts","finalResult","altsHashes","dict","newData","pathLength","currDataset","altIdx","currAltPathsAndSuffixes","currPathIdx","currPathPrefix","prefixKeys","isUnique","currAltResult","$1d44efb04eab6ceb$var$containsPath","newPartialPathsAndSuffixes","prefixKeys2","insideDefVisitor","insideDef","afterDef","afterDefWalker","searchPath","compareOtherPath","otherPath","searchTok","otherTok","matchingTokens","$1d44efb04eab6ceb$var$isStrictPrefixOfPath","prefix","otherTokType","singleAltPaths","singlePath","$1d44efb04eab6ceb$var$validateLookahead","lookaheadValidationErrorMessages","lookaheadStrategy","validate","errorMessage","assign","CUSTOM_LOOKAHEAD_VALIDATION","$1d44efb04eab6ceb$var$validateGrammar","duplicateErrors","flatMap_default","$1d44efb04eab6ceb$var$validateDuplicateProductions","termsNamespaceConflictErrors","$1d44efb04eab6ceb$var$checkTerminalAndNoneTerminalsNameSpace","tooManyAltsErrors","curRule","$1d44efb04eab6ceb$var$validateTooManyAlts","duplicateRulesError","$1d44efb04eab6ceb$var$validateRuleDoesNotAlreadyExist","collectorVisitor2","$1d44efb04eab6ceb$var$OccurrenceValidationCollector","allRuleProductions","allProductions","productionGroups","groupBy_default","$1d44efb04eab6ceb$var$identifyProductionForDuplicates","duplicates","currGroup","currDuplicates","firstProd","defError","DUPLICATE_PRODUCTIONS","param","$1d44efb04eab6ceb$var$getExtraProductionArgument","parameter","subrule","option2","manySep","atLeastOne","atLeastOneSep","many","or","allRules","className","occurrences","DUPLICATE_RULE_NAME","$1d44efb04eab6ceb$var$validateRuleIsOverridden","definedRulesNames","INVALID_RULE_OVERRIDE","$1d44efb04eab6ceb$var$validateNoLeftRecursion","nextNonTerminals","$1d44efb04eab6ceb$var$getFirstNoneTerminal","LEFT_RECURSION","validNextSteps","errorsFromNextSteps","currRefRule","currSubDef","isFirstOptional","hasMore","rest","$1d44efb04eab6ceb$var$OrCollector","alternations","$1d44efb04eab6ceb$var$validateEmptyOrAlternative","orCollector","ors","currOr","exceptLast","currAlternative","possibleFirstInAlt","NONE_LAST_EMPTY_ALT","$1d44efb04eab6ceb$var$validateAmbiguousAlternationAlternatives","globalMaxLookahead","altsAmbiguityErrors","$1d44efb04eab6ceb$var$checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","$1d44efb04eab6ceb$var$checkPrefixAlternativesAmbiguities","$1d44efb04eab6ceb$var$RepetitionCollector","TOO_MANY_ALTS","$1d44efb04eab6ceb$var$validateSomeNonEmptyLookaheadPath","topLevelRules","currTopRule","currProd","actualMaxLookahead","pathsInsideProduction","paths","NO_NON_EMPTY_LOOKAHEAD","alternation2","foundAmbiguousPaths","identicalAmbiguities","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","currAmbDescriptor","ambgIndices","AMBIGUOUS_ALTS","pathsAndIndices","currPathsAndIdx","currPathAndIdx","alternativeGast","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","searchPathAndIdx","currAmbPathAndIdx","AMBIGUOUS_PREFIX_ALTS","tokenNames","currToken","currRuleName","CONFLICT_TOKENS_RULES_NAMESPACE","$1d44efb04eab6ceb$var$resolveGrammar2","actualOptions","topRulesTable","$1d44efb04eab6ceb$var$validateGrammar2","$1d44efb04eab6ceb$var$MISMATCHED_TOKEN_EXCEPTION","$1d44efb04eab6ceb$var$NO_VIABLE_ALT_EXCEPTION","$1d44efb04eab6ceb$var$EARLY_EXIT_EXCEPTION","$1d44efb04eab6ceb$var$NOT_ALL_INPUT_PARSED_EXCEPTION","$1d44efb04eab6ceb$var$RECOGNITION_EXCEPTION_NAMES","$1d44efb04eab6ceb$var$isRecognitionException","$1d44efb04eab6ceb$var$RecognitionException","resyncedTokens","setPrototypeOf","captureStackTrace","$1d44efb04eab6ceb$var$MismatchedTokenException","previousToken","$1d44efb04eab6ceb$var$NoViableAltException","$1d44efb04eab6ceb$var$NotAllInputParsedException","$1d44efb04eab6ceb$var$EarlyExitException","$1d44efb04eab6ceb$var$EOF_FOLLOW_KEY","$1d44efb04eab6ceb$var$IN_RULE_RECOVERY_EXCEPTION","$1d44efb04eab6ceb$var$InRuleRecoveryException","$1d44efb04eab6ceb$var$Recoverable","initRecoverable","firstAfterRepMap","resyncFollows","$1d44efb04eab6ceb$var$DEFAULT_PARSER_CONFIG","attemptInRepetitionRecovery","$1d44efb04eab6ceb$var$attemptInRepetitionRecovery","getTokenToInsert","tokToInsert","NaN","isInsertedInRecovery","canTokenTypeBeInsertedInRecovery","canTokenTypeBeDeletedInRecovery","tryInRepetitionRecovery","grammarRule","grammarRuleArgs","lookAheadFunc","expectedTokType","reSyncTokType","findReSyncTokenType","savedLexerState","exportLexerState","passedResyncPoint","nextTokenWithoutResync","generateErrorMessage","getCurrRuleFullName","SAVE_ERROR","tokenMatcher","SKIP_TOKEN","addToResyncTokens","importLexerState","shouldInRepetitionRecoveryBeTried","expectTokAfterLastMatch","nextTokIdx","notStuck","isBackTracking","canPerformInRuleRecovery","getFollowsForInRuleRecovery","tokIdxInRule","grammarPath","getCurrentGrammarPath","getNextPossibleTokenTypes","tryInRuleRecovery","canRecoverWithSingleTokenInsertion","canRecoverWithSingleTokenDeletion","nextTok","consumeToken","expectedToken","mismatchedTok","possibleFollowsTokType","isInCurrentRuleReSyncSet","followKey","getCurrFollowKey","currentRuleReSyncSet","getFollowSetFromFollowKey","allPossibleReSyncTokTypes","flattenFollowSet","foundMatch","resyncTokType","RULE_STACK","currRuleShortName","getLastExplicitRuleShortName","currRuleIdx","getLastExplicitRuleOccurrenceIndex","prevRuleShortName","getPreviousExplicitRuleShortName","shortRuleNameToFullName","idxInCallingRule","inRule","buildFullFollowKeyStack","explicitRuleStack","explicitOccurrenceStack","RULE_OCCURRENCE_STACK","followStack","resyncTokens","reSyncTo","prodFunc","lookaheadFunc","dslMethodIdx","prodOccurrence","nextToksWalker","getHumanReadableRuleStack","currShortName","getKeyForAutomaticLookahead","firstAfterRepInfo","walker","getGAstProductions","$1d44efb04eab6ceb$var$getKeyForAutomaticLookahead","ruleIdx","$1d44efb04eab6ceb$var$LLkLookaheadStrategy","leftRecursionErrors","validateNoLeftRecursion","validateEmptyOrAlternatives","validateAmbiguousAlternationAlternatives","validateSomeNonEmptyLookaheadPath","buildLookaheadForAlternation","buildLookaheadForOptional","$1d44efb04eab6ceb$var$LooksAhead","initLooksAhead","lookAheadFuncsCache","preComputeLookaheadFunctions","repetition2","option","repetitionMandatory","repetitionMandatory2","repetitionMandatoryWithSeparator","repetitionWithSeparator","$1d44efb04eab6ceb$var$collectMethods","prodIdx","laFunc","fullRuleNameToShort","setLaFuncCache","computeLookaheadFunc","prodKey","prodMaxLookahead","dslMethodName","getLaFuncFromCache","$1d44efb04eab6ceb$var$collectorVisitor","dslMethods","$1d44efb04eab6ceb$var$setNodeLocationOnlyOffset","currNodeLocation","newLocationInfo","isNaN","$1d44efb04eab6ceb$var$setNodeLocationFull","$1d44efb04eab6ceb$var$addTerminalToCst","tokenTypeName","$1d44efb04eab6ceb$var$addNoneTerminalToCst","ruleResult","$1d44efb04eab6ceb$var$defineNameProp","nameValue","writable","$1d44efb04eab6ceb$var$defaultVisit","ctx","childrenNames","childrenNamesLength","currChildArray","currChildArrayLength","currChild","$1d44efb04eab6ceb$var$createBaseSemanticVisitorConstructor","derivedConstructor","semanticProto","validateVisitor","semanticDefinitionErrors","$1d44efb04eab6ceb$var$validateVisitor","errorMessages","currDefError","_RULE_NAMES","$1d44efb04eab6ceb$var$createBaseVisitorConstructorWithDefaults","baseConstructor","withDefaultsProto","create","visitorInstance","$1d44efb04eab6ceb$var$validateMissingCstMethods","missingRuleNames","MISSING_METHOD","methodName","$1d44efb04eab6ceb$var$TreeBuilder","initTreeBuilder","CST_STACK","outputCst","nodeLocationTracking","setNodeLocationFromToken","setNodeLocationFromNode","cstPostRule","setInitialNodeLocation","setInitialNodeLocationFullRecovery","cstPostRuleFull","setInitialNodeLocationFullRegular","setInitialNodeLocationOnlyOffsetRecovery","cstPostRuleOnlyOffset","setInitialNodeLocationOnlyOffsetRegular","cstInvocationStateUpdate","cstFinallyStateUpdate","cstPostTerminal","cstPostNonTerminal","location","fullRuleName","ruleCstNode","prevToken","consumedToken","rootCst","ruleCstResult","preCstNode","getBaseCstVisitorConstructor","baseCstVisitorConstructor","newBaseCstVisitorConstructor","gastProductionsCache","getBaseCstVisitorConstructorWithDefaults","baseCstVisitorWithDefaultsConstructor","newConstructor","$1d44efb04eab6ceb$var$LexerAdapter","initLexerAdapter","tokVector","tokVectorLength","newInput","selfAnalysisDone","$1d44efb04eab6ceb$var$END_OF_FILE","soughtIdx","resetLexerState","moveToTerminatedState","getLexerPosition","$1d44efb04eab6ceb$var$RecognizerApi","ACTION","impl","consume","consumeInternal","ruleToCall","subruleInternal","actionORMethodDef","optionInternal","altsOrOpts","orInternal","manyInternal","atLeastOneInternal","CONSUME","CONSUME1","CONSUME2","CONSUME3","CONSUME4","CONSUME5","CONSUME6","CONSUME7","CONSUME8","CONSUME9","SUBRULE","SUBRULE1","SUBRULE2","SUBRULE3","SUBRULE4","SUBRULE5","SUBRULE6","SUBRULE7","SUBRULE8","SUBRULE9","OPTION1","OPTION2","OPTION3","OPTION4","OPTION5","OPTION6","OPTION7","OPTION8","OPTION9","OR","OR1","OR2","OR3","OR4","OR5","OR6","OR7","OR8","OR9","MANY","MANY1","MANY2","MANY3","MANY4","MANY5","MANY6","MANY7","MANY8","MANY9","MANY_SEP","manySepFirstInternal","MANY_SEP1","MANY_SEP2","MANY_SEP3","MANY_SEP4","MANY_SEP5","MANY_SEP6","MANY_SEP7","MANY_SEP8","MANY_SEP9","AT_LEAST_ONE","AT_LEAST_ONE1","AT_LEAST_ONE2","AT_LEAST_ONE3","AT_LEAST_ONE4","AT_LEAST_ONE5","AT_LEAST_ONE6","AT_LEAST_ONE7","AT_LEAST_ONE8","AT_LEAST_ONE9","AT_LEAST_ONE_SEP","atLeastOneSepFirstInternal","AT_LEAST_ONE_SEP1","AT_LEAST_ONE_SEP2","AT_LEAST_ONE_SEP3","AT_LEAST_ONE_SEP4","AT_LEAST_ONE_SEP5","AT_LEAST_ONE_SEP6","AT_LEAST_ONE_SEP7","AT_LEAST_ONE_SEP8","AT_LEAST_ONE_SEP9","RULE","implementation","$1d44efb04eab6ceb$var$DEFAULT_RULE_CONFIG","definitionErrors","ruleImplementation","defineRule","OVERRIDE_RULE","ruleErrors","BACKTRACK","isBackTrackingStack","orgState","saveRecogState","reloadRecogState","getSerializedGastProductions","$1d44efb04eab6ceb$var$RecognizerEngine","initRecognizerEngine","tokenVocabulary","shortRuleNameToFull","ruleShortNameIdx","subruleIdx","tokensMap","allTokenTypes2","uniqueTokens","isObject_default","noTokenCategoriesUsed","tokenConstructor","resyncEnabled","recoveryValueFunc","shortName","$1d44efb04eab6ceb$var$BITS_FOR_METHOD_TYPE","ruleInvocationStateUpdate","cst","invokeRuleCatch","ruleFinallyStateUpdate","originalGrammarAction","resyncEnabledConfig","isFirstInvokedRule","reSyncEnabled","recogError","partialCstResult","recoveredNode","optionInternalLogic","DEF","orgLookaheadFunction","laKey","atLeastOneInternalLogic","doSingleRepetition","raiseEarlyExitException","ERR_MSG","atLeastOneSepFirstInternalLogic","SEP","firstIterationLookaheadFunc","separatorLookAheadFunc","repetitionSepSecondInternal","manyInternalLogic","lookaheadFunction","manySepFirstInternalLogic","firstIterationLaFunc","nextTerminalAfterWalker","beforeIteration","afterIteration","altIdxToTake","chosenAlternative","ALT","raiseNoAltException","isAtEndOfInput","firstRedundantTok","ARGS","subruleInternalError","consumeInternalError","eFromConsumption","consumeInternalRecovery","eFromInRuleRecovery","savedErrors","savedRuleStack","lexerState","fullName","$1d44efb04eab6ceb$var$ErrorHandler","initErrorHandler","_errors","ruleOccurrenceStack","newErrors","userDefinedErrMsg","insideProdPaths","lookAheadPathsPerAlternative","actualTokens","errMsgTypes","$1d44efb04eab6ceb$var$ContentAssist","initContentAssist","computeContentAssist","startRuleName","precedingInput","startRuleGast","topRuleName","gastProductions","$1d44efb04eab6ceb$var$RECORDING_NULL_OBJECT","description","$1d44efb04eab6ceb$var$RFT","$1d44efb04eab6ceb$var$RECORDING_PHASE_TOKEN","$1d44efb04eab6ceb$var$RECORDING_PHASE_CSTNODE","$1d44efb04eab6ceb$var$GastRecorder","initGastRecorder","recordingProdStack","RECORDING_PHASE","enableRecording","arg1","arg2","consumeInternalRecord","subruleInternalRecord","optionInternalRecord","orInternalRecord","manyInternalRecord","manySepFirstInternalRecord","atLeastOneInternalRecord","atLeastOneSepFirstInternalRecord","ACTION_RECORD","BACKTRACK_RECORD","LA_RECORD","disableRecording","that","topLevelRuleRecord","newTopLevelRule","originalError","KNOWN_RECORDER_ERROR","mutabilityError","$1d44efb04eab6ceb$var$recordProd","$1d44efb04eab6ceb$var$recordOrProd","$1d44efb04eab6ceb$var$assertMethodIdxIsValid","$1d44efb04eab6ceb$var$getIdxSuffix","JSON","stringify","prevProd","newNoneTerminal","prodConstructor","mainProdArg","handleSep","grammarAction","newProd","MAX_LOOKAHEAD","hasOptions","newOrProd","IGNORE_AMBIGUITIES","currAltFlat","$1d44efb04eab6ceb$var$PerformanceTracer","initPerformanceTracer","userTraceInitPerf","traceIsNumber","$1d44efb04eab6ceb$var$applyMixins","derivedCtor","baseCtors","baseCtor","baseProto","getOwnPropertyNames","propName","basePropDescriptor","getOwnPropertyDescriptor","$1d44efb04eab6ceb$var$EMPTY_ALT","$1d44efb04eab6ceb$var$Parser","_Parser","performSelfAnalysis","parserInstance","defErrorsMsgs","recordedRuleGast","wrappedRule","resolverErrors","validationErrors","lookaheadValidationErrors","allFollows","initialize","DEFER_DEFINITION_ERRORS_HANDLING","$1d44efb04eab6ceb$var$EmbeddedActionsParser","configClone","$1d44efb04eab6ceb$var$buildATNKey","$1d44efb04eab6ceb$var$AbstractTransition","target","isEpsilon","$1d44efb04eab6ceb$var$AtomTransition","$1d44efb04eab6ceb$var$EpsilonTransition","$1d44efb04eab6ceb$var$RuleTransition","ruleStart","followState","$1d44efb04eab6ceb$var$createATN","atn","decisionMap","decisionStates","ruleToStartState","ruleToStopState","states","$1d44efb04eab6ceb$var$createRuleStartAndStopATNStates","ruleLength","ruleBlock","$1d44efb04eab6ceb$var$block","$1d44efb04eab6ceb$var$buildRuleHandle","$1d44efb04eab6ceb$var$newState","stop","$1d44efb04eab6ceb$var$atom","production","$1d44efb04eab6ceb$var$tokenRef","$1d44efb04eab6ceb$var$ruleRef","$1d44efb04eab6ceb$var$alternation","$1d44efb04eab6ceb$var$option","$1d44efb04eab6ceb$var$repetition","$1d44efb04eab6ceb$var$repetitionSep","$1d44efb04eab6ceb$var$repetitionMandatory","$1d44efb04eab6ceb$var$repetitionMandatorySep","starState","$1d44efb04eab6ceb$var$defineDecisionState","$1d44efb04eab6ceb$var$makeAlts","$1d44efb04eab6ceb$var$star","sep","plusState","$1d44efb04eab6ceb$var$plus","$1d44efb04eab6ceb$var$optional","block2","handles","$1d44efb04eab6ceb$var$makeBlock","plus2","blkStart","blkEnd","loop","loopback","$1d44efb04eab6ceb$var$epsilon","star2","loopEnd","optional2","decision","$1d44efb04eab6ceb$var$getProdType2","altsLength","transition","transitions","isRuleTransition","ruleTransition","$1d44efb04eab6ceb$var$removeState","$1d44efb04eab6ceb$var$addTransition","currentRule","nonTerminal","epsilonOnlyTransitions","nextTokenWithinRule","stateNumber","$1d44efb04eab6ceb$var$DFA_ERROR","$1d44efb04eab6ceb$var$ATNConfigSet","configs","finalize","$1d44efb04eab6ceb$var$getATNConfigKey","stack","$1d44efb04eab6ceb$var$createDFACache","startState","predicateSet","atnStartState","$1d44efb04eab6ceb$var$PredicateSet","$1d44efb04eab6ceb$var$EMPTY_PREDICATES","$1d44efb04eab6ceb$var$LLStarLookaheadStrategy","logging","dfas","$1d44efb04eab6ceb$var$initATNSimulator","decisionIndex","decisionState","$1d44efb04eab6ceb$var$isLL1Sequence","prediction","gate","$1d44efb04eab6ceb$var$adaptivePredict","g","sequences","allowEmpty","fullSet","altSet","decisionLength","decisionToDFA","dfaCaches","dfa","closure2","$1d44efb04eab6ceb$var$computeStartState","$1d44efb04eab6ceb$var$addDFAState","$1d44efb04eab6ceb$var$newDFAState","$1d44efb04eab6ceb$var$performLookahead","s0","previousD","d","$1d44efb04eab6ceb$var$getExistingTargetState","$1d44efb04eab6ceb$var$computeLookaheadTarget","$1d44efb04eab6ceb$var$buildAdaptivePredictError","isAcceptState","reach","$1d44efb04eab6ceb$var$computeReachSet","$1d44efb04eab6ceb$var$addDFAEdge","predictedAlt","$1d44efb04eab6ceb$var$getUniqueAlt","uniqueAlt","$1d44efb04eab6ceb$var$hasConflictTerminatingPrediction","min_default","$1d44efb04eab6ceb$var$reportLookaheadAmbiguity","atnState","$1d44efb04eab6ceb$var$buildAmbiguityError","$1d44efb04eab6ceb$var$getProductionDslName2","nextTransitions","actualToken","possibleTokenTypes","uniqBy_default","tokenPath","edges","intermediate","skippedStopStates","transitionLength","$1d44efb04eab6ceb$var$getReachableTarget","$1d44efb04eab6ceb$var$closure","$1d44efb04eab6ceb$var$hasConfigInRuleStopState","mapKey","numberOfTransitions","p","atnStack","$1d44efb04eab6ceb$var$getEpsilonTarget","$1d44efb04eab6ceb$var$allConfigsInRuleStopStates","altSets","$1d44efb04eab6ceb$var$getConflictingAltSets","$1d44efb04eab6ceb$var$hasConflictingAltSet","$1d44efb04eab6ceb$var$hasStateAssociatedWithOneAlt","configToAlts","values","DocumentUri2","URI3","integer2","MIN_VALUE","MAX_VALUE","uinteger2","Position2","objectLiteral","uinteger","Range2","one","two","three","four","Location2","uri","undefined","LocationLink2","targetUri","targetRange","targetSelectionRange","originSelectionRange","Color2","red","green","blue","alpha","numberRange","ColorInformation2","color","ColorPresentation2","textEdit","additionalTextEdits","typedArray","Comment","Imports","Region","FoldingRange2","startCharacter","endCharacter","kind","collapsedText","defined","DiagnosticRelatedInformation2","Warning","Information","Hint","Unnecessary","Deprecated","CodeDescription2","href","Diagnostic2","severity","relatedInformation","integer","codeDescription","Command2","title","command","TextEdit2","newText","insert","position","del","ChangeAnnotation2","needsConfirmation","ChangeAnnotationIdentifier2","AnnotatedTextEdit2","annotation","annotationId","TextDocumentEdit2","textDocument","edits","CreateFile2","overwrite","ignoreIfExists","RenameFile2","oldUri","newUri","DeleteFile2","recursive","ignoreIfNotExists","WorkspaceEdit2","changes","documentChanges","change","TextDocumentIdentifier2","VersionedTextDocumentIdentifier2","version","OptionalVersionedTextDocumentIdentifier2","TextDocumentItem2","languageId","MarkupKind2","PlainText","Markdown","MarkupContent2","Text","Method","Function","Constructor","Field","Variable","Class","Property","Unit","Value","Enum","Snippet","Color","File","Reference","Folder","EnumMember","Constant","Struct","Operator","TypeParameter","CompletionItemTag2","InsertReplaceEdit2","asIs","adjustIndentation","CompletionItemLabelDetails2","detail","CompletionItem2","CompletionList2","items","isIncomplete","MarkedString2","fromPlainText","plainText","language","Hover2","contents","ParameterInformation2","documentation","SignatureInformation2","parameters","Read","Write","DocumentHighlight2","Namespace","Package","Key","Null","SymbolTag2","SymbolInformation2","containerName","WorkspaceSymbol2","DocumentSymbol2","selectionRange","deprecated","tags","Empty","QuickFix","Refactor","RefactorExtract","RefactorInline","RefactorRewrite","Source","SourceOrganizeImports","SourceFixAll","Invoked","Automatic","CodeActionContext2","diagnostics","only","triggerKind","CodeAction2","kindOrCommandOrEdit","checkKind","edit","isPreferred","CodeLens2","data","FormattingOptions2","tabSize","insertSpaces","DocumentLink2","SelectionRange2","SemanticTokens2","resultId","InlineValueText2","InlineValueVariableLookup2","variableName","caseSensitiveLookup","InlineValueEvaluatableExpression2","expression","InlineValueContext2","frameId","stoppedLocation","InlayHintKind2","InlayHintLabelPart2","tooltip","InlayHint2","textEdits","paddingLeft","paddingRight","StringValue2","createSnippet","InlineCompletionItem2","insertText","filterText","InlineCompletionList2","SelectedCompletionInfo2","InlineCompletionContext2","selectedCompletionInfo","WorkspaceFolder2","TextDocument3","$1d44efb04eab6ceb$var$FullTextDocument","lineCount","getText","positionAt","offsetAt","applyEdits","document","sortedEdits","mergeSort2","diff","lastModifiedOffset","compare","leftIdx","rightIdx","_uri","_languageId","_version","_content","_lineOffsets","update","getLineOffsets","lineOffsets","isLineStart","ch","low","high","mid","lineOffset","nextLineOffset","toString2","undefined2","check","nodeStack","buildRootNode","buildCompositeNode","compositeNode","buildLeafNode","leafNode","removeNode","construct","addHiddenTokens","hiddenTokens","hiddenNode","addHiddenToken","tokenStart","tokenEnd","childStart","childEnd","_astNode","_offset","_length","_hidden","_tokenType","_range","$1d44efb04eab6ceb$var$CstNodeContainer","firstNonHiddenNode","lastNonHiddenNode","firstNode","lastNode","_rangeCache","firstRange","lastRange","_CstNodeContainer","addParents","unshift","_text","$1d44efb04eab6ceb$var$isDataTypeNode","$1d44efb04eab6ceb$var$withRuleSuffix","endsWith","_unorderedGroups","lexer","Lexer","wrapper","$1d44efb04eab6ceb$var$ChevrotainWrapper","ParserConfig","ParserErrorMessageProvider","choices","wrapOr","optional","wrapOption","wrapMany","wrapAtLeastOne","isRecording","IS_RECORDING","unorderedGroups","getRuleStack","wrapSelfAnalysis","nodeBuilder","assignmentMap","linker","references","Linker","converter","astReflection","shared","AstReflection","fragment","ruleMethod","DEFINE_RULE","startImplementation","mainRule","lexerResult","clear","wrapConsume","isValidToken","isCrossRef","getAssignment","convertedValue","convert","subruleResult","wrapSubrule","performSubruleAssignment","resultKind","object","assignWithoutOverride","existingValue","newValue","elementStack","lastElementStack","nextTokenIndex","stackSize","resetState","tokenIndex","keepStackSize","resetStackSize","removeUnexpectedElements","before","after","$1d44efb04eab6ceb$var$defaultConfig","useDefaultLookahead","$1d44efb04eab6ceb$var$createParser","$1d44efb04eab6ceb$var$buildRules","parserContext","reachable","$1d44efb04eab6ceb$var$buildElement","ignoreGuard","method","$1d44efb04eab6ceb$var$buildKeyword","$1d44efb04eab6ceb$var$buildAction","$1d44efb04eab6ceb$var$buildCrossReference","$1d44efb04eab6ceb$var$buildRuleCall","$1d44efb04eab6ceb$var$buildAlternatives","$1d44efb04eab6ceb$var$buildUnorderedGroup","$1d44efb04eab6ceb$var$buildGroup","$1d44efb04eab6ceb$var$wrap","$1d44efb04eab6ceb$var$getGuardCondition","ruleCall","$1d44efb04eab6ceb$var$buildRuleCallPredicate","$1d44efb04eab6ceb$var$getRule","$1d44efb04eab6ceb$var$getToken","namedArgs","$1d44efb04eab6ceb$var$buildPredicate","ruleArgs","ruleTarget","condition","true","methods","predicatedMethod","guard","orIdx","idFunc","lParser","stackId","groupState","trackedAlternatives","wrapped","delete","assignTerminal","$1d44efb04eab6ceb$var$getRuleName","buildTokens","reachableRules","terminalTokens","buildTerminalTokens","buildKeywordTokens","terminalToken","buildTerminalToken","requiresCustomPattern","regexPatternFunction","stickyRegex","sort","buildKeywordToken","caseInsensitive","buildKeywordPattern","findLongerAlt","longerAlts","runConverter","convertInt","convertString","convertID","convertNumber","convertBoolean","convertBigint","convertDate","ValueConverter2","convertEscapeCharacter","BigInt","Promise","resolve","setImmediate","__reExport","__toESM","$1d44efb04eab6ceb$var$lastTick","$1d44efb04eab6ceb$var$globalInterruptionPeriod","now","period","promise","reject","arg","$1d44efb04eab6ceb$var$FullTextDocument2","_FullTextDocument","isIncremental","$1d44efb04eab6ceb$var$getWellformedRange","addedLineOffsets","$1d44efb04eab6ceb$var$computeLineOffsets","isFull","ensureBeforeEOL","$1d44efb04eab6ceb$var$isEOL","rangeLength","$1d44efb04eab6ceb$var$mergeSort","isAtLineStart","textOffset","$1d44efb04eab6ceb$var$getWellformedEdit","spans","t2","e2","t3","TypeError","r2","e3","r3","n3","o","h","n2","cwd","normalize","isAbsolute","relative","f","l","_makeLong","dirname","basename","extname","format","dir","base","ext","delimiter","win32","posix","r","toStringTag","Utils","P","platform","navigator","userAgent","scheme","authority","query","isUri","fsPath","with","i2","o2","t4","e4","m","C","file","y","toJSON","revive","_formatted","external","_fsPath","_sep","$mid","s2","encodeURIComponent","h2","c2","decodeURIComponent","A","w","joinPath","resolvePath","$1d44efb04eab6ceb$var$Utils","UriUtils2","equals","fromPath","toPath","fromParts","split","toParts","backPart","repeat","serviceRegistry","ServiceRegistry","textDocuments","workspace","TextDocuments","fileSystemProvider","FileSystemProvider","fromUri","cancellationToken","readFile","createAsync","fromTextDocument","fromString","fromModel","model","$model","createLangiumDocument","cancelToken","parseAsync","Parsed","textDocumentGetter","createTextDocumentGetter","oldText","getServices","AsyncParser","textDoc","LanguageMetaData","documentMap","langiumDocumentFactory","LangiumDocumentFactory","all","addDocument","uriString","getOrCreateDocument","createDocument","then","hasDocument","invalidateDocument","langiumDoc","Changed","precomputedScopes","deleteDocument","langiumDocuments","LangiumDocuments","scopeProvider","ScopeProvider","astNodeLocator","AstNodeLocator","link","doLink","_ref","getCandidate","_nodeDescription","documentUri","linkedNode","loadAstNode","createLinkingError","unlink","scope","getScope","getElement","refNode","refText","refData","getLinkedNode","ComputedScopes","descr","$nodeDescription","nodeDescription","doc","getAstNode","targetDescription","referenceType","getName","getNameNode","nameProvider","NameProvider","IndexManager","nodeLocator","findDeclaration","sourceCstNode","nodeElem","nameNode","findDeclarationNode","findReferences","includeDeclaration","getReferenceToSelf","indexReferences","findAllReferences","getAstNodePath","sourceUri","sourcePath","segment","local","addAll","entriesGroupedByKey","inverse","getKey","descriptions","AstNodeDescriptionProvider","computeExports","computeExportsForNode","parentNode","exportNode","createDescription","computeLocalScopes","scopes","processNode","outerScope","getAllElements","localName","elementStream","toDispose","isDisposed","onDispose","disposable","throwIfDisposed","provider","contextKey","cacheForContext","contextCache","documentCache","sharedServices","DocumentBuilder","onUpdate","changed","deleted","indexManager","globalScopeCache","precomputed","currentNode","allDescriptions","desc","getGlobalScope","createScope","createScopeForNodes","_context","allElements","$comment","$1d44efb04eab6ceb$var$isIntermediateReference","ignoreProperties","commentProvider","CommentProvider","serialize","specificReplacer","replacer","defaultReplacer","currentDocument","space","deserialize","linkNode","sourceText","textRegions","comments","uriConverter","_d","refValue","$error","targetDocument","$ref","addAstNodeRegionWithAssignmentsTo","$textRegion","documentURI","$sourceText","comment","getComment","createDocumentSegment","assignments","textRegion","propertyAssignments","containerProperty","containerIndex","propertyName","reviveReference","mutable","getRefNode","fragmentIndex","node2","documentUri2","document2","singleton","fileExtensions","ValidationCategory2","checksRecord","thisObj","category","wrapValidationException","addEntry","getChecks","checks","validationRegistry","validation","metadata","validateDocument","processLexingErrors","stopAfterLexingErrors","LexingError","processParsingErrors","stopAfterParsingErrors","ParsingError","processLinkingErrors","stopAfterLinkingErrors","LinkingError","validateAst","lexerError","diagnostic","getSource","parserError","linkingError","containerType","toDiagnostic","validationItems","acceptor","nameNodeSegment","nameSegmentGetter","nameSegment","selectionSegment","createDescriptions","targetNodeDescr","refCstNode","docUri","segmentSeparator","indexSeparator","containerPath","newSegment","getPathSegment","segments","currentValue","propertyIndex","_ready","settings","workspaceConfig","ready","params","capabilities","configuration","initialized","languages","section","lang","toSectionName","fetchConfiguration","configToUpdate","conf","updateSectionConfiguration","updateConfiguration","getConfiguration","sectionName","Disposable2","updateBuildOptions","updateListeners","buildPhaseListeners","buildState","documentBuildWaiters","currentState","build","documents","Validated","IndexedReferences","previousCategories","validationChecks","completed","emitUpdate","buildDocuments","deletedUri","changedUri","newDocument","allChangedUris","shouldRelink","rebuildDocuments","Linked","changedUris","isAffected","prepareBuild","runCancelable","IndexedContent","updateContent","scopeComputation","ScopeComputation","updateReferences","toBeValidated","shouldValidate","targetState","filtered","notifyBuildPhase","onBuildPhase","waitUntil","uriOrToken","buildDisposable","cancelDisposable","getBuildOptions","validator","validationSetting","symbolIndex","symbolByTypeIndex","referenceIndex","astNodePath","targetDocUri","docRefs","refDescr","nodeType","uris","documentUris","getFileDescriptions","_a2","allFileDescriptions","indexData","ReferenceDescriptionProvider","initialBuildOptions","documentBuilder","mutex","WorkspaceLock","folders","workspaceFolders","_params","write","initializeWorkspace","performStartup","collector","loadAdditionalDocuments","wf","getRootFolder","traverseFolder","_folders","_collector","workspaceFolder","folderPath","readDirectory","includeEntry","isDirectory","isFile","_workspaceFolder","TokenBuilder","toTokenTypeDictionary","lexerTokens","chevrotainLexer","chevrotainResult","res","opts","$1d44efb04eab6ceb$var$parseJSDocComment","$1d44efb04eab6ceb$var$tokenize","lines","$1d44efb04eab6ceb$var$getLines","$1d44efb04eab6ceb$var$normalizeOptions","normalizedOptions","firstRegex","lastRegex","$1d44efb04eab6ceb$var$tagRegex","$1d44efb04eab6ceb$var$inlineTagRegex","currentLine","currentCharacter","whitespaceEnd","$1d44efb04eab6ceb$var$skipWhitespace","$1d44efb04eab6ceb$var$lastCharacter","tagMatch","fullMatch","inlineTagMatches","matchAll","$1d44efb04eab6ceb$var$buildInlineTokens","lineIndex","characterIndex","matchIndex","startContent","tagName","endContent","$1d44efb04eab6ceb$var$nonWhitespaceRegex","$1d44efb04eab6ceb$var$whitespaceEndRegex","startPosition","$1d44efb04eab6ceb$var$JSDocCommentImpl","$1d44efb04eab6ceb$var$parseJSDocElement","$1d44efb04eab6ceb$var$parseJSDocTag","$1d44efb04eab6ceb$var$parseJSDocText","$1d44efb04eab6ceb$var$appendEmptyLine","$1d44efb04eab6ceb$var$JSDocLineImpl","inlines","firstToken","lastToken","$1d44efb04eab6ceb$var$parseJSDocInline","$1d44efb04eab6ceb$var$JSDocTextImpl","$1d44efb04eab6ceb$var$parseJSDocLine","inline","tagToken","docLine","$1d44efb04eab6ceb$var$JSDocTagImpl","$1d44efb04eab6ceb$var$normalizeOption","escaped","getTag","getAllTags","getTags","$1d44efb04eab6ceb$var$fillNewlines","trim","toMarkdown","renderTag","toMarkdownDefault","rendered","$1d44efb04eab6ceb$var$renderInlineTag","marker","tag","display","displayStart","renderLink","$1d44efb04eab6ceb$var$renderLinkDefault","getDocumentation","parsedJSDoc","documentationLinkRenderer","documentationTagRenderer","findNameInPrecomputedScopes","findNameInGlobalScope","_node","_tag","grammarConfig","GrammarConfig","$1d44efb04eab6ceb$var$event_exports","syncParser","threadCount","terminationDelay","workerPool","queue","hydrator","serializer","Hydrator","initializeWorkers","worker","createWorker","onReady","deferred","shift","lock","timeout","acquireParserWorker","cancellation","terminateWorker","hydrated","hydrate","catch","finally","clearTimeout","terminate","onReadyEmitter","sendMessage","onMessage","onError","_parsing","_terminate","unlock","previousTokenSource","writeQueue","readQueue","cancelWrite","tokenSource","enqueue","read","performNextOperation","grammarElementIdMap","tokenTypeIdMap","dehydrate","dehydrateAstNode","createDehyrationContext","astNodes","cstNodes","dehydrateCstNode","arr","dehydrateReference","getGrammarElementId","createHydrationContext","hydrateCstNode","hydrateAstNode","hydrateCstLeafNode","setParent","hydrateReference","num","cstNodeObj","getGrammarElement","getTokenType","createGrammarElementIdMap","id","DocumentationProvider","CompletionParser","References","JsonSerializer","WorkspaceManager","ConfigurationProvider","module1","module2","module3","module4","module5","module6","module7","module8","module9","$1d44efb04eab6ceb$var$_inject","$1d44efb04eab6ceb$var$_merge","Module2","merge","m1","m2","$1d44efb04eab6ceb$var$isProxy","injector","proxy","Proxy","deleteProperty","prop","$1d44efb04eab6ceb$var$_resolve","ownKeys","Reflect","$1d44efb04eab6ceb$var$__requested__","cause","value2","value1","$1d44efb04eab6ceb$var$utils_exports","$1d44efb04eab6ceb$var$minimalGrammarModule","$1d44efb04eab6ceb$var$minimalSharedGrammarModule","$1d44efb04eab6ceb$var$createMinimalGrammarServices","json","$1d44efb04eab6ceb$var$__defProp","$1d44efb04eab6ceb$var$isArchitecture","$1d44efb04eab6ceb$var$reflection2","$1d44efb04eab6ceb$var$Branch","$1d44efb04eab6ceb$var$isBranch","$1d44efb04eab6ceb$var$Commit","$1d44efb04eab6ceb$var$isCommit","$1d44efb04eab6ceb$var$isCommon","$1d44efb04eab6ceb$var$GitGraph","$1d44efb04eab6ceb$var$isGitGraph","$1d44efb04eab6ceb$var$isInfo","$1d44efb04eab6ceb$var$Merge","$1d44efb04eab6ceb$var$isMerge","$1d44efb04eab6ceb$var$isPacket","$1d44efb04eab6ceb$var$isPacketBlock","$1d44efb04eab6ceb$var$isPie","$1d44efb04eab6ceb$var$isPieSection","$1d44efb04eab6ceb$var$MermaidAstReflection","$1d44efb04eab6ceb$var$InfoGrammar","$1d44efb04eab6ceb$var$PacketGrammar","$1d44efb04eab6ceb$var$PieGrammar","$1d44efb04eab6ceb$var$ArchitectureGrammar","$1d44efb04eab6ceb$var$GitGraphGrammar","$1d44efb04eab6ceb$var$InfoLanguageMetaData","$1d44efb04eab6ceb$var$PacketLanguageMetaData","$1d44efb04eab6ceb$var$PieLanguageMetaData","$1d44efb04eab6ceb$var$ArchitectureLanguageMetaData","$1d44efb04eab6ceb$var$GitGraphLanguageMetaData","$1d44efb04eab6ceb$var$rulesRegexes","ACC_DESCR","ACC_TITLE","TITLE","runCommonConverter","runCustomConverter","_cstNode","_rule","_input","keywords","$Gr8vk","$18c11f3350a906ea$export$6503ec6e8aabbaf","$18c11f3350a906ea$export$f7ad0328861e2f03","$18c11f3350a906ea$var$mapping","baseUrl","manifest","resolved","URL","$d10833e8570ddaee$export$df8d68917b0b9773","$d10833e8570ddaee$var$InfoTokenBuilder","AbstractMermaidTokenBuilder","$d10833e8570ddaee$export$ff9bd92f44cc7907","CommonValueConverter","MermaidGeneratedSharedModule","InfoGeneratedModule","$d4fad4bc643f38e9$export$7e4e23c01014549b","$d4fad4bc643f38e9$var$PacketTokenBuilder","$d4fad4bc643f38e9$export$696749b8bb714ad2","PacketGeneratedModule","$296a600e4286884f$export$8c8c36c453ebad36","$296a600e4286884f$var$PieTokenBuilder","$296a600e4286884f$var$PieValueConverter","AbstractMermaidValueConverter","$296a600e4286884f$export$82c0f447a0f95de","PieGeneratedModule","$d50b8c1bbf3383d4$export$6bf19b4a269deaf6","$d50b8c1bbf3383d4$var$ArchitectureTokenBuilder","$d50b8c1bbf3383d4$var$ArchitectureValueConverter","$d50b8c1bbf3383d4$export$b6995d23b3452254","ArchitectureGeneratedModule","$51e7999b1e5f3296$export$ef9a00b13c3f874c","$51e7999b1e5f3296$var$GitGraphTokenBuilder","$51e7999b1e5f3296$export$499b7d9a23e4443d","GitGraphGeneratedModule"],"version":3,"file":"gitGraphDiagram-GAN24H3L.eaff6536.js.map"}